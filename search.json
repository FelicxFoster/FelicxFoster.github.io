[{"title":"2025年度OKR","path":"/1985364334.html","content":"c8f9345acf8a8db129dc4f70a76800da18d542646271b3d2d46081d8c283c54eb6c12ea6cb7c8cd49becfe8ef4c789366af60f6703fe84ef6629e4efaacb2261d2eeb17465754c54fd3a232bb2f9e820735f23f6573a3592ec6b35f1bf9caf4144c52e861c55c72ba05e381ba1586dccdabe4ec155efa9f95a07ba06482dea20050ae396cc497fa93a957425c5ea53ee69c861fa0c597d859158625e882fc54338adf275fafc1e3d8a39de05ad1d88f5e92c0d485d36b5df7cb486d30ab6132f72b1e1664da11ae5cd2954a9a9ce9c242f2beb4d868ccbe6087d5eb454199adb11245a55a73b956259fbbc14844d0a56b0e150f13a022a1b19cfd0f112f8e35fffcbbf05b3d2aeb47d2fa0156cc51cdfe7f6358aa82b7e5daa7169819749ce83c6370feb196edec9dc90eb38c28e9efa9c36482b9abc42e4f716d906e779bbc9bdaafc2f4913245bb2dce0412bfdb91da7fef44c6606ee81a23207c672bc928757db6ecb3bdcda0d8337eca363ffd332ddb2dd314f3a89a6b5bd7808dbb14c1e869558e7e847b8414a0991ebea919808c35c20fdf4c62dd69727386c69b0beed79a53cf2c6cb658e2593fc8216659546a8804e0360f7acaac68600c648ad5bf9370d5fb83918b6fe2d2e437ce07719eba27d09199c624097d327b2b8c133d846d810e1326bca04232f08b36c86237ef07988bc796859e0da7c04f0f9138d9c180cdea56acd81fcb2f3469c970f9226321eb4243bcc10a71064b34cc6ba01b0f393fb5115d71a8913faf7172ef9f4243356fa429418602fb05ddb335a34156b2f7950999408db72950431c3f1666fd2916abb0617c9b202c18e9c8d525386cc611a9cbb56faeb8afc575d88676aa835aad40d069887c18b9720e5b17396087349fbf84d534cb1dad456567f30e0f34e2b1ec50e3faf654e3121aac18c36d785fb5993cab3a1cdc4ef98845f8b25adcbaf4d270ab58ed0c1d7d238ac488b13d5416c06929344167fc142fd9873bf8d4ec057944989ae0fd392a5323083207ffe90c33e1ed9c111c9dd6a74dc4469908d22727d180393b5ffae4d581e798186a096dac84333f82e603a15b0e272f46ce0f4574bba8199f067db3b4b474ca9b40db2e94a101a4cc21838347a040f87eeda86afcf17b4ef6845f40429de1bfd913ad2dc14122ee973e593d11efca42bcef1465be6daea4b4b61fee226b8aaf39f52693d803c0704756b709f645c910345dca87e7024070eae2af38ec5bffc3abf31c36f42e91876faaf3785466313d861138ae68cd35d83783206ea57b33ae34aad394a6afc2cdc386a23b3222c9c78fb8fafbdff40093fefa089af8c995e06c0c967b432e49665efaa04d88dd1510a763ad0c5a5547e7a8ba3db1bbb4341478facf6e0bdaae79526b29f92cb5dfba287260e3888bf871de533c63823ad57668dc5169fb65ab279e19c8da8df5b2618fc034695a62355306c6e56b333a0c8de852c1a1a758bfaaa6c81806296f931f310cb8a334916fc8b2d171de47dcd5badfee419b25f4d3025273ea2d0ad6c040134d30809723b82407f20a0433b40c00a8850f68e6feeefae08b54ab9b8669ef4c30fb3f18f86cb61390d20a337ec23bafc107c85427294ecb87c87ec2af6eeb8703231f4f741a25f3f0ea2f0607c7499e767c17f57126521f0790663b2f0a51b4f7553b59ee63fdd4322189c6b0ab5a901488175509a49d701e82b57adeae74b8210b74cba36472cfc2ba582945457458cf58fb81802490f4c0ce89c761f3e3cce31c56ed57c464d48f7b4ce3dc29f91f1256b4d27faf634a1ecfe07a4d78eb9bb883ea35bd24000882c53d6e04554c13d22cb9fa8d420dd1665970b41c6d00098ab3326a276fcb847d9d8877493c6d89281f6b97c2cdf0e162a8897945c2e7fef8fbd31820c1bd6d7072c1de6e668e46799ebf7215287fccaa17a055bb34be6f4d98b22a06d79f3b03621df3de424614e212f5b257e876622a32465e47c15e564038601c5323a50574b34141c5052b6190c6c28c7cfb443712e0daca3f95643143151b9a87c6665c0dd7b4fb37cfbd9bb58b9470b1ad550bc9d47beeebb0e82cf509c2a2ec8c3fad8f1553376162635834fe4a3745419b3b3906cb32f47d94c2d6981081f44f044f590ce81dd039d0f2220e8780b17b120f6401accb64d250e66143c8a2d1e37eb5e89123de9c9e8c61e1493338e7cf39b16fc289ba13187f60ec50f9f2fa41dc3e24fa32b3e4c5b9c18759b37caa632a5375a4548f15c0eddb95e61a716bd784d9ecc01b85a83a332afd85f63a1bdc2aec1bc48bea769b35cb1f73f174e3912cc45992a3e4796dc78c8fcf14261458eaa519dde50de50cb138025114180c332099c3f676910fbeb2b98a4772c4f572b699360ec4a20fd38873b413c9e9ef5610d05768a96a97ea1e5892f3366d24bec63cf754623e82376503d1fa817f69d0b0e28215c5489c385e783289b5375ee065b3401f06cac279edee22ac8bcbfa6a82af0e6f5438abfb1a8a5940ae07e8682c1d34eda0485418cdd6a4e805c1bb2b43a559fea49ab2099248a4af3c4202b2b017cd225d1bd77bbafe1beac44b56824de0040480406712c3d081f67b2ff02eba5643d61ef30aa07e45fa34804131f8e44965bfa15c774b1c196cf3f63fdde1205ae6c14c3717436ecb40b528785428c66816a383cf28d4d848c45fd56f3548c871dc72431e9e0a57fd37840838af3ef2a8f91f20eea9ca076e9f3158824c4abb02d618b877c6944f741921d1fb0bf6fcb2df6d0a735b98836959b9a71f17aea3bfeac3cb01bd4aebc197f85ce6674254a2f11c87111c8e32d53e555592f8b1b056e35e9fc0d82216344e666d932bee4d1ec2bf65ebf4cb9be8245f0707c0451496442f78c55ffc0ef277d695a54ee798618d6cfe7435830c8a78cf1eff48f58e437b18e6d3f0d1f3903d6779506a1f2a875fe3f7f9d0623a77f83e95d3fcc7d997877efe58603ad8241377392c93cc7ace7f2bbc8e3fdd9aa90821a8aeeca932d2ef9dd38ee0b04a5da4ac35ae8b118434335bda53ec5da3b33098104af48c25d70d4b890380b56c0dd270a1df63c048673e1ee3dd75134c36a77bf340bca721bd59ac789d8a614c9853fd388652e0204177e569748f9f3a24195c6d241b3e69203961da7919c0d187dee79831a9829f57224d0702ce45a152e1be43134f20f218faf25317b4cec3bae7d4c9c6ca72f7524723baa9c0a09a6c65d80fdd3711e8f80af965705f84a64030ab697d861fd66af81cb8c26d49ebf2ae0da494f348a918615df9af90efac57a194b3fd891db3ad3f9d1cdbe9963cff8efa10a720d3b5cb93186723960e9b5ca31b0822a41016315253ac64a25b81bec006aa2534a9af441bf5a35ce6eddbb2f63751e9856cf20b61a847ef4f0396dac964e68312a30ce5a0c97b11c71694abd1445dfd65ceb6a4e1796f17796d51ad170f53e39f18a8617f8bbe5dfbb5e59ab0d202c10b3cbd903b2a7f5389dab31b984f47b72d736ba0b082762b3fd95c9ee702991f7934f68a1da386ea250d82c20cf5bdc8f0e8e9a718b72a80c23267bf9c31421faa15ba428fed0de618ea3b50666b3bf590cd88825680355d9a4dc7d4db6b853324db6ada86fb0dc7e7ea0036c1124882dee9c3634d6a1fbc61575af68821fe5aeab41222c616503d539e795fcbce5787b5a7a4fc581fd2b6800b240c2b143eb187912c15ae5b04593d3bbe0b9848afae8891dd387244e107f86571a416ba5cd8e3bc074cd555e65591d19058bc061fdea0f5b00d1b25d3da7b825b1dcae5a1cbcba46ba698b447030b933ff819927b1298c387ae0a465a6c8615ca2d6c39a4092b6be8757b69bb6b78da4d6d556919cdafeb1c235e9f2deac7ed59fecd4f5e91382ff57d15d94a342478358d42f9e965d94e2dea163ccb6b7ce3624ff48fb240d403c86695d76455d09c8594d2fae8529ebcdf4e9114354c430f9f8a620080e97b4c828a06a9c477bb244ca0d80e47aed432616591a0ec294ca3dea8c530b5277a6a68ccb2666bcb27f15ee45a484f07abcffb7c516a423c672fd7339ea4b06e8a904881cf13789ec299af89420920f526f70ceed5f09ae917edbb733e438865ecde5851b1b7402f77f414e60d0b71b97fcd1103307dd4f401239fb1e0bc7ceb67fffa9000469289b5bbd2567200fb5c9605ce3a20927c071ad7ee74118ad04216698a4f14a293345d23d8bf009ab43071332dfa78c6ddb9eb82d08112388c0d533ffeeb7a98022464dc0f1b52dce7f3b2e694bf3d7873404b69fa199ef76e2a8ca1d480b6d51e5b59e41e6ac96116744cad9f740796c1deaaefce5e1af8697f4fa62e35ea7feaf06bf61e74b01beb0116a320ee5a47e5901e381ba31dcca3a2f54d171ed27bcc4458d20ced20bd5d93905925fca8f26eb771edfcacf9f01deb3ae1edbe327ea5a8e76bd7fd520264e85d770582591501e0c5ba4c04c84a8d6f8f23b60cdc49a14a8a39e2fb76da2e4f50c18fcbf82262c75e38b579f405cdbf114fa548b058b9551574874e3d457670509dad7bc87c92e6191aa97d5854989f5450ef870647c777370d9d44eac66c3c8a9bb4a225c01ce62d80f0cf4f55d30f5fb51fc638d5b7dc39d800b6277b11ac93df3f9e485bbee3571b159a11084050dcbb3c74a0694aa316e76671ba83dcf2afd8d0bc1454734a7682a9ded908ef5da9418b961eab5f7ecbd62a22903350e06e208684f9b65504ed8c038b71ef27fa3d38c89cd47b9137c3307c0311d37e0955c64e62dd08e9a8bbb29356f6914913e3344ae74f638ca156a3cdc1f2340391b5fa031e387ae3abd661a537f8f7d78b46e09353282eafd50d2d31e47f02bde73e240137d4f6ff0378d84ab5490f324c2a5e67c1c2fb5edf44ab66e54c9312e63ae597249e77b2b69e3c5fd0aa3dafc78f5d5ddd12408187d798b8a1c2ca716312d88125de45008c4c31c58252ab76db4edc4e3a99b39c8bdb53ca45b7fe0530792a8e04180c46b75febfcef1bf4ebe4abd0cd62d2845f6d4cdee46b43dbce767576296152a7c59a38e2519c31877284a27e3944eab5c0fe47c40e222452d69f7763b08921a18d4e2defe78c8ed5429a829883abdbeae58e1ff6862270b55817f3c1bf1098d919bee88dcd9dbd24d2384d85b9832cdefb8568ab5a10ad2349cc6b21a5c73e0461110ee4ebde7a811258c5156d4d3028f2d6a35d459446b072ed5570e2dd8a968ee57132196043879fbbbf2b1421ad7f8dbc6226fa8c0f82f3283d161ce20d40b6df3ba862f03c600f35206cb877d81e1c4e07cee2adb3e83b51d734be3b049ca21a25901529e904aab50a93dfbfaf8892f8ae8501c85e4399f80e2189c4aa8aec1c26f2a01c195cf4b682255934987f36f06f18534e1be2e8d83ca64922d8659fe70288b0f5c6f5d9f01a2ab335e00387153c88475d275f81ad5a54f4c3bc95b91780063b54df4daf0f6f66c6e58b98ccc5bcf059d039ad9056f555a73f4c446627eabfe6b0827b3253e5636c7fbea8ca832bde36cea77d006bafffbe0f21fe532a056ca21b3a0a52fcf84efef39ca58101fb1686c41780e8c23b1385ea383c6909f2de34b82d66718e7b4ceca724c8d406df7a8caa24550ef988ade2173acb0c32210ea68284523051ab377766f21e035bc34fbaf0fc25aba069c9df52cb147ee30b1ea96610bf5ccb6c6bdc0b6536e78c8c9aad0782020a78619d9b49d78bb12f90adcb53f7a29d6d3ebf9a479f0150b6131bc2d66ef48f98485bb9e6e9e2e1f9cb88066a26120a45c93bfabaca049a13b5a0ebba2125e4796d671e5fcc1bedae12f9038cc73e94e07704cbbd89576766d740d39578bfdc8aa7a164e02853e1f658770adc80ed62283f8204d2cc5aac3dc7f83311f980b99a02b7d16016be27a211241b36eda693d29b0a3b14452e728d981fe59a856879462a48567c94fef4ba49a2bcd11558204906524f5884a76a2bee916a6ab8aa385e6bcacd5225eb734ba1b12a6eceeabb20175c6b7e4794e442e3d3e9737e0ba839da04b18c53a274c84fe7bab73800d621b72a45e629fd37c8aaf0d71f26ea7d89821026c3e0d0bf323230a8aab01060f5b8da4b3dcc20ffde2b93f311b7ab52ca085c5934a5bab06f29b269aabe7f3ef53c39397c042f63a6885cafe8c69e58a0a0468f071b629a3082dbb6f21d073325ff5e62f8df9f68b2f338ded893eaf0fbb4c517ce7e1770ee7acb6b3a9247a325774fb5f5df3c605abfc6127f3d777e3ebd280e97ff658ac8986eb8a97a880858bfede6c32a499cc3a9ed29257a4ac1e5e873656c3b10e029542ceddcb020ea4afc5bade9e34d7a190b569c1ff6b1b1f6a470969246f26f1b737af69bdb43e3f55fba8af1986a2dd91301b703a1b69541811ba4771c6191fea6d8780f4b486e3f7018085d9efeac1ea6f49bf100538822c9ec733f69920ea0763d3a62736eeeca268f3d5a01d5e7e649b2bac827d1071aa3980d01f447a27b3e6526dcac176a38278f47bc2fed53a60fbc5061d6340fd1fedc2e9d3a51c93e61e73357e91e7712dcb527d79a193cb78e9d8eed514b423a53cc77b2cf71bac4e644ef03a6c6f06788a27d24ea99eacd18d530a545a311974b877040de28a70cdbd79f95ea3f6e763058b855c7f2b481cbb41c8509c2716b8370bb98d171466e89b394688bb04f25a2c75f66e2eb7a06a3c30efa1c1eff63adb64ddeae542cc97ce49f045a956c2dc8233fcf55d41e7b4bf31e8614a88e809951fef4531ec62546b0add2707d27f8d33dd6e062859e58be0c0a7531df4b0d78d63404d99ceab186b6cc122535cff71a4bd463a9f4d38636b2b0f352f3f7dddf0caa512159a1281aac6001e54086a16f6215668efaa89b224d7653d71577d90c4768b01c28311337a900f5502cbebba8adbf7aea3f24fbe055ed0ed2b1408b228c7ede4d6d76e1f5514fd3087d1bb24eee042171ab334f620eabc70b3b05a24bbad67c3b7f358e2b8f97ee456d48ce8250818156557b961a75c0713f6be44f0a6d09d35906ea39bdd87f0f50a02d1751c1f73c8f2836cc196b6630fbd824eb51a28e8c235838cd3616a45b2303b3f843cf3a021ea3c5e0c5fd13b83c529183b17bc9e45d8f1440180f3c025967d5d6aff96800220f6ff672420feda3548d828b4f418bc00336e6422925d4100485faeeff351b2a5164163689138a7566c6b04dd41cb60fa323283fabae3397983073598ebe0a28fc394b90036d10ac9da72cbbcf310918bb3a7d869bd2d300f798a8d4a8d94459733a6b512182c2ab157aaafe1041928d5c9d261c4c4df329f47ed6929446cf65b1fb25cbf7614c694cd770bae527beaece13f07427a6ac93378c1dfa3b06bab7e5ccc6bd251df8e3103a70db38686283fad7c467739d8a8abb3f5cf323f9e40a26517bbdb8b9465f449a7ff97e09ba6af4b37bd9954f0a663183a8fe6184ecaecea537fc670eece081a6506a0990726d531cd686ddfffe2eb0789ee859eba12aa292cc5bb5c0cef43deb2d60a5fed9a4350b52ec61dfe29a455f5b499b4348af8a2d0c6c867d63caf838c8ed4103d9f4c753a642e20eb5e36ec6da27bedd357e6b97abba770aae18832ea7fc826945707c738edec437df37d52e34f983805d534db5fad871e80713a013cf49c0048d8785637c45cf53388fbf42a0f2ec656c587dffb1226b526313b9be7fd9f1bc016556a1400779b6051a92ae7063766ed1064a8b696572f7dec266844c47e672090e886350ea67c3182c72b273ced7c4b51eb3c2d767bae4152a4b6ee90199fb4e9ccc7d5f5eafaf18ce734434d526fba3d06064dd047449d00e461624b2904df70e656e5287ca41a45b47f33a7ce33b221a371d7964a545eef44813131f8952fa2d7796cd636d0d979d1882fa136a33ab59aabb2474428cc31ff3fb085fbb9450a762b7f1902babc4aca622817b9f255f01e007a27166e182907905327a89daa9ab7e3b18e5baf07ec99abd78041d6219f7ec0efe26e478920ff802c7a8a152b814c75a2f309d44eeb90d3d25aa236672f33177d801946ab747093c69d87396378e85fe6e16e1c592293c0e26c739f8630962a7543bbca482dc9afab600141928c00145232b41825d57e925f0dfda7f10b1d209ee4b243fb9e549440e6bb038b65994a3e979b4a6b1cdf50079449ffe34bfcad10681514536af1a16fab910bdca1c7184eeb3bcdcd6cee15d1932f4538e24b70995d1fbceb3a7e3f29ae39a55b10c3686f695647a8b14ee3f6c761007950fd72ea0b8c1ef38904cb904c07d23268bc1de91cd888e42cb81cd00924b732ade1dcf3c2fce048b75a75fcc4b20a47b48d15971e012423fcc75412148cf79671ddcde5e34ea219c66a7a12a70c5a194c1e12ae0958b251a4098c6b3cbaa84388164d89243568ff02135db9b2bcc67a6424232ab10067c93f77e91ccda27ea878ee3b6d9c330d6fd263798def63cf42ebb6db131ec3d9bef07c76e0696f379fa65d4f9a04c95ff527674719027a3ab208b58e795f5c7fd99607c90c7fa24f8b58344510673282219ac6d8b6c64938540a263fda8d3295c28af40e7a9ada1ffbb08c56393010cb9f7090c4f220e07ceb8f5757dd311f2c3bdfea01254b341ab261fa3c5fae205f90ccdd93c22e8520cc633ae96faa948984f820673a4db096df2d99cd8eb8f35b1b2a6b7b72571d6b801afd33830a507ddd471b88d23f577b54f3c5a10bf0ee55c5890baa9760b1d626b4b46467e8282d6b967539eb572b8582432f9824151f8bcaf3e6fd3480ae2221115bbf85d810951b5b4400621dacf4c8551ba1359b29b167aead02c8b6398155fbfca244d03b761d9f1b9aff4227adc9b8133efecae228e446278913a6f3a7059d89a61168757ffd7d857052e002a802f15f9ba79c2073945cc001285464bf984cef8f96b700b1d427a842dac6dc83e0262c5d575481db1ee70d21789c7a069a81411781b9cbd27cb8e7740b19914a6d86c08c50b710a51556b35e5cb0a5ebebf8450c893d69e49e44263b9601d1954287ae14520b22488d063735f85844c0cb8d082738901a9f1aad0795168f976bdcb76bbf346fa1af8bf13e78d7c92c327d58b93609d8782a411b7c1943657759a0769ffa85047b2e3f1f047468aa0e2fcae74184589c2f648ceaff6f3d76fa2b8e26caf283ce7465257551c9f8ffb37239e8a70b693f0e56a1c135fab03e4cd63f4bada5aa8ba31c8ffcc1f2c0dedfc0bbfe92ecd84fe85c73b02e788d266f5423de2cd8402627bc74ba9c5af098e11b29f8ffced4a738800b417ce29ed00c993de0bde05123598fd63a9695c1441e90cf7eeee4c7c140a573db11b3fec600df2cd79b73e39471732440177a66d055af28f6b888549c53734f69d311491841e2eaa82acf15d3e2a4fde5dcc1ad14e3d57ff6c2d4c249fd35d2f6bd4b3b131ea3f062692c31762febe846e394e3f38e08fbcfb8653d620447444366932c419863e06e720f1f9e252f2812507c74a9b233700903886ed564855cdf0ec7501bacc92d38d218223a977434332c4dbb796fe42a4f6e4af66e6003398d87f2db19f39440cc358e2b3e54bfa312f72b2e03ee3639d07e65e2721eaab550887247aef4d4d7a50b0e74e56e204e1c5a57aebe13cf86933918ec710125e2c68855648cf8a31642162ac43cc6ac093a64452cf2209f5425f2768bf188d3a166358997a93e3093fd7e83713dd82472ebafbb72f17620ccc960d96c87bd74c7284e585b2778c2d8d87904bb159984b2269a35d28e9388ca028c2719b0bc09edcb520647f2724edce100cf71879ff275ac217fa5ab3a433f4dff99e97c78a47a80982efef6876cf50d9bfc62bac6e2237793ef3be16b76093f4182472ea9b08efdaa6b57be63382ae000f7178debb802254db514a206d5d051d7ea7bde2e7e5a806fcee10feef921a9c073dfdb3097da7f1b42352bc63271c9f0d7aa2f8efffcfa3a0cfa5b7f1e2972d801c143f74c3680b905abaf6d4d46520222862486f9e97d0b4c1bca5223e6d7a6663909a9f58b4e9fdebb527a10a7a17d6fdd51daf32bced836c0bedb0448eea2eae210f185d6c272f30a5ae5312a6106840203e2e91a3ed345761627a9cc4aab77f55bf4d6c323d259614981db9f36580b638c58849fbcfa00752ab6ca5ea1f735fdbc7696ccde23421c652abc3af5758a02ccbbcbb8501a7d151e0e154f083a094c64b6d344de63dd62be62f8224fadea7527b585be7ff6182310013bebfacd48c10909e1ba414c4941c4b84b285fb8e1e775b4b40a7663bc9e1a36bbaab49e25f140b168e780b5235c58289dad1eb426f04cddde90e231ab91efe725da47179de743008d1445f59bdc1b806da760ae5aa04d7247b7f02ed6594593f2b0005fc1e9f76e17a5a6523303b3c5013cc6cfdc7c4a722aff5f0fe4c4cfe9c076feb751794371ad50a0fa6ff245b310a3e99597a38d958a1e200326125d9358350d1f110994b572a258c4b123907a2471e67b2a013357dd2ce89a29db28d31ee4df4535a543f5ea13ddae5553fe9d6c6124357f7c41fc9699d75a92fb9dd536004ba9ffa1b110b62f932f5193f06617ff58abfd1b71c631a6fb7587288e3c791be6ad99f2adf7bfe248b82051181b10e4be89a1e6807b9c589914c6517fa6dcfdc040ce5f69a44a8fd1262ad0582ced690757c217c9f678c72190d93391de3749c6cfecf84840c6a182645ef23cd398bbae1ebf54cc73ed3620ad2215d9e955f4f329c06a5f9090693e6544934a99c830615bfa694017da052afd62f4802794a57c76a0d73f461551650a12c887f2ebaf3f6f8453ac759a47780d3e8ba1ce471f44c48f58d9d74ec2cf49469f07365dfb6d8c5fdd4d04439b9a18ba02e7780efb61285005571650219402785106e622c2dadf0f354dcc3edfc4ad89d777158f77416ff14bd78738ad13f81f03d131c299c0356ceb60ce53309c3086087b700cd948b715b901c037b389308b7f5fef546d763105b0df78aeeb96dbcd2e67bccf4fb06df3d11ff3c81dd051eb393d244ad0006d14a24e93e582ac83cbaa78096bd21e4ce5f6427507c1ecc9659826fbaf69f832b4e1e36434c6dfd25f85aacc79076b06ec482b2525f8b1f5a7939fca0a1633e134c95e94ee0168bf428b33a3524b3357a82efb6a1d6fbead17c593e8d7dc44458806a1d1f79c5ef19c246b091e6745d18f57847c2d52336bff0115b3ea761725d4807d9e953d131d6cf95bb78c2eef2f9e77954a14fcb60090de37282408cdac8007a7a89933f5773aa94ebfa6da47bd8470261343d2be231644d3b8858382877661ea0b177eef582ab0d0231814e7f0be5decd01c7c3ed6ac2e13149280f836284050ecb765c8eec1e9245cddd1d642211da67d08c647fe24fe3b4f3d054e195b4f323eb18b9f3c3edbe2201582243e300cf3a908b4d245c31f0f3f89dd100be625b74a52a48beb4622c20a53adafc96dfea9d186cd17102fd7df526fdbcbd4715c4541b9e23c614214139f4ebdd2e1dc83f9e5a6b256bfafb4d2b867e31dcae0483218b0d393b290d3075e9448c09e0e91b3cbba12fecf90fd444d182cedba70377332b4e6ed62e9518c9f673a43352bcc1545a3772a02711f3b8e350b22e63fd362253d19d4f233eb2859c3d9b8bb9d2586e156dd256ef4593ae6d18b8902b23335be490e3548fca858fc0773ccef6c27ab2e2e5a5140951070edb7ae31744d81aec3a163ee4a08ab74c98d9c037dcdeb905da8023c124e82534851a194573d805c2eab9166ef9fa43e150c09a43a9a1f1712bfcf8bd011ddb4c481499921ed5daacf79d3036d8738f8c37357a09a274e7c21199843431ac3b5f7a77b76d817546b727390adb035a4737a61ab41d5c4ac3dd70c00dcb159d6e609cc160bdfe1339996867c3bd1cf7d732dd0ca2b392f4638de1e94d609a1e25b3c8bb5dd4e910fcc9890cdde3e42e0e1a176765aa0c129e669e5e3355e2d748a19a1c391c5e1d92f139f97ee4b1c0cc84cb90b106994b0a961ff9a397c2b6d53780c164c6daa05e6a1d8fc8fc15d4e4838bbd9e75014ef68d68c80b9d2b5f9266189f3dce89720b5eabab01b7b68b763dcc06536650217dd01ccba19f1e9a070dfd688c730afd5dd68cb17846b86247bcce78d5cf6b41854383a711b6d5262eb96bc8154abc01fa0efe70a91a30b7230ad34a8e5614daecddc9ba58a20b2dc7890665ec205e9d11d45251fcf37026747a4c0993d43e2364df8772f0a7ee65a2795d64d387ab795426332afe2ccf1da4a0f236e074491e83d1b5e46a7a7ef1b7d76e34482e83f6c0e6a673b17504ece6d9d964aa1daa1a89f3f5f7a322f012e57c0e865f42f49393d44d2be2db69078acc06999af444eaa9983838e827ef217459dc1a32947b7fc1080e1a0cf8c1b909d06e2e6eab1ce934cbc1d79772e785a70a5ae4d1d05257140d803c05989dcc0a14021f1d2e63413558847f52d040e00b986f905108f9fca3f1ff195f1e03f8498e3a4cbe96544460c88a679bcef2e9d62bc8b89bfc0ac18a7a54961b455d89d9fa7be7648315d8da23c24bf9c6464171f54cde5597f00420883704b3d5d63b07181bb71976335ee9b34ad82665f4cce9c67a8b359c3c7522a4e85ad952056bb212e02c91e182504a98fe8b1676efe5bb3a7ba38370e2a6b9fbb4ad3d356b88eac81dcebf27b8f56558d98222352447daddae39e93e04aa29466db934b6e4c7bc4c99c41a2409fad3c6a05dd17394065f171f5cad6733660c7d59a6989c31d9f51829280def06bd42f3fd369482d0389dea3449ae7e979f4b8f4e437a9f6eb76459776214c81453f44ad90a6109a2a179ee944c7565e975f8d6966fb25214aff4fc53bd78a7b809c8eae4c46435b216ffc0d7e9cbd09261a96d0c804333ebb74579adf70b991e04dadc336ce7b532b0649ec4f5dfecdd09dd07b4c05d1ad54027c53ea968336f8b27b18298875fb8cd01a49cd3f96eef03f674ed80156b62fa5821503f3972f2f184043e612a6860d39ac9ed566a9eda8373bc63aeea444182770fd90c55d32daf43ece401cf27c6820dac3530f6b5f59bd6e644a263dd1bf96d4f4e96a11a5ac2231f02185ae4a1b59327bfb0dba56c05d874967d4a19162381f6d706b5615b2b19892069bd8b4dcfae26656ee32ffb04412ca2c0a6e1c8262b5dd805e166e5e73d2fb635158d308bb3466705845329d41536822e5e2a07300508dff7818b6c99143c29529fff6d84532d407fcade51c57e99225d57f63665abb4530beddfc10fe676ad522de5d60f8c546428ff1113ed93e41b458e413b9be6b9d87221e015c2d42d576ce497630907cab8556a5e0d262bc45f07ebf3852a71b90067b674f18530843ae8d1c0579578885331970c9cef92e26317802ab34da7d5b7ab7f0e9c7df203991178a404666d5e0314442244154c62bdb32055d0be345ae5357770677dbb537de156458438cdfe54519221892111bc4a67bbf7ba4dde88d6ac1cae8b9ca1b62d1732a558ea73d054cc76ea0a78fea09a8bf78f045cae978a48bc585b14336ce7d8c75967fec97f1e6459da82854ddb42856ffed0cd7ffe224b2395414fb33d72003a910e4a050fcb770b74da86ac00feca90028492ce7021ab424ba98bbc1de340b0f76f495b037dc958f01b526e5843f8097e3f03be4ddda94b361677b8bf4740ccbcac2a5cf9f1f68d516745813e2289708617d6516ac86a8ea7ba385a6a2a1d6cad4845470ee3e28ac5fbea10af87a85207a9166497bef100c383b9a2a6657c593865827fd6995eb502ff57eaa6f86e565be01c8c4e2011c0c65ba14f2a36e84dd931f257fc6500c031dbcf87f2ad34e50a926998015e9942ae662c37e1d85abfdff2dadd05d06529356dca5c1ae720f1ee804710955d071fcd3221e4cb4d1f5fb1b96dcab82d02d0b024efd677f71227eec5f74d55617f038923e5a822224b94ed388a5dbff027c562252f1210f9f8145d5505afea9e8bdb55e2a4fb6a3cd8f78871581e9787c4f88d1c39000769064fa3b9610e1e6e280979cfc7193476a66cd2bda58bb5555de3b42f46916c957795fcd7cf248b64baa2db953adcc2c2677dedf689fef310791a2fb1c1da3f01efeba24bd4bad6d2a6e00ea22e74e19e045457b8e340e12531ea04042ff3a6064dae48dffa29f4a96683db2d3a78359e954f53eb96fb9886f33114a891b2353d2f1fb1794ef357f2be0afbe7bddf0ceb2a01d46ac38244c7b271371ab6a90d11c6b6a02f409857c6dba499c3d869fb2db49ca2497adee745f79d099d2c08c65de3c4ea6d603ef4e05619c1c63fd1abfb65e561242785a8005b6535b48eb8ca5b091a08b98af0f04c4bae92fe930321340404888d6d0fabe23bb21e2d50bf43e8567dab199b14cdcfca509f62ca8f8d1ecdbf5781ddc901cf065b3c5fd0b9eeb222e30dfc8fe4879b61d0559d7b3a2e6882ab5c65641c1e6f48a51160f2c65f48f3b5e643adcd87b01fa35ffd41cf487023183da654ca2fa995a47fdef7a12a55e7871516832910b0d5e88373008af48980de27330196c85ddecd05e0955bdaff1b947951e1ecc0c684172c77ecd7e39c1d84b4b12c328a2797b130ab8a4d19d7d11cbf8259d65483821863e0f7b622155cc31c334735846c2ecd044905d888a5cac2d80572c493f37a0c1ab3715c7190ae975ec607ebc80407e4b5d9aab0bfb32e98b8a9890c6aab6ef23d2a3bef6c5290de31c8679d1cfab22e24ee131cad7677ec49b8fc366f9de17800a7a025efba31139dcc628f22b8e6622c5dcb71faa8155c17a3dc566f5b15dbb38f96b07cb939c2ac889f4a00b1f644bda4944d19292ad68486f66af6e190d3e8fab3d81890c7d6893dd5cde9fb8fa2ddec7636a86a552c79c1c2637ba94404cc71d1b6c314539ffb3a9217fad3cba766508830ea56ceaad0caed3cd31f847b4a36d1683172fd976e66bff5658f67e617867e8ea49190fe4834333085921d9f76ae9555a4a2616e1902959a84f03911bfbf71767ab2c2b563059e4f27e513123c719cde14de14a6a584d06484abbbf2c0c6d800c4174c0c109643c16824ace9a98e87ebd340e8634007124ce56462a55206d58ad888ba4b5f1e51b11440a520b90b257aa88bf3cf403b8316d7ecf35b994781a07858ba6199f6727949ecad650e4ce8b986ea40dd18d6a8887c7237d8a2e47cf8c97f2ada497037e821bd1c8ce1d3fd6bc210cb632494973d349820a86ac894f5d46f804ca0bb73f6b589820c49f3819b52191d7a354b1aba58a5f2ac1c880368894653b687777d743c3a589c92a95e4cc790a1f443809a6b410cb960efcf2e3785dcd0ddb69318467e77c5fe679c4464d639a05b0a541fa1ffcc5bf7088f18140f3c9c4184b608b5cd739b7daff5e24518156e2c3ec88fedafec6054fba5cd73fa8743c3da30fab7154a9eb668a54eb3c3d913a4f7ad272a99ed9a4aefaa610219a5aca9865319ea97a784063777663ec8c69f8599f63128f35011862791de9d098b8efe11f29b1a67d46456f453e4b3442388cf4785f06d6f8a1dce61ff61896c6798cbaf8ebad89f9506f64a83b1e40bd3feadbf0e2be70efe57726a1bd7a23857f025a191f92aaad51ece7220b2ce8f241102f2e9da24ae6bb6e6191cef6e44a8fc7aa6a95ee1741f02055188fca19cbdb770c40de35e1c903cb11e3236fd3b8d3467b226a45f6bd1aef9ada551d7e93ab396544b0d7405fd9e77b3c36939105e359a2b080ef5e25e6eaebf423f9260c1d596c94db67a84b65fa893c4e87c4a2606990dca308dd42a3e4e8eb144055bbcc087f18beecb1fff189b07849209c1e260878a1b85aaa5b73b3ca0536d7f435c9527de86a9586867897725df4ceef263d5d2199ba57e374d91857b782ea35468da7f241aa592c1667226baec4315455a20b0c1069daa5b2ee0080e7e6a28f8a405a54b7f6eb114624b77565a3cd08949d9b9754e9dd5e0974985648f638c3340ddf1605e2f82accfa1571f08c8ab090bc9f24985dc29df7572eb63669592bdbe451895bac1ce50766c32d7d35b3cc53578de81471df198a6f5ed55acb18448bcceee70b6fccb5ff945ebc375b80b8a63f834e306c8c05f909eae2c30e2cc9343fafeebe5b9b80672a8d2b0c9eef631bec8d2b985675ebeb74958c5e219e4c9ddbeec32f6d54512860db86a237a77fa4467a0775a2b1e59204bc65ffc8df62e1f0f80dc0bb77eb2b954173683ddbfc96bb6b8b7d19eea31e2b6975d74a262075759e5a591ad0a28433e7c3f744f8c2de9215e556a8d074aa0ac755587ccd47cf8d6a28f11ee534cfb485e868da7a57470e7849f872e3e52b18b62d6b3e15096978947b4b4936ee90a66149cec8a8f4113ee36502204b2a744225cf04d150208f9fe5ce5e9a53307ca460a491e24e80bf10d57c2210aecd050067df2d25214d091cdd36f943d77fbe88a51c062c9b9dcddc2865323406e0aae1dbf07a31c9d016979d57ecc5a754169f4c739b15df242e6514374536afda52c53705b7531a10928c05636f825d7a621ed5840a4f0bbbc491f893a5d49a9e2d9df6f5be93541bd8f62e42f66553221f4c51bc17a16b6827a8855541b3e4a1d45221e984ed4aca7266c4f0998e455ee888ffff6293b2da6ce173770e989a6e9eb78eb5ef5c31bfe6951dc6053900033905550df386baf65a635cf177ec60602998b0e8a0a1e6289a250f3d24d9089f1734068d66fb82c44d38d88b92553bb57f5efd1829be12cd103a0453230cdf5e1b8d1caf0b2852f78e7b5b6fff8da06d306266eee6d21f7bb947fa185e1f4df430acbb32ed4b08208703b8325b6bc20ecf6e3e2d5ee4298b0f04172034aade276e2ed9b961bedcdf3a25e39478d62d99cdef32f24b8e7bb7e80796f43f89f85a17100978b72dd08c39f592c402b9aa7bdd02e06ddeb2c8045717bc69dfc6909b348dc60669157a05247f9aecb0eadfb300ae82a98e301ac7c0061251b644d65d27c9a2c1d8b3ccfecb3bd13b1317deda71cbdc1a8dafb33482c57b5f55744422f862a5aacf1120f2c7d70f2a472dbfd3399d5161900a1f77c97abd94b68ae6ba9b2ee76bc4681b7735ade4f7e3469b2579d7bf529a78582f452b8b987ccba4338e26f666c0ff329c3f5bd1798e73e24744e85bd31bb4a3a4a3d09424396ac34555f31d3b10618fea9eb2b6d9af2570a016fc40d5ce14d8f64119301eca067fb7637c6bae238512a8be76911993aec9923918a161a81d8be05230121d91a2c0f2d463fa617ce92bc431d89003ae27d730c09df020295cbcd2250a08fd640ce8b1af0e30fcc1c5e6fec7a64e44b2801f254fc760206c2a55777b819097026da8739f019d949b7094857def725172b49edb00df4993f9fc0230c83c12a73f245eefdab6ff3dc0fbbbc16bcd2f06a5c2a4de0a29453cd8d1c76bfdabd0b7f9bba8e79442600cfd221e40223cde5011837cc2e2d54a97738d480987e68ababbba65a5f039894c305370e9ab06e3f544b69c8b010732d0d2f9de4720552b8411db29f348b1316190cdc8dac5997c0f7b66a192f52ea730cee462bf2c3824ec2945e14df5cc4fc88acf309b7c5f36ca2ae566191f815e5b8ba2488f04979de51e79abafe71c93a40666f16ca89aa2b7022c1eb36fb8ca523c843c7e4f2f0114db325d3caa20cba64f0c727498e7fa77b715c11c2614286edc637b3a393e650e5de6cef6aa50205022c1237eaed2159b9265d4717a506134eeaf96cbf4d40413ed58945dc352802d5d79bb72467e4f0332bad5dfa92a54b514850e4003c3c4595f85a3a7e25e4924123218dc5da27a5059e13950d6765c45e2253aec552bb37120d727f4c032367ec90710f61e33c21a3bd664c5cdaf0b69370559ec98e9073a03a939b7dd0d4927f3daed739029939df398cb92be5ee7b6ecbadbc2846a8d134e130c3d9af6d11667682154e8df882a2412c013817c5eef3c0fd7b6325629f049684ab076f0990c2853939b65e43625c022a85b4de35da1a81b7362eaef75b90bedb1c0056b4524c69e1eabb65950c5d7e4b8d714f74e8dfc81280585245738ec7bf70947787740df38d1df8d2aca95473b70b375147582fc1d24283f3032b7578313fcfce0b0a6f83fd899962e1dda0f5617ebaa1ebd2721231930f02478771dd1bdfe8b5c6c0efd19cc4fa62e634d91d6d9619f817a1ea78b32c3ccd3d12bddc83ed33ee6111ccab4a4b81a1d4bcc9fe51bc90c344f32f1a24fd878e7f8f928c52cf97e0c49ab29b60f8fac4ffe572a3b2a75923dd2c5dcda963938316b86e82522bc678950e303030c1c0c2044fad64ab51458e47d01f086a8d88b00d37911db1727f61c00ed3febc678f840d3a566081d988e8b6eaf25ed0577ffec4ce62f4299cdbfc6946a13d8932bc5c1a9123371ccf456e8ce1c50f1fd86c3b5f5109079540b98aeab4f659f083694c499a71afc289ad94b58f6fe9a4a1f19ca53a01b0e30a7221f3e90826bf27d2dd95e34e84539283f994f0dd5c916b4b7b40d4e82d0f757159ece9ad2abea345cc2f1ff45e14dff5bc4ae21f0a3cf5c78bd5ae5add058cd481005b24b74ca55733750c4ba31bfef1203d6506d88261acd8beb5ce50a9d4510c9aeba4d507748c364cb783c167d93b6a23d81b61039b47b7a2799fb1da78b12d371d3ec19bced0ec7c06560af3b3bd95984afc000453d38534eb5e40cdd4312e015681075473e6cb24ff79288792b4d3b95c0cc210afd3aa8e03c11d3f81c7966b4cacec215846bb6d8af8e5479b0aa16a6a8aef8b2c2430af7117464b027cce2d02367543b9a518e9336564ed34d90d21e56f2103a6d0f191af5b74e419cae43b82c61da01ee5afc8043aac888fd246963cd46316b55cb569a1060628315de35058a97f0a8197465c8d3b86529db740792ca8938adb0c039922283d129bd0058055c5c1038cc31447c2de8edcc4ccc1630da779d671ab083a35098de600f914104f61953a830545055c7f6c80b6187807d4a309a44921e04d7897c157e47ec657631715de321426600e08d7aa8cb96fa60cb52a0ce5f440dab8890a3486d2c1b46c9f4fc8168a484f681ba12139264cbee9d801f7d3a0af454646774a8718f6c8cb0f1e345ea0fcd02d67f1b350a673df147dc6a9907def7b32e13a50c4651e96230859dd344da97c43caae4abf4a2199fbe0e1996478ee74f4add80fba4baf621e0e49e65f3309fc4363ca3984166870894e58c5ed29e64b5ef5b6359213adca3266e40475210650c22255294d7eb79458ca6e7346436cbfd42c0c01d8bb05181485abbb23db1db520ca156d979f0525dbd2a23b06c01cf93d4d61622dc2b63a5ceb9724ffdddd0398835382b77dc327b00ba04033147129742e3418d90e3098a74d425183856f70c1837402d973bb2d153cf1790a54a59cfbbf18573c9df06f76c9e97130affe3217fd79dbe0275e26e32b6da02526aab47504bfd7f4b5395608b80528ede7edf11de1fa6e6a28e4576b74a7ae49c8a41cb64a70d21d177044c6010720d94a25e938586bd632d20d454099020277cd01f3e5ddb6c2624c7ebe8281888ff893f3ad2a596b85e0605326c0ccd9a1eae00f2a17b25c1a133aa75947433b4c5e39580cccc821b646f3ed3163ae935285bc37c6c054206939659e26ae25c4a700137d862f59a9c72e13ad23bd5dbc8b2f88a29090651971326add27250fa0d5b72c2686054456c24df41ab515b811bf45931a860b9f12038a3ac44116286c941cb2e46031c0d69d20a3ab22b7b2b2f80cf753445f495343fc3dc308ed2014d8ae3100092266773852d287ad15a7fd23fbe7bfdd76e0aa8e2d01628c7712c8850070e40299e9fabb4628080c87a82753e3fb9ceb9c0f7acb6d5f0533d890f62e4a76714dfb030a95137a3ee1a5af34ab7cf445acc113611ebbc884a20a30bfe860b55ce61ff215c3fc6a962c1e874e16324969f9b5d9b1b0dc69815ac9e8cc3e45e317285de03d4583cd928d1302195fb89a186543c417e4faae2907fa2e429c3c19c6f2d3543f3d2dc73c2527eec637b7186306a4db50d7fc0bd766cb71d5c04367f09920ace895407740085833e09d27ecd144dc904e5a099908b39c1d27f1138bd0374cc1ed4139155926a944f43936abfff5b7618670fbadd3eecf455b36d2c936c01bbd690755ed198e6a6e4f6621922edbb096db30c8ec9edb65173022ea8ecae2c2df9899eaac670e9614a10eedcc8cf7973060c15a5479f21dc159b598f563175cf1e7cacbe18c30e5616895dd2d0509d70be610b8d47ea386d27f365ef844b52eb5f941f511706e4131ccfe8e94c2cc0c985be6c0f6aeee9a2117c6c71438bce1777be0b0b8521b57175b4ad8c41f5908364257f035324b41e046c7d075d206b191cf73fd76c79df3d838aca37b9c258017235c88ae8d49a9982b3741d7ac98f36b96400e8c34d39e3e8b60eb42fd5591fcd99425530b2ab185a068700aef04d02a7062f1075b6fde1205741873cc4e6bf8b1df24f7bcc0ec5947dbc62b9b9dcdebb51e525ca64202aaaf3f3cc0d00bfdf46f4aea08e009778406b20288c6d74f94b49e723caf519db0cadfaf7a7e799e6d9d75507467f9398321eb190c4048d1478be5895267f943cf6076d494820bf5a60361fe436882c5647fdfd79179daecb014bb44594d84eef41de6210b9a6c15433d80a734cc1911fe190f26847dd2a849c1e56ef578b43f8300588de65b21a0d79c563470a496de88020e4215a5e77278d7adec649a20292ac5973dea3954526b825c8d569438c624f45f2a0eca5a0970437be6b38363d7d54a7aabc9c57e675c6e9f85e5586894651cc5003de4d64264b7c9c13623c2d7f82b19e9d6800e5ef22633de23d9c830d191d6c7df773872578cb64e62d1ce9c66e206df4f842123577c4009dc33573eda84f94d405ec101266a1f6bc4d02d74bb8b5dc644659159c8d64fddeeac3828a1e790db95f9eaa25ca61974656493b8b313df8296199ed4373bf3f16a70d24a98f533a1013d827f0f39caff68c5d086e6186bc479b78331a4a56f12d828fb4d6002a092a67f43d7b8bc4410dd15fd0c3c05048ac16002a1ebbacb657de136dcad6a8b13a23d7543b272eae8cc84745f5c99b70f2bcd912e2cb6167ebeabf31de1e16b56f9eca879c4903872ae57ae14dd858e8c753de90cd9701f2797f46a12a34852d3663b253eb9ee76e59849f8b7cc0e8109455492bafcbee84986b809be53009bddb2697e6b6c3ff842d36d20756cdb0f923d2aabc986e331d2fe18032ad28ef28080e7a3745d9766b7dd8ad6da19edab9a90dfce36845df08d04af8d73c8798fa32605558873f8dcfe279041d12520025a67d38e2e19df5ddbec1fae352d3a8daeb17828af59015873acc6271f1f586771cd2062729d66b98d8cd166fc32c4c5943f7cb8d45f4e9228ef37cd7bedfa1b433b63e0065b317f55756474f48ddd700bf8d10edbfbab05741b2f9316404dbb455ae8341133e32a1101d0410c947c1c9e7c8d1bc0d61b8cf78c7ba03fc5bdf6c4f64317c82716239c687181a83faa340d1400759194ad66bb5151f9122182dd07f50dcb4a75a398de5c593d10a232dd18ba120fe2c6d6f30fb72d9c2be0e31f459fafddb659b833d840b63426def1380bec697b44c2e2403125d57ded213cc308dce5a4652e38ec1e27501a5c0abd5f8f7983da656fb771af464c7954ac51f536325f5652f7def955c4643d82d7c7ef74c705932deed7506f1122ebf07a17ffe958ff8a456ccace0755237151afd348adf54e754b7174e2b61b1ff5c7dc6daa6379d3a4f296d9bf56c8f9653902d4e235b7c37d792438d6b1187aebcb73888b7e2b62b56bb43929dfadbd456f7a438df09f021e470af6d02e23aac9981eac4dc2e40c46068bc629a9d74746040f77ef97dd7c91a11a8441b1e2ef4e040e12ef76f4b7c46fec7e501ac56385960d2feec89b3f56341a4f99f55d3432e8cf95e3df609772176f21b29a6dc1c8d252253c1a21e19724e4ab204e047e543689ae1d53d7c66e470a2e02ccd65be4b0694a543de6c2600283fa543dc38eec1e3044d72a2d9b58419c48d87f3651d75eab6eae025ba8389268c9bca7a016f8d7256bf510b4a9b02a4cc9aa1ea185e8479900109e22db8dad4551d127eef62c8f6b6f25f50085854b44806ea9a57665d79855dde9e13563412171a2c6ed5a044453cc6116a96cd6dcd17f0164704c1644d6d85348d43cbf3365b78c48f29c918591a7247b423695ae714301b5415b465e10cf31785e77104a5d4b52ced8c33fa4bd7728bd385bcd72ddd9fc02a680c76acab6d7064709ecebca07727a977170c8590524a985ac190aa09709155f7ec635664b283a50e4a0a8ab6fa81b963f811a8fb029f11b2bb68e1880faa7b0891f688d824d3e6017ff5328dbe5aa273e089bfc4e12087ffc155fe1caa8c988d84e0d2de68d491c21d53ca3d57baf2718240453d4b088fe189d5e597a0ec78e47e9b6024ad3c326781fbf8a741bc5fe4ca8bcde5bc209b559790967187ade696d64418155ecf05bc48d1c40d262353b4600490b91c69344ce87cc864f9c3473bcf417a4ab795839f02d127314c6c998d6a0d03f509e5621ba9160ef8cf2c797b743d32cd5b80bdf9ab78e5e1814bb3e298cff1b6b89a98414cf0d9f8b546fa86801f239f8dbcfb195fb7606cdf107616d65367be34b0850e88987fa30e99159d44c045d2d1c2d7a662e060b87c06f52e28e1f4523f8e36f4d0dd000bffe471abd3033a19cbbb3062b51b4bbd3122ff4e4268c5e76c94a7f0c67963df1ee29341ba272e55b3884456a12f8b6fe7483cc6e1fd077869d70babe1ccf32d9ec0fd562cc4cfea54c742f5e85a7ad070f02773ddd8b793d5743914c23b125f3184cb6d814525d74b9407203ce580c79cc6ae0521206ea6f7ddaf50478fe4a274ff9735d3e8608f3b0e128b7d19d1ed3ea91cac8e20e45440d0493ccd396de73303249504dbc0be7142301ba8c826b8bd955fd65f02741ac7385280c01a5437c3a5520ee7c0ce8bfb12d5dca1e51f5b68b7744ff6abf2e57a1d3ed4ae04f502a5770ed9173784b8819e90e4cd941a13af4348456d23ec9165a1dc8a619bbcc016ea3d2a6f7160483c2f6ab3238980aca2fd3e4e550f46d20176ff9ce606a4eb18d6255b0dd1ee8f957c1a336f6fe4b6dfb328b0374b974675feca85bf708ed873be12bb6969e2c7df31506ab69f658511e39b884c3c97278e634102abbaf2473bca30a6e68c3739d1130074cd8a61eeff87435dada580a78ccb82935c839db6a896d29dff986308afb9736de9f3aea8a15d865bea19e0c1b8eb8b04001cf8c9cb830d3e8d3662aa15eb0ee84c85182bd9d5484c4125c11eef1edbc3f0798bb274edce24eccf5a8f7a3d8dfa625d792a9a4af99c5dc370e5c22883fc02b642a48355bf94598adb235f9fd19701a7f6ab5a73d9de7d31c46dbf6098788d8cf7d04f3764d86ed5543a1560009701851354a0275868766faa9e1d46160b94fc918f11a838cbb06d1402f0f55fbb70f27c88b1b0de4e2fd95e3edb93594507a9f253868584f6227988f60000b056856fab439b82e85f52260fa8a6204c4d6e22ac03366925f2da6ce151ccbc1fe5c6e1ca7aeba046822e0dc39d0cb70cff6e0929c9c8584b14a398ace28bb0e792518108f440e9cd438bc2b45add78563274bf07ac134ee52bc699906952d67d60e35631364b52e230798adb716b7dff8c9bd444a0b91c75cc7d722dcc7fd1201ec0a879589c1c2a4b8e6bca9ae5327af53aa2f51fa8f5c92ad0e53371a1f5848bab2b816ed1b88ae35eda148e00ab652f2f9f80f901c14f519c12d58233b9ff086c0270d28fa539327a509f9d463ea050d2104a85b875314f5ffb51b061fd2ecf667f72b17da360576b1c835ece3eeb0b8a631b2cf6789e80aeadead707b9cb9b10393fb6e21eca46408ea0c9899655d92da9b2cdca52308ee46fbadd9bc9a9b35987c7941dbc8c9af644417c87c439d300f7fddbfd642491a36c89388a951fb9aa9360751aeb3b72aa12a1a785638b4aa0dd5fccef6b3525de5b4cff0621e4a1884657eda3ef2ccbbe86e71009bc65d1d376aaa3501716c85fd4c4f60fa5da3d6926f18a6bcdd950de31c55192963f1ff57e47922e295cd01919f7dbff2eac2ea01aca27ec6f8ef956d13c16d24e325bbde99a0e5bb899a8f3c94a424095c9db52c3fa928c31f0cb182d13d7b15d2770c0980bf643c4c1ee2ca206e53f077c090c3935113f7355eb87e88ef1b9efb39768d8f24c507b44781e9ff3fa831da32e567f3df43cecd19dfff79d1fdc9d6cd45611318be79b85f6ecb04621670fd8ce0f5708d9bcde7463c180d1d36d21df8fb8f3e29d187df3f5d349850eb73d668fcb4cf062c7c6c209a1c2d47b354ed47d5e7608208bc3c6ee3aaa8700d8c7168f17d974f8729aa29098d45eb8e19e740d341def0b7dda64c69cbd1121a4491ef284c8f4c5a698e573c7c73ab4461172d9d564cd9b38b813a907aa5764a29a0799c6672b70e479e0119e75c4059cd688b8122e68616bca3b71bf30170471d75a543bc48c1e434f7771b7c4a06c424691c991c6d58faae6bbed620c9a0d8fb2e19e81fd2177f12d7e579b62d4d2ab0a06f2bd33b5f20ad749710f3b36d1bc35e705fd4bd3bb3cd15e7ceb356c3e674f36fe6538e0f5ff0dac3521312907bde8189b2babd79e17b67d4d4cf0bb02c11e79fc451d5f9b9f4c3e63dd77652beac769f7a72cf7b01e8a6d56f3e3da8a182f8957800ec81f427b26590e05e22f6faeab06ba7f4145ac75c9f7e708786bb1e551676bdcfc9a67d0aab551fea4f03f2e1755ee40e56bcd272929542af9e69a978205b55d53176e586168d40511d893a8a2f00f81915260617ed749eee6696e5843fbdcb1836300fcb9f95b17235c34b194248170d475d690a9e6a23a1efeaf79885edf97a2eeef97fa713c19e9056c6d2e79752440fdf5b1361c99e6eb7eb80479b43bd75c51c34118967a1f5ebb8d841a366c5a7aa25cfd221010cd555a4c1e25fd1ff6224cb424c00f110f56725bfc1a8a2f4e033c18eb2e8b87523280f2e6cdd17173c94dfcf192679151afa242f2c74b4f1e13e2b8b1b99b0b211d499716bf3d65c91087ba0389a89e18b91cb42aa1902c4fedac6f380bb203f6aec33a125161c05b60b9277d97b1dd9383ce48139a5e12ee5e5b101cbd36efeb0dbba63987848cf1455d09b4b82544bc7f2ac5b26c5ec54d8748ae6b4c7a47e8ca987a49ad2f74eb0b21bfdcd0cbd223399a2ad6723b687ff2fd1a21b5f219218c0241eb71fd51b1a3aed15f693527e9c4b976b618d5483bc8fa324a55ce79c8a45675fa2440490e9dbafcd9f1b274400b1bdf043b50b26091f55c43121552770b4bcf98daa2727c0ecc4498a639c1e5d8873de5edb59d3fd574f9c4efa9563d440ffef9923d4934ee8dcdd94ccb6c25528012447a7e8378e8f101960f163625c407f4937c0e210f43577b4d48f503eb1ee5801529979cf43def2193840d57c4be3798bfa82fa74a63162918e092c3f5fc68510c49524d08934618aa35eab2c112e20d83071d1e00afe5215b32309160d6e0e0b5fa20ce89d0b93ff24e311c089ba67b1d53a32d7831a9f8155f29c11252706c1435c16e623cf8c11751dd231a70e8e3b5aa36e2f68719fe922b3e935d8ee0c4a598a8f38ed153b623a58fe29c0ea44894af3c3dc1793d72f28720ffdfc27e0af020d0ff0af4c616a9483f199762df82820121ec18ca7eca0b2c7092d026a9adb9d5ed463085b82ac4ca1dcd3dbf174e1684a3465b16dcc0f1db64a7768b45abc0cada9881119e86b711872a38bb279f25f933223f3ebd06afba564d0965dd2b849a43a536be5dc10dda9a3dc0d0fb35a72c28e12d29cddbbe8d4589686c4db82877868b80ae4ad8e09de7d413f42aa2423afd2cfcbb88c3584505665a1bf0a2719e93c6aece13f7a82767b20e75495488baec60660fc0313c91682696548a9a8541fa52b43955bac580b5dcf108c2c6754bd6a6d435f9a67923ad790bb249a7c408151ff5577283d2ba807ea761d0b9ddd8a6bb21e84c2c0d3e0c6e379b58954a7df26004e97effd3681df734a83c68d6a29511b132c49ea4a5cf63e18915a17863668a65f8c6bda627d2a6626612533cda86354664e157c7bd83445b0d6c48dafdb13dfcad041a87377ec24f55872594ebee339b9e01213ed671ad5d2ebc82bfdf89317d72c8ebdbfc7b9ccd30bd4455596a633e4ec56af31669a8d257d29da7831c35aae7032d1bb1ddab24333c5554be10676cb25bf95bb60c84c48571b08b601a4f23229d575e5ca003d62118aaa3b76227199591658af90a0c63842c3cb93be40fcfae98fcac2483c2ca3ab4e49c780f4f45cf82ca34b8ebcc05aae360868fa8bbbd99cc42a934c8bd957ecb0c6c63b0784c742aa3a12a52acc6ce9bf225e1bcdcbf6974406d14e3066f84716f8a122f4d4406a87b35147b4e687892f4b83ff8501253cec5fcfe96516fbd48cdc22fb114bb404e0e695f27aa7395839df2c5c1a61f229e20ca30276f2fb868183d0ac33e0faec6879100ae548a4f78517b6b470829d7e6c6919aa209a49c96103ef37c5b73c8dc93c462e0e0afbe30bdaf42d5421167feaff9a7bdfda2d0cbea1ef4b82f6a8655267976de1517f14b2fcb8f267911c2cfbf245544813165718173b00196d40f728f2cf2b2c78cde4c9dcb23f5c1f1755288db95c8180ad546152420dcc2d62140eab0a536aed7f4aa1062336d81068e8a7ec86833724f54e05b9e064e997880cb7dcb57114e3dc7fa0bc08a7e6698a6c39dcf97b2964771a9e6a5599f0dbc281cb2e0d004673c8cb37e0526a6768fb32acea396d66b8cce3e6fa62af25aabeac723bec305fde2c48233054b8d812f7ab1a96fda91550595832c4174183b1eda68d3ae1a68bc6a5d0d4fca6f2d70ca5be6b586302607a41fb5493617c8c045ab8c8574b3f3303749a361c8030765287525948dbcb4a72758e39f9b5d4b16fe9c5716e038e07e1c15e51d7ffb54bd5190bd1195a485da12833404d48541de90af13e5b7f22613b2e454409c3f595fda412eca590f666b256f5f96048b74440440f486f96feb13256f50112575bdced8ad078cf7859efbdf3385f89e6766255c60dd1e5e4ccab4f4363af6e5ba17aeadf9c805ef7c6d42e30ee1693a2984e741ab7ca0f81a15577cd0e478930b2a038ec580f27c290118b6b859f543ac04f1f3ca43486749aa69d74687c6a563d8cae399044e67ba30908919ea7cf7ef6ee67c2bacaf57f026e97ef669fc4a71ad660062b7afe28550a15a7ad580a6d5357fb212170b45aaaf40e25e7b94fd871991c22660b763688b94761b7874b5c14d54b00ff7dcc2ac515e633fd117cf7ed9b3a622278e9c48e656843a1bfb65092128caa6163603c6a1fd3dad7a867b5dde0f33d8d374e326f689552770c5e0484c13a2531ca9081fa3fd81b9c7ef2227488cadafa9d1caa8bb858888f9eca87c11700b4909438d96d4e09633ad52379d42f208b4a6c298679acea2de03fc77cc0b613ff7903b24119845b3d8bd5206717221d06ce75573717d1f7a64015d8b61664b6692608f41875a1a03a234477097c31a965c152e8f40b1bcf486651d57911870a0bc6d02db9e902c4f3515c578d33359fbf95a18561afaf7c88f4b726ca4df8a9e183c1ba32493791d1b8244e33fc7e3a5122b9a6e8f4927912872e3584be3061e7eed46c87808d66bdd3000f440ad7119f2863818d30a93e5a0b83c9576ca0953b817285caf303bf4c6a8735780c2031f433cba5fe765dd4520d4f51c4a165df92f6efc0913048bf7764bfe16d1085062f37e5238667bfdecbde9ab70ad017b7377adf6049f91ffbc3bd2d6c882e013b53221b3b6382f3399b8f357c8035db070a1be7d70295dd8b7834e4f0150515931a2e5cb814fc061c3e78992b35b239cab74c67710d79cb68dec9eb235b014676c3e9129b1857505174254c699bac8831b349f6e246bc431aa283d05059f92e293bc5ebb62f9f82acaa4b6b2c4eb0088fb15cb919dbf0e583b0176c87bdf148c053df8bdda5b09b9aebeb05f08e6011a08f9836a86f55e7b356f810dd02e433947384e0cd2825cfebc7c033d7c25aa1685d5d1a080692ac6c6134889cb01580384e710afc653d1fdac7bf99a5a5b5d0d3b305441f1ed8a5e1bfad59cc1dbc88757d725a70515897fdd4159b4ad63d0961ce65f072f5f1e24b4747ca0da9af24a557dbb9c3f760ea8461320753010aae71e0b7b02517c890e1ad55f168c27bf0329c0fa885a104a6df5b76967b16bb21382d90240849e7f5dfb8a6c24e7aafda2d2e766e06343d40c803c718ee7aa1efa7b720b2442c37ecfd4e64069473f539bb85edee222554eaf786b86af2b15b328b4f8974b866ffd373433a0d376695165f366adceedb6ee65d2cb5f728113839f1185f7933000f665a03490a16e013afd5dcc4cf60aee48715a395abde3689e326281c4bb017f6f8422fb791d82ae3004fe1ada252a00a38c59725012ae2b403cb725d39cc4146c5b0de534301796f1b8e8a8e144d07b3f547a6bceb765c764aa7481099c3a766bb88b7aade25ce37fe96e93cb997c33e79dfceebd71c8d86c277618ffdec4dc9aa2ef3e31cea586554ac95464688e285c62b150745ee54be09b8cfd9e5aa1fdb75803bf1a1e99ccd5e66644e0c2f033dc924959a15b35b3db633856037612d1e57c29a2df3994fbdb065dcf92848ae5b74d49cec6da11fa744851ae265558a35ea9627b1878b5c78dd386f68a5fcf503e4cb397cd974fcb998ee43e6bc2ac8e40da804698fbacc026409c6dfa5d8a11e4237b44fff47f6a8cb1607ac28e0cae82b697b585a64d322e17955a3b9a55475f7e8a1cbf1ae102b5334b14558203412c658f9408f6409ab7b4c29bf13313f38038c3afa9d4514c22417ac6978caf555c1de754f3d3626665b826e6d418a42744d8b8175481c1c314188c8f97b809c98bbeb92c4a07f3039d25d31cd4bde992931467d366e9a6df17b5465eae4e0772cb38f8db0ddd5755f2b97b00bee204741f8ff003c77d44e82c3113ce94dceb9ceb15b249ed8ba05377063f7863b827d7625c778cb98beaa21d60afb2ad9cf7ef5732b91cdf2706bb3a05b929875e26cab797c7d71ecd1da177bb734f2a1754548194a0fb66dd672c0ecc6e7131f6cc9b7a1f7692b2b272c24d0815fac9fb5f1b01ffc6098e13ebe62c769e950eca1ca44172513a37434f579cd2895039664b47c789b844c43dfb132b038f749c0921d2c2da1b820c9f084aaeaaa685d8a2ff4300e9fcb9bb3e1decec9bd5176259563e15a0eac5870c08218df6908409023e68079656ab5263bb2423f8b51988d7f144d3a4fbe9f10e48adc576348bb72f5829437055b816d019c117fc8a251d7a6c40e6406454753716eb131c9c2a4b242dc10515b2951cd8de694f408865830cdaf5ba58fcb3128121ce2db563500c1cbb9b4a4193a845c444fcbe90d344023c775622230e851a2a45ce6253212ced2ea7fc3d71f023dfe246c5b8eca13d570aed11ee6ae2b913678882f4cba97d2ea1a96dc6e19e9a4497fae61a2972190900c364f664ca437dea96892bd702e6126419a1554ea7e81216afd98fdb1a1beb276267d8884811d7dda8c69b1d357f20585f4a66861dea856570f5be066aa6589d685aa161aa7c1c5ea79628a009816f6682bbaccf14cbb02a678f6c920f99cce891d1f1c556d3742f9605bc3c09bc7428ef7a5452f14f373eb148b20ac7357ab4a8adf35e7b8d22002980e76438b8cb4947cd7bf5c6afbd0fd1c1d571a34900a5d62f243f5b2efd484b8c6389ba405482baecd8bd027f22fbb72c25d76c7759d902da26177f59cf28021be2098b8c1a8c79d5e17951e5f40f0feeeaa235c3ebf2b3cfcca6a42b08108431a0c1e6a60775b530fe703f470a34d0122b8ed8ca904639519b94be17a05e6508c06a1791994feeaca0b9ca0721209d19e3859f787a233755f987217bb63d35ea076797f88e535ef4ef0b368b49be99fbe26e5d55a500903b39aa04f489e67aeffabcce57b6d8748e1050c7ce9cf4a53a9cc34df4832df032d1829092dec63e97b4badcb8fe43abb8448a1bc07e78d084cd26cb0af5e48a150d933ea1412117abc442044147ebd268fcbd951a4a7704f34a162338905e28c249a1836eba4bf94466dbef05214962c13c98b4ca9b7911afabe36f04b95a2f7b96d799ddb1eac3364320eb941cfc8c9ddcaa6afb20cc0fb7c9a5631dafd293fd6f73b13f9d9699c71a8851979318a189e9e7e87c07ae083f67cd028f81cbd654712ec4914db8eac8c8aaee071974d5184b114fb780625e3ceca7598cb4945a3b03e3ff0038bb547977c4b6187a7481ef4feaf4cba754c95272b58ada88ca08afa256b89c9e229a7a8c5a2e6bad8b311ffffe51ddbdcaeff7692642ea9b5a43090f98bf2ef2c7c2bbf758f32254cf04dc375d19b5952ddeba34cc713d8c6f19a159486b001f3636a91704c551a3bd9540115df7125998d821e9613a8c4d4a2fecd952185cd31f85aebde1e5ab182b109f3af9da245747a2d55e0840ad0ad91854fe81580d87ecc00dab66f6a23d7d64f0cfb4592422ba96d8c9dfe4a7ccd1753934ebefb9b7a65c504b4fe616d90be1187f3333459751076edd9144df835570c51b46f4bbd7899b1be6bcc5abf15d79a19c79a3dde5ae9c0fe6b76ad4a0dcbb42cbc5d91c21dc4d8bdce814ad81aa8aebc30a7d303e4d62bdaad279105b9bc322d0b42fb0c5f2023a805c3dcaa51597f70e5da4a3feb3306478bc5fe5a79940f387dd46c5a1b57693a5bb2c38c73b6a3515a36d817adf2d0ab45ad49354da8f1d7899a39804aa70395989ce53472315dd8a0a1d35aac52326be1324c8f37fbf1e56b6a6f0fe9734ed3d3c99bde7bcf30a0cbe7d7052e8e106496df4a7330d72002c4474b5f457873778575dca2bb0ce55c3c87bcbe89f9a7fab43774bf06e03defc803f995716c2d35ef37e2fed938d54f73df50496c54a061c59a6e5f72f5ae3300c25f692ed27fed5a895c853c92e3817dfba53245b1335f996d661429e77948386acd3a17811f11a9546c21d6165b313a64e4731d59d9db94791f629a4d2e171f0a1fcfb3fe4caf01b6904238a450a762d4712bd06d4b078bd0bf6578facfbf98c674cf90f1ab551efb448981b7b709713a1e12e898b0021e7af2e6fb321c51f1da5350c165bf777b0bd7e06bc5d2ea7edde32ef12db1d9abd1f6fc93ea9dcc145983b0411ed6fa49496273d4d4c6af53cac21ea5539425e66b1400bf9f788cb0525fde40d659141f8fde1d939a974ddc0cfc0a488397f9129708f9cb053b58393b44f689c9f3ab6f6bd1ca0153366ef01ec90a9688fc85eacf85391cb0ae78b1de76781d6ae1137655b42be01d0f28e13c7988385d22d6b8006f04f954679b749b3b965fe389a721ced58fe6986627707cf68598d8866cce3f97b79d14672a79833eefa9e475380f093810f7800be459be8648053874f81419eafeccaaed6d7b3b2869ec13d248b7f396bdfdd3211e85ae4cad06f60ea2f2b329ce998fcc13b9eb39607f0378080b72c90b7762b8293a34429fa2751da1dee3dd4b82980f3d977657490b9b2d8266f6f03d2b02bc61aacfb34fffe027a1c15fdb3357e6792b8b1e0370cf4ee2eabda497081b2e7b4b8643121895ceb6b3306e15f11e943834d0ef2a984b1bfa54393638eb67fbc7e94bf57e1d75d6f84da848dbfc71ee396540747c258dab6cb8b15fa31e273cb63b59b60851da86e52af8b79b254d7d55cb8feeff8d35130d99c76e8d86653621f61ffcb7b8ab12dabdf8b68334e015e74acca2504cf4bbd786e877663ec4c3badbf857b8c414414dd341272266f4ed91393d4dee7758f46dff45ff3b07dacf18e949622c3081d0b667af1f0cc256f26b1c41ef53fc5ed1f07d35cad322a576b3acc6279e3cdba0961862ba64f97e61a84b68060f9455301d4727fa54dfa174596d3ae89b82c23efeaf43970b433fb7d1bab8309128da972d3eb6dfc549dbca8b4ae22a8d1b9ef08a1e7e390b0e64002078fa30544c00ea8dabea4dda82c56ecc1f0786445a6b9fff494810825a0286bd3a0be0c37aecc1e66663e58decb8f24af5ea59b081e5ce8b97a412b6f3b14cf9f63bf2d62795bb3699049307a7615d2915ad6858dc448980ae0bf0f484433c47f3df547a26433db6dc5ff783a687797b632ba918ba1f4b423dda3e582ba111258187ccc4e6e7acc2864c81891d026f3fc3762e363f398f20666a64df66505c0186b5a09892eece7e8dbaa45162bdef40fa88663337081449959c29052483f9323acaf7a73048988416dc3484a2ba940c4c1c9a284846b49feab2d0cb6c67275934a8bfd53b4dd78fe565e8deed8649e974442f726a32292ea804e70668a0a4e028737cb5a0ff2da6a9b5d138044f17282778707e146c9df50b010a1813c412abd2313bcb424cd5d145c3197f6627b5a320995f4cb6c9776862726d7f555903bdbf8cb375224665b3e4a57429f59fd9627a62b2bed7f157af56d2a22f8b1d8944cb8c4315130e67af924bcb6944241be450a533fc9b78e593f91f5037da7640762075a9afd29e6f0ff416133043dede0f001d9209faf5107f1af684d61b662b1757da5578f76603abf580fefd61785769c284b3ba43d115f227131723bce69f9cdad3e53ae86eacd82daa7a2f3b1f8cdf6b66d86c64cd2c0a3e05d3204481aa5a70d2488174114fb26fa11bb693e69ffeeaa51fdee802d89dfa4e903814acde397112c4152ac57634d1746a53115adafe0388faa1460ca30797ff7a924affce5dc814c84f679807c1d8d1d91944d7ef917aff7009cf9c167715dbc9f2c445be0a72c7b65041a9c77d0e7c773166d0b6e4450fec58791dcfa3b1657ef88ba150185bc5090568a4993493ed4039f128a90dff8a25b788d243cddd79b650fdef1e6fb155d218fdd04071e034f7aea4d90e8ff79ad4341f1a3ebb9c19f8d6ddfcf0887a50bd37cdf4dbbe4c24809dc30dd1fec82d6972eab562f1f9fb7f04ae17f0b1390137b19fab8f8c046c0bd02d6f271a6330ec5ed555874136f488ba05cd6b8d76008c9a90ce20db7bd82b5e50a19854563652c4dd917c0a80d983fac7664b55f5bff22f69dc5b090294bde3620f2b7b85552e4a1192444b1dc40f8ebd7ef6b67de5fddc8f60eb7ea22630d24f12d741331fdd59682c8df1c0b9c109622e6acdb57abec446c9ceca112826e018bb1cb9df63e695fffe3f0d4f40605ce7e2a981eba0b7133c78a680aae869603f2a64fe6260a410dc782460d2e8b2dad96a0bf21db28639b42ea375c65e8ad7718b7a397dff0a6edf668d527447f5cc79e361781b2dafa354fffef6792d91c7ff04b6648b8f8fd29b7ed5494d29ee9332ab2e04f068a340b5a7cd67349ec87494ea3b1d10360ceab784798300e6d044a9b522da1fa101b01f4f402bc76d709d23fe83a91d929c26143a963190e48c623ea83d866595033ddcad1bee1575dd06baa0a321e8473a9e77ff622b936306e7898e10d2ddb3c6d15e39991de6554ec7a4cb87ca8b342f3dc158b9cd353b9434fc0deb8ecff5b1694422246b896cf07b8ef07830f5c5f175f7637c5787d516a44c2e7afbe97520ee79765696cf7a1b0451e9d7b10557e70c6f5846d3931c6dc11a5e61bc378ed62a8e269c20d23100c90e3b24bbf3496a763a3f427dff3c31f1b65364dd5afea140ab319e142c306a2d9f00d53741ed78a771938e5c38371294f46cbe178125f042fb8d5d21fa32e952f01ae9837e6c4d8f00616bc057af38fdbf44fc799d373f3a2bf475317b6fd466d9861627d71b47241d011a7d59cea00586451be99dee11678c052cfadd280f5b506a4ae4f9c83800d3404f7a8fb601222f60dca1bf0c0b4bcd5c26edb5d7b15c15dfea30da341b8fd4365f958fed3487cb50dbe90559d64fc7c214d48c6fc38e20170dde22c9e42d0d23b6d7df1ceabdbbef1462aa363920d692b8e77a7df996976ecb6e56db38cea0d44e69434f84fdfc2e5639ed4763773b277e7df640e0ae5ee8b68ce760342e0d2fa453f7623dbaf03c013127740c88ccd7e3e71e40eb36ebc3100140d499734df0b7a9a909facb4eb30142861ae874112943bcc1686b082212e9d07106092b1619cd43ad783d2e148632457a5e97f47c6f2c0e31daeb5cfc83bea68e7b861b37462fb0a060cc315ebea94972e5a47b37d117d4cc089be8dfae9225aa6aae444a6c04c88d522988c62ea5155b331e6237af29e827b8321685d0fe08862b4f8f15779f1d400bfe9a0584b133e7d9e2dbd98de561b3373f60e68835d2582323975ebfc7e3547e9a00a75ba342ac8745de650da7028d569b597c8ccbc179ccf216b89d973f5ddc4df331f8cb25681f3056a07e5b6bf4d3f549140ca9704f9bcc59ec7eb2bc0940df463d8392e49aae714750167c28eaee48d1d01c9e814eb3fd1b2b094b63783085177facdf60f2d5ccdbbb68cf3585d80fdcc1458032df7f1fc700f389cb7abad0ae2ac93afc0a54b0ff8ccda5fed4bf768ee49928f4c1e0610a9f25f5a38d5ba42f34b2edb04adc89c8927cc9aa5bd385d357cc0c8fd720545cd1b5ebe237e5c9a050e1223ea170ed573f885b0e7901fd858061af29a2615c8f316ea380dbf2c37494f3a2f5d82210ebf32342e4b255ecbc80ab2248f605a843bd70e89a07e4f4e03ac5f2971b828c26b5bd307a86da60b393de0eed261b5f6799ecd752d8355ad8b3e32f0395f6bf5fc007a6e541da73820bef257e181891579b75150484fa6f74cc8346c8835203eb3b259fb37b585b274b07eed83e04ec48f6b69fcddec621c9d801d84b4e0c05952f89bbebf64a9582a72b012d61d33f40043e7214fe7a210d55db3c65b02d21fca52e33b4354f1aef5408e2d2083b8ff543a35c0317a42eb871b69198793c979c729163d16ee6adc78bb434a932a43f2f00a0bcdc31853cc0d1694fe028b539c8c4029fbf101829429b87ca80dfbf2e73e52060386e63e90d17f7e98604419e1e259dccf38ad0e720c36455cba07c22f23e233c9a67ece2e3c4e0243b0b03aac498327f66694b476ae83d90187d020d60e3c495b34ce67fd2780bfd92d0a9a02c51968312d3bf401a3d9fb8784d2a2dd174ed3c05e728e760e1b24168315ef802da2b71bd6f2ec2465e0a47c2aa2835443875ab3f62e498670a29cadf2e099f5e02f9f1e2ef46303703a731ca42a30b7e854a512cb452024e5cfbf684c461b6f368f734c27a35d8b7949d3c162412fab3d94ee4a5759406a4d1b1d9f1086265c42b767d2f5c52ec805869509c45deee38606b7f4016aaac664383d5216a4ac02daf65398a0a42626efba3b1a733c37aa7995b2a253d2ae8d6be7c45c44f33d86e4db9b0383a55ebfa344900beab5de5332086ebf25f82bb07995f45825e7ce3ade64472a6cb194eed14ba0defbd53961246cdb2c8ca62a3fd59d18bc4551d10a60952269fdda60170b03dec787497ee2087cc599c2799031597043994116748e8f381dd72d7dc7220f1e7595768aa4ecf9f634021112de114fb0dc60e6735afde1ac935e634076a8294dac7d814651fa86e107e2a76c2be3849095e7e4befc76dd69e887f597d0cc28e3fc6294e48e072b7135b9e76320fecf98b935ac0103b81782c5fbac12ad0aca41c12631fff54c685b6ae54ae94de2ca4ead4537d77225d675942a1b7df03f6309b74af2ab665265dda2cbac154b273d4d33ffb6a694dcc9edabfc70bafe6141887e0a7056d66065310e9af0d361fa6f90e68fc98bfec6e42579f049d153f7e3d0a2b204288734ea5cad9d7e151d2959234a98a9182f64381323e0561ff43dc4c83266d1941311cf7e02ebf8f012c899ee8e32467cd3b637b0a87d5b5717b59aa98b4354f341701a551bfc25e75e5bfbec5d5358a8efc5e2e1837acecbc3e17d72f726df75ea14e03037b65f3031f69348eb8caaf0ca2625a8b4440de5168008fddfa1589439bd70817a2fda97ad3b5887cc66e420280d66c985229089a9156bb77b3e53c48160f4ca00df6227614c8f4066b545b5f1f966c096d61b5bce21664f9181654344e85e67690075c89ba596c8013c397d91630a2d6192d3713463ab89e06228c3f9eb6c23003f4ceaadf07e10f55326dfee7c4269a700b1136ba4ffacba8c365cc07db644a8c7012c9166a3e40dbc5706ad0400c267aa78ec132a6ec4e4aa1bd34757f567b9d14512e1dd1fe3b23f86e4446e459463ad0287e485ff341e47fe464715150875e4f2e8c7b4aa41cfc199d0cbfb178203426f8f4058f70888f840d1f51d71e22ec4dac4cfb610faa1add35dae4aaa0ccf665b91588261f5edaaa88f020790d954a6eb220057977e7e580c64ed8927c5be2180cafccffce3c3025636e21458d4f76f640a0d3ab65283ec6aef0f3d462d61cdb7fc4281f3ae5650ee6da9a3e080ec28e6dba6944e999b2864987ba41da46cebc21806c525d78894bbdf758d73843b52b13274fa97a1d5dea6e3279a6fe3071c76b1082ed11a51d9b4ea0559680b803b6fb70d67f0531cd3d40c497860118e67ce2bdd4670cd762d37a2125f3204dbb91fa0719c824f3ff36944185a4031286b4ec9c10fdc78f4c8b8b49a23372cdbece6d9c15b42b398c2e362173472a41eb3194cfb4405566b3cf8e8b7df018703ce62ddd03eabd7a79e13c9cf70894e9f54916c2b157e9946d8a1518da7dcd2c37bd91754608e90c66ddea77240608450be81a8b814c2da778b0c3f9c0807bccf2f450ac711721598bce0dd71a99397c90a1c91abc429a22cf873a5a237dab1da70bd9ffa14144233cff88efc6f0333ec4459b3cf3e7de41491200bad26f4416bf207a4e92c93e7aec5623650c997134829d755f3bddeb9b462cabcd102b9b67f1953e4122817fabc86d28229a4d50468c18d91c61a9c801e08eff0171a16166f295e1d56e4307374d6a759d8bdfb22efc2e23bed5b7697e15cba6e8e1dd6089595462adca41e69d0fa91d5b55f65b550943f25df5c554641ace6d33b48b71133f474d17bed6318b804cecfea85cd5804ab097c0626c61387a7dfaace9a1d339d6cbbf8daec567301052779a2fb72a5853a0046e7d1635285aa00aee2c714c4cd210dcd48030017bc300da07c268d78cc956a108e25bdc62b766cb56d5ea416ce4b11fae72d64908fae50a8b7e40f3da4051a2fb00b6bbd9770b6d8468836dc98df53c9da4d74702be2fcad509ca23415b6f6000ea23ea33efa19f5480ab8ceacb9d2a20e875665400f84d0ec146fb08c67ba16e415fa348b06a14ce72898fc68910c70bfcf77fcd78f6e5b6930e43685cdd5bf25bfa2367f8e8daaa764fde7c3d1c367df30aa8cfb022b31952dc61cbbc31368008bed99333168967c6c19170c2a16fe276dbdd09095c923adb6d1617c15552b115c0bb09cbe0ec7ec7fa3b8e523d0f9a141ae9474b68a7cb532aadd6249c8abe1d820d1c60f94bdd13c28f53e1aec41f87d85f1f27694abdc0fc7679baa9685772965c081e856a972b6c2ad54b17989bd7df5229f5473cc312a463ba2c191650707d159cbafc205fa6b12bebc7bf1e5a94d279fe77f096e49a4bac9f9ba73b6e42676e68e7a84fc07c5e5441eb6098361468b248dd25013969e25854249641dc33869d22857a882a2edd8d9c73052e8e11366529270f87ac8b61525be94fb8f61a06ae1654ec2549dddb0a567bfcda1fdd3b76394bf16767975a27c32ca9788c4c1496f621303a707ab254f9969ccf6b8f88c9294afaa15365b73291fe82c014f4e676c87c8944b4bcc5ad1805bd6f0be86d957df83477dc978aebe4bf056031a64747ca3ea9c02f04df1132eeb0f9c3e477ccb50dddbc9565be8c3d215a1af75955ef219f8a05f617457d61012777c5fe4c493f7e41be2f8cda276cc6e260b7d00f21e1408e8c7049fd4680c8a070e29510056f91a87722ca34dbe4ea754eb5eecd93fba7f7e83b13158e4a9b943ed8ffa4831ba454d6f902305c63f3f9ee923381f661b1020922d4a3b09c550be9adc808214b64714d2fe9582c1a8183051de81e072da253181196a5629b7d51a3f1587ee4f3ed1b959bc743bbaa39d0d268272ae89b2bc2f7f1ea2f5a71d3983523333df9ad847a9a46207e92888d04344e6b503b9b8fa5a28585cee2c149f92339e35da781e4dede64de4f52a5b2a17fc8ee0a5b30d3600b8c9002d3624349b6ab921689c3793862d503b0dc98ba6d50107be55477514605933182fdacb13f2247645474fcdeea9f09ef1f12a87b28476e25e4ed31667e3614ea6cfdbbf06b2e1e9658479985099cca2db3d9e9bfc841fef39e9b3f7910c362ee80eed09a88200b85c6b7ae98ed2bb1c84746df98bc1b46e6c4999ba6a1fb7a06e75cf69382ef2f5c48c7ba789f30076dc136bf22a4a548612715bb6ce37b2e1b47ee615a902529ab0143d7f912266969b107aa65567d958068fa15ea062a211d7367ef98df7ef9124f65ee8d14846774a9f199a5c6e0b04cebe26bb1f228c599f84fb289a73e4d1a6d2112de725f2e2fa4278f71925e2692825de5e5f1af63430c787a001e567474847df18b1a5b268d4a0c30b227ca8515c579d082ae6869457c05775b871f0a729f796201b3d3f4005057b5ed29aa6e522b3aa4149954cb4626c12ae034eb1490ce9f32ff05f7d9cf749d98524735666a97c4e00996153b4a37f070f6c3e08cee8c4577f36b8f40324904da5bb2e4b4492ace82b99c847ba39514cdfcb4a86d8363fc6f50da1a624dd7aaf72b4d5f1f72093413f4213744cfe1f29a2299e31809fa2db7b9fe542792f70d8e367aaaad7243347badd22bb067f81f0c358450a091b96eadfcae227578b4bae62513e5fc8bd713e233443e5ed1336bf48195862f533fe6bde0ee98f8516a88945ff8aa311684c4c8b107c92c8f65ab6acae9642cb547558fe08b9ef49777c425228e315dc08472e552a3768ac93cbc71fc83b2c06e63889945854635c755dd3f5348f8834d42bfa6c2d9dfa09012f76801e6176cdc5a93f8b2fbb55e239d91446e7a80549cea1d766640954a0aa399da53c3cab25e346881a38734c24242e6d5c6e17377a5f1e22a9c25736871a94153a8f46e2a16ea1bce9d0516041560a2c6b2ee332b95894d0656e8c02d6181c9254939dcbcf7c69bcff496d32f2c5eedc9aa7e7f63a1a7ee7275d5c1e8b4c5ba9c1581cc34669f6e95f3ae05737eab68ac58e80ca26130f93a3cde8cb4637836dadf79b205699bac28bb2bd83e3f54a4175b371399f8431fe54f93081c0c06f48a13b7a3bc6f9b42df5f1f5369f38d2589ae35f08bc8ab5a520ec3ea3760b3fd23a7bf1bb2b833ede3fa489ed64c96e1dc92c56c1b0f74f496b889a7d4e8715a23d6e82f364f19cb0ea729c63d1fff4c2410539b49874c061c633db9db674de1123bc1c4742733fbd0df65c51abf44687f321f15109f06ebcf2369fe892b8d260e4efc6f24d4479d856a0de0682059067a68632070422427c2620550ae4d9ee243364c2b4de369c77d95487e09313e541e81ed4cb31e70a0fdac0203e90c70ac4578de7386a4591c3160b655059555b180c76bcab11c9068cfcefde030bbf9b07a122bcc34e50637ae57eb0603424455e3e757a0ad8755a448ac419a4d0b13fe84a4ea054dd8bd8f0c51ed38c4e2f9ebe56738795b5d995a181381d320538fd09899c6890d6b158fa1d46c3924ec403fd306b8aa423ed24a60d030213dc4cd33078e58e322b5caaf0650c36152378e638552cffa76176324cf31498c367496efc245dfcf9c7d52dcf8554202e1975a32761917c306449836878e229b374365adb18fa4810d516a0b5c98f5823dff847ea9ff52e6a1399adaed96ee43864badb92dead474652ffcead01470e1cae1bcb4f7ff10df4ddddf2ee94dbeabe50e3ee0e1ee2b3c583d5ff7fc42adbba363d23f69fda77cc67fd81fe319d68fcdf623aae263d6440f034118378c0b0549f2c7ae04b2b60ac38d456485e36ab4acc26201a9f1b887ec65575a46145bfabbe9e53932629601a6619241aacb1ff9e72db5f794f2313d1e60576174a8d9cdf6471b8fa69387dc6cc7a8329cf0fce4ead9a1f5d73b5289341cb33ab6038e42d12d3b69fac7b95b71bbe41f9e044381614ca7c82dd757caab8bae1e0a004f19ac9865982f79c81c2904d64a9f3ff3bd74a66f71f13bab520b012c19f6967aa8ec950ffc1f3779e591258b7518a4dd4a3b9f46e853b3015b459be89813d5521d2e70f17e6407a1c7fb360de5d9e96783444a7276d0e991f038497dc270d17afa277254c30a9d454462eecde3b36353bc76188000e8a2d424c5617d1713c36ad60bccfa29a38c4916b73a176b4f74c517d75ad76a385b19b51ce62a5d4ded64818a77132e5b3cf38cc7f97321725c4ef8fe00fe88230e122e2a3a4d26b4832c39a4747d14b0740f41846ddc9ca266a5afbba5dc1ad1a413fd4af41de75ffe0feec8e873bace7838b128282858d1baa8348ae6b82c7dc26dd0d36693860b99fca586e660e95378523b5152bea66c9eac85862175bfb6c372ac6bcfd88f316521f13a21dca9e589579a3a86e9b71f8c61e1379804df50e80580152fdbe4984aef7bcf65f6abce22ffec305ae4a379453d905cba6ff8686cea59f879923d5d28ca96134bba1d1e57dffcb088bab1f9985ee5c73857470ec088fc16afafa51cb1171f0718be9778574424d37189a0f1a205ef8a405c7fb8c237a1c895aa0004b4e98fbb2e6248c76fce56b436a2f0c5d8183367e09a01e8142c298f9af44a029bd38f304993e4749d83bac3d3e22296ddbc0686b370ab4e24ab260a396aac7838e27d4df8e2ecee66aa9037c6664e2da0c8351638bc53d49517cae6f20c04a2444633ab3139a187a81aacc8db5372bfb2b9b7442cdba52727900463a12af3baa306b2790d00e2ebdeaccfe0614a9287ee1107dea72024669bc75cf64758ef5cf0ae18a704e2836196c1c39617bacdecee99fc34a63d039221d76610495e7f85acfaaef2fef75309a0a53e0a424c1f4aed7b6a0815486db9340c6dee99b4e2e2169dcfb78b17a0e3575adcdc14e973b6d1cf7f9686914233e6edf9bd176cbdf2fe6c2092448b9bb242120c3fae8a2629b Hey, password is required here.","tags":["年度总结"],"categories":["随笔"]},{"title":"我的听歌之路","path":"/3315959774.html","content":"今天闲来无事，翻了下网易云创建的歌单，发现很多歌单现在都不怎么听了，但是在当时的年纪，却每天都在循环。 小学时听音乐的途径只有收音机，每天除了听鬼怪故事，就是听歌，喜欢听《包青天》、《我的中国心》、《酒干倘卖无》、《冬天里的一把火》，反反复复的听。反倒是对大街小巷传唱度很高的《老鼠爱大米》、《最炫民族风》这些流行歌曲嗤之以鼻。现在想起来，多半是受父亲熏陶，因为这些老歌属于他那个年代的流行歌曲，而他每天都在家里哼，久而久之便习惯上了老歌。 到了初中，开始接触到 MP3，也开始接触到了更多的流行歌曲。像《春天里》、《我的好兄弟》这类讲兄弟情的，当时很是喜欢。初中是叛逆期，就喜欢称兄道弟，倒也不出奇。也是在初中开始接触到了 Beyond，《海阔天空》是我听的第一首粤语歌，从那时候开始，就开始喜欢上这支乐队，无论是家驹的嗓音，还是他们的歌词，总能激起心中的澎湃，特别是后面听了《Amani》，全场大合唱的时候，很有感触。 到了高中，刚好碰上《爸爸去哪儿》开播，那时还特地把手机铃声换成了主题曲，当时用的是老人机，没法下载歌曲，还是用收音机录了好多次才当了铃声。这个阶段，开始慢慢意识到自己和别人的差距，也没有时间去说情情爱爱，所以对《客官不可以》、《多余的解释》这些都不感兴趣，尤其反感 TFBOYS 的歌。高中更多的是听朴树的《平凡之路》和南征北战的《我的天空》，给我难熬的学习生涯一抹阳光，让我还有动力继续往前走。值得一提的是，直到毕业，我都不喜欢凤凰传奇的歌，觉得太土了。 到了大学，开始喜欢民谣，还是那种伤感的民谣。那个时间段，网易的歌单里都是《成都》、《城南花已开》、《Let Her Go》、《Five Hundred Miles》这一类的；慢慢的开始听《觅香》、《Wait For You》这些，情窦初开了嘛；到了大三，接触到了机器人，每天都是泡在实验室，开始喜欢上了小众的歌曲，像《阿衣莫》、《上头歌》、《月光光》，说不上为什么喜欢，但听这些歌能让我平静，写代码这些能更有思路。当然，这个阶段我更像是是杂食系，听粤语，听日语，听英语，只要是喜欢的都收藏。期间买了把口琴，有事没事就在宿舍里吹，所以我的歌单里又多了很多流行歌曲的口琴版。大三时韩综《Super Band》开始播出，每周更新都没落下，十分惊艳乐手们的创作水准，专门列了个歌单来收藏他们的歌。当然，这个时候 Beyond 更是我的内心寄托，感觉和 Beyond 有种奇怪的缘分，高中时年级级歌就是《光辉岁月》改编的，到了大学，校歌《大学问》也是《光辉岁月》改编的。 毕业后，开始工作。恰好这时《乐队的夏天》开播。每天都是在公司下好新出的一集，回家慢慢看。当然不是所有摇滚都喜欢，像重塑的歌我就无感，我更喜欢新裤子、后海大鲨鱼这些，像羽果的《怒马》、丢火车的《火车日记》、康士坦的《美好的事可不可以发生在我身上》也比较喜欢。仔细想想，我应该是向往这种自由的气息，毕竟一周除了工作没剩多少个人时间。工作第二年，我开始跳槽，也是这个时候接触到了毛不易的歌，很慢很舒服，尤其喜欢《无名的人》，仿佛写的就是自己，比《平凡之路》还写实。对凤凰传奇的改观也是工作后，再也不觉得他们的歌土了，而且又开始喜欢起听小时候的华语乐坛金曲，实在不喜欢现在的流行歌曲，完全没有听下去的欲望，感觉华语乐坛倒退了好多。 写了这么多，听歌品味的变化，我觉得是我听音乐的动机和方式不同了。小时候只有收音机和父亲的哼唱，所以喜欢老歌；初高中接触到了流行歌曲和粤语歌，所以听歌风格开始变化；到了大学，要静下心写代码，所以听小众歌曲，要练口琴，所以听口琴版；毕业工作了，更加向往自由，所以听乐队，越发觉得孤独，所以听老歌。","tags":["音乐"],"categories":["随笔"]},{"title":"Typecho 博客搭建","path":"/9399837.html","content":"前言国庆前就搭好博客了，放假回来到现在，总算有时间整理下博客了。主要是前段时间看到个朋友圈主题的博客，挺适合我这种随手记的。 数据库创建之前写过一篇『国内外一些免费的云数据库』，挑来挑去选了 TiDB（主要是使用 Supbase 死活无法连接 Typecho）。 创建数据库集群； 创建项目所需数据库；CREATE DATABASE tidbcloud_WeChat_Moments_icefox; （可自定义为想起的数据库名称） 在 Overview 界面，点击右上角的 Connect 获得数据库连接参数； Endpoint Type 选择 Public，数据库选择为刚刚创建的数据库，保存好生成的参数； 下载 CA 证书，TiDB 的 Public 连接方式强制要求 TLS 连接，故还需配置其 CA 证书； Typecho 程序 打开 Github 链接下载 Typecho 程序； 根目录新建 vercel.json，输入以下1234567891011&#123; &quot;functions&quot;: &#123; &quot;api/index.php&quot;: &#123; &quot;runtime&quot;: &quot;vercel-php@0.6.0&quot; &#125; &#125;, &quot;routes&quot;: [ &#123; &quot;src&quot;: &quot;/(.*)&quot;, &quot;dest&quot;: &quot;/api/index.php&quot; &#125; ], &quot;regions&quot;: [&quot;hkg1&quot;]&#125; 根目录新建 &#x2F;api&#x2F;index.php，输入以下123456789101112&lt;?php$file= __DIR__ . &#x27;/..&#x27;.$_SERVER[&quot;PHP_SELF&quot;];if(file_exists($file))&#123; return false;&#125;else&#123; require_once __DIR__ . &#x27;/../index.php&#x27;;&#125;#echo $_SERVER[&quot;PHP_SELF&quot;]; 将刚才下载的 CA 证书 isrgrootx1.pem 放在根目录； 选个主题，我挑的是 icefox，放入 \\usr\\themes 目录下 将代码提交到 Github，等下要用 Vercel 引入； Vercel 部署Vercel 部署没什么好说的，注意要配置环境变量 12345678910TYPECHO_HOST=&quot;&quot; # 数据库地址TYPECHO_DATABASE=&quot;tidbcloud_WeChat_Moments_icefox&quot; # 数据库名称TYPECHO_USERNAME=&quot;&quot; # 数据库用户名TYPECHO_PASSWORD=&quot;&quot; # 数据库密码TYPECHO_PREFIX=&quot;typecho_&quot; # 前缀TYPECHO_ADAPTER_NAME=&quot;Pdo_Mysql&quot; # 数据库适配器TYPECHO_CHARSET=&quot;utf8mb4&quot; # 数据库编码TYPECHO_ENGINE=&quot;MyISAM&quot; # 数据库引擎TYPECHO_PORT=&quot;4000&quot; # 数据库端口TYPECHO_SSL_CA=&quot;isrgrootx1.pem&quot; # 数据库SSL证书位置 Typecho 安装输入 Vercel 分配的网址+&#x2F;install.php，进入安装页面，跟着步骤走就行了。","tags":["typecho"],"categories":["折腾系列"]},{"title":"技术岗位如何写简历（转）","path":"/1589846811.html","content":"前言最近在搜东西，无意中来到一位大佬的博客，看到了这篇技术岗位如何写简历，这里做个转载，方便日后反复学习。 明确目标求职是一个双向选择的过程。投简历面试的过程应该尽可能充分且实事求是的展示个人能力和特点，让 HR 和面试官在最短的时间里了解你，判断是否适合岗位需要。 能力问题。简历应该尽力展示自己的能力，但是如果目前能力还不够，抱着侥幸心理刻意夸大个人实力、隐瞒欺骗方式通过面试的做法不可取。即使通过面试了，如果个人能力差太多，工作业绩很不好，一样会被淘汰。 时机与合适问题。如果对自己的认知不够清晰，不了解自己喜欢和擅长什么，强行拿到并不适合自己的岗位，和自己擅长或者感兴趣的事情差异太大，每天上班都很难受，也没意思。反过来看，面试失败并不一定是因为能力不够，可能是因为目前招人的意愿不强，或者只是因为个人能力和岗位需求不匹配。 双向选择的过程通常都可以拿谈恋爱来类比。 为了追到对自己并不感兴趣的异性，一直努力迎合对方，从一开始身份就是不公平的，即使追到了也容易会被嫌弃。学习PUA技术欺骗女生的做法也不可取。 强行改变自己甚至迷失自我的做法也是不好的。被一个女生拒绝并不一定是不够优秀，可能是因为对方目前没心思谈恋爱，或者是因为不合适。例如某个女生就喜欢家庭条件一般能吃苦的人，而你偏偏是个富二代 (●ﾟωﾟ●) 换位思考多进行换位思考，站在面试官的角度想问题。很多有工作经验的人包括我自己也做过面试官，对面试官的处境有所了解。在短短几个小时的时间里了解一个候选人其实很困难，有时候面试完了也拿不定主意，不确定候选人到底合适不合适。面试官挖掘候选人的能力很重要，候选人自我展示的能力也很重要。 应聘岗位的关注点： 大公司、负责成熟产品的团队，分工更加明确，招聘实际干活的开发人员时，通常比较注重基础知识，关注技术深度，希望求职者在某些领域有较为深入的研究（当然不可能所有领域都很深入），一方面这种技能可以解决团队遇到的该领域的疑难问题，另一方面也体现了候选人的钻研能力。 高职级的岗位，或者是小团队，可能会关心员工有没有创业精神、产品意识、技术广度、领导能力等。 开发人员的通用能力都会比较被重视，例如智商、逻辑思维、学习能力、解决问题能力、团队精神、沟通能力等。 简历内容组成关于简历具体的形式（应该写多长，写哪些内容），不同的人有不同的看法，这里主要说一下我的看法。 根据文章 CV vs Resume - What are the Differences &amp; Definitions [+ Examples] 的介绍，Resume 和 CV 是两个不同的概念，Resume 更加精简，通常只有一页，用于各行各业的求职；而 CV 更加详细，用于学术相关的招生和招聘。 有很多“江湖传言”说简历只能写一页，理由是 HR 每天要看很多简历，太长了没时间看，这里的简历指的正是 Resume。但是对于开发岗位，最好要用类似 CV 的东西，从技术专业角度对项目做一些更详细的介绍。 借鉴 Resume 和 CV 的概念，针对社招开发岗位，简历可以分为几部分： 一、简历 (Resume)，保持精简，最好是一页纸。简历用于HR筛选，以及让面试官快速了解你的基本情况。 基本信息：姓名、年龄、联系方式（电话、邮箱、微信），必要时加上居住地、求职意向。 教育经历：时间、城市、学校、专业、学历，必要时加上英语成绩。 工作和项目经验：因为要精简，并且通常会有重复内容，这两者可以压缩到一起。 每段工作经历，基本信息可包括时间、城市、公司、团队、职位。 可以采用总 - 分结构描述。每段工作先用一句话做简单总结（例如公司、团队、项目规模、个人成长等），然后分几点介绍工作内容和成果。每一点又可以先用一句话概括，再详细介绍。 关键项目的介绍，说清楚自己扮演的角色，是独立完成、项目负责人还是参与者，也可以注明大致的贡献占比。使用技术关键字（例如开发语言、工具），但不用写技术细节。成果要有说服力，多使用数据展示（例如开源项目 GitHub Star 2k+，性能提升 30% 等）。重点关键词可加粗，还可以插入相关网址链接（当然电子简历才好用链接，纸质简历就不太方便了）。 如果项目多，又有博客，可以写“更多项目详见个人博客”并插入链接。 做到让 HR 这样的非技术人员也能大致看到你的实力，并能根据技术关键字判断你的技能和岗位需求是否匹配。 自我评价：可以列举自己的优点，一定要有实际案例支撑（可直接在括号中简要说明），否则就成了没有说服力的空话了。 个人技能：最擅长的东西应该在项目经验中已经介绍过了，这里列举你用过的所有编程语言、框架等技术关键字，主要作用是体现技术广度。使用“入门”、“了解”、“熟练”等描述，慎用精通，因为容易翻车。如果写了精通，面试官碰巧有了解这方面，可能会问一些比较难的问题，被问倒了就会让人怀疑你是否诚实了。也可以使用图形例如五角星来描述熟练度。 二、履历 (CV) 或附录，是简历的补充，内容相对详细，长度可以有多页。 内容可以包括重点项目经验的技术实现细节和关键点等。可以借鉴 STAR 原则说明，即 Situation（情景）、Task（任务）、Action（行动）和Result（结果），但也要根据实际进行调整，不能生搬硬套。 面试官如果对你简历中的某个项目感兴趣可以具体看 CV；同时在面试聊项目时也起到提纲的效果，如果担心一时想不起来，可以对照 CV 介绍。 形式上，建议附在简历末尾。也可以考虑写到个人博客中，在简历里贴链接。 三、其他。 个人博客：如果有还不错的个人博客，可以贴到简历里。个人博客如果写的好，远比简历的参考价值要大。 GitHub：如果 GitHub 比较活跃，有个人项目，可以贴到简历里。有一定技术含量、Star 较多的开源项目，通常是个很大的加分项。 Demo：对于客户端 App、网站之类的项目，必要时可以准备好项目、Demo、截图、网址等，面试官可以自行查看，或者现场给面试官演示，帮助进行说明。 项目经验的整理有一定工作经验的人通常会有较多项目经验。为了保持简历的简洁，需要挑选最重点的内容来写。写项目经验时可以按照这样的方式进行： 使用思维导图，将自己过去所有感觉还可以的项目都列出来，想到什么都写上。 对每个项目的成果如何展示、能反映什么样的能力特点做思考。例如复杂的业务，说明自己业务能力较好；技术项目，说明自己有一定的技术深度；某些小工具项目，说明自己注重工具的使用；个人开源项目，说明自己热爱技术等。 挑选几个最有代表性的、比较容易说明和展示的项目，做相对详细的分析，根据项目的重要性，介绍的篇幅也需要有控制。 最后将选定的项目和介绍压缩到简历上。 其他没有被选中但是也还不错的项目，可以通过博客或附录的形式展示。 内容与排版 整体结构要清晰，避免逻辑混乱和内容冗余，和写文章类似。例如工作经验和项目经验，常会有很多重复内容，可以合并到一起。 文字表述要简单明了。如果觉得内容较少，不要刻意凑字数，简历字数和个人经验能力没有直接联系。 排版要整洁，版面要匀称。例如前面很拥挤，但是后面却有大块空白，就会很不匀称。字数较少可以适当加大字体、增加行间距、增加页面距等。字数太多，首先考虑压缩文字，实在没法压缩再从排版上考虑。 尽量避免错别字和标点符号问题。这会让人觉得你做事情不认真。 简历编辑工具简历有多种编辑工具： Word。不太建议使用，想让简历稍微精致一点，Word 不太好实现。 Markdown。我使用的是这种方式，自己修改了 CSS 调整格式。 LaTeX。LaTeX 的排版效果很好，但是环境配置相对复杂，LaTeX 语法也需要一点时间掌握。我尝试用了大佬的 LaTeX简历模板，但是编译后的效果不对，可能是兼容性问题，一时不好解决，就放弃了。 PhotoShop 等设计工具，可以制作出画面更加精美的简历。比较耗时并且考验审美能力，对于技术开发岗位没太大必要，更适合设计师类岗位。 在线简历模板。例如 超级简历 。","tags":["职场"],"categories":["随笔"]},{"title":"国内外一些免费的云数据库","path":"/1521393913.html","content":"前言最近在折腾用 Vercel 来部署 Typecho 网站，其中项目要用到数据库，这激发起了我寻找免费云数据库的兴趣。 汇总 数据库 介绍 TiDB Cloud 国产之光，5GB 的 MySQL 免费存储和 每月 50M 请求单元，支持每天备份，要 SSL 连接，需下载 CA 证书 Azure 面向学生的 Azure 订阅里有免费的数据库服务，按下面教程操作即可；另外也可以在免费 1G1C 的小鸡上自行搭建数据库服务 Aiven 5GB 存储空间，有 PostgreSQL、MySQL 等其他服务 Memfiredb 国产数据库，512MB 存储空间 Koyeb 免费 4GB 的 PostgreSQL 数据库空间 MongoDB Atlas MongoDB 数据库托管服务，免费账户可以永久使用 500MB 的数据库 Supabase 专用的 PostgreSQL 数据库 Render 10GB 数据库空间，有 PostgreSQL、Redis、MySQL 等，好像需要绑卡了 FreeDB 国外免费的远程 MySQL 数据库，25MB 存储空间，缺点是连接较慢 Xata PostgreSQL 的无服务器数据平台 SQLPub 国内免费的 MySQL 数据库，获得最大 36000 次&#x2F;小时的请求、同时 30 个连接和 500M 存储空间，是测试服务 DB4free MySQL 服务器测试服务 FreeSQLdatabase 5MB 存储空间 Serv00 支持 10 个 MySQL 8.0、3 个 PostgreSQL 14、3 个 MongoDB 5.0 Turso 用于生产的 SQLite，500 个数据库，总存储空间 9GB Neon 512 MB的 Postgres 数据库空间 LeanCloud 云端数据存储服务 Cloudflare D1 Cloudflare 的原生无服务器数据库 Vercel Storage Vercel 本身也有免费数据库服务了，但有限制，每月只有 60hrs&#x2F;0.25cpu&#x3D;240h 的使用时间；可能还会休眠，如果您的数据库在 5 分钟内未被访问，则数据库将被暂停。下次访问时，您将经历长达 1 秒的“冷启动”","tags":["数据库"],"categories":["折腾系列"]},{"title":"红十字救护员培训之旅","path":"/855438526.html","content":"前言最近红十字会来公司做“初级急救员”培训，想着无事，参加下也无妨。另一方面还是想学习急救技能以备不时之需，刚好有机会索性参加下。整个课程就8课时，既有理念知识，又有实操练习，收获蛮多，这里简要记录下来，后面可以温故知新。 CPRAED情景再现情景：假设你在逛商场时，有人突然晕倒，而你恰巧有红十字救护员证书，你应该怎么做？ 观察周围环境，确认环境安全无误（不能救人把自己命搭上去）； 确认自己做好个人防护，比如手套口罩（救人要确保自己的防护安全）； 跪在患者边上，双手轻拍患者双肩同时大声呼唤“先生先生，听得到吗”（确认患者是否还有意识）； 左手手肘撑地（假设你在患者右手边），脸贴近但不要触碰患者，口中数“1001、1002、1003…1010”（数10秒，确认患者是否还有自主呼吸）； 大声呼救，“这里有人晕倒了”（确认患者失去意识了，叫人来帮忙）； 亮明身份，“我是红十字的救护员”（不说身份不一定有人帮你）； 请人帮忙，“这位先生请帮我拨打120并告知我结果，这位女士请帮我找下AED并拿过来给我”（你要救人，肯定没时间做这些事）； 招呼懂急救的人，“现场有懂急救的朋友也请来一起帮忙”（心肺复苏按压很累的）； 掀开患者衣物，准备做CPR，也就是心肺复苏术（避免患者里面戴了啥影响按压，而且后面用AED也要掀开衣服的，患者是女生就要做个人墙再掀衣服）； CPR按30:2来进行，按30次，嘴里数着“01、02、03…30”，人工呼吸2次； 然后AED来了后，按图示贴好左右电极片（患者右乳上方肩胛骨下方，肚脐左边肋骨下方）； 插好电源，AED会提示两次不要触碰患者，跟随AED提示，张开双臂，“请大家不要触碰患者”； 点击完成后，按下闪烁的放电键，开始继续CPR； 当患者眼睛或者手脚有反应后，停止按压； 左手手肘撑地（假设你在患者右手边），脸贴近但不要触碰患者，右手双指搭在患者喉咙处，口中数“1001、1002、1003…1010”（数10秒，确认患者恢复自主呼吸）； 确认患者恢复意识后，边帮患者拉好衣服，边人文关怀，“先生您好，刚刚您晕倒了，我帮您做了急救，同时也拨打了120，我会陪伴您到120到来”；","tags":["救护"],"categories":["随笔"]},{"title":"职场语录","path":"/3001155188.html","content":"前言经常会逛比如脉脉这些职场论坛，总能学到很多行业大佬的职场经验，这里做个记录，方便反复学习。 笔记📝&nbsp;对如何快速适应测试组长岗位的看法与建议。1. 组长还算不上真正的管理岗，不过是管理岗的必经之路，可以先试试，不做管理岗，走专家线路也是不错的； 2. 组长通常自己还有测试任务，但是一定要留出时间处理组内的事情； 3. 与组员的工作差别主要是要对进度和质量负责，无主的临时事情也要处理。首先要学会有效的监控进度和质量，做到对自己没有参与、不大熟悉的项目测试过程和结果好坏有判断能力； 4. 根据遇到的问题，制定必要的日常管理和分工规则，比如各种文档整理有默认的分工，收集不紧急的事务，分到个人，项目不忙的时候处理； 5. 向上争取资源，解决组员的问题，比如太忙的话争取人力、延长时间或缩小范围，加班多的时候争取点小福利； 6. 抓大放小，明确原则，保证重点项目； 7. 多倾听了解组员的意见或错误，不要因小事跟组员有冲突，组员无伤大雅的问题私下沟通消化； 总之，组长与组员最大的区别是会增加很多沟通，随时保持清晰的思路，能识别问题，及时解决问题。","tags":["职场"],"categories":["随笔"]},{"title":"零成本部署网站统计系统","path":"/2224651331.html","content":"前言有了个人博客，想统计博客的访问流量数据该怎么办？本着一分钱不花的原则，使用 Supabase 免费数据库服务，通过 Vercel 搭建一个替代 Google Analytics 的网站数据统计。 操作步骤 首先在 GitHub 的 Umami 项目 Fork 到自己的账号下； 在 Supabase 中创建一个项目，需要记住所设置的密码，之后会用到; 等待初始化完成点击右上角 connect 复制出需要之后使用的连接链接;其中 postgres:&#x2F;&#x2F;postgres.vzhpxlcldnemfwtfztfh:[YOUR-PASSWORD]@aws-0-us-west-1.pooler.supabase.com:5432&#x2F;postgres 需要将 [YOUR-PASSWORD] 调整为上一步中设置的密码; 在 Vercel 创建项目，选择自己 Fork 的 Umami; 添加环境变量后点击 Deploy 进行部署;其中 HASH_SALT 是你在键盘上随机输入的字符串，DATABASE_URL 为替换了密码的数据库连接地址 等待部署完成，通过项目地址或者自己绑定的域名可以进入具体的设置页面，账号是 admin，密码是 umami；登录后可以修改密码，设置自己要统计访问的网站并获取到监听代码，之后就是在目标网站上进行部署操作了； 最后就是在 Hexo 中使用 Umami； 如果主题没有适配 Umami 的话，可以使用 hexo injector 直接注入; 在博客项目根目录，创建 scripts 文件夹; 在 scripts 文件夹下，创建 injector.js 文件并填入；12hexo.extend.injector.register(&#x27;head_end&#x27;, &#x27;&lt;script async defer data-website-id=&quot;&lt;data-website-id&gt;&quot; src=&quot;&lt;src&gt;&quot;&gt;&lt;/script&gt;&#x27;);// 把 &lt;data-website-id&gt; 和 &lt;src&gt; 替换成在 Umami 中获取到的信息","tags":["umami","supabase"],"categories":["折腾系列"]},{"title":"天涯神贴 KK 三部曲之第一部","path":"/940241892.html","content":"阅读原文个人笔记总论2010年的房地产调控，让很多人看到了希望：让房价降得再猛烈些吧。还有人更是幸灾乐祸似的呼喊：让房地产赶紧崩盘吧。让没房子的好好看看有房子的笑话，是人生的一大快事。 但是我们是不是要仔细想想，为什么调控？调控期望得到什么样的效果？ 1、是如千千万万想买房子的人期望的那样，让人人买的起房吗？ 2、是如千千万万的流氓无产者期望的那样，让房地产崩盘，开发商上吊，地方政府不再靠卖地实现GDP吗？ 2010年房价下跌已经变成了人民最急切的期望，已经高过了解决超贫困家庭的温饱问题，已经超过了子女教育，医疗和养老。并且为房地产必须下降提出了若干义正言辞理由，总结下来无外乎三条： 1、人人都有居住权。房子是用来住的，不是用来炒的。2、房子太贵了，租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘。3、房价上涨造成物价上涨，人民生活变得困难。 的确，当经济过热，房价过高，会对经济运行和社会安定带来较高的风险。这也是国家所担忧的。防范金融风险，一切维稳才是中央考虑的重中之中。 而民间所总结的三条，应该和调控的原因和目的基本不沾边。让我们一条一条的分析一下： 1、人人都有居住权。房子是用来住的，不是用来炒的。 其实这是一个伪命题。房子包括房屋及房屋所属的土地两个部分。房屋本身只有居住价值；而土地所具备稀缺性，决定了土地的投资价值。房地产贵的不是房屋，而是房屋下面那块地皮。所以商品房具备了投资与自住双重属性。 任志强说的并没有错，居者有其屋并不等于人人享有商品房的产权。居住的房屋也不等于商品房。 2、房子太贵了，租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘。 这个问题比较大。房价是不是太贵了？有没有泡沫？ 我们首先从国民的收入结构来分析 一个遵从“丛林法则”的精英社会决定了国民收入的金字塔结构。 既然是金字塔，底端的中低收入者占据了金子塔的最大比例，但是大家要知道金字塔的顶端既使只有 10% 人口，那也将是一个 1 亿多的绝对庞大的数字，远远超过了绝大多数西方国家的人口总和。 而北上广深以及三十多个省会，这些个靠掠夺全国或者一省资源，以牺牲大多数人口的利益为代价发展壮大起来的超大型及大型城市，需要容纳全国 1 亿多的精英人群，是否能得出房地产严重泡沫，空置率过高的结论？ 当低收入者们努力挥洒汗水期望着自己年薪能够超过 5 万，8 万，10 万。。。的时候，他们可能做梦也想不出精英阶层手中究竟拥有多少财富。 精英们会象流氓无产者们一厢情愿认为的那样：因为一个区区房产税而恐慌性抛弃手中的大量房产吗？ 答案显然是否定的。 可以确认的是，房价不是由统计局的平均收入决定的。而是精英的平均收入决定的。 便于分析，我们剥离掉商品房（注意：只是商品房，而不是房屋）的社会属性，先把它看做商品。是商品就有他的内在规律。 什么决定商品的价格，价值？对不起，我只能说你上学上傻了。 是供求关系，只有供求关系。 我们判断一个核心城市市区内的商品房是具备足够稀缺性的。 如果你在北京海淀区上班，即使你在山海关拥有 1000 平方米的住宅也不能替代你住在北京市近郊区以内的愿望。而无论你是租房，分房还是买房，只要你还在海淀区上班，你就必须住在北京市近郊区以内。 假设你挣得钱不足够多，你需要租一套房子解决你的上班问题，上班距离的远近及居住的质量，取决于你愿意支付的租金。 假设你的钱够买房子，我相信你更愿意买房，因为你可以拥有房屋的产权和房产增值的收益。而买房子的大小，品质，离你上班的远近，取决于你手中的资金和你对未来收入的预期。 买房问题很象是中国的上学问题，而且简直是异曲同工。 假设你家附近有个重点中学，教学质量很好，考大学几率很高，而其他的学校你觉得不理想，你肯定希望无论如何自家小孩也要上这个重点中学。 上重点中学凭什么？我们简单的剥离掉其他社会因素的影响，可以认为想上重点中学就要凭好成绩，小孩努力考到前多少名，就可以上重点中学。 这与努力赚钱买房是一个道理，有钱的出高价就能买到好位置好环境的房子。 我们再加入社会因素的影响，比如某大人物看到这个中学很抢手，很可以赚一笔，于是就设计了加分项，谁给自己送的钱多，就给谁加分，于是小孩要上重点中学不但要考高分，还要送钱加分。 同理，当好位置的商品房成为稀缺资源，各类炒房客的出现是必然的。 如果说炒房客加高价给最终住户的行为会产生泡沫，那么重点小学和公立幼儿园高昂的择校费应不应该也叫做泡沫？ 尽管炒房和公立幼儿园加价成为普遍的社会现象是令人痛心的，但它们不以刚需人群的意志为转移的存在着，且与泡沫无关。 最被提及与泡沫有关的是以下两点： 第一，中国的房价甚至高于某些发达国家的房价。 其实，众所周知的是：不光房价高于某些发达国家，石油，高速，教育，医疗，税收等费用都远远高于某些发达国家。 而且中国的精英人群尽管所占比例不大，但是绝对数量足够大，而且精英平均收入甚至远远高于某些发达国家的收入水平。 未来 10 年还得涨，从前 10 年看后 10 年，按照经济科技发展的速度。涨价幅度可能比之前更猛。 第二：租售比问题 这个问题不用过多解释，使租售比更合理的方法不是只有降低房价一种，还有一种更靠谱的：房租大幅度上涨。而且已经在行动中。房租长期保持低价就像 1990 年以前的和田玉长期保持低价一样不可能。 3、房价上涨造成物价上涨，人民生活变得困难。 这个问题其实也不用多解释，懂经济学的该明白自然会明白，不会轻易被忽悠，不懂的解释半天也不会明白。 简单的可以这样说，物价上涨是经济过热，钞票印多了的后果。而房地产因为稀缺性和易保存比较吸金，所以吸收了大量的钞票，以至于大家光看到了房地产的飞涨。 其实如果房地产交易量下降，不再具有吸金功能，那么农产品等生活必须品以及房屋租金等等就会大幅上涨。这是因为多出来的大量钞票总要有个流向，如果不被房地产吸收，就会被大蒜，绿豆，姜，及全部生活必须品的上涨来吸收。 事实也证明确实如此。2010年房产调控后，物价上涨的势头非常迅猛。 那麽是不是房地产就没有泡沫呢？ 这个问题谁也不知道，因为到现在政府拿不出一份权威的数据来说明房地产到底有无泡沫。 但是房价高了就有风险，政府从感性上还是有清楚认识的。 注意，我们前面啰嗦了很多，现在才开始接近真相。 这次调控的真实意图，防范金融风险辨别利益是看透一切事物真相的武器。 高房价谁是受益者？ 诸侯、开发商、炒房客。 独独缺了中央。 这时你是否猜到中央为什么要调控？如果还猜不到没关系，听我道来。 纵观古今上位者最不能容忍的是别人受益，自己被黑锅。 大开发商，小开发商，大炒房客，小炒房客，地方政府都是收益者，但是风险却由中央来抗。这是一笔很不划算的买卖。 而房地产混战的局面，造成了国家队央企成员只有凭财大气粗高价拿地的份，钱花的最多，风险却抗的最大。 中央深深的感觉到要想国家队受益，要想控制风险只有做到两个字：垄断。 【PS：一语道出真相，垄断是最赚钱的买卖，稀缺资源永远要掌控在上位者手中，就好比西游记中的蟠桃、丹药等，垄断决定话语权】 提高资金门槛，让小开发商，小炒房客，有点钱的小老百姓退出这个游戏。房地产很好玩，但不是小人物应该玩的。 先让市场冷静，彻底整顿，踢出那些个跳梁小丑，然后国家队出马，绝对垄断的市场，才能够统一定价，才能够控制风险，才能够利润最大化。 既然油价高于美国是合理的，那麽房价高于美国一定也是合理的，关键在于垄断。 不仅仅是房价的垄断，因为过高的垄断定价将会使交易量下降，国家队也需要资金周转。 真正厉害的，还是房租的垄断。公租房的推出是房租垄断进程的里程碑。 至于苦等廉租房的同志，不要抱太大的希望。城市要建设、地铁、广场，政府大楼都要上马，钱从哪里来？不会无缘无故凭空出来。 想想小学就近上学，但是重点小学真的就近就能上吗？小学名额可以寻租，经适房、廉租房也是一个道理。 篇外：统计数据 说到房产泡沫的问题，就不得说说官方的统计数据。 官方的统计数据从来是可以很雷，但不可以很真。 我们的统计原则基本就是：村骗乡，乡骗县，一骗骗到国务院。 不知道有人去市、县、乡、村进行过社会调查没有？ 社会调查是怎么一回事？ 我来告诉你，所有的关于人口、收入、田地、贫困户的数据都是官方统一编写，统一口径，如果胆敢有哪个小民对调查人员乱说，那是吃不了兜着走的。 你问数据编来编去的意义在哪里呢？ 意义很大，起码跟向上申请拨款是关系非常密切的。数据不假，钱从哪来？ 统计数据无所谓是否真实并不重要，重要的是它是或缺利益的重要手段。 假设官方想证明房地产不存在泡沫，那么一定拿的出不存在泡沫的统计数据作证。 反之，也一样。 好比，CCTV 为了证明高空置率的结论，派出记者专门找偏远且刚刚完工的楼盘，进行了一次纯粹为了证明内部已事先得出结论的毫无科学依据的调研。 而地方政府，为了证明刚需多么强劲，也立刻拿出了选择性失明的统计数据来进行回击。 无论是左还是右，同样都是不科学，都是先有结论，再有证据。 我们到底应该信谁 商品房本来名字中就有商品二字，不准投资岂不是笑话？真正不准投资的那叫公房，这才是保证老百姓有房住的关键。 商品房诞生的时候就很明确是：改善居民居住条件的，现在政府怪商品房价格过高造成老百姓没房住本来就是颠倒黑白，政府不造保障老百姓居住的公房，而让老百姓去购买改善居住条件的商品房来解决本该政府解决的居住问题，政府不作为才是造成老百姓出现居住问题的罪魁祸首。 我不期望人人有房，我只希望每一个在城市里找到工作的人通过努力工作勤俭持家能在生活城市里有希望拥有一套安稳的房子来容身，不管这房子的性质是商品房、经适房、廉租房或者其他什么房子。 【网友说：你说的正是根源所在啊，政府的职责应该向无房者提供的保障房，建成经适房、两限房，被权贵占有牟利，而非要把商品房赋予稳定社会的职能。政府不是不知道问题的根源，而是不愿意放弃巨大的利益】 房地产游戏的模式三个环节：地方政府卖地、银行贷款、开发商在二级市场销售。 地方政府卖地之后，剩余的风险和收益都归银行和开发商。 地方政府卖地的款则用于地方广场、地铁、公路之类的建设和权贵的挥霍。 地方政府只负责卖地，是无风险的买卖。当然还有人企图利用流氓无产者和无知群众的群情激奋来进一步收取房产税来提高地方政府收入。 税收从来都是向下游转嫁的，政府多收出来的钱一定是通过最下游的房租来体现。 当然，也有很多明白人士大声疾呼反对房产税。 自古而今，即使最辉煌的朝代，最被广大群众津津乐道的太平盛世，普通群众也仅仅只是解决了温饱而已，包括贞观、文景、康乾。 国家的富庶都是以老百姓勒紧裤腰带为代价的。 所以，政府是不会理会部分明白人反对房产税的呼声的。 真正对房产税的顾及来自于地方政府对土地出卖前途的担忧，真是鱼与熊掌不可兼得。 尽管流氓无产者和无知群众的呼声很高，然而房产税征收一旦实际操作起来，就会变的不得人心，征收难度非常之大，实际效果难以预知。也就是说政府没有底。而如果房产税征收效果不佳，地方政府卖地收入再受到巨大影响，那就真正是得不偿失了。 就会变成赔了夫人又折兵。这样的买卖，政府是不会轻易做的。 房地产的现状是，商品房二级市场是由各种类型的开发商自由竞争的，一手房开发商之间的竞争，二手房投资客之间的的竞争。 房价为什麽在一个自由竞争的市场上能够持续上涨？因为稀缺性。不是房屋的稀缺性，而是房屋所必须占用的土地的稀缺性。 有些群情激奋的群众立刻以 6500 万套房子空置的事情提出质疑，还有 CCTV 的报道，那是要多煽情又多煽情。 我们无需说 6500 万套的真实性（明白人都知道非常离谱）和空置率的科学性。为什么不说，因为这种稀缺性跟空置率就完全没有关系。商品房的稀缺性是相对人民币而言的。人民币印多了，资金没地方去，商品房就涨价了。 垄断的市场是没有风险的，土地是完全垄断的，所以地方政府完全没有风险。 而商品房是自由竞争的市场，是具备风险属性的，尽管由于大量印钞造成了商品房的飞涨，但随着房价的高涨，风险也在积聚。 地方政府土地垄断没有风险，完全可以置身事外。 可是银行呢？属于国家的银行。 银行正在承担自由竞争市场房价高涨积聚的风险。 这是中央不允许看到的，地方政府受益，而风险全部甩给中央。 既然垄断的市场是没有风险的，那还是让房屋和土地一起垄断好了。 垄断还可以解决一个问题：社会稳定。 常被媒体和群情激奋群众所提及的一个重要问题就是:房价收入比。 大量印刷的人民币促成了房价高涨（因为商品房实在是具备了大资金需要的所有投资品属性），可是那些个巨额的资金普通老百姓并没有见到。 路人甲：我们一个月就挣 2000 多块钱，干一辈子买不起房啊。 路人乙：我一个月上万都买不起房。 媒体：一个家庭不吃不喝 22 年买一套房。 大量的疯狂印刷的人民币在哪里呢？ 在精英手里。 我们再回顾一下开篇，我们奉行的是精英社会，丛林法则，金字塔式收入结构。 人民币再多，也不可能流到金字塔的底端。 地方政府垄断卖地也就让百姓们发发牢骚。 而炒房客，开发商赚的盆满钵满就让生活在中下层的老百姓眼红和不能容忍。 不患寡而患不均啊。 垄断，国家队的垄断，可以解决眼红问题，也就是社会稳定问题。 还有一个最重要的问题：银行和民营开发商之间，是官与民之间的问题。 而银行和国家队央企，是左兜和右兜的问题。【PS：国家垄断还有利于稳定，便是这种不均的问题，真是控民于心，得心应手】 房屋垄断土地是垄断的，然而房屋垄断并不是一件容易的事情。 因为民间百姓手里是存在大量二手房的.当然这也是为什么调控的板子只打在二套房、投资客、炒房客身上的原因。 同样，房租的垄断也并不是一件容易的事情，因为民间百姓手中的大量二手房都具备出租的特性。 要垄断，必须抓住源头。 源头在哪里？ 在一级市场，而不是二级市场。 房地产的垄断就是要国家队从一级市场做起，从一级市场开发着手完成对商品房开发的垄断。 一级市场，那是一个高高的门槛，民间资金，就让他该干嘛干嘛吧，房地产不是你玩的。 一级市场包括的内容是一般开发商无法参与的：城市规划，城中村改造，旧房拆迁，城市综合体开发。 可以说从规划、改造拆迁、开发、到二级市场销售，一条龙服务。 一级市场开发的最大特点就是可以创造需求：你不是有房子吗？我拆掉你的房子，看你有没有刚需。 国家垄断控制风险的意义还在于：需求可以拆出来。 以后的路，民营开发商的日子将变得越发艰难。 土地是地方政府的，商品房开发是央企和国企的。 处于金字塔下层的 40% 家庭，如果还没有一套自己的房子，那么买一套自己的房子就越发的变得不可能。 商品房将逐渐往金字塔的上层积聚。 处于金字塔下层 40% 的无房家庭将只能以租房来解决居住问题。 租金的快速上涨期即将到来，政府已经盯上了房租这块巨大的蛋糕。因为房租的收益比房产税更靠谱，更具有操作性。 公租房，呼之欲出。 自古以来，民生问题的底线就是不要出现陈胜、吴广的极端情况。所以政府更在意的是农民问题。【PS：农民无底限，政府只要把握住某条红线，就不会出现陈吴之人】 因为历史的改朝换代都是大饥荒引起的，无论是汉末、隋末、唐末、还是明末。农产品价格的上涨对政府的震动要远远大于房价的上涨。 农民具备最原始的力量，而他们关心的并不是三线以上城市的房价，而是能否填饱肚子。 而关心自己能否拥有一套产权房的都市白领，除了呻吟一下意外，几乎是没有什么有效反抗的可能的。 中国自古以来都不是人人都能有属于自己的房子，大量的丫鬟、仆妇、管家、小厮寄养在权贵人家，身体都是不自由的，何谈拥有自己的房子。 自古以来，最多的就是失去土地的农民，住在地主家做长工，又何谈属于自己的房子。 只要是有贫富差距的社会，只要存在阶级，只要存在统治和被统治，这个社会就会不以人的意志为转移的出现大量的底层居民，没有这些底层居民。权贵就不能很好的生活。【PS：没有阶级就没有人性，有人性就会有阶级】 为了权贵生活的更好，就要维持大量的底层群众。 权贵必须保证大量底层群众的基本生活，才能够让自己过得更舒服，仅此而已。这就是民生。 （呻吟一下）。君不见，天涯上多少盼着被美军解放的铁杆准汉奸，政府楼被炸，七成网民不是替死者默哀，而是一片欢呼。为什么会有这样的民意，参考前苏联，政府确实应三思。 爱国是与中华的历史分不开的，自秦统一以来，中国由封建时代转变为帝国时代，只有在项羽焚烧咸阳后，对诸侯进行了一次分封，但时间非常短暂，刘邦重新统一了天下，帝国时代经历了漫长的汉、唐、宋、元、明、清。天下一统的爱国情结是根深蒂固的。 而在秦以前，与中世纪的欧洲是极为相似的，齐国人可以到秦国做宰相，赵国人可以到燕国做将军。中世纪法国的诺曼底公爵可以到英格兰继承王位，瑞典的贵族可以到基普做大公，封建时代的国家概念并不是明显。欧洲经历了漫长的封建时代，国家观念很淡薄，能够抛弃国家货币成立欧盟就是明证。这对于漫长帝国时代，天下一统的国家是很难想象的。 爱国只跟历史文化传统有关。 1978 年越南入侵红色高棉，当时的红色高棉对内实行红色恐怖，以共产主义的名义对全国 700 万人口进行奴役和屠杀，总共屠杀了 100 万人。当越南军入侵时，受到了广大柬埔寨群众的热烈欢迎，称越南军解放柬埔寨是解放人类的战争。 红色高棉失去了民心，必然败亡。 那时，为了支援红色高棉，中越战争打响。有我国的强力支持，红色高棉仍然走向败亡。【PS：没有民众，失去民心，再强大的帝国支援也是枉然，得道多助，失道寡助也】 但我们还没有谈到所谓“造反”的地步，只是说房价如你所述——暴涨。中国的中产和以上人士将进一步携款合法外流（在房价暴涨的 09 年，中国外流人口达到历史峰值）。这一部分人利益如何保证？您觉得政府不需要考虑对么？ 现在社会跟几百年前最大的不同是，世界是开放的，这得益于地理大发现和世界经济一体化，即使缅甸、朝鲜这样封闭的国家也免不了受到来自世界范围的影响。大一统的集权社会融入了西方民主的思想，同时互联网的出现也让人们对过去的思维进行了再思考。【PS：文化的普及，将有部分人会觉醒，尽管只是少部分，却可以改变世界】 尽管底层百姓出国还是一个梦想，但对于精英人群，基本上是在世界范围自由流动的。【PS：君不见，16 亿人口，真正可以出国定居的又有多少】 中国自古以来，商人都是没有地位的，商人的财产可以随时被官员没收，自古如此，至今如此，即使是今天也并没有出现私人财产神圣不可侵犯的宣言。即使出现了，也没有任何可以操作的可能。【PS：只要不是当权者，一切都是羔羊、肥猪，只要成熟便会被屠杀，屁民是韭菜，会一代一代的被收割】 明朝以后大量的商人移居海外成了华侨，现今的商人为了安全移居海外也不是什么新鲜事，不过是步明朝华侨的后尘罢了，政府会真的放在心上吗？朱元璋没有放在心上，朱棣没有放在心上，现在同样也不会放在心上。【PS：明朝首富沈万三，可能是商人外移的觉醒，富可敌国又如何？最终被收割】 真正可怕的是官员一方面谋取私利一方面把亲属和存款送到国外，这其实是一种国家背叛。在国内榨干老百姓的血汗，得到的金钱却在国外挥霍。什么叫卖国，不过如此。 不过从政府要分租房市场的蛋糕而言，我有不同的看法： 政府的公租房要想租出好价格，有两种方式 1）减少市场可出租房源（北京就这样干了，拆迁廉价城中村） 2）提高竞争房源的成本。（所以我认为推出房产税是大概率的事情，因为政府的公租房是不需要交房产税的） 于是竞争房源的房租暴涨，政府的公租房也就可以羞羞答答的打个 9 折来安抚一些底层了，反正所有的黑锅都有竞争房源的房东背了。【PS：背后的一只大手，随时都在薅着底层百姓的羊毛】 房产税的问题，我觉得政府还是慎重的 1、如果采用不公平法则 公务员，垄断企业，事业单位的福利房不上税，权贵与利益集团购买囤积的大量商品房不上税，只有普通百姓上税，会加剧社会矛盾，而房产税会大幅提升租金，在公租房没有大量建起来之前，对稳定不利，维稳才是第一要务。 2、如果实行公平法则小产权房，福利房，权贵囤积房都要上税，执行难度太大，可操作性不强，阻力几乎难以逾越。如果真的收房产税，采用不公平法则的可能性最大，普通的无房百姓生活将变得非常艰难。【PS：想动贵族利益，自古没有好结束，只有强权变法可以坚持一段时间，一旦遭到反击，维稳将会破灭，收割底层老百姓，才是最好的方法，两害取其轻是也】 维稳问题其实最终还是吃饭问题。 房价上涨可以不买，如果房租价格不能控制，农产品价格不能控制。一旦大批群众吃饭出现了问题，维稳就无从谈起了。这个底线，还是要严守的。 说到公租房问题 首先还是要提到我们实行的双轨制。 从某一方面可以简单的理解为统治阶级内和统治阶级外。 也就是我们常说的体制内，体制外。 体制内:公务员、垄断企业及医院、高校、科研院所等事业单位。 体制外：外资、私企打工者，个体工商户，农民，这里面也应当包括高层的老板和最底层的长期无业人员。 我们感受最深的就是涨工资的问题，一旦政府涨工资，那就一定是体制内涨工资，跟体制外完全没有关系。 在金融危机的 08 年，大批企业关门，减薪，裁员，美国欧洲因为钱紧不得不降低公务员薪水。而这时，我们神奇的国家在干一件事：公务员普遍加薪，是为了全国百姓着想—刺激消费。【PS：应该还是以维稳为主，稳定体制内的人，让他们过得安逸，国家才会舒服，至于屁民只能紧衣缩食，有吃就行】 还有保障房问题，这个也是我们感受最深的：保障房&#x3D;公务员及垄断企业住房；解决住房问题变成了如何让领导干部住更多更大的房子，如何让体制内员工拥有足够舒适住房的问题。 体制外的群众，那是别想得到一点好处的。谁让你是被统治阶级呢。 公租房的推出，也要解决两个问题： 1、体制内的最下层（最下层也是统治阶级，也就是是古代官吏中的吏）员工的基本住房问题。 2、向体制外被统治的小民稳定收钱的问题。【PS：哪怕底层的吏，经济收入低，但他们可以有福利，收取租金等，便可以安逸，铁饭碗便是如此】 以国有企业为主导，发展住房租赁市场。这是现在的政策。 商人还是要分的吧： 红顶商人就是官商，统治阶级，那是上位者。普通商人，比如开个袜子厂赚个辛苦钱，最后袜子厂不挣钱了，官员还天天找他，让他孝敬，他就只好移民了。普通商人在中国也是海量的，有点钱，但是没一点地位。 房产税无论是持有环节征收，还是交易环节征收都是要向最终租房人转嫁的。 好比鸡饲料上涨没有可能鸡肉不涨价，但是养鸡的并没有赚更多钱。 降低百姓租房困难的唯一国际通行办法就是减税。但是减税，在我国是很难行的通的。一个高增长高通胀的国家，高昂的腐败成本和巨大的浪费将导致国家必须维持高税收才能维持运转，GDP 保 8 实际上是必须的也是迫不得已的。维持正常的运转，维持庞大的消耗税收而不是创造税收的公务员队伍，没有 GDP 快速的增长怎么可能呢。 政府为什么要调控难道就为了给你说的 P 民面子？ 如果房价一直暴涨，不更符合食利阶层的利益？房价低价一起彪～ 真不知道你仔细看了没有。我通篇也没下过调控是为了给 P 民面子的结论。 调控的根本原因还是中央在房地产的游戏中没有得到好处。调控是为了让中央的国家队参与进来，成为主体。 垄断的目的还在于能够控制价格，为了维稳，中央是不希望暴涨的，但也不希望不涨。 回头还说公租房 在私企打过工的都知道，毫无归属感可言，老板脑袋一发热，随时让员工卷铺盖卷走人。那是要多没保障有多没保障。原因是社会关系，关键客户，都掌握在老板一个人手里，员工就是打个下手，一不爽，就换人呗。 统治者可知道不能这么用人的。一个庞大的国家机器要想正常运转，必须得让手下的和自己的利益一致。如果自己吃肉，手下的连汤都没得喝，这个机器就转不动了。 因此，在房价高涨的时代，保障房才成为中央默认的公务员房、垄断企业房。 公租房首要解决的就是手下里面最底层人士的住房问题。【PS：跟着国家走，有肉吃有汤喝，但凡出现公务员增加，必定是因为福利太好了】 我认为针对于体制内来说，无论是公务员，事业单位，还是国有企业的初级员工，都可以通过所在单位申请公租房，公租房的租金会略低于市场，主要是单位一定会提供补贴。 体制外对公租房的申请就没有那么幸运了。 钱的问题，地方政府也想到了解决的办法。 在卖地时就要求开发商配套建设一定比例的经适房、廉租房或公租房。【PS：一旦形成垄断，就形成绝对的控制权，开发商想要有活干，必须要满足政府的要求，你占大头，但小头必须有我一份】 然而，羊毛出在羊身上，开发商不可能做赔本的买卖。经适房好说，反正是卖个住户，大不了利润很低，顶多挣得少点。而廉租房和公租房就纯粹是只见投入不见产出的（开发商可没资金没耐心收租子）。廉租房和公租房的建设成本必须加到所建的商品房身上，这肯定会抬高房价。【PS：一消一涨，最后倒霉的永远是底层百姓】 关键是拿地成本逐年上涨，孝敬的资金也在逐年上涨，在加上多出来的廉租房和公租房建设成本，房价不可能无限抬高的。开发商也需要资金回笼周转。房价越高风险越大这是无论政府，开发商，炒房客和买房群众都有的共识。只是房价多高才是高，不同的人理解是不同的。 显然，把大量廉租房和公租房的建设寄托在开发商配套身上是完全行不通的，不仅不能解决住房问题，还让本来就高企的房价更加雪上加霜。 体制内公务员、垄断企业和事业单位的员工住房问题是不难解决的，因为有政府行为的强制意志在里面。 1、地方划拨土地，征集开发商建经适房、公租房。 2、地方政府强制要求开发商建配套经适房、公租房，建设成本就转嫁给购买商品房的冤大头吧。 3、体制内单位自有土地，集资建房。 多管齐下，体制内人员的住房不难解决，甚至体制内人员每人住好房子大房子多套房子的问题都不难解决。处于金字塔的中上层，他们俯瞰着芸芸众生。 处于金字塔下层的体制外的广大群众怎么办？ 体制内员工的住房舒适性和投资获利是首要保证的，不然光让干活不给好处，怎么能让手下听话呢？ 体制外广大群众的住房问题也要解决，这关系到社会稳定。 能不能拿出一个办法，即解决了群众住房问题，又可以从群众手里长期获取收益？ 细水长流收租子的事情开发商做不了，但政府可以做。 公租房，如果解决了钱的问题，面向广大群众的公租房的推出，将会取得双赢的局面。 既然房地产开发最肥的肉留给了国家队，国家队也应该投身到公租房的建设中来。 国家队全面进场之前，大鱼小鱼虾米泥鳅，皆可得利。 不把小鱼虾米泥鳅赶出池塘，市场无法控制，风险无法控制，公租房建设也无从谈起。 二套房首付提高到 50%，第三套房停止贷款，小开发商的清理整顿，民营企业在招拍挂中无论价高价低都无法取得土地，等等一系列重拳直击小鱼虾米。 土地将回到国家队手中，这个世界将变得清爽。 让时光倒流到 80、90 年代，我们的地方政府守着蕴藏着巨大财富的金矿、锡矿、铜矿却过着贫穷的日子。 没有资金，矿山是没有办法变成财富的。于是招商引资，为了 GDP,为了解决就业问题，出台了各种优惠政策，于是外商堂而皇之的走进来了。成为了这些矿山的主人。 5 年，7 年或者 10 年，外商享受的免税期满的时候，外商卷着巨额财富走了，留下了一个个废弃的充满危险的大坑。这是血琳琳的教训，政府没有理由不吸取。外资、私企、小业主总有一天会让他们清场，尽管这一天晚来了十几年。 在土地日益稀缺的今天，房租难道不是可持续产出的金矿？让炒房客、投资客、民企开发商见鬼去吧。 宁愿住桥洞的早晚要当盲流处理的 逃离城市基本是一部分人被淘汰掉，选择，离开，而又有更多的人冲进去。 房租收入下降基本是做梦才会出现的事情，国家队的进场就是不让房租下降。 商品房和公租房的区别实际就是土地性质的不同：一个是出让，一个是划拨。 出让那必须是招拍挂（招标、拍卖、挂牌），那必须是天价。 划拨就基本算是白给，收钱就是象征性的意思意思。 是商品房还是公租房，土地的性质说了算，地方政府说了算。跟房屋质量没有关系。 一套房子假设 20000 一平，房子的价值也就占 30%，剩余的都是土地的价值。 无耻 - 提通过税收调节房价、收入今天看到搜狐上一篇文章说到要通过征税来调节贫富差距，提出这个方案的人不知是无知还是故意，如果政府听了这种无耻参谋的建议，不知道多少老百姓会活的更惨。 假设出台又一个新税种，无论它叫什么，我们暂定为财产税。既然有了新税种，就要定任务，那好了，为了这个税种制定了年上缴多少多少的任务。【PS：无论国家出台什么样的新政策，都会有地方或部门争功，定任务，表示积极拥护】 实操的时候，执行的工作人员发现一旦轮到权贵脑袋上的事就没办法执行，你执行，他先让你下课。 但是任务必须完成，那还是从普通老百姓身上打主意吧。于是政策就完全走样了，非但起不了劫富济贫的目的，反而加重了穷人的负担。 往近里说，个人所得税，挣的是谁的税？权贵没看见交，月薪 3000 块的工薪层可一个都跑不了。3000 块月薪上缴的个人所得税你看着不多，可对于养孩子糊口的老百姓来说，哪怕 10 块钱都是重要的。他们可没有资本像月薪上万的小资一样动不动花 500 块钱泡个吧。 个人所得税是有任务的，工作人员必须完成任务，税别管是局级干部交的，还是连孩子幼儿园都上不起的穷光蛋交的，总之完成任务就是好样的。既然局长的税收不上来，就要从穷光蛋身上加倍收上来。 往远里说，王安石变法是怎么失败的，以史为鉴可以知得失。王安石的初衷难道不是好的吗，可结果怎么样呢？只有一个——民不聊生。 书生误国啊。 许多兄弟关心房价什么时候会涨。 那么先看看这次调控后都出现了什么样的现象。 1、全国房产成交量大幅下降 2、一线城市房价略有下跌，但并不持续，到现在基本跌不动了 3、多数二三线城市房价不跌反涨，成交量逐渐回升 4、大多数二线以上城市租金持续上涨 5、农产品价格有上涨迹象，大蒜、姜等小品种农产品遭遇爆炒。 6、变化莫测的政策导致精英阶层出现移民潮 还有什么，欢迎大家补充。 农产品价格的上涨是很值得警惕的。想买房子但嫌房子贵的都市白领对农产品的价格很不敏感，但是金字塔最底层的最大多数群众是很敏感的。领导们也很敏感。这牵扯到相当大比例人口的吃饭问题，稳定压倒一切。【PS：治国如治家，当家里的人都吃不上饭时，这个家就散了，稳定压倒一切，真乃绝句】 农产品价格的抬头将会导致物价全面上涨，在不引起质变的前提下，房价作为商品也不例外。这个引起质变的前提是出现饥荒的极端情况，这样的几率在现在社会很少。尽管干旱和洪涝使农产品大幅度减产，但是农产品还可以进口，国家还有粮食储备，保证全国人民填饱肚子还是不存在问题的。 一线城市仍然沉默，国家队在积极运动。二三线城市的房价上涨的成交量的回升却给了市场一个明确的信号。这是资金运动的规律。国家队对一线城市的布局，迫使资金流向二三线城市。二三线城市相对（与一线城市相比）不高的价位给出了较大上升空间的预期。 全国富人买北京上海，全省富人买省会，房价的合理性已经不能用简单的本地平均收入来衡量。精英阶层的购买力才是关键。 明年物价进入持续上涨期是一个不容回避的问题在资金总量不变的前提下，巨量资金推动农产品价格上涨或者推动房价上涨是一个必须的选择。 今年政府用行政手段严厉打击蒜和绿豆价格的暴炒，基本上没有起到作用，资金有自己的运作规律，光靠拿张悟本出气也不能解决问题。 二三线城市的房价的上涨使与一线城市的差价缩小，为一线城市的发力提供了动能。 无论你喜欢还是不喜欢，都不是以人的意志为转移的。 许多人心怀房价肯定会跌回 2004 年的美好愿望，刻舟求剑似的思维错过了一次次购房的机会。在患得患失中，在牛刀的号角声中，在任志强的大炮声中，迷失了自我。 任何事物都是有其规律性的。关键是否有一双慧眼能够穿透重重的迷雾。 假设你是个投资客，你非要去石家庄和长沙买房子，结果发现不怎么升值，怨天怨地： 石家庄作为一个二线省会怎么会不涨？长沙的房价怎么那么低？ 我们知道，北京的房子是全国有钱人买的，省会的房子是全省的有钱人买的。但是当省会城市距离一线大城市在 6 个小时高速以内，省里的有钱人的资金就会流向一线大城市，而不是省会。河北的富人一定会选择在北京投资房产，湖南的富人一定会选择广州深圳投资房产。 假设你是一个投资客，你去昆明旅行，发现昆明的房价甚至高过重庆，很不理解。你很疑惑昆明这么小的西部边陲城市投资价值在哪里？ 昆明是云南省内唯一的大城市，且相邻的二线以上城市离云南省都比较远。云南地州资源丰富，虽然穷人占的比例大，富人的数量却也不少。昆明南有滇池，北有长虫山，作为一个 700 万人口的城市，土地资源非常稀缺。所以贵，一定有贵的原因。便宜一定有便宜的道理。 问：楼主针对南昌的房价做个分析吗？从刚公布的 100 个城市房子均价看，南昌 5k 每平左右，是高了还是低了？ 答：对于不了解的城市不敢妄下断言。没到现场调查就没有发言权啊。房价会不会涨还要看地方政府的规划。比如广州拥有大量的城中村，其周边有较多的大城市，广州的房价就比北京和上海低。如果广州的城中村一旦大规模拆迁，房价将会大幅上涨。比如南宁东盟贸易自由港的概念使南宁的房价涨幅惊人。南昌的地理位置，政府规划，发展前景，江西富裕人口的多少，都是决定房价的因素。 我们是第二个日本吗供求关系？供求关系，现在是谁在决定？ 国家！ 国家的经济结构决定的。 制造业的资金都进入房地产了。能不涨吗？普通人有几个可以够炒房资格的？ — — — — — — — — 问：日本当初也是供求关系！供求关系的根本也不应脱离国家的经济实力！！还暴涨？怎么涨？再涨都够去美国买房了！！你这不扯淡么 中国和日本最大的不同在于日本的货币是开放的，中国的不是，是不能自由兑换的。 暴涨是相对于钱而言的，不是相对于实际购买力而言的。 80 年代工资 200 多块钱一个月的时候，是不能想象 90 年代末北京城区 5000 每平米的房价的。那时候万元户已经是富人的代表了。 90 年代末工资 1000 块钱的时候是不能想象现在 30000 一平米的房价的。90年代的 100 万绝对是富裕群体。可现在连个中产都算不上。 货币的持续贬值你没有考虑。 — — — — — — — — 问：说真的！！楼主背后还有这么多信众。。。。真傻啊！中国的房地产，根本就是政府控制的！什么贵有贵的道理！国家投资那里，那里地价就高！国家决心打压地产！明天就能见效！！关键就看他愿不愿意打！ — — — — — — — — 秦始皇也是想怎么样就怎么样，结果国家没了。 李世民懂得按规律治理国家，所有才有贞观盛世。 — — — — — — — — 问：再反驳楼主一句！！在中国的土地，可不稀缺！只是没开发罢了！！中国与世界不同！ok？13 亿人！！用十三亿的居住权作为市场竞争的资本。那太可怕了！真的！！！如果可能，中国绝对可以产出世界第一贵的地价！为什么？这么多人需要房子。能不涨吗？呵呵！多少有点扯淡！！别再提供求关系了！供求根本是平衡的！！ 中国有 13 亿人口，960 万平方公里土地，土地一点不稀缺。 但假设你在北京西城上班，让你去塔特拉马干买房子，你愿意去吗？ 全国有点钱的都要在一线城市和省会城市买房子，所以才会稀缺。 大兴安岭有大量的土地，哪个有钱愿意跑去置业呢？ 中国经济发展不平衡，牺牲全国大多数城市和乡村，来保证北上广深及大部分省会城市的繁荣才是造成土地稀缺的愿意。 土地有的是，房子有的是，但好位置的土地和房子并不多。 一方面大量的小县城和乡镇、村庄人口锐减，因为缺乏谋生手段不得不背景离乡外出打工，另一方面超大型城市越来越拥挤，土地资源越来越稀缺。【PS：还是那句话，土地位置与稀缺，绝定价值】 这就是中国集中发展极少数标杆城市所造成的呀，也是因为如此，才造成了中国金子塔式的收入结构，贫富差距越来越悬殊。 民为何，官为何很多人很疑惑，贪官越来越多，根本不把老百姓的利益放在心里，这些贪官即使被曝光了，还能继续当官。这是为什么呢？ 首先了解一下老百姓，也就是民到底是什么？ 民就是牛羊，古代的时候，官员管理百姓叫做牧。官员管理百姓就是替君主放牧，只要保证牛羊不逃跑，不骚乱，那么就是合格的官员。 秦始皇暴政，百姓揭竿而起，可是陈胜起事后基本视民众如草芥，项羽屠杀平民比始皇更残暴。 萧何是一个很贤德的人，对百姓很好，赢得了很高的名声。刘邦在广武山和项羽对峙，得知了萧何在关中深受百姓爱戴，就疑心萧何要造反。一个君主爱民如子是为了百姓的支持，江山永固，一个臣子对老百姓好是不是要造反呢？于是派人去调查萧何。 萧何是个聪明人，感觉到刘邦已经不信任他了。于是赶紧改变工作作风，开始霸占百姓的田产，上大街欺负漂亮的妇女同志，并且派自己的子女上前线给刘邦做人质。 刘邦看到了萧何的行为非常高兴，知道萧何不会造反就放心了。百姓不是牛羊是什么？ 在红色高棉统治下的柬埔寨人，民连牛羊都不如呀。 波尔布特同志坚持共产主义的按需分配，取消了货币。于是市场经济完全没有了。群众完全变成了按阶级分配了。 阶级只分为两种，波尔布特老板及其打手是绝对的统治阶级，其他人为被统治阶级，也可以称为奴隶阶级。统治阶级对奴隶阶级不爽可以直接拿 ak47 突突。 柬全国 700 万人口被波老板突突死了 100 万，当然不光是突突，还有活埋。 以至于越南派了 10 万军队侵略柬埔寨，受到了柬埔寨人民的夹道欢迎，称为解放人类的战争。 公道自在人心。【PS：人心其实并不准确，应该说公道自在民心，自古如此，民众基数太大，只有他们的力量才是无限的】 我们的今天本来就是历史的延续，前人经验和智慧的总结，不是一句话就可以抹杀的。 因为秦以后漫长帝国时代的大一统，才会把中央集权延续到现在。 而西方封建时代延续到地理大发现，诸侯割据王国、公国、侯国林立为现代的西方提供了民主制度的可能。 在制度上完全的不可比性，使向国际接轨成为了笑话。 我们看到的结果就是，物价上涨与西方接轨，甚至堂而皇之的超过西方，体制外的工资则与非洲结果，也算是国际化了。 — — — — — — — — 问：大家听过那个西三旗的有名的限价房旗胜家园吧！外表看起来那么光鲜，地段也不是特别偏，紧邻城铁，当然是被人疯抢都抢不到的两限房呀~！还不是质量问题一大堆。政府安排的政策房也是要开发商建的，哪个开发商没肉吃还能保证把房子盖好？？所谓检测都 TMD 是虚的。 — — — — — — — — 这是肯定的，开发商都追求利润最大化。 政府建设两限房限制开发商利润，开发商必然偷工减料，政府都知道怎么回事，必须睁一只眼闭一只眼，否则这个政策就执行不下去了 对于渴望拥有一套产权住房的都市小白领对希望房价狂降已经到了歇斯底里的程度，他们赞成农产品价格放开，让资金炒作农产品，而离开房地产市场。 理由很简单，一套房子一涨就是几十万甚至上百万，而大米小麦，一斤就算涨到 10 块，也根本不能影响到自己的生活质量。 如果我国农产品价格是开放的，资金流向大米、小麦、猪肉，并且允许囤积，房地产一定会下跌的，这是毫无疑问的。 但是，我们看到的绝不是 10 块钱一斤的大米、小麦，而是 500 块钱、1000 块钱一斤的大米、小麦。 我国将会出现大面积的饥荒，几千万甚至上亿的底层人士饿死街头，社会将出现大的动荡。【PS：无论哪个时代，粮食永远是第一位，民以食为天，国以民为本】 而产权房屋价格的上涨牺牲的主体只是体制外部分都市白领的利益，换来的不过是网络上没完没了的牢骚和咒骂。 巨量资金必须有地方去，如今面临的房地产和农产品之间的选择，你认为政府会怎么做？ 体制内中层、高层可以分到多套福利房，低层至少能够分到一套保障房，即使最不重要部门的底层员工，搞到由单位补贴的公租房是没有问题的。 体制外的高层、中层，以他们的资金实力买多套房子都是不成问题的。 农民，分配有宅基地。国家要稳定，首先就是要农民稳定，因此我国只有农民能够分到土地自己盖房子。 军人，会享受到比公务员更好的福利，让军人享受更高标准的福利待遇，国家有深刻的认识。 那么只有体制外的都市中下层群众才是高房价的受害者，可是这个群体的地位真的很微不足道。 这些既无稳定工作（低层都市白领失业的概率还是蛮大的）又无自己的房产的都市小白领是金子塔底层被压榨的对象，甚至远远不如交通便利地区的农民。 没有这个群体的存在，金字塔上层的权贵是无法享受舒适的生活的。 社会需要底层群体用巨大的付出和极少的收获为金字塔上层群体服务。 当然，在巨大的付出后，有少数人会从低层脱颖而出，爬到金子塔的中层、甚至上层。 这些少数人带给了底层群体奋斗的希望。 拥有一套属于自己产权的房子，就只有一条路：从金字塔的底层往上爬。这条路很艰辛，并且会越来越艰辛，但总有希望。 — — — — — — — — 问：楼主有一点没说透彻，那就是白领的工资普遍较高，他们有能力买房子，但是受到几千年以来的小农经济思想的约束，他们普遍认为买房子不划算，占便宜心里普遍严重，别看他们外表光鲜，其实还都是一帮农民 — — — — — — — — 我说的是买不起房的低收入小白领。 高薪白领不买房的不多吧，都是网上吹的吧。 高薪白领一般还是有自住房的，只是有人不愿意投资房产。每个人想法不同而已。 — — — — — — — — 问：请问楼主所说的低薪白领一个月赚多少钱算底薪？就拿我说吧，我 06 年买的房子，当时月薪 3000 元，这在当时算不算低薪？但是我买房了，还是一个人买的，当然老爸赞助了点。每个月还完月供兜里就剩几十元，硬扛下来了。目前年薪 12 万，我老婆年薪 6 万？这算不算高薪？如果我当时没买房子，以我们 2 个人的收入当下也买的起，只不过生活负担重一些。所以请楼主明示，什么是低薪？ — — — — — — — — 兄弟，你所描述的是另外一个问题。先说说你所说的这个问题，再谈谈什么叫低薪。 先说 06 年你月薪 3000 买房子的问题。 我们打一个比方： 假设 80 年代，咱们两个月薪都是 100 块。你喜欢清朝的瓷盘子，咬咬牙，一年用好不容易攒下的 100 块钱买了清朝瓷盘子。我喜欢缝纫机，用一年好不容易攒的钱买了一个缝纫机。 市场有价值发现功能。显然，80 年代清代瓷盘子的价值没有得到发现。进入 90 年代，随着社会的发展，社会财富的增加，钞票也大幅度增加。清代瓷盘子的市场价值发现出来了，瓷盘子价格开始大幅上涨，你的瓷盘子由 100 块涨到 1000 块。而我买的缝纫机已经淘汰了。 瓷盘子具备投资品的一切属性，能够吸收社会的富裕资金，而缝纫机没有这个功能。我很眼红，我虽然买的起这个瓷盘子（因为 90 年代我的工资由 100 涨 到了 800），但是我觉得价格太高了，没有买。而你的瓷盘子在 90 年代为你挣了 900 元钱。 时光又到 21 世纪，社会资金越来越多，钞票越印越多，可瓷盘子在市场上越来越少（都被收藏了），于是瓷盘子涨到了 1 千万一个，我即使想买瓷盘子再也买不起了，而不是嫌价格高的问题。而你已经成为了千万富翁。那个瓷盘子也并没有因为 1 千万的价格实在太高而暴跌，相反价格仍以每年 20% 的速度增长。 06 年你在房价价值发现的初期买了房子，就像 90 年代你用 1000 块买清代瓷盘子。如果你的工资不变，或者变化不足够大，现在你将买不起房子，就像你在 21 世纪不可能买的起瓷盘子。 收、入高低再说说收入高低，不同城市，不同消费水平，对收入高低有着不同的理解。 我们举北京为例。 反映真实居住成本的是房屋租金，而不是房价。 在北京生活，一家三口的通常情况。 一个位置能够满足上班条件的两居室租金大约 3000 元，小孩花费没有 3000 块是下不来的，再加上夫妻俩 2000 元的基本生活花费，也就是说 8000 月收入的 家庭，刚好能达到收支平衡。 如果是体制外的都市白领，这个收入是很可怜的，因为还要考虑到失业问题， 并且应付万一发生的意外支出。所以每月能有 2000 元的结余是必须的，那么 10000 元是在北京生活的基本水平。 而购买商品房所支付的金钱是要远高于租金成本的，因为你买的不是房屋居住权，而是房屋的产权，一定会出现溢价。 如果你现在的家庭收入能够再买得起一套房子，那么你的收入水平应该至少是小康，甚至达到中产。 — — — — — — — — 问：楼主啊，你有一个概念错误：清代的瓷盘子是收藏品是古董，其价值是由拥有瓷盘子的收藏家决定的，而房子是商品（我指的是商品房，不是公租房之类的保障房），其价值远没有古董增值速度快，所以说收藏品和商品是有区别的。 — — — — — — — — 呵呵，商品房当然和清代磁盘是不同的，升值空间不同，投资对象也不同，但价值发现的道理是一样的。投资品的基本属性：稀缺性是共有的，当然稀缺的程度不同。 我所讲的是投资品的价值发现，而不是商品房&#x3D;清代瓷盘。 — — — — — — — — 问：此外，您还没有正面回答我什么是低薪，我今年 30 多岁，如果我刚毕业肯定是拿底薪的，往最坏了想，我毕业几年到今年混的不好，今年只赚 3000 元一个月，我就买不起房么？如果你觉得是，那么你错了，我仍然可以买的起，我会到比较偏远的地段去买房子，比如密云，延庆等买套小户型二手房，那里的房价我仍然可以支付月供，当然我还是要像老爸要点钱付首付的。可是如果我不这么想，觉得去哪里不划算，在四环里买房子多好啊！那么我可能就买不起了，因为在四环里买房已经超出了我的能力，那么请问我买不起四环里的房子是房价的问题呢还是我的问题呢？是不是说我买不起四环里的房子就是我买不起房？ — — — — — — — — 如果我们买首套房，不是为了投资。我们买房总有个基本的要求： 有一个自己的家，并且上班相对方便。 如果你在长城饭店上班，你跑去密云买个房子。首先你上班就成问题。 如果我月薪 3000 块，我甚至不能在密云买房子（因为也上万了），但我可以在山西的某个县城买套房子。问题是我买这套房子干什么？ — — — — — — — — 问：我的中心思想是：北京的白领普遍买的起房子，但是有一部分不买，其原因是想花最少的钱去获得最好的地段，最好的楼层，最好的朝向的房子，这是划算不划算的问题，不是买得起买不起的问题，当然有的人会说：买房了，得病了怎么办？失业了怎么办？一大堆怎么办！那么请问：既然你知道早晚要见马克思，为什么现在还活着啊？一刀了断了算了，呵呵 — — — — — — — — 你说的这类人其实是因为贪婪和恐惧，幸运不会垂青即贪婪又恐惧的人。用天涯的语言来说：就是传说中的傻空。 — — — — — — — — 问：楼主，一对有工作经验的年轻的北京白领夫妻月收入只有 8000 元？这 是怎么统计的？您的统计结果不准啊，我的结论是 10000-12000 元&#x2F;月是北京标准的白领夫妻的月收入，那么这笔钱能不能买房子？能，能不能付首付？可能不能，首付款怎么来的？一部分是父母赞助的。作为父母就要把自己的孩子扶上马，再送一程，这和啃老没关系。 — — — — — — — — 呵呵，这个也不好这么说，不同行业间的薪水差距实在太大了。 比如一个有 6、7 年职业学校的教师或者一个有 5、6 年电脑分销经验的产品经理（都是大学毕业），他们辛辛苦苦干一年多点的也就 7、8 万块。他们都不晓得招商银行随便一个客户经理轻轻松松年薪几十万。 同是大学毕业，同是 5、6 年工作经验，北京几十万年薪收入的人不少，但一个月只挣 3、4000 块的数量更庞大。 — — — — — — — — 问：房价是由土地决定的，而土地是咱们这个国家的根本，当年不就因为要改变土地的属性，才有了我们的党。凡房屋也都是只有土地的使用权，土地属于国家，说收回的话不管你有无房证更不会和住房者商量（如拆迁），这个性质绝不变，想下，对有房者如此，会为了没有房子的而制定均衡均分的土地政策下降房价吗？现在贫富分化越来越严重，真买的起房的考虑的重点不会是贷款，买不起的，房价跌去三分之一也还是买不起，不要看政府如何了，如果能少贷款或不贷款买处房的话就买吧，人早晚得有个安身之所，不要贪大求全，战争或地震来了房子不值钱，但万一战争或地震不来呢？ — — — — — — — — 没错，就是这个意思，如果战争来临，你手中的钱也变成废纸。📝&nbsp;人人都有居住权。房子是用来住的，不是用来炒的。如果大家都这么想就好了，就不会有炒房客这个职业了。 📝&nbsp;房价不是由统计局的平均收入决定的。而是精英的平均收入决定的。21 年的新闻，腾讯应届生房补每月涨至 4000 元，南山区房东笑了：该涨房租了！ 📝&nbsp;我们的统计原则基本就是：村骗乡，乡骗县，一骗骗到国务院。从疫情期间的统计就能窥见一二。 📝&nbsp;真正可怕的是官员一方面谋取私利一方面把亲属和存款送到国外，这其实是一种国家背叛。今生无悔入华夏，家住加利福尼亚。 📝&nbsp;如果真的收房产税，采用不公平法则的可能性最大。真收房产税了，苦恼的一个是房东，一个就是租户了，房东被收税，自然成本就要摊到租户身上了。 📝&nbsp;我们感受最深的就是涨工资的问题，一旦政府涨工资，那就一定是体制内涨工资，跟体制外完全没有关系。2024 年全国退休人员基本养老金提高 3% 喔，我还有 40 年才能退休呢。 📝&nbsp;降低百姓租房困难的唯一国际通行办法就是减税。不扣税哪来的退休金呢。 📝&nbsp;但凡出现公务员增加，必定是因为福利太好了。KK 大神没想到的是，现在大环境不好，考公人多了，大家更趋向于稳定了。 📝&nbsp;社会需要底层群体用巨大的付出和极少的收获为金字塔上层群体服务。这个很一针见血，虽然不想承认，但这就是事实，大部分人都是牛马的一生。","tags":["天涯神贴"],"categories":["读书笔记"]},{"title":"CANape 之快速上手","path":"/1037199537.html","content":"前言CANape 是一款用于 ECU 测量、标定、诊断以及 ADAS 传感器数据采集的工具型软件。搞车载总是离不开 CANape，这里也做个记录，方便自己后面遗忘了，导致用起来费时费事。 使用准备CANape 使用的前提条件是需要 License。只有连接设备与电脑，通过电脑识别查看 License，激活相关 license，这样 CANape 才能正常使用。 License 获取License 有几种，一种是硬件设备自带 License，一种是 Vector 会提供 Activation Key，通过 Vector License Client 就可以激活。这里不过多赘述（都要花钱的）。 驱动安装CANape 使用的前提是需要硬件设备 VN1630A 或 1640A 等。针对这些设备，需要安装相对应的驱动才能正常使用。 运行驱动安装包，选择已有硬件的驱动进行安装，如下所示： 如果没有安装驱动或者安装不正确，则硬件盒的状态灯亮红色，如下所示；安装成功，则硬件盒的状态灯亮绿色。 状态灯正常了，但是所使用的通道指示灯仍然为红色，如何变成绿色？ 跳到下面看『硬件通道配置』。 开始使用新建工程首先打开软件，点击 Devices -&gt; New Device，给工程命名，选择存放路径、A2L 和 elf 文件；然后点击 Devices -&gt; New from database -&gt; database，选择 A2l 文件，硬件设备和通道，关联 A2L 和 elf 文件。 测量配置点击 Start -&gt; Measurement configuration，配置所需观测或变量的信号，比如观测量的观测周期等信息； 然后在图形页面添加观测量和标定量，选择相应的显示形式，比如数值格式或图形格式等。 硬件通道配置使用到的通道指示灯亮红色，原因是 CANape 硬件未配置或配置不正确。硬件通道配置有三个关键点： 第一点在 Hardware Config 中，选择正确的软硬件通道映射关系，根据硬件设备的实际使用情况来设置，使用 Channel1 则按下图所示配置： 第二点在 Device configuration -&gt; Transport Layer 中： 首先是 CAN 总线参数设置，需要根据实际的 XCP 基于的通讯协议来设置，如果是 CAN 通讯，要确定是 CAN 还是 CAN FD，其波特率是多少。 然后是通讯的 ID，也需要根据实际情况来，注意这里的 Master是指上位机，相当于CANape 端，Slave 是指所连接的 ECU，因此从 ECU 角度来说，CAN ID Master 就是 ECU 的接收 ID，而 CAN ID Slave 就是 ECU 的发送 ID。 最后就是长度 DLC，Max DLC required 是否勾选，若需要勾选但不勾选，亲验会影响通道指示灯的状态。 第三点在最初新建 New Device 时，当在前面选定了基于 CAN 的 XCP 后，到下图所示的这一页要注意 CAN 类型的选择，默认是 CAN，但如果是 CAN FD，那么需要选择 New network； 然后选择正确的硬件通道，在 CAN Bus Parameter 处，点击 Change…； 选择 ISO CAN FD，设置正确的波特率和采样点即可。 总结以上三个点中，个人感受第三个点最容易被忽视，而这点配置不对就会导致无法建立正确的通讯，通道指示灯一直为红色。这点配置结果其实在 Device configuration 中 的 Device 是没有 CAN FD 的选项的。 此时若要正确配置，需要重新对上述的第三点进行配置。一方面在 Device configuration 中的 Device 有了 CAN FD 的选项，且可以更新波特率和采样点信息。另一方面硬件盒子的通道指示灯就从红转绿，通讯能够建立。 更具体地可以实际测试通讯是否建立。在 Device Configuration -&gt; Protocol 中点击 Test connection，一切硬件通道配置成功，则会显示 Communication established。","tags":["can","canape"],"categories":["自动驾驶"]},{"title":"Hexo Stellar 主题装修笔记","path":"/4199909915.html","content":"Stellar 主题全面的配置文档可参考源码作者：Xaoxuu 一键配置Stellar 配置文件在 themes\\stellar_config.yml 下面，一般不要直接修改，我们可以在博客根目录下建一个 _config.stellar.yml，在这个文件中的配置信息优先级高于主题文件夹中的配置文件。 然后直接把 themes\\stellar_config.yml 里面的复制粘贴进来，再对 _config.stellar.yml 修改即可。 字体设置效果展示开始部署 _config.yml 文件中，最后一行加入以下指令：123inject: head: - &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/lxgwwenkaiscreen.css&quot;&gt; 在 _config.stellar.yml 中找到 style.font-family，修改以下内容：1234style: font-family: logo: &#x27;&quot;LXGW WenKai Screen&quot;, system-ui, ...&#x27; body: &#x27;&quot;LXGW WenKai Screen&quot;, system-ui, ...&#x27; 添加运行时间&#x2F;访问量效果展示开始部署_config.stellar.yml 文件下，找到 footer，在 content: 之后添加以下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556content: | # 支持 Markdown 格式 &lt;center&gt; &lt;span&gt; © 2024 &lt;a style=&quot;font-weight: bold; auto;&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/FelicxFoster&quot;&gt;Felicx&lt;/a&gt; 使用 &lt;a style=&quot;font-weight: bold; auto;&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/FelicxFoster/hexo-theme-stellar&quot;&gt;Stellar&lt;/a&gt; 创建 &lt;/span&gt; &lt;br&gt; &lt;!--不蒜子计数器--&gt; &lt;script async=&quot;&quot; src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &lt;!--添加一个访问量--&gt; &lt;span&gt;总访问 &lt;span id=&quot;busuanzi_value_site_pv&quot; style=&quot;font-weight: bold;&quot;&gt;113701&lt;/span&gt; 次 | 本页访问 &lt;span id=&quot;busuanzi_value_page_pv&quot; style=&quot;font-weight: bold;&quot;&gt;326&lt;/span&gt; 次&lt;/span&gt; &lt;/br&gt; &lt;span id=&quot;runtime_span&quot;&gt;&lt;/span&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() &#123; var runtime_span = document.getElementById(&#x27;runtime_span&#x27;); function show_runtime() &#123; // 调用定时器 setTimeout(show_runtime, 1000); var seconds = 1000; var minutes = seconds * 60; var hours = minutes * 60; var days = hours * 24; var years = days * 365; var today = new Date(); var todayYear = today.getFullYear(); var todayMonth = today.getMonth(); var todayDate = today.getDate(); var todayHour = today.getHours(); var todayMinute = today.getMinutes(); var todaySecond = today.getSeconds(); var t1 = Date.UTC(2018, 9, 12, 0, 0, 0); // UTC时间，月份从0开始 var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond); var diff = t2 - t1; var diffYears = Math.floor(diff / years); var diffDays = Math.floor((diff / days) - diffYears * 365); var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours); var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes); var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds); // 更新显示时间的span元素内容 runtime_span.innerHTML = &quot;🦉营业：&quot; + diffYears + &quot; 年 &quot; + diffDays + &quot; 天 &quot; + diffHours + &quot; 小时 &quot; + diffMinutes + &quot; 分钟 &quot; + diffSeconds + &quot; 秒🦉&quot;; &#125; show_runtime(); // 初次调用函数以启动定时器 &#125;); &lt;/script&gt; &lt;/center&gt; 添加评论功能效果展示开始部署目前 Staller 主题集成多种评论功能插件，包括 beaudar、utterances、giscus、twikoo、waline、artalk。今日来探讨 waline。 配置 waline，参考我的另一篇文章：Hexo 博客美化 在博客配置文件 _config.stellar.yml 中启用 waline 评论1234567891011121314151617######## Comments ########comments: service: waline # beaudar, utterances, giscus, twikoo, waline, artalk comment_title: 快来参与讨论吧~ # Waline # https://waline.js.org/ waline: js: https://gcore.jsdelivr.net/npm/@waline/client@3.1.3/dist/waline.js css: https://gcore.jsdelivr.net/npm/@waline/client@3.1.3/dist/waline.css meta_css: https://gcore.jsdelivr.net/npm/@waline/client@3.1.3/dist/waline-meta.css # Waline server address url, you should set this to your own link serverURL: https://waline.js.org/ # 这里改成自己的链接 locale: placeholder: 😎嗨，朋友，留下脚印再走呗。 reaction: true 使用 fontawesome 动态图标效果展示开始部署因为 Stellar 不再内置 fontawesome 图标库，所以我们需要手动添加。_config.yml 文件中，最后一行加入以下指令： 123inject: head: - &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css&quot;&gt; 就可以愉快的使用 fontawesome 动态图标了。比如配置 footer 栏的图标，_config.stellar.yml 文件下，找到 footer 12345footer: social: github: icon: &#x27;&lt;i class=&quot;fa-solid fa-github fa-brands fa-bounce&quot;&gt;&lt;/i&gt;&#x27; title: &#x27;Github&#x27; 给超长代码块增加滚动条效果展示开始部署首先判断代码块是否过长，如果是，则设置最大高度并开启滚动。在 themes\\stellar\\source\\js\\ 中新建 custom.js 1234567891011121314151617181920// 给超长代码块增加滚动条function adjustCodeBlockHeight() &#123; document.addEventListener(&quot;DOMContentLoaded&quot;, function () &#123; // 选择所有的.md-text元素 var codeBlocks = document.querySelectorAll(&#x27;.md-text&#x27;); // 遍历每个.md-text元素 codeBlocks.forEach(function (block) &#123; // 检查是否包含.highlight类的子元素，且父元素高度超过500px var highlightBlocks = block.querySelectorAll(&#x27;.highlight&#x27;); highlightBlocks.forEach(function (highlightBlock) &#123; if (highlightBlock.clientHeight &gt; 800) &#123; highlightBlock.style.maxHeight = &#x27;300px&#x27;; highlightBlock.style.overflow = &#x27;auto&#x27;; &#125; &#125;); &#125;); &#125;);&#125;adjustCodeBlockHeight() 在 _config.yml 文件中，最后一行加入以下指令： 12345inject: script: # 自定义js - &lt;script type=&quot;text/javascript&quot; src=&quot;/js/custom.js?1&quot;&gt;&lt;/script&gt; - &lt;script src=&quot;/js/custom.js?1&quot;&gt;&lt;/script&gt; 需要注意的是，Stellar 主题有 tabs 分栏容器，如果在容器中写入长代码，这段 js 是不生效的。因为这时候生成的 HTML 结构可能与原始代码块不同，导致 JavaScript 选择器无法正确找到目标元素。解决方法也很简单，可以直接在 Markdown 文件中使用内联样式来设置代码块的最大高度和滚动条。 1234567&lt;div style=&quot;max-height: 300px; max-width: 100%; overflow: auto;&quot;&gt; ```javascript // 这里是你的代码 function example() &#123; console.log(&quot;Hello, world!&quot;); &#125;&lt;/div&gt; 文章面包屑显示字数|阅读时长|标签效果展示开始部署 在 themes\\stellar\\layout_partial\\main\\article_banner.ejs 中的 // 3.left.bottom 处，新增代码：12345678910111213141516// 3.left.bottomel += partial(&#x27;dateinfo&#x27;)//新增：字数显示|阅读时长显示el += &#x27;&lt;div class=&quot;flex-row&quot; id=&quot;page-words&quot;&gt;&lt;span style=&quot;padding: 4px;&quot;&gt;本文：&#x27; + wordcount(page.content) + &#x27;字&lt;/span&gt;&lt;span class=&quot;sep updated&quot; style=&quot;padding: 4px;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;text updated&quot; style=&quot;padding: 4px;&quot;&gt;阅读时长：&#x27; + min2read(page.content) + &#x27;分&lt;/span&gt;&lt;/div&gt;&#x27;;//新增：标签显示if (page.layout == &quot;post&quot; &amp;&amp; page.tags &amp;&amp; page.tags.length &gt; 0) &#123; el += &#x27;&lt;div class=&quot;flex-row&quot; id=&quot;tag&quot;&gt;&#x27;; // 将标签容器的创建移动到条件内部 el += &#x27; &lt;span&gt;&amp;nbsp标签：&lt;/span&gt;&#x27;; el += list_categories(page.tags, &#123; class: &quot;cap breadcrumb&quot;, show_count: false, separator: &#x27;&amp;nbsp; &#x27;, style: &quot;none&quot; &#125;); el += &#x27;&amp;nbsp&lt;/div&gt;&#x27;;&#125; 在 themes\\stellar\\source\\css_custom.styl 文件最后添加：12345678910/* 文章内字数统计&amp;阅读时长 */.bread-nav div#page-words span.sep:before &#123; content: &#x27;|&#x27;;&#125;.bread-nav div#page-words span.updated &#123; visibility: hidden;&#125;.bread-nav:hover div#page-words span.updated &#123; visibility: visible;&#125; 页面底部字数统计效果展示开始部署 安装 hexo-wordcount 插件：npm i hexo-wordcount –save themes&#x2F;stellar&#x2F;layout&#x2F;_partial&#x2F;main&#x2F;footer.ejs 文件中，找到 //footer1234567// footerel += &#x27;&lt;div class=&quot;text&quot;&gt;&#x27;if (content) &#123; el += markdown(content)&#125;el += &#x27;&lt;/div&gt;&lt;/footer&gt;&#x27;return el 在 el += &#39;&lt;/div&gt;&lt;/footer&gt;&#39; 前面加上：1el += &#x27;&lt;span class=&quot;totalcount&quot;&gt;共发表 &#x27; + site.posts.length + &#x27; 篇Blog · &lt;/span&gt;&lt;span class=&quot;post-count&quot;&gt;总计 &#x27; + totalcount(site) + &#x27; 字&lt;/span&gt;&#x27; 在 themes\\stellar\\source\\css_custom.styl 文件最后添加：12345678910111213/* 页面底部字数统计 */.post-count &#123; scrollbar-width: none; color: var(--text-p2); &#125;.totalcount &#123; color: var(--text-p2); &#125;.page-footer &#123; text-align: center; margin: 0 auto; width: 100%;&#125; 侧边栏欢迎语效果展示开始部署 在 themes\\stellar_data\\widgets.yml 文件中新增一项侧边栏配置，写下你的网站欢迎语。也可以引用开放接口，如【今日诗词】。123456789# 欢迎语welcome: layout: markdown title: 🎉欢迎 content: | 本站托管于Vercel, 加载缓慢请耐心等待，欢迎大家畅所欲言。 &lt;hr style=&quot;border: 1px solid black; background-color: black;&quot;&gt; &lt;span id=&quot;jinrishici-sentence&quot;&gt;&lt;/span&gt; &lt;script src=&quot;https://sdk.jinrishici.com/v2/browser/jinrishici.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; 修改主题配置 _config.stellar.yml，设置欢迎语出现的具体位置1234567# 站点主结构树site_tree: # -- 列表类页面 -- # # 主页配置 home: leftbar: recent rightbar: welcome 新增 memos 说说功能效果展示开始部署想要实现 memos 功能，首先需要注册一个账号。注册账号可以使用别人已经搭建好的 memos，也可以自行搭建 memos（需要有服务器，我就不折腾了）。这里直接采用的杜老师的 memos。 查看教程，注册一个自己的账号 注册好后，在教程下面评论让杜老师帮忙查看自己的 ID 在博客 source 文件夹下，新建 bb 文件夹，在文件夹里新建 index.md12&#123;% timeline api:https://s.dusays.com/api/v1/memo?creatorId=&#123;你的ID&#125;&amp;limit=10 type:memos avatar:/assets/icon/20240713_rtEVzmVj.webp %&#125;&#123;% endtimeline %&#125; 可以建个图标跳转哔哔页面，找到 _config.stellar.yml 中的 footer，新增一条记录123456footer: social: bb: icon: &#x27;&lt;i class=&quot;fa-solid fa-globe-asia fa-bounce&quot;&gt;&lt;/i&gt;&#x27; title: &#x27;哔哔广场&#x27; url: /bb 如果需要在博客侧边栏 sidebar 中展示 memos，首先在 themes\\stellar_data\\widgets.yml 中新增一条记录1234567# 哔哔memos-du: layout: timeline title: 🥂哔哔广场 api: https://s.dusays.com/api/v1/memo?creatorId=&#123;你的ID&#125; type: memos hide: user,footer 然后在 _config.stellar.yml 设置让其生效123456site_tree: # -- 列表类页面 -- # # 主页配置 home: leftbar: recent rightbar: memos-du 展示最新评论效果展示开始部署我评论使用的是 waline，所以下面是搭配 waline 食用的，如果有其他评论插件的，参考星日语大佬的文章。 在 themes\\stellar\\source\\js\\services\\ 目录下新建 waline_new_comment.js1234567891011121314151617181920212223242526272829303132$(document).ready(function() &#123; const default_avatar = &#x27;default_avatar.jpg&#x27;; // 替换成你的默认头像地址 const els = document.getElementsByClassName(&#x27;ds-waline&#x27;); for (var i = 0; i &lt; els.length; i++) &#123; const el = els[i]; const limit = parseInt(el.getAttribute(&#x27;limit&#x27;)) || 10; const apiBase = el.getAttribute(&#x27;api&#x27;); if (apiBase == null) &#123; continue; &#125; const api = apiBase + &#x27;/comment?type=recent&amp;count=&#x27; + limit; utils.request(el, api, function (data) &#123; data.forEach((item, index) =&gt; &#123; var cell = &#x27;&lt;div class=&quot;timenode&quot; index=&quot;&#x27; + index + &#x27;&quot;&gt;&#x27;; cell += &#x27;&lt;div class=&quot;header&quot;&gt;&#x27;; cell += &#x27;&lt;div class=&quot;user-info&quot;&gt;&#x27;; cell += &#x27;&lt;img src=&quot;&#x27; + (item.avatar || default_avatar) + &#x27;&quot; onerror=&quot;this.onerror=null;this.src=\\&#x27;&#x27; + default_avatar + &#x27;\\&#x27;;&quot;&gt;&#x27;; cell += &#x27;&lt;span&gt;&#x27; + item.nick + &#x27;&lt;/span&gt;&#x27;; cell += &#x27;&lt;/div&gt;&#x27;; cell += &#x27;&lt;span&gt;&#x27; + new Date(item.time).toLocaleString() + &#x27;&lt;/span&gt;&#x27;; cell += &#x27;&lt;/div&gt;&#x27;; cell += &#x27;&lt;a class=&quot;body&quot; href=&quot;&#x27; + item.url + &#x27;#&#x27; + item.objectId + &#x27;&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;&#x27;; cell += item.comment.replace(/&lt;a\\b[^&gt;]*&gt;(.*?)&lt;\\/a&gt;/g, &#x27;$1&#x27;); cell += &#x27;&lt;/a&gt;&#x27;; cell += &#x27;&lt;/div&gt;&#x27;; $(el).append(cell); &#125;); &#125;); &#125;&#125;); 在 _config.stellar.yml 中找到 data_services，新增一行记录1234# 内置服务，按需加载（页面内用到了就会加载，没有用到就不会加载）data_services: waline: js: /js/services/waline_new_comment.js 在 themes\\stellar_data\\widgets.yml 中创建小组件1234567# 最新评论new_comment: layout: timeline title: 最新评论 api: https://example.yourdomain.com # 此处为 Waline server，末尾不要加 / type: waline limit: 16 # 限制获取数量，默认为 10 编辑 _config.stellar.yml，让最新评论展示在右侧123456# 站点主结构树site_tree: # -- 列表类页面 -- # # 主页配置 home: rightbar: new-comment 部署友链效果展示开始部署Stellar 支持两种友链，一种是静态友链，一种是动态友链。实现静态友链很简单，新建 source_data\\links\\ios_developer.yml，将友链数据写进去即可 12345- title: 某某某 url: https:// cover: icon: description: 在 source\\friends\\index.md 中写入 1&#123;% friends ios_developer %&#125; 动态友链比较麻烦一点，参考苏末了大佬的教程。 Fork xaoxuu&#x2F;issues-json-generator 仓库，名称设为 friends，任务栏点击 settings 下滑到 issue 点击勾选 √ ，此时任务栏出现 Issue，点击任务栏 Aciton，点击 i understand； 点击任务栏 settings，左侧选择 Action 下的 General，下滑到 Workflow Permissions，勾选读写权限 Read and write permissions，然后 save 保存； 点击任务栏 Issue，点击 Label，删除现有标签，新增并保留以下四个标签：active、suspend、404、checklist； 点击任务栏 Code 点击进入 config.yml 文件，点击修改仓库名和地址；12345# 要抓取的 issues 配置issues: repo: xaoxuu/friends # 仓库持有者/仓库名（改成自己的） label: active # 筛选具有 active 标签的 issue ，取消此项则会提取所有 open 状态的 issue sort: # updated-desc # 排序，按最近更新，取消此项则按创建时间排序 点击 issue → New issue → Get Started，填入你的基本信息，label 设置为 active → submit new issue 提交； 添加后，等待一会，点击任务栏 Code 进入 output 分支，查看 v2 目录下的 data.json 文件，出现刚才新建的 issue 内容则设置成功； 要想使用，需要在 source\\friends\\index.md 中写入12&#123;% friends api:https://api.vlts.cc/output_data/v2/你的github用户名/你的github仓库名 %&#125;# 示例:&#123;% friends api:https://raw.githubusercontent.com/FelicxFoster/friends/output/v2/data.json %&#125; 友链朋友圈效果展示开始部署友链朋友圈就是展示友链朋友发布的文章，参考xaoxuu大佬的教程。 Fork xaoxuu&#x2F;friends-rss-generator 仓库，大佬的教程说是可以 Fork 原作者 Rock-Candy-Tea&#x2F;hexo-circle-of-friends 的仓库，但是我用原作者的一直部署不了； 设置自己的友链页面地址和主题类型，修改 hexo_circle_of_friends&#x2F;fc_settings.yaml 文件1- &#123;link: &quot;https://blog.felicx.eu.org/friends/&quot;, theme: &quot;stellar&quot;&#125; # 友链页地址1，修改为你的友链页地址 打开 Issues 友链抓取功能，修改 hexo_circle_of_friends&#x2F;fc_settings.yaml12345678GITHUB_FRIENDS_LINKS: &#123; enable: true, # true 开启github issue兼容 type: &quot;volantis&quot;, # volantis/stellar用户请在这里填写volantis owner: &quot;FelicxFoster&quot;, # 填写你的github用户名 repo: &quot;friends&quot;, # 填写你的github仓库名 state: &quot;open&quot;, # 填写抓取的issue状态(open/closed) label: &quot;active&quot;,&#125; 点击 Actions -&gt; I understand my workflows, go ahead and enable them -&gt; update-friends-posts -&gt; Enable workflow -&gt; 点击 Run workflow -&gt; Run workflow 进行第一次运行； 运行时可能会遇到报错 ERROR: No matching distribution found for uvicorn==0.14.0，就是安装依赖项的问题，issue 里也有人提问过，修改下 .github&#x2F;workflows&#x2F;main.yml12345- name: Install requirements working-directory: ./hexo_circle_of_friends run: | pip install --upgrade &#x27;pip&lt;24.1&#x27; pip install -r requirements.txt 等待运行完毕后，仓库会新建 output 分支，同时在分支下面生成 data.json； 在 source\\friends\\rss\\index.md 写入下面代码，其中 api 部分替换为自己仓库地址及其对应的 data.json 文件真实路径；12345678910---title: FriendCirclerobots: noindex,nofollowmenu_id: postcomments: falsenav_tabs: true # 这就意味着页面会显示首页文章导航栏---&#123;% timeline type:fcircle api:https://raw.githubusercontent.com/FelicxFoster/friends-rss-generator/output/data.json %&#125;&#123;% endtimeline %&#125; 在 _config.stellar.yml 中修改，即可实现在首页增加一个「FriendCircle」栏目的效果123456 站点主结构树site_tree: # 博客列表页配置 index_blog: nav_tabs: # 近期发布 分类 标签 专栏 归档 and ... &#x27;FriendCircle&#x27;: /friends/rss/ jsDelivr 加速 GitHub 文件访问上面部署友链和朋友圈文章，使用的都是github仓库的json文件，国内环境大家都懂，指定是无法访问，这里介绍一种蠢方法，使用 jsDelivr 来加速这些 Github 文件的访问。 在要加速的 Github 仓库里，点击 Releases -&gt; Create a new release -&gt; Choose a tag -&gt; 随便起个名比如 0.01 -&gt; 点击 Publish release； 在使用时 tag 标签直接写 latest 就行； 使用如下规则访问 CDN 资源；12https://cdn.jsdelivr.net/gh/&lt;username&gt;/&lt;repo name&gt;@&lt;tag&gt;/&lt;resource name&gt;# 比如 https://cdn.jsdelivr.net/gh/FelicxFoster/friends@latest/v2/data.json 然后替换掉上面的 api，现在就可以在国内愉快地访问友链和朋友圈了； 这种方法需要每次手动在 Github 上创建最新的 Releases（还没摸索出怎么使用 Github Action 自动生成）； 需要注意的是，jsDelivr 是有缓存的，更新一般要 24h，所以最好一周再新建一次 Releases； 另外，如果发现页面没有生效，大部分是自己的浏览器缓存没清除导致的； 当然还有第二种方法，使用这个工具，实现 Github 链接转 Jsdelivr，直接插入转化后的链接，也能轻松实现国内访问。 添加 Google&#x2F;Bing 收录 安装 hexo-generator-sitemap 插件来为网站生成网站地图（Sitemap）1npm install hexo-generator-sitemap --save 打开博客的配置文件 _config.yml，添加如下12345# Sitemap Generatorsitemap: path: sitemap.xml tags: false categories: false 打开 Google Search Console, 点击立即使用并登录谷歌账号； 选择网址前缀并输入站点网址，如 https://blog.felicx.eu.org ，点击继续； 验证方法选择 HTML 标记，然后复制 Google 提供的元标记1&lt;meta name=&quot;google-site-verification&quot; content=&quot;xxxxx&quot; /&gt; 因为 Stellar 主题没有像 Next 主题一样，配置文件中没有 google_site_verification 设置项，所以直接修改 themes\\stellar\\layout_partial\\head.ejs，找到 字段，在下面添加上面复制的元标记1&lt;meta name=&quot;google-site-verification&quot; content=&quot;xxxxx&quot; /&gt; 将修改后的代码重新部署完毕后，点击 Google 中的验证即可； 同样 Bing 收录也是类似的，登录 Bing Webmaster Tools，登录添加站点，选择 HTML 标记，重复上述操作即可； 添加捐赠图标效果展示开始部署身为博主，没有大家的激励怎么会有动力更新下去，所以一个 Buy Me A Coffee 图标是很有必要的。参考 Stellar 主题，在每篇文章下面都会有 License 和 Share，那我们可以直接在原来代码的基础上添加一个 Donate。 在 themes\\stellar\\layout_partial\\main\\article\\article_footer.ejs 中添加 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849if (theme.article.donate) &#123; const donateImage = () =&gt; &#123; if (theme.article.donate.wechat) &#123; return ` &lt;div class=&quot;donate-image&quot; id=&quot;donate-wechat&quot; style=&quot;display:none; position:absolute; z-index:1000; transform: translateY(-100%); left: 50%; transform: translateX(-50%) translateY(-100%);&quot;&gt; &lt;img src=&quot;$&#123;theme.article.donate.wechat&#125;&quot; alt=&quot;Donate with WeChat&quot; style=&quot;width: 150px; height: auto;&quot; /&gt; &lt;/div&gt; `; &#125; else &#123; return &#x27;&#x27;; &#125; &#125;; el += ` &lt;section id=&quot;donate&quot;&gt; &lt;div class=&quot;header&quot;&gt;&lt;span&gt;$&#123;__(&#x27;meta.donate&#x27;)&#125;&lt;/span&gt;&lt;/div&gt; &lt;div class=&quot;body&quot;&gt; &lt;p&gt;$&#123;__(&#x27;请作者喝杯咖啡吧&#x27;)&#125; &lt;span class=&quot;donate-icon&quot; onclick=&quot;showQRCode()&quot; style=&quot;display: inline-block;&quot;&gt; &lt;i class=&quot;fa-solid fa-gift fa-flip&quot; style=&quot;font-size: 20px;&quot;&gt;&lt;/i&gt; &lt;/span&gt; &lt;/p&gt; $&#123;donateImage()&#125; &lt;/div&gt; &lt;/section&gt; `; el += ` &lt;script&gt; const showQRCode = () =&gt; &#123; const qrCode = document.getElementById(&#x27;donate-wechat&#x27;); qrCode.style.display = &#x27;block&#x27;; document.addEventListener(&#x27;click&#x27;, hideQRCode); &#125;; const hideQRCode = (event) =&gt; &#123; const qrCode = document.getElementById(&#x27;donate-wechat&#x27;); const donateIcon = document.querySelector(&#x27;.donate-icon&#x27;); if (!qrCode.contains(event.target) &amp;&amp; !donateIcon.contains(event.target)) &#123; qrCode.style.display = &#x27;none&#x27;; document.removeEventListener(&#x27;click&#x27;, hideQRCode); &#125; &#125;; &lt;/script&gt; `;&#125; 在 _config.stellar.yml 添加1234######## Article ########article: donate: wechat: &#x27;二维码图片&#x27; 这样当你点击捐赠图标时，二维码会显示出来，再次点击页面的其他地方就会隐藏二维码","tags":["hexo"],"categories":["折腾系列"]},{"title":"Github Action 自动化部署 Hexo 博客","path":"/165643616.html","content":"前言每次部署 Hexo 都需要运行 hexo clean &amp; hexo g &amp; hexo d 指令三件套完成推送到远程仓库，随着文章越来越多，编译的时间也会越来越长。 Github Actions 可以很方便实现 CI&#x2F;CD 工作流，类似 Travis 的用法，来帮我们完成一些工作，比如实现自动化测试、打包、部署等操作。当我们运行 Jobs 时，它会创建一个容器 (runner)，容器支持：Ubuntu、Windows 和 MacOS 等系统，在容器中我们可以安装软件，利用安装的软件帮我们处理一些数据，然后把处理好的数据推送到某个地方。 通过 Github Actions，我们只需要在每次完成博客的编写或修改以后，将改动直接 push 到远程仓库，之后的编译部署的工作统统交给 CI 来完成即可。 创建仓库为什么还要创建新的仓库呢，我们之前根据 Hexo 博客搭建部署的 Hexo 博客，your.github.io 这个仓库是用来存放静态博客页面，只有前端页面的文件，所以我们需要创建一个私有仓库存放 Hexo 项目源码，下面用HexoBlog称呼。 上传仓库代码创建完私有仓库后，在本地博客文件中复制几个文件到另外一个文件夹，其中包括.github，scaffolds，source，themes，.gitignore，_config.yml，package.json，package-lock.json还有一个很重要的一步：在.gitignore中添加themes/keep/.git，不然没法提交代码。 123456git initgit add .git commit -m &quot;first commit&quot;git remote add origin git@github.com:用户名/自动化仓库名.gitgit push -u origin master 生成部署密钥任意目录下，ssh-keygen -f github-deploy-key，然后一路按回车直到生成成功。当前目录下会有github-deploy-key和github-deploy-key.pub两个文件。 复制github-deploy-key文件内容，在 Github 的HexoBlog仓库点击Settings -&gt; Secrets and variables -&gt; Actions -&gt; New repository secret页面上添加。 在Name输入框填写HEXO_DEPLOY_PRI； 在Value输入框填写github-deploy-key文件内容； 复制github-deploy-key.pub文件内容，在 Github 的your.github.io仓库点击Settings -&gt; Deploy keys -&gt; Add deploy key页面上添加。 在Title输入框填写HEXO_DEPLOY_PUB； 在Key输入框填写github-deploy-key.pub文件内容； 勾选Allow write access选项； 编写 Github Actions在本地HexoBlog根目录下创建.github/workflows/deploy.yml文件，目录结构如下。 1234blog (repository)└── .github └── workflows └── deploy.yml 在deploy.yml文件中粘贴以下内容。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566name: CI # 自动部署on: push: branches: - masterenv: GIT_USER: xxx GIT_EMAIL: xxx THEME_REPO: XPoet/hexo-theme-keep # Hexo所使用的主题的仓库 THEME_BRANCH: master DEPLOY_REPO: FelicxFoster/FelicxFoster.github.io # Hexo编译后要部署的仓库 DEPLOY_BRANCH: masterjobs: build: name: Build on node $&#123;&#123; matrix.node_version &#125;&#125; and $&#123;&#123; matrix.os &#125;&#125; runs-on: ubuntu-latest strategy: matrix: os: [ubuntu-latest] node_version: [16.x] steps: - name: Checkout uses: actions/checkout@v4 - name: Checkout theme repo uses: actions/checkout@v4 with: repository: $&#123;&#123; env.THEME_REPO &#125;&#125; ref: $&#123;&#123; env.THEME_BRANCH &#125;&#125; path: themes/keep # 主题路径 - name: Checkout deploy repo uses: actions/checkout@v4 with: repository: $&#123;&#123; env.DEPLOY_REPO &#125;&#125; ref: $&#123;&#123; env.DEPLOY_BRANCH &#125;&#125; path: .deploy_git - name: Use Node.js $&#123;&#123; matrix.node_version &#125;&#125; uses: actions/setup-node@v4 with: node-version: $&#123;&#123; matrix.node_version &#125;&#125; - name: Configuration environment env: HEXO_DEPLOY_PRI: $&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125; run: | sudo timedatectl set-timezone &quot;Asia/Shanghai&quot; mkdir -p ~/.ssh/ echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts git config --global user.name $GIT_USER git config --global user.email $GIT_EMAIL - name: Install dependencies run: | npm install - name: Deploy hexo run: | npm run deploy 查看部署123git add .git commit -m &quot;&quot;git push 重新提交后，即可在 Github 的HexoBlog仓库查看Actions部署结果。","tags":["hexo"],"categories":["折腾系列"]},{"title":"2024年一波三折的Q2","path":"/1057849259.html","content":"距离上一次写博客已经过去了4个月。不是我不想写，实在是有心无力。Q2这段时间经历了太多事情，整个人都不在状态，这里也做个总结，顺便聊一下一些人生感悟。 3月份主要是在准备面试和面试的过程中，最近行情不太好，投了几家都没面邀，后面就只面了一家，搞自动驾驶的，一共三面，面试过程倒挺轻松的，问的问题也比较符合我现在做的，就是到了谈薪阶段，给不了想要的薪资，最后也是不了了之。 4月份一直在忙工作上的活，也没时间搞博客。 5月劳动节放假期间去配了副眼镜，结果度数配高了，戴了几天眼睛都很不舒服，赶紧请了半天假去医院检查了下眼睛，确认眼睛有点发炎，然后度数确实是过高了，只好戴回旧眼镜，想着后面有时间再去重新配一副。然而，痛苦的事情来了。检查完眼睛的下午去参加了公司的团建，席中喝了些白酒，回来后右后槽牙开始隐隐作痛，本身这颗牙之前做过根管治疗。到了半夜，疼的受不了了，抓紧吃了颗布洛芬，模模糊糊睡了过去。到了早上，去牙科诊所看了下，先给我开了点止疼药，说是后面可能需要拔掉。吃了几天的止疼药后，牙齿没有自发疼了，但是有咬合疼。约了个中山大学附属口腔，想着主任能不能有办法只做根管，不用拔牙。但是事与愿违，医生建议还是拔掉，因为做了根管可能保不了半年又会复发，没必要浪费钱。整个人有点恍惚，又约了穗华口腔，想着能不能拯救一下。到了医院，拍了片医生还是建议拔掉，粗略跟医生算了下二次根管的费用和后续种植牙的费用，毅然选择了拔牙。整个过程很快，拔牙后的一周都在喝粥修养。 到了6月，最痛苦的来了。1号晚上饭还没吃完，突然肚子上腹部疼，到了晚上12点，痛感很明显，自发性绞痛，赶紧吃了粒洛索洛芬钠片，还是没法好受，而且开始怕寒，期间肚子很胀，又拉又吐。到了凌晨3点，痛感更加明显了，钻心痛，汗水直流，实在顶不住了，开始裹着外套出门，本想着去附近医院挂个急诊，结果没开门，赶紧打车去南方医科大学附属医院挂急诊。到了那里，整个人都不好受了，医生也看不出啥，诊断是急性肠胃炎，然后打针挂水，挂到了早上，肚子还是很疼，但是医生看不出来，只好先回来了。到了下午，右下腹开始按压疼，走路都很疼，顶不住了，去附近医院，又是B超又是拍CT，确诊为急性阑尾炎，心里想着先保守治疗吧，所以开始吊针，晚上回来后还是没有效果，晚上还被疼醒了。第二天起来后，肚脐周围都开始按压疼，早上忍着痛去公司上班，实在顶不住了，又去医院挂了一次水，完全没有效果，立马挂了中山大学附属第三医院的胃肠外科，到了医院后，给医生看了确诊急性阑尾炎，立马给我挂了个急诊，让我办理住院。早上六点开始做手术，麻醉很快，九点钟我醒来的时候已经做完手术了，然后整个人迷迷糊糊的被推回了病床，就是一整天都在挂水，下午我就开始下床走动，肚子被开了三个孔，有时候伤口有点疼，还带了个引流管，走路很麻烦。一共住了4天半院，最后一天早上拔了引流管后，下午就出院了。回来后整个人还是很虚，只能喝粥。 到了今天好了一点，趁还有精力写了下博客，记录下Q2这一波三折的人生经历。从眼睛到牙齿再到阑尾，Q2真是够精彩的。经历了这么多事情，也有了一些自己的感悟。 ✅ 身体是自己的，只有搞好身体，才有赚钱的本钱。✅ 好的心态很重要，心态好对病情恢复很有帮助。✅ 身边有人陪还是挺重要的，一个人孤身看病住院其实挺难熬的。✅ 医保是个好东西，能省很多钱，还有保险也要买。","tags":["年度总结"],"categories":["随笔"]},{"title":"CAN 之 DBC 文件解析（详细版）","path":"/4096777957.html","content":"前言之前写了一篇简单版的 DBC 文件解析，下面详细介绍下 DBC 文件里的各个字段。 总体概览DBC文件是以 Tag（标签）来标识每一个元素。 如上图所示，一般 dbc 文件中包含了如下的 8 种信息： 版本与新符号 波特率定义 网络节点的定义 报文帧的定义 信号的定义 注解部分 特征部分 数值表部分 详细解释版本的定义VERSION 信息可为空，也可以由用户自定义；NS_ 表示 New Symbol，在外面创建 dbc 文件时已经自动生成，所以无需过多留意，默认即可； 波特率的定义格式为 BS_: [baudrate:BTR1,BTR2] 其中 BS_ 为关键字，用于定义 CAN 网络的波特率；[] 内容表示为可选部分，可以省略；但关键字 BS_: 必须存在，省略则会出错。《DBC File Format Document》规范中明确提醒，必须保留 BS_: 标签。 网络节点的定义格式为 BU_: Nodename1 Nodename2 Nodename3 …… BU_ 为关键字，表示网络节点；Nodename1、Nodename2 为网络节点名字，由用户自己定义。注意需要保证节点命名的唯一性。 报文帧的定义格式为 BO_ MessageId MessageName: MessageSize Transmitter BO_ 为关键字，表示报文； MessageId 为报文 ID，是以 10 进制数表示的； MessageName 为报文的名字，命名规则和 C 语言变量相同； MessageSize 为报文数据域字节数，即数据长度，为无符号整型数据，CAN 2.0 为最大 8 字节，CAN FD 最大 64 字节； Transmitter 为该报文的网络节点；如果该报文没有指定发送节点，则该值需设置为 “Vector__XXX”。 用 BO_ 996 HUD_1_B: 8 HUD 来举例，这个报文是由 HUD 这个节点发出的，数据域长度为 8 字节，ID 为 996（0x3E4），名字命名为 HUD_1_B。 信号的定义格式为 SG_ SignalName (SigTypeDefinition) : StartBit|SignalSize@ByteOrder ValueType (Factor,Offset) [Min|Max] Unit Receiver SG_ 为关键字，表示信号； SignalName 为该信号的名字； SigTypeDefinition 是多路选择信号的定义，可选项，有 3 种格式； 空，表示普通信号； M，表示多路选择器信号； m50，表示被多路选择器选择的信号，50 表示当 M 定义的信号的值等于 50 的时候，该报文使用此通路； StartBit|SignalSize 表示该信号起始位、信号长度； ByteOrder 表示信号的字节顺序：0 代表 Motorola 格式，1 代表 Inter 格式； ValueType 表示该信号的数值类型：+ 表示无符号数，- 表示有符号数； Factor,Offset 分别表示因子和偏移量，这两个值用于信号的原始值与物理值之间的转换； 物理值 &#x3D; 原始值 * 因子 + 偏移量； Min|Max 表示该信号的最小值和最大值，即指定了该信号值的范围；这两个值为 double 类型； Unit 表示该信号的物理单位，为字符串类型； Receiver 表示该信号的接收节点，若该信号没有指定的接收节点，则必须设置为 “Vector__XXX”。 如示下面的例中：第一个信号 SG_ S_Check : 45|10@0+ (0.00625,0) [0|160] &quot;M&quot; EL3160_60,ESC表示定义了一个命名为 S_Check 的普通信号，其起始位是第 45 位，信号长度 10 bit；信号是 Motorola 格式，数值类型为无符号类型数；因子为 0.00625，偏移量为 0；信号取值范围为 0 到 160；信号物理单位为字符串 “M”，该信号接收节点为 EL3160_60 和 ESC 这两个节点。 第二个信号 SG_ Send_Mux M : 7|8@0+ (1,0) [0|0] &quot;&quot; EL3160_60,ESC表示定义了一个命名为 Send_Mux 的多路选择器信号，其起始位是第 7 位，信号长度 8 bit；信号是 Motorola 格式，数值类型为无符号类型数；因子为1，偏移量为 0；信号取值范围为 0 到 0；信号物理单位为字符串 “”；该信号接收节点为 EL3160_60 和 ESC 这两个节点。该信号做选择通道使用。 第三个信号 SG_ S_Level_A_Voltage m50 : 15|16@0+ (0.00625,0) [0|160] &quot;V&quot; EL3160_60,ESC表示定义了一个命名为 S_Level_A_Voltage 的被选择信号，其起始位是第 15 位，信号长度 16 bit；信号是 Motorola 格式，数值类型为无符号类型数；因子为 0.00625，偏移量为 0；信号取值范围为 0 到 160；信号物理单位为字符串 “V”；该信号接收节点为 EL3160_60 和 ESC 这两个节点。Send_Mux 作为选择通路使用，这个例子中，当 Send_Mux 等于 50、51、52、54 时，代表后面的选择的通路。 注解部分格式为 CM_ Object MessageId/NodeName &quot;Comment&quot; CM_ 为关键字，表示注解信息； Object 表示进行注解的对象类型，可以是节点 BU_、报文 BO_、消息 SG_； MessageId/NodeName 表示进行注解的对象，若前面的对象类型是信号或者报文，则这里的值应为报文的 ID（10 进制数表示）；若前面的对象类型为节点，则这里的值应为节点的名字； Comment 表示进行注解的文本信息； 如示例中的 CM_ SG_ 996 HUD_HeightLv &quot;Control hud height level&quot;;表示对 ID 为 996（0x3E4）这条报文下的名为 “HUD_HeightLv” 的信号进行注解说明，说明的内容为 “Control hud height level”。 注意注释以 “” 包围，注释内部不允许再出现双引号。 特征定义部分和特征相关的 Tag 一共有三条： BA_DEF_ 特征名称类型定义。格式为 BA_DEF_ Object AttributeName ValueType Min Max; - BA_DEF 标签 Object 特征类型，可以是 BU_（节点特征定义）、BO_（报文特征定义）、SG_（信号特征定义）、空格（项目特征定义）； AttributeName 特征名称（C 语言变量格式） ValueType 特征值类型（只能是十进制、十六进制、浮点数、枚举、字符 5 种类型） Min Max 数值类型这里出现范围，枚举类型这里是枚举值，字符类型，这里是空。 BA_DEF_DEF_ 特征默认值定义。格式为 BA_DEF_DEF_ AttributeName DefaultValue; BA_DEF_DEF_ 标签 AttributeName 特征名称（C 语言变量格式） DefaultValue 该特征的默认设置值 BA_ 特征项目设置值定义，格式为 BA_ AttributeName projectValue; BA_ 标签 AttributeName 特征名称（C 语言变量格式） projectValue 该特征的设置值 举例：BA_DEF_ BO_ &quot;GenMsgCycleTime&quot; INT 0 65535; BA_DEF_DEF_ &quot;GenMsgCycleTime&quot; 2200; BA_ &quot;GenMsgCycleTime&quot; BO_ 400 100; 表示对定义了一个针对消息类型的特征，特征名为 “GenMsgCycleTime”，特征值是整型数据，取值范围在 0 到 65535 之间；默认值为 2200；项目设置值 “CAN ID &#x3D;&#x3D; 400” 的消息，其特征值设置为 100； 数值表部分格式为 VAL_ MessageId SignalName N &quot;DefineN&quot; …… 0 &quot;Define0&quot; VAL_ 为关键字，表示数值表定义 MessageId 表示该信号所属的报文 ID（10 进制数表示） SignalName 表示信号名 N “DefineN” …… 0 “Define0” 表示定义的数值表内容，即该信号的有效值分别用什么符号表示 如示例中的 VAL_ 996 HUD_OffSt 1 &quot;Active&quot; 0 &quot;Not Active&quot;; 表示对 ID 为 996（0x3E4）的这条报文下的，一个命名为 “HUD_OffSt” 的信号，进行其数值表的定义；用 “Active” 取代 1；用 “Not Active” 取代 0。只有自然数类型的信号才可以使用数值表表示。","tags":["can"],"categories":["自动驾驶"]},{"title":"CAN 之 DBC 文件解析（简单版）","path":"/768939725.html","content":"什么是 DBC 文件DBC 是Database Can的缩写，其代表的是CAN的数据库文件。简单地说，通过 CAN 总线通信的数据类型可以用 DBC 文件来读取和理解。一般通过 Vector CANdb++ 进行编辑和查看。 DBC 文件内容当我们打开一份 DBC 文件时，左侧树形目录对应 Networks：从网络的视角来观察总线上存在的节点、报文和信号 ECUs：每个 ECU 的 Network Node 和 Environment Variables Environment Variables：在使用 CANoe 仿真节点时会用到 Network nodes：从单个节点的视角来观察与节点相关的总线报文及信号 Tx Messages：节点发送报文 Rx Messages：节点接收报文 Mapped Tx Signals：节点发送信号 Mapped Rx Signals：节点接收信号 Messages：CAN 总线上传输信息的最小单位 Signals：Message 里最小的元素单位 值得一提的是，Messages 与 Signals 下包含的报文信号比 Network nodes 下的收发报文信号要多，并且有可能会包含实际没用到的报文信号，因为所有创建的报文信号都会在 Messages 与 Signals 下显示，但只有映射到节点的报文信号才会在 Network nodes 下显示。 因此我们主要看 Network nodes 下里的网络节点，网络节点分为多个类，如下图，分为 SDE、sensor2、sensor3 三个类节点。 当点开节点时，会看到类节点下的 TX 与 RX 下的多个 messages。 ID：CAN message id，一般以16进制显示 Name： CAN message name ID-Format：CAN 报文的类型（CAN Standard&#x2F;CAN FD Standard） DLC：数据长度代码，CAN 报文中数据的长度 每个 message 又包含了多个 signals。 Name：信号的名称 Multiplexing：多路复用 Startbit：信号的起始位 Byte Order：信号的位计数，分为 Motorols（大端字节序）和 Intel（小端字节序） Value Type：数据类型 Factor：信号的转换系数 Offset：信号的转换偏移 Minimum &amp; Maximum：最小和最大的信号值 Unit：信号中存在的物理数据的单位 Comment：信号说明 其中 factor 因数 与 offse 偏移量 定义了 physical 物理值（如vehicle speed，engine speed,water temperature）与 raw 原始值（总线上传输的值）的线性转换规则。 12physical_value = raw_value * factor + offsetraw_value = ( pysical_value - offset ) / factor DBC 文件解析这里使用 Python。首先安装 cantools 这个库文件，可以直接解析 dbc 文件。 1pip3 install cantools 使用时，直接 import cantools 即可。 123import cantoolsdbc_file = &quot;******&quot;dbc_info = cantools.db.load_file(dbc_file) #创建一个dbc数据库对象 直接使用时，下述附代码，可直接复制使用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import cantoolsclass DbcInfo: &quot;&quot;&quot; 用于读取dbc文件，返回dbc信息 &quot;&quot;&quot; def __init__(self, input_file): &quot;&quot;&quot; init &quot;&quot;&quot; self.dbc_file = input_file self.dbc_info = cantools.db.load_file(self.dbc_file) def get_message(self, frame_id): &quot;&quot;&quot; return message，特别强调，frame_id输入10进制即可，同时必须是int型数据，不能是字符串 &quot;&quot;&quot; return self.dbc_info.get_message_by_frame_id(frame_id) #直接返回message的所有信息 def get_message_name(self, frame_id): &quot;&quot;&quot; return message name &quot;&quot;&quot; return self.dbc_info.get_message_by_frame_id(frame_id).name def get_message_name_by_message_id(self, frame_name): &quot;&quot;&quot; return message id by message name &quot;&quot;&quot; return self.dbc_info.get_message_by_name(frame_name).frame_id def get_signals_list(self, frame_id): &quot;&quot;&quot; return signals list &quot;&quot;&quot; return self.dbc_info.get_message_by_frame_id(frame_id).signal_tree #这里返回的是message中signal的list，包含一个message中所有的signal def get_signal(self, frame_id, signal_name): &quot;&quot;&quot; return signal, 输入message id和signal name &quot;&quot;&quot; return self.dbc_info.get_message_by_frame_id(frame_id).get_signal_by_name(signal_name) def get_signal_config_maximum(self, frame_id, signal_name): &quot;&quot;&quot; return signal maximum &quot;&quot;&quot; return self.dbc_info.get_message_by_frame_id(frame_id).get_signal_by_name(signal_name).maximum def get_signal_config_minimum(self, frame_id, signal_name): &quot;&quot;&quot; return signal minimum &quot;&quot;&quot; return self.dbc_info.get_message_by_frame_id(frame_id).get_signal_by_name(signal_name).minimum def get_signal_config_scale(self, frame_id, signal_name): &quot;&quot;&quot; return signal scale，这里指的是signal定义中其取值范围的间隔， 比如从1到10，每个2取一个值，scale就是2 &quot;&quot;&quot; return self.dbc_info.get_message_by_frame_id(frame_id).get_signal_by_name(signal_name).scale def get_signal_config_comment(self, frame_id, signal_name): &quot;&quot;&quot; return signal comment，signal说明 &quot;&quot;&quot; return self.dbc_info.get_message_by_frame_id(frame_id).get_signal_by_name(signal_name).comment def signal_config_value_description_to_num(self, frame_id, signal_name, value_str): &quot;&quot;&quot; return signal value description 这里需要特别说明下，有些signal取值不是正常的数值，而是文字描述， 这个在定义中是个表，比如1：open, 2:close, 4:ignore， 本函数的意思是当你取到这个字符串，比如close时，能够返回这个字符串在对应中的数字2， 这在解析和保存以及后续发送中是很有用的。 &quot;&quot;&quot; return self.dbc_info.get_message_by_frame_id(frame_id).get_signal_by_name(signal_name).\\ choice_string_to_number(value_str)if __name__ == &#x27;__main__&#x27;: dbc_info = DbcInfo(&#x27;D:test.dbc&#x27;) #test，根据自己需求使用上述函数即可 #frame_id输入10进制即可，同时必须是int型数据，不能是字符串 print(dbc_info.get_message_name(520)) 如果想进行 can 报文修改，需要注意的是，直接给的数据不一定符合要求，需要保证修改数值在 signal 的最大最小范围内，同时保证该值符合定义中的取值间隔，可采用下述函数进行 check，保证输入数值符合要求。 1234567891011121314151617181920212223def check_value_meet_norms(self, frame_id, signal_name, value): &quot;&quot;&quot; check value meet norms and return closest value based on scale factor 检查输入是否符合规范，同时输出符合规范的最接近输入value值的value 如果你要用脚本修改can报文，但是修改的值如果不符合要求，给入会报错， 该函数保证修改值符合规范且接近用户期望值 &quot;&quot;&quot; max_value = self.get_signal_config_maximum(frame_id, signal_name) min_value = self.get_signal_config_minimum(frame_id, signal_name) scale_value = self.get_signal_config_scale(frame_id, signal_name) if value &gt; max_value: if isinstance(scale_value, int): return int(max_value) return max_value elif value &lt; min_value: if isinstance(scale_value, int): return int(max_value) return min_value else: num = round(value / scale_value) if isinstance(scale_value, int): return int(num * scale_value) return num * scale_value 参考 cantools 官方包","tags":["python","can"],"categories":["自动驾驶"]},{"title":"CAN 之 BLF 文件解析","path":"/1584988185.html","content":"前言blf 数据是 CAN 数据录制的一种格式，以二进制格式存储数据，需要用 CANoe 等工具进行解析才能查看数据，下面介绍使用 Python 解析 blf 数据。 工具包安装1pip install cantools python-can 解析blf文件一般情况下，解析 blf 需要 dbc 文件，当然其实不用 dbc 也可以，只不过解析比较麻烦，推荐还是配合 dbc 解析，这个也是我们最常用的办法。所以要用 dbc，需要先加载 dbc 文件，这里需要cantools。 1234import cantoolsimport candbc_file = r&quot;xxx.dbc&quot;dbc = cantools.db.load_file(dbc_file) 加载完 dbc 文件，就可以解析 blf 文件了。 1234f = r&quot;xxx.blf&quot;log_data = can.BLFReader(f)for msg in log_data: print(msg) 打印结果是这样的 1234Timestamp: 1673917200.026000 ID: 0301 S Rx DL: 8 1d b0 41 54 07 02 00 00 Channel: 0Timestamp: 1673917200.026000 ID: 070b S Rx DL: 8 00 c8 0c b6 24 b8 24 b8 Channel: 0Timestamp: 1673917200.028000 ID: 0322 S Rx DL: 8 00 00 00 00 00 00 03 00 Channel: 0Timestamp: 1673917200.126000 ID: 030d S Rx DL: 8 00 14 00 00 00 00 00 00 Channel: 0 上面 msg 输出的格式为“时间戳、can_id、属性（比如是否是 canfd 帧、是否是错误帧、是 rx 还是 tx 帧等等）、长度（也就是 dlc）、以 16 进制格式输出的 raw data、can channel”。 由于 msg 本身就是一个 can.message 类，因此我们也可以手动取到它的各种属性 可以发现，时间戳解析出来了，其它的数据都是 16 进制，没法直接看。当然我们如果熟悉 blf 格式，可以自己把数据还原出来，但是既然已经用第三方库，我们当然就不用自己解析了，而且仔细观察一下即可发现，之前的加载 dbc 并没有用上，所以这时一个重要的函数登场了，那就是dbc.decode_message(id, data)，具体代码如下 1234567891011decoded = &#123;&#125;for msg in logdata: try: dec = dbc.decode_message(msg.arbitration_id, msg.data) if dec: for key, data in dec.items(): if key not in decoded: decoded[key] = [] decoded[key].append([msg.timestamp, data]) except: pass 因为我要把 blf 数据解析出来转成 mf4 了，所以构建了一个 decoded 字典，每个 key 里记一个信号，熟悉 mf4 的应该知道，mf4 里每个信号主要包含两部分，一个是时间戳，一个是数据，有了这两个，我们就可以创建 mf4 文件了，最后放上创建 mf4 的代码。 1234567891011from asammdf import MDF,Signalsigs = []for k,v in decoded.items(): timestamps = [i[0] for i in v] data = [i[1] for i in v] s = Signal(data, timestamps, name=k) sigs.append(s)mdf = MDF()mdf.append(sigs)mdf.save(&quot;xx.mf4&quot;, overwrite=True) 这样就实现了 blf 文件的解析与转换，当然，转换的格式很自由，只要熟悉相应的格式，比如 csv，hdf5，xlsx，json，pickle 都可以，因为我们已经拿到原始数据了，保存成什么格式就很简单了。","tags":["python","can"],"categories":["自动驾驶"]},{"title":"CAN 之报文录制格式","path":"/2276434991.html","content":"前言搞自驾，免不了要跟 CAN 数据打交道，那常见的 CAN 报文录制格式有哪些呢？ CSVCSV（Comma-Separated Values）以纯文本形式存储表格数据（数字和文本）。 多用于测试数据，全文本文件，可以用 notepad++，Excel 等软件直接打开。 ASC&#x2F;BLFASC（ASCII）格式为可读的文本文件，该格式文件可以与外部程序进行数据交互，可读性强。支持所有总线信息&#x2F;协议、系统变量、环境变量、内部事件、标记和注释的报文。 BLF（Binary Logging Format）格式是基于报文的读写格式，是一种二进制日志格式。以二进制格式存储数据，在文件大小和读&#x2F;写性能方面非常高效。支持所有总线信息&#x2F;协议、系统变量、环境变量、内部事件、标记和注释的报文。 这两种文件主要用于 CANoe&#x2F;CANalyzer 等相关 Vector 软件，用于记录测试数据（ASC 可以用文本直接打开，BLF 需要用 CANoe 进行解析）。 MDF&#x2F;MF4&#x2F;datMF4（Measurement Data Format version4）格式用于汽车行业以二进制文件格式存储测量数据。CAN、LIN 和 FlexRay 总线信息以 ASAM 标准存储，其他总线系统和协议以Vector-specific 标准存储。支持所有总线信息&#x2F;协议和环境变量。 MDF（Measurement Data Format）格式分为基于报文的和基于信号的，基于报文的格式只记录报文信息，基于信号的格式只记录信号信息。支持环境变量、统计信息、CAN 信号、LIN 信号、FlexRay 信号、GPS 信号、J1939 信号和 J1587&#x2F;J1708 信号，但是不支持MOST 信号。 这几种文件主要用于标定工具（如 CANape&#x2F;INCA 等）测试数据的记录。这些数据可以包含不同类型的数据，故在标定领域应用较多。 A2L&amp;HEX&#x2F;S19A2L 文件是基于 ASAP2 标准，采用 ASAP2 指定的一套类 XML 语言的描述性语言（采用开标签和关标签来描述信息）书写，描述 ECU 的通信等相关的参数，以及标定，观测变量的地址以及物理值计算公式等等的文本格式文件。HEX&#x2F;S19 文件则是对应的地址的参数和数据文件。 这几种数据也多用于标定领域，从事标定工作的小伙伴肯定不陌生。 打个不太恰当的比方，如果把车载 ECU 比作一个人，那么 A2L 就是他的骨架，HEX&#x2F;S19 文件就是他的血肉，两者缺一不可。另外需要注意的是每一版软件的 A2L 和 HEX 里的地址是一一对应的，如果错用了HEX 文件就有可能出现数据紊乱的情况，需要特别注意。","tags":["can"],"categories":["自动驾驶"]},{"title":"Docusaurus 搭建个人知识库","path":"/2483129101.html","content":"前言博客是用来展示自己的，想写啥就写啥，所以会比较杂。而 Wiki 更偏向于电子百科，可以作为个人知识库。市面上有很多优秀的 Wiki 系统，但我不想花钱买数据库服务，只能找不需要数据库的这一类系统。因此找到了 Docusaurus ，支持用 jsx 语法的 markdown，无缝结合 React。具体效果可以参考我的 Wiki Docusaurus 安装主要参考了官方文档 系统需求Node.js &gt;&#x3D; 16.14 或 yarn &gt;&#x3D; 1.5 创建站点安装 Docusaurus 的最简单方法是使用命令行工具，该工具会搭建 Docusaurus 网站骨架。 在新的空存储库中或现有存储库中的任何位置运行此命令，将创建一个包含支架文件的新目录，并自动下载安装需要的库。 123npx create-docusaurus@latest my-website classic# `my-website` 为你想要创建的目录，`classic` 为你想要用的模板# 也可以选择 `facebook`、`bootstrap` 等模板 运行站点要在编辑文件时预览更改，可以运行一个本地服务器并启动你的网站，最新更改就能立即反映出来了。 12cd my-websitenpm start 默认情况下，浏览器将打开 http://localhost:3000 网址。 恭喜你！您刚刚创建了第一个 Docusaurus 网站！浏览网站以查看可用内容吧。 配置站点信息由于我只是想搭建个人知识库，因为已经搭建好了个人博客，所以修改了下 docusaurus.config.js 中的presets，删除了 blog 页面，只保留 Docs 123456789101112131415161718presets: [ [ &#x27;classic&#x27;, /** @type &#123;import(&#x27;@docusaurus/preset-classic&#x27;).Options&#125; */ (&#123; docs: &#123; sidebarPath: &#x27;./sidebars.js&#x27;, // Please change this to your repo. // Remove this to remove the &quot;edit this page&quot; links. editUrl: &#x27;https://github.com/FelicxFoster/WikiPage/tree/master&#x27;, &#125;, theme: &#123; customCss: &#x27;./src/css/custom.css&#x27;, &#125;, &#125;), ],], 找到 docusaurus.config.js 中的 navbar，注释掉 blog 那一行 123456789101112131415161718192021navbar: &#123; title: &#x27;YOLOのWiki&#x27;, logo: &#123; alt: &#x27;YOLOのWiki Logo&#x27;, src: &#x27;img/logo.svg&#x27;, &#125;, items: [ &#123; type: &#x27;docSidebar&#x27;, sidebarId: &#x27;tutorialSidebar&#x27;, position: &#x27;left&#x27;, label: &#x27;Note&#x27;, &#125;, // &#123;to: &#x27;/blog&#x27;, label: &#x27;Blog&#x27;, position: &#x27;left&#x27;&#125;, &#123; href: &#x27;https://github.com/FelicxFoster/&#x27;, label: &#x27;GitHub&#x27;, position: &#x27;right&#x27;, &#125;, ],&#125;, Docusaurus 部署Vercel 有个好处，可以自动编译并部署，所以只需要把代码提交到 Github 仓库，并在 Vercel 里 import 该仓库就可以了。 由于每次部署 Vercel 编译需要时间太久，所以尽量在本地调试好再推送到 Vercel。 12npm run build # 编译生成 build 文件npm run serve # 可视化编译的效果 Docusaurus 美化搜索插件Docusaurus 默认是没有搜索功能的，这里使用 docusaurus-search-local 这款本地搜索插件来实现。 插件安装1npm i @easyops-cn/docusaurus-search-local 配置在 docusaurus.config.js 中的 config 内容中新增，与 themeConfig 同级 1234567891011themes: [ [ require.resolve(&quot;@easyops-cn/docusaurus-search-local&quot;), &#123; hashed: true, language: [&quot;en&quot;, &quot;zh&quot;], highlightSearchTermsOnTargetPage: true, explicitSearchResultPath: true, &#125;, ],], 配置完后，可能会报错，显示 Module not found: Error: Can&#39;t resolve &#39;@theme/SearchPage&#39;，不用担心，根据 issue，只需要重新 npm start 即可。 语法高亮Docusaurus 默认使用 prismjs 进行代码块的语法高亮，但是需要自己安装这个库，下面参考Docusaurus 代码块。 库安装1npm i prismjs 配置安装完后，使用 3 个反引号包裹文本块，就可以实现代码块高亮了，比如 1```js console.log(&#x27;每个仓库都应该有个吉祥物。&#x27;); ``` 但是 prismjs 默认只有部分语言可以高亮，像 bash、poweshell 这些，需要在 docusaurus.config.js 中的 prism 内容中新增 additionalLanguages，如下所示，具体要添加的内容，可以在 Supported languages 中查找。 12345prism: &#123; theme: prismThemes.github, darkTheme: prismThemes.dracula, additionalLanguages: [&#x27;Bash&#x27;],&#125;, 注意添加了 additionalLanguages，需要重新启动 Docusaurus 才能生效。 emoji 使用想要在文档中添加 emoji，如📝，需要安装 remark-emoji 库。 库安装1npm i remark-emoji 更改字体Docusaurus 默认字体有点不好看，本站使用霞鹜文楷来替换。 法一在 releases 下载想要的 ttf 字体（我选的是 LXGWWenKai-Bold.ttf ），放在 Docusaurus 项目的 static&#x2F;font 目录下。 修改 src&#x2F;css&#x2F;custom.css 添加字体 ，在最前面添加如下内容： 1234@font-face &#123; font-family: &#x27;LXGWWenKai Regular&#x27;; src: url(&#x27;/font/LXGWWenKai-Regular.ttf&#x27;);&#125; 设置 ifm-font-family-base: 1234:root &#123; ... --ifm-font-family-base: &quot;LXGWWenKai Regular&quot;;&#125; 保存即可生效。 法二上面这种方法每次都要在网页端加载 ttf 字体，会导致网页加载很慢。其实我们可以使用 CDN，网页加载时只需获取所使用的文字所在的分包，大幅降低所需加载的大小，从而提升网页加载速度。 参考 lxgw-wenkai-webfont 的使用文档，先安装字体 1npm install --save lxgw-wenkai-webfont 然后将 CDN 地址添加到 docusaurus.config.js 的 stylesheets 属性（与 themes 配置同一级） 12345678stylesheets: [ // String format. &#x27;https://docusaurus.io/style.css&#x27;, // Object format. &#123; href: &#x27;https://cdn.bootcdn.net/ajax/libs/lxgw-wenkai-webfont/1.7.0/style.min.css&#x27;, &#125;,], 最后像上面一样修改 src&#x2F;css&#x2F;custom.css 的 :root 属性（注意和上面的有点区别） 1234:root &#123; ... --ifm-font-family-base: &quot;LXGW WenKai&quot;;&#125;","tags":["docusaurus"],"categories":["折腾系列"]},{"title":"Hexo 博客美化","path":"/3164120416.html","content":"前言Hexo 默认的博客主题有点单调，挑来挑去选择了 keep 主题，下面是我的一些踩坑操作。 评论系统我的博客使用的是 Waline 这款简洁、安全的评论系统。要在博客中使用 Waline，分为三步 通过 LeanCloud 配置 Waline 评论系统的数据库 通过 Vercel 部署 Waline 评论系统的服务端 在主题配置文件中配置 Waline 服务端地址 LeanCloud 设置 登录 或 注册 LeanCloud 国际版 并进入 控制台 点击左上角 创建应用 并起一个你喜欢的名字 (请选择免费的开发版): 进入应用，选择左下角的 设置 &gt; 应用 Key。你可以看到你的 APP ID，APP Key 和 Master Key。请记录它们，以便后续使用。 Vercel 部署 点击按钮，跳转至 Vercel 进行 Server 端部署。 输入一个你喜欢的 Vercel 项目名称并点击 Create 继续: 此时 Vercel 会基于 Waline 模板帮助你新建并初始化仓库，仓库名为你之前输入的项目名。 一两分钟后，满屏的烟花会庆祝你部署成功。此时点击 Go to Dashboard 可以跳转到应用的控制台。 点击顶部的 Settings - Environment Variables 进入环境变量配置页，并配置填入三个环境变量 LEAN_ID, LEAN_KEY 和 LEAN_MASTER_KEY 。它们的值分别对应上一步在 LeanCloud 中获得的 APP ID, APP KEY, Master Key。 环境变量配置完成之后点击顶部的 Deployments 点击顶部最新的一次部署右侧的 Redeploy 按钮进行重新部署。该步骤是为了让刚才设置的环境变量生效。 此时会跳转到 Overview 界面开始部署，等待片刻后 STATUS 会变成 Ready。此时请点击 Visit ，即可跳转到部署好的网站地址，此地址即为你的服务端地址。 绑定域名 (可选) 点击顶部的 Settings - Domains 进入域名配置页 输入需要绑定的域名并点击 Add 在域名服务器商处添加新的 CNAME 解析记录 Type Name Value CNAME example cname.vercel-dns.com 等待生效，你可以通过自己的域名来访问了🎉 评论系统：example.yourdomain.com 评论管理：example.yourdomain.com&#x2F;ui 主题配置keep 主题已经支持 Waline 了，所以只修改主题中的 _config.yml 文件 12waline: server_url: https://example.yourdomain.com # 这里填上面设置的域名 设置文章加密访问有时想写一些私密博客，这里推荐一款适用于 Hexo 的静态博客加密插件 hexo-blog-encrypt。 安装插件12cd your-hexonpm install hexo-blog-encrypt 文章配置在想要加密的文章里添加 12345678---......password: xxx# 下面两个可选message: &#x27;Hey, password is required here.&#x27;wrong_pass_message: &#x27;Oh, this is an invalid password. Check and try again, please.&#x27;---","tags":["hexo"],"categories":["折腾系列"]},{"title":"Hexo 博客搭建","path":"/426584999.html","content":"前言之前博客用的是 Halo 2.0 搭建，最近服务器到期了，在国内服务器需要备案，不想再续费了。对我而言，写博客重点是写，而不是一直折腾外观，所以没必要选择动态博客。搜索了很久，最终选择了 Hexo+Github+Vercel 的组合，既能满足我写博客的需求，又能省钱，两全其美。具体效果可以参考我的博客。 Hexo 安装因为 Hexo 是基于 Node.js 的，所以要使用 Hexo，那么第一步肯定是安装 Node.js。 安装 Node.js进入下载地址下载 直接安装，完成后，在 cmd 上输入 node -v 和 npm -v 查看是否安装成功，这两条命令如果都输出了版本号，那么就表示安装成功了。 安装完之后，因为 Node.js 仓库会被墙掉，所以我们需要更换为国内镜像仓库，在终端中执行： 1npm config set registry https://registry.npm.taobao.org 安装 Hexo 工具执行命令 1npm install hexo-cli -g 出现 Hexo 的相关信息则表示 Hexo 安装成功 创建 Hexo 本地程序在电脑上创建一个目录 HexoBlog，cmd 命令进入该目录（不要用 Git Bash Here，不然你没法用 Ctrl+C 关闭） 执行命令： 12345hexo init# 下面是在执行上面的命令之后的结果INFO Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitINFO Install dependenciesINFO Start blogging with Hexo! 启动 Hexo 本地服务安装完成 Hexo 程序直接执行 hexo s 或者 hexo server 命令就可以打开 Hexo 的本地服务。在命令行上会显示启动后的服务地址。 12345hexo s# 下面是在执行上面的命令之后的结果INFO Validating configINFO Start processingINFO Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop. 复制上文中的 http://localhost:4000 并在浏览器中打开，就可以看到你的网站在本地的部署 GitHub 同步新建仓库前往 GitHub 新建一个仓库，而且得确保你的仓库是 public，同时，仓库名最好是 用户名.github.io（其实自定义也是可以的，是为了防止后面 vercel 被封了还可以迁移到 GithubPage）。 设置 Git打开 Git Bash ，运行下面的命令 : 1ssh-keygen -t rsa -C &quot;&#123;&#123;你的电子邮箱地址&#125;&#125;&quot; 连续 3 次回车，最终会在用户目录下生成个包含公钥私钥等数据的目录 ( 一般是 C:/Users/&#123;&#123;你的用户名&#125;&#125;/.ssh/ ) 。 打开这个目录，找到 id_rsa.pub 文件，用记事本打开并复制里面的内容 粘贴到GitHub仓库的 Key 中，Title 填你喜欢的，点击保存 ( Add SSH Key ) 运行下方命令 : 12git config --global user.name &quot;&#123;&#123;你的 GitHub username&#125;&#125;&quot;git config --global user.email &quot;&#123;&#123;你的 GitHub 注册邮箱地址&#125;&#125;&quot; 验证是否成功打开 Git Bash ，运行下面的命令 : 1ssh -T git@github.com # 此处邮箱地址不用改 如果提示 Are you sure you want to continue connecting (yes/no)? 请输入 yes 并回车。 1Hi &#123;&#123;你的 GitHub username&#125;&#125;! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. 看到这个信息则说明配置成功。 部署到 GitHub完成上面的步骤后，接下来就是推送网站到 Github Pages 了，然后我们就能被其他人访问了。 只需要在我们刚才的 HexoBlog 目录中的站点配置文件 _config.yml ，找到最后一行，修改它 在你新建的仓库这里，可以找到repo，复制它 cmd 进入 HexoBlog 目录中，依次执行以下命令 123hexo cleanhexo ghexo d 完成上述步骤之后，主要使用如下命令，就能将我们本地的内容推送到远程 GitHub 仓库了，然后在浏览器中访问：https://用户名.github.io。 Vercel 部署我们知道，GitHub 是国外网站，所以有时候访问会很慢，这时，我们可以尝试用 vercel 加速博客访问。 注册账号进入登陆页面，使用 GitHub 账号登陆即可（需要手机号码验证，直接填手机号收验证码即可，不会收集你的信息的）。 导入项目选择 Create a New Project 在关联的 github 账户中，找到刚才的博客仓库，选择 import 进入部署页面选择 deploy，注意 Framework Preset 要选择 Other 而不是 Hexo，其他的默认 生成之后点击 Continue to Dashboard 访问 Vercel 给你的域名（类似于https://xxx.vercel.app/），就能加速访问你的网站了 自定义域名然而，你用上面 vercel 自动分配的域名是无法访问你的网站的，因为 vercel 在国内已经被墙了。所以你需要在 vercel 中绑定自己的域名。 选择 Settings 中的 Domains 添加域名 另外，需要在域名解析处（比如我是 Cloudfalre）填写相应的 CNAME 值。 Type Name Value CNAME blog cname.vercel-dns.com 博客使用常见命令12345678hexo new &quot;name&quot; # 新建文章hexo new page &quot;name&quot; # 新建页面hexo g # 生成页面hexo d # 部署hexo g -d # 生成页面并部署hexo s # 本地预览hexo clean # 清除缓存和已生成的静态文件hexo help # 帮助 主题美化你可以通过更换主题，并写上你的名字以便修改自己网站的信息并美化它 我用的是 keep 主题 他的介绍文档写得非常的详细，简直是保姆级教程，大家可以慢慢去探索。 参考资料 Hexo+Github+Netlify博客搭建教程","tags":["hexo"],"categories":["折腾系列"]},{"title":"2024年度OKR","path":"/2576624208.html","content":"c8f9345acf8a8db129dc4f70a76800da18d542646271b3d2d46081d8c283c54eb6c12ea6cb7c8cd49becfe8ef4c789366af60f6703fe84ef6629e4efaacb2261d2eeb17465754c54fd3a232bb2f9e820735f23f6573a3592ec6b35f1bf9caf4144c52e861c55c72ba05e381ba1586dccdabe4ec155efa9f95a07ba06482dea20050ae396cc497fa93a957425c5ea53ee69c861fa0c597d859158625e882fc54338adf275fafc1e3d8a39de05ad1d88f5e92c0d485d36b5df7cb486d30ab6132f72b1e1664da11ae5cd2954a9a9ce9c242f2beb4d868ccbe6087d5eb454199adb11245a55a73b956259fbbc14844d0a56b0e150f13a022a1b19cfd0f112f8e35fffcbbf05b3d2aeb47d2fa0156cc51cdfe7f6358aa82b7e5daa7169819749ce83c6370feb196edec9dc90eb38c28e9efa9c36482b9abc42e4f716d906e779bbc9bdaafc2f4913245bb2dce0412bfdb91da7fef44c6606ee81a23207c672bc928757db6ecb3bdcda0d8337eca363ffd332ddb2dd314f3a89a6b5bd7808dbb14c1e869558e7e847b8414a0991ebea919808c35c20fdf4c62dd69727386c69b0beed79a53cf2c6cb658e2593fc8216659546a8804e0360f7acaac68600c648ad5bf9370d5fb83918b6fe2d2e437ce07719eba27d09199c624097d327b2b8c133d846d810e1326bca04232f08b36c86237ef07988bc796859e0da7c04f0f9138d9c180cdea56acd81fcb2f3469c970f92263295007b1ae981f2c9d0960bc8c849eafe4edb60fc3dba909784c8883e9b746ba0a62c0f12e4eaf7b1219cba6cad6cc2ed7bdfc3f321d377cacf7b668437bf71299d29171c3efd7c2f72cd2d5d1aac63579e7bd7d972623c8b26903dc7d9bf852e24e6e3461363d75f02a6f5e33443bc04ed37be570ada2c37e152789736bc888025183ab3bf58a035c597be83118a546d6569d973c6760cf159756e368aa1fc0e6a61486bb90f8719b69473a22ed7f8b86f3e716a39cd91d59a0b3b0658006793f15a3e94c48e9bf3a15751778deef8a544f50c673bae08d4aad9e02fb8b059c3b6d332b62986a3d606c62d7df85aae036bf21ddf18bd269ade880acf205a489430f05fd552e85066563206bd6ea32b5369ed89015c9f4e5687755325d10c5df9a8dc47523e12aa0a9d744ab1c7c4296fe4854f38fbd088c896bca6b79da7c11b9e2d472845b25d45a9d68ae8718ea3fd2a61b8d8ded84971c578a850348e184e585ab28fe801ef6e02b847352ba78c267fd16c7de3949f16ba113d0c614a883b143afa1484d56258cb4697617fcc442a141395506365c36c682b65bec80c5601c5f464252cce71543b23b9d15802a64fc509aed5bd5e4f402cdf0b0b70ab1d7839ff810f24a075be58013ecd0b78bffe1d7589cd0a05c67830d6739bafec9f4778b17d4d1b2d373abb330ffb420c2d6a50d3cc3d02d242d1dfbb932f3e20d86477483e81650c95321c892fd772e2fd5a0f2a8d5286d3cfdf67218abb0bd60a93d778d0a3f088660e19ac1394b518fe57b6cf6e4c26608e583bc39e65f87da647cab7dbc63d1b74db73390ad0b163571a0d2ab4707aef74471ed2869fa5f52e25fe6b312e60ef4d0fadd65a7267442603dd767fd97a2d08087cdb503a87c192f487bb897bd5d809151f6f125c166e0a6ec5d7deb9a947735951ef5a5dce68c378c33c7ed4a44bb073a59f86664340debf219398feca15a98b4ddc1bdf75d286c274552a234342f8f6c71ae2985b63705ddb10b31b106875dc2a8dd94e67b79076b0863340444afa507bbed2a3fac0248f0d6279f59fa14443e34f011aecc9d5abc9cecad1d088601160376aa61a96f0900ccbb2cffe2750ada42dc55e3cda6d21e9488ca7ffebdcb71082bce9fec6d8ffadc2f71765a2974b49354c62c29980b51bc43cf30527ec2544e987656f83586b9d272165a7de1a4c9277cd8b4efd7305faae2f2356b0dc2e1e02a60bf39a22333178746c21acebaaae0088ba81fb18d5e645016e145bfe201f53ae5d4bb31342f14a43d8c5416bdff1b63de87aee53a5252547e36b5aa0792d849b01bb5ff9e427ff825923b51de7d0e3cc88d3902a1421c811a3b6e6e336e5b0073ddf9205dfb3e83bca76b06cb353f7b5d92d61fc1a877fe3e3f4041e1821038449c7fdadbaf8b144b3ef19e95b8852a3988773d457ff82506b7facabfccb2be56ff8b234b38509631796d39cbcd3199a4254d88995bcd886b8f0544c93394cf7f9ade361540b6da9c0fee97edbd86b8268fd0ba3425941007ead6e92d2ea76ae86436cc46c5e2c38dd85170c0dbdd81321e4c9799a236f67cc9b8f48158d810b179189a8ecc626b258157a52c59de371389c18ec6736bbb909119f1c15decc77ec4c25176918c0f4089541dd30e0dfdf3659c2ffa0f6231b025737ce319d8062f25155712371a288fab84649a7138b6b6f4c2d0f4d7ae7cb9fdb1ced09068f063b0f40cb1c24d2313dec11edc03d180b91a86828e4d57c8fce7462aede94ee64e9d9aad44a5864cf16704029bdfeffbe6df7cbec450aedb5daa4f04253df62d61b487aebc49c88cc10524c528ddce93a3f0660a09b5f7399ba74ee0fa6c9eec709e723ce200822c604a3f04b59d84df0964d7dd60ff52e02287a26496c2541921118ca42acd87f718fd03320e377df83c8d75c4386737c266905ae0b1a8583ed6f149a2566eab3e60c809d04993f535afba18e154e0c1e7fd7c20eacfb1ecd4d2505a3c648cd59983b513d3060c28916b0f4c1bf106cf5b943439328fe425d950aa0007f94a60affc353105d5ed54344033acb0c27ff9ee3bdbaf83c9a18e42449074d2fdd15c395810677ab21c5b1dda422767a297e2dd63b571dfa109d79747a3372d4f19573edcb4a25b13e6e3e63e89be95065eb82b44b5420a9d12fd55fcd902e3c9f255e9005833b193dd9cb6b31382476340a1ab2a8e7c5a00bf43ac050af50ad6d7c767a0723c9800502810dbfad8f69f46bacb18abd1f7ea89dbabba1a517fcba2bb5905d28ca2f0e15ffb10e02b618154fac49e0a917e5179abf715b76720d83cfbc55c898847283d9af4a30c7ec1101b029c2d5002d72f1db33db45df4157bd159aa8649bc61a2bc866cb3e49828d6c41b56d398d157e8027b987a958ede341524c09c3b045fb47c7e44b5f1ca32cd15d9697c0ca1ebad0b33dacac522711dd41013a403167533db0a5c9bbcc45389810c12faabe456f873f3f17022e06e9d1f0fe8c795d0e73f003d821fc01c4520537ffd21047d50047c0702b01ed97482b9ce25fc323e920be54cc470de552410ea38e9970fbdd89ba47e8b4e5deb1dbbc15e2b4c8cf304ca46458ad067620af09743971de28f1dbc4698266779dc709240ed6e732f86a8b821fb2ca4de0eadb170efda442d80c85c41b5cb331e20fa23cd1b2be96f617060e675b688447755ceacfa046b437ee2caa3517b0e406f15ba2e8533b9e6c24f05ef39899d8fa470901b14b6ea0e07e4c06c3fb8ce791c0fb1474b58cfc854bcaa84d70fe779af4efe4adb6cf5b7f3b3c8b3a9f4f4211d258a40641fbca2b523a859b01c666834ac5eedf31de77988b94df526aa1c6fbae6cd16eb6edfacc7543a5b577ab182bd62d6dff717fa22f9a687ca2caed27dd2e312fb076e7d2454e9326884544eb124068e34fe83305adab32b6f2da2a6d9f2b74a831622b828ba34ffa650e28fecb2906c9a92f91102544e34fedd76786f586fdf4c76ae432790134a7a7eb9954d5c742daa29af0c862f085a1525801ac8d1d191a571c80d9eca4690827efb3dfa5d3262aaaa1ab41df86f329e3c1985f9668bd4e386482d02a88e17a796094954faa0597216ca6c3fde1fc5885f3d189da159eaae8e427f5c439c3efbf79f9fde7562283842925af5f1a8d0adff9a998237a00c655b4fad26b964be6db2f4ea62834d2120504f0201ab40ed7f97810566057cab710dab4b84294a49349f4ed753d34d7f47dcf50e3b1a406df16faa59360a07e408cdcc97a402281d58ab50e3c494192dda7e0fb27eac9bd3d92166c28b275b4ed24a09f438040f51ed7688508fc70e1358391abc3e4194ef5e4396d26a53e0806d7bd4fea1a8a91dd5b68bdad47aef9baec04ff252fbfc40ae7fcaac886f1aa2dee7fb26682c4f8794aac6a98b2c4de2851b2074c73a511c85298d7a107b1d5e0350ce067471aff110a24098aa620ccd703e1cd2fa9222833dae8b8d72fe5a7510ca8d8471e88034d4b880b845e259a1a50550f63abc5e608b68b2ddf2b0f8c7ae05064de3a77a75d3d4837c28464af463cd861a55b13ba4740e3010e1dbf7fe2ca31780862ea9e9ec42c81e7a159dd4c8c599a68f8a445790737f2405ccc75e62ec3ed5f336bd01fea09d21626af264531bee95e1aeb8d6e1dbfa471eee5eb82808f3adecca8a60148d13ca9322d5b77b0f7652133453e800283af6ed627bb41f72d327d8108294ed35bcc7479ac6de3bbbad5c5c2737cea632c3fa7c751eb9255f9f85b01d4416e8d6719661114a40fc694cfcdea6548da2d5d2e7b33d911a8fa6bb3a775924c4d298a75550ba7544558cb7e9e30be07f3554ab051a2c9bf4747302fad8b8e6b453ea7ab08759cade06c3e1b442eb9ebb79c67af208dd3cb696c3cd6574dde2709d1c2ee0ab49679976120a1b45bc2574701d6c212fde096c86dd8ccb9951b7a63cd2d5ead086c8dc00cf95279af9ceb5f43162955708f26ace7fe1a84a934130769ec5b66868046c76ee729ceb8af2387b0c18b25f51a0ad31f5b786200a1b564b5b81f4befd904405221b3105b6d05942df00af7b209991b9e9ff6ebdee4e20a5a7dc5e4e581494c701d0528ef04886fa82ec1805338c856e0ebcdcce0a0471c8f9858fae94c99706ae2c8544817b239a45cd89d50746f0e7ccacd1090df4805a4e5a70cf95d9b3b6e98db4679265a6ed816943226fbdfb290bb14fe2f7d5ab15766fe48049283e662bdbf7e3f51031bbe90fe297bd086a2b2f56976583213a96bf5e9690bd95b80b617bcc23313e1087e02ddee46fda7e7b2c1ed6646953ab5b1aa1eff3e45fe3a03769f4a13e3b9ced15709f332b0d3e195bf7b6d19cb3ded17060da65beac5b5658558bf48c75df3b1cf92ad33ce947b0a339f3117684474881788c0985e0befd2833be13e182c355cfa2ad0792d7ddfca8f8b11342b6bed081e2d78371083f8c02e78e4e354ff4555e52b3d5cd4acc50614a24dc252321941e0f1a3bec389d10eb582a18dca24e24b0643ccb881d317848b7c42ff0b349bf8fc6e9650d98fe3630c1bac34e5202900ab1c429b66cae83a98ff144fc3a23e1fae31b38b12267fc90e586ed115bc1c42e98f55eef2af0f8bade90b8dc33fc73e9dfbb2137da9f9906e8a9137d9e2dac93d93157e8e10a0105cae14730bf8f1dd3ff638e5b98ee20a85491b62eff43f0ea5a80b8b6b97c6c94cd1a0df6b804f1d101cda727e41592be406257d88c7c1d91e088ab9298bba1ad2d54b9092fd014e953c36341d0ee361260d86ea8431f9bf6449c5e340f01172fe47145a9bc6c8fecfb8f1ddf651baa5863cdea775e704e1b8326c4985cc2dfbebb779f60a661c7a63d6112342c623c1754defa6fc629800fa897de0f9e4d0f13f95350e7f5f06d6fb5b2c50dc5bdd57be010f6be671fc1aa74cd3a9051dfd4bb8be0feccd943d4df078a206a848a057751192b097ebe6e713ea74e3bc856446a3f2e667ac29d201bdecfa2c4dadcb4a2ad4f67a15b96f929b39eccab0a597dfcd3b1c30ee217d7a29b564f4629f9a6da1a14721a8433338ba6793aaa066be1d23ba38fed597278f69e760739b3c3ecb4e6ef05f59aeea92aac87e9a4cf60171682fd07850b2cfbe3971b410b0422d92b9aeb7d846eb1da3f20b94a6d37914baa5ad3ac318c6579d61b41ce8078b28efbf6c2390aca2e0ea696393f0f3d947a26986dedc43a704a8ed5a4fb79bf9f5ea1a2cb4b589755761688f3d45b3f993211eb5265f5f61a0431c8724714878520774d4d4e77ac44122b40531f5d68d32f120ab543383eba2454a4937d7e2c9f9e91316281a37be9dd489eecc630aa2cd57304b622b5729d59565cf8a8a042ef6b35eb38bd196912b07de8c1d2bb1f592a4bc285ab55088895b4cddadce697a56854c75d1b31a87b7d44c87a44f693293384311e359f15862ca7366dbe7f67bb229544eb0e95126caf5ba5b003393966054fb22059fcfd308f29cb20c96346eccacfb3c9752910fc6680a2981cea010d3650af53c84ef728f5db1ed3bc666958f3783293e4d9ab5b62f60828effee46ad4e8f09e94ac555a92435a91edd2d88c7a111772185d37e4764713a7084817188d44d0bfc4cab769256f2fc69be6ca44c55dd7fa7deb4d76d939fc877b195a9610b45e0ee3273fd15bb5cae883e55a6b7b9a7be2abf5d08a59d693954e445c016c5dca519e2a388bf000319e7e433fb186d1ee077b4cfd4dd605dec98c04f98a2aa40603503be29a268fcb8571e3e20939a38bed3c0569e2e6e09f1eb507a3c5e1bc81b902ef1df64d6dc0e8960861476dfc773122c5ad1043fe08a0d620d357d862e7319292b24d76296a8c8b9718f480ecd8900b5400579162ab7bd2f4a08659c2721bc32e85b8481caaa9b8af3f31ea45f29817f1c57491b615610e363383a85a6a4b367617f988893064e77731aa75332c67bb051fec9fb383599da7ad0a478a23f7d11215052aebc01fbf2f6db1d665f389aa0ac4a0055e026cc6180954c97f556d6775e60fda550c43e0f1675d23231778cb6cb9ae3df8bd292ee3155734646b58198ef5ca4ad2ee0fd151663914e64555ab8343040e8ecc868c1147ce4116b5b358c4f28756c96b9e2a1426c72cf7a8d7947061595202dda27406cfd0c9a5743de179c0993dc560b213488520603e4520c011f4b0f748038ea9ad58a8121f597f4305b167c31b60d052c574e3fd0e29c699f004026b4133ebaf49e55e432f26ee5f43af5fd76b34f12d31e2b66cae434f8b923caff9b26c1bd26bbdad5308eb2d63632e6c0dcafb1cc02ca297ca26cfe33af91743007de7199325bc62ce6e65182eb0aeab933613fddd5f57a61fe344ef396468c2ea82d4c7e5eed4b9dbfd2587d6c21afd888636fd3eeb74f5dd9db1ed72a0fdb402209d43d4620644e012ecb6cb1b7555bf34fe462fd2d217803074c91bb10340a55231d5d254a6726f8a96c797720111b2aa5f9ab51ff559d91354e7ad0ba66cf3281300e7982deb80272e6b82782fb54ad33ea96b985f9778ac29f5b6cfafe5221234ca03fb77ca8722cb1331dbd2300648f4f07549fd86a8d1c80bb49962d08d24abb0e9047656acf0d35a2e06e1e03d49bec144e3c813b86cf761182f33384fc5f144cfae4b75c007edb053d78cdf50b97f57fd448604f317314c50bc5c307539279477b3acf065c0a4c22f29f508a61e870d040709afdcc6d99486cad8fc0e4674936f355c917bae572cb9860fb75b6ad4e71f94344be04bb4159794b763799d772caf1c67be0bc0ebc461d93613c9208f07791e7369d6a085c5317cb0d48f49c75bf1c3da815ab6ef5ff4a8040102c1a75541736c765cdb51a1126ad47c9fde25d29cc44595dc83cbf2b6da7c26b9db1b18ed6af89c1d32303d42213fab2ed6c2be5e792bfeb63834537269813153c549eecc4d573cea46cd77226e36328ee0e6a5e9954ac2344d149a163f843e304fef9dcba97bd8e4db617f065a3812a752d0e6e2beaf776c5c4fb040c6f20ccc427a50046eb89293409e34fa561326ed61f81759fb0d07fbbaba3c145e2c16560dbbdf69fe6a393ee54c9303abace1618edaf48cf01503f62f1cd1cb9dfecc9e108d4b582e354ef20ad0946bcf5f7ac7239ef44f1398ad9e4c3b3b9b62ee7ea4c8f651682fd4d7d46436eed95106ffa3667f2fdb084832943a22446eef22120181a0d9885c3bc0e622366223374d2954bf6d7bf3bea4e45ecc9584dc2ff8b0b6b26d3cd3dba45a1a943530df06cf2a56e9604c9b4012504e71a9b8d287b97bcd4d1ac5b305c6f0a965acfa29cd4a6e69fb54460bc9b601457a4a312c599a3c726ba1a21de9fc4f6cad3bdb335d20bafa546002ce173d4e963c3ae30299f3c295adf0bc1a5919e3ac35b98b081927841e49402c3a5fcd056018407083d5e4199566af250f3b9248c3cf17a0f77bd91b82e5836611aeace2f3e3e125870ca0748bec68ed9be9c30a51932e1f3ea5285b8b26e4ab093f4297910352190f810ce5aa5572390a0e4c32bf1738ce2bdcabc43fca925043f985778865bd27787c9ca918f00b8b9326d18de9128907b76d51fc97b22eef0db5abd91b4ce1b59ae48b5b55ade12dc89d10d932f299f0ac7d12216b9e8ed439e0829350377e55363e238453db0ffcf5f7bd3f82634a6b18d8568fc1f982bdb4aa48168e3f21b317b49e1da86912286cf58514f0210ad9e560615de9272124f4a28afbb21db6bafb3e2eac96379f1ed386e538670d93af928a04ad5b906b8f9294917d1121a2c2f2d6dd21515c9dfa37f26f5b503a1cba863a410b35f77415b4543c3c48f6880f9712e8bde711b072bda1a5cef1b0ca0a2e039602a59cf923d32035040a76828439eaaf142dc9bf8bc5c3d8d1d57e4cdbb543efb69191da0a708e17c2538f97b45c0e9ce28a9136167a4d0c2369a173e1d43937c52c7e019e0e74b2e90ad57c715410c3765f7c09c604485c8e7781561b1bffd97e6fda5e263e2109ee3a7c10e559d0e1162cd1857d35c8a6790abcd2b05f1746f654d0065657d49cb84e259bbf5d8c791ac037d0fc836836696941ae0667bad016f5237acbe8ce1b88f32baa2fb400443386b39da46b016e4c09e80d318667596f3718ef312551d5b7b004ed8bb8a8e759471cf8be32f335501ac24e7990d21505e612714f1d3a67a4dd10c887643929f09fe84f59acbdba1f0b4b7dabbada620152717b016e80c60816dc6501b0aa91942fcb48d30ec93baf4b4d84d29d735e106c61430ce1ec68b939ca6532ea8f3bd6fa54ab13f03ac38e433bf01f685b877406291648227bc1e367dd2aff14415e467c12dd3532348efffc77177526a4be0db0507b1bbab062e371eeeb8eea98dd75854516ecfafa3dffbbded8aa5b6706cfbf213139647511a61ab77545fcef1ea3cf3c4bcec2aa4720c370237be0b0d4021581e81c6823088ca998189fc17c3ec4dbb32081ec293388e84a639613eed2e7ad6a52ac68548012dce1d104411c3bdc49b647c91ef4ad480077bdf3f76f7fb57ea54abe4600ac4ee313f3d40699446fbba767e06b54533a36c791360a5c272e59c88381c711a7c05dbb0cd22caf2c2b1ca87767dfe105e473ada98179f26160b4dc31677deaddc82876eb2998ca12f16ef7287252ff1add3fdb5ad59c6e5638c4135e591f865b5ef8a4e22cbc14a61ec0c256c9e71810945b457ff6757a7827e14789c76374028ed06d3faa66cb20e252f82e937295974df9951c6f00c169eaa8ebf4134d749914b939c0acfb305d4e15905a4134748f98da291fa38eee12f300114cf86069adfb3ff6f125df56154bad42c2a5bcdd3a17b3160c17544902865fa62ba5c88d81001f22ec0419d9d09d10a1e2d61182ece5371c24bc1a62609e90c4769dc0b96e32e1496bfd37530a098f6d7d888f3bbc17a9d3092b464d318495eb625b9f3a24db5a21bd1993b896d2df6415182877c697e630f4b18c44bda8866d78a1a870afd08b8664299d6203efea21876fe2fffc3cacb87fd93e5326cd27889c54a63b7aa5bb1d8fd96ebb49569501adc557fe04faa11313ce213fb8444f6b0b3465f945c6c7a2401ef801d4acd93228efc44e00c1b888564ebebbf54998c4ab1dec2807bbd4509509afc76ee39302032325435999f360b9760f2e7eaadc0f11921885cf26d13c103147c4886cc42a458298e95dacb54bdbd136f659fa607d1e18c39b2993bf9303a623a2540ae061b6d95cbea1392f60988d5ab2ebcae174eb4e55630364111a36a9d5fea9551956cdd3d6b1e74c7444b5438649fcda1b4226b7cf2326e51a54b508bbb5db0ec07f9408b068fd3207a51a84c2a03ae221ac14dab852be563405aed389b180b1dedc23e0bea79f2268b3a23a6b2b2d71a74fbf2c3332a8cd47f199ea30801f178f71220bc0316348d048265bc956a2429c28fd7c5685fd4e7fc6f0d54d76c98ecc2af352ab67d54fbb91a903479b4580bfc9620172abdb4479f49873ec06849eef839f93c6c50dd66d7c3524ea305ff58d607a42b62cd017ac0cb3e0b209691a3619aa47fa3ffd0f21328b664115f791cdbba7dc519e3b3c82e629ad07efac2c0a7a408c8120051dcbb42be5b4aca8c0883a50f94dcb161a737ba319e09866710a21e47bc946bdf28838d43f727025a82de6201035fbc79e3a98a52da3fdec6e1c316587ee000304c15e6e699502676aad1e88b580ee2e758e884ed85d732d1282eac4f7ec511931b181a7dae3f53dcb951e9b79b47ee53731930e671a9f21e30d67ed362f0be69887b92c73016a8ba2b37b8539a91b678f08b23066cc5b09b3b47cb07483dc477f9d08542a146fbf1e06554927be0bc5187e75d4c7b3e483cead19e6fc6b98a3f26bac9007b8933045aa13a5088e03d27b5d93641637ed63fdff0a66643ed950c901c0bf093ef8cfa7b2299d6f90af432228719fcb47adfa604ca3666b65c49e6b9d0f9494a981e8a5931c6e24211f5bbb1983a04fd3549702179403efc983cc61e0d2cf0d60c3baf82c796ef0f26de60a0e8e6fe5b542154e4b1831edf7cda8eb9cd3b5b71805a4d06ebd3b2deecf05411b6ca3c349ced753436fcf0f5cbf714a4e76b36eead1764080b5b36925d834fc777c97628129b43be2fff5b4770eaf0c783aed2f52444ee5ed668b9428f14913a4bf6a267b650d67959646e0b6c8c51360871f3c784fb7c6dab49a0c580affcad9ee5e65cf1a00944ff3a733bf6c7bc89d503cc84c14fbe9d1e2eaac6d1637435543bd0cbad416a854399a27ee62df9fa5c57f4a2ab8bde8caf33ab95383f469464b8a320bd846236e4f40e170f989834b072058af7dde301f0d4bfa2c7cf45a34bf6e4a1b474fbdee7d76e9c1142caeb230514326bf437134a0550ee5ab1942c013333f26638c52da2337f62494b0a8a87681d711bcaeebade53657b957c954d3cb445ff072ca9feefa721536d43ca6a5b31478181c826c3f2db08069c5ecb1e5777c56027ddae4fe5b9b7d4b1c2d0603f63275d87752b219c0e947dfd5c17311b3baa05ecc34171546ae8149cfefd6bb83894590e56865d60ae12c85ffc6b62358e790dc3f21351fcf28aff1c4f6c6bee555f875acb21c4e3338331289e93329f01f1480576e7643d5347020d6d33f66b78df5bb774ae5877e1b19f5e2836a9e1fbfa776b7c38393044a37f49788eb0a542ccc22ea984fc3d68b227b51ce07803a63726548f4c4d8e691f04158019bcab7db62b86686be0c1aaac423f94f259e4fe06eb4164d7f238cc87ae0bfe9c14c9daa7c03ea422b382334920e24a40021749872d91a485be5303a8298847faaef38788a63ab1637b8549824997975a75ce130033b060b5eb799ac1c0c9fbd544df45822710adf54fdae6bef61d037cfe8454a2d4bc0ed3e7739f3be0d496b357ea016a64d51be670d29354146259b3c4c9a592956283f2360614819f85853cc782262583414973fe7f98fff1973d17972a07a85a00e1507f9a44c006bc44bfd2553a8704dd7f61a4eb17048c391ac81cdf56ea0191eea20acdafc5f9871befbbc7ee65e8089a53e5bfe705e915b64c8c52339116463cea1bd76c6c49e411be86b9d7d74da6f15b2a2e4cd9bd607f066f2e7c2b012e66cd6a453885871b1447faa951f95274933822ab35ec54d4062e827a008784331f183c42a5b5c5d73b45527dd23d7c36646158cade4ffa6befc2f83ab72eb6438145ac305b649ffb647509d0edba8ae5c594c52c1fb120e2930bd505d44a1b9a9c9c84cb99e73ce6e16dcf3b3719b9754ec7b7f570d377dc90106b8c0ad4fa7e5c913b5ca94bd9a47faea0e605d937ed06b8b7edb45eee3335c8026ac8f1d13a0731d4c7d451597c0def4e0a46dc06000ac12fe7669fce070ea79c133917f0d95eae1590581704506278277c6da7b08bc11605f1f585fb1bdfe7e3dcf0ead8e636899f27ef195dca95e625427a6429a082151b813def4ce63305f5e5dd9e1628fcf490094783620ecb907e2cd172b23bb673665f794e05208dcefc2b5c33c160607cb46b1125148248ca881a5642329b9f4f58d643198940d2e1061d3139f71859d393cba60d8fc2291b14ab694790fa4ee8108971e20bdcecff2711ffd089e586e9d5b650e22e2bb9f6b9aad32fe93a23c3a2ca18051242784678d5a5f1ba83d82c302ca8610b54b7e80af2101db3a8cf7f8333b437dcbabd09b577146f3dca4c8fde77dd1d5548fab1c53ad28d0ca16f4da541e5644f144ae4f0711c587b123e24e7a2a908d7b7f85e638d7fe54bf9fc0291562b7b09d8633cd20335ac9ba1540d9a5e32b1a6ec520efa99e8501594dec3b14e50c97c288c9c3971b987ab05bdd212b06f23a6c026b03db24ecdaa038aacc308a5811b7f2c80a7161723323553b87db1c249af681ff8395d2fa95bd3692c2daf598c28731510ccac54e6d1cdf3e66fe3968d984fbd50ce281ddd77f9941cb960524f44ceb8dfcbd944de4ea85348bdd42b08cd03fdf9dc4d63063df6da3a330127a1d8a9da19259b30ecfba0b16ce6a15943b325f2219f91b287d37f89af8dce4b5cb202c0bf7fd986b40e00a46525f73853c356ffbdd2151a673079dfdccee39989c8f87ae41f7b775284c3d5b1128e14f3e519736b95439b01e45a4d68894413ef8e331f07e451d60fb13b8e1355f5dff25de71b621723115eee1eea803955103b0f84b8258e24891fb413504ac1eb1b7b33de0573e25ccce10a87b98d56e1b7193da55a26514f3fdb7e6941067d3d2f5f0ebed2869f33d69e2d9570f46de43a864bd2427246cec2b1da06827e394e8ac48379290722a67fe6e84ca10fc7660a501cce1717f42656689f0953d737c7e61201402715a72658bfeada0e038750d2b7e7f2c2c66383dddb560f83aaab3ec55e30e757ef01e2eb369e61fa357273af75359d2000516f22f236d39ebab96b075c2960e22a4ba9055631872b72e50d31453ed985dee5c2282b86ddbb76571435b044d307c25e33bd49cc3490838c9960862390d6e6ea730cc72b678c58a1de5b8ad0edf83284a9dac6d266dce756844d888661e76cf7f573754af378efd4b94763980b7dcd9e6c2b6921965fd837a038827ab4fdc50ed71fb78de6e2111e1f7610a2eb27612e4a77055f0e0794193d02f66e382808ff7547d688962eaffd967dc6aa6ce74e69ee49c98cd3edeeb6d95c040e6b1478303cc3e41ee1f5d34adbf466b4259e8342237f45c8483a7a1d8eb8cf3d955db56e2816137e782813432916fc12b078b4d3346f77f577c82aa4d9e10fcd2847ded86361c709b99d9b4fc11299a4985a21350586e4300f151283822032ea0df7d808e82166f035c2c869ca746a3f85a9560b712cedf6d25edce08db1472abfbe1021605e3bd5863d0a6a6450c776342c4f7eb6c274f5551c70f54279d94598371ff14e756b7ca6af1712a38c8e5da56475eb3e558c54439c4bbbd5df8df1a057cd5d94fbbcd04a389d3e33d35a3f9efe1bdf6f238f6565818749ecd08d0bb2c196ad5b90f83038c2a477ed0acf9e3a209e5a37acb286861928202b15a4a0c0110b3b083f481f8a1a84d4ffa5e9cd79bb5de1fd47ece425debf756ccfc657cc8657ae2e475af42f256ca4d43bf7c135e3fe0a11365edc12dc1135525d7cc21f97396b21f9b9e6f44b6a4694b2bd1c20dfdcf09c645de4afdf9b72c9d9d52d837a757b9423c31423ab4f4a28f70e979c79fafdee08b2023d26b02cdbcb9d04d3ddddbb94926be959fe73411d42204916c7207f7d5f2b01a78c870d834b2bcbfdfe9ae6791b5cc5b96a5aabf5445283487d22d2dce7232ba4964091cbd628f53da7dabfd244969c70cb28b1a68340d58dc36555683bbef843f2cd4a946b65f9a2724578ee4a90aeeb99f0bb9d0297c7c1c0184f790f5ac041de49090eb08ed6f0f6d5fb1c32545bab3f6c076e3d4a6e07daa59d0692dfb1120f20169157b317803aa4b8002c1517e9985a7a082d22f67aadbcd4349afe2b3be541c12e3fe3f7e4affd38d4649e6efb6d4bd99dd5c3b5afbe90ce17f96570739501b487b7dcc669b34ade2132d6a69f85fb779b71570b12f453a0075635082b4ec6b105caeb1f5e132170837b4343df4eec4df9b66d6381385044ebb9e7424f89f132f08bf9478c7c7180b0682e956476a058d11f9b25fa0b5095c51a6d587eb4a96364d7fa2b2204e1a044d7ba6e7b7c0604f1b9d4c8cf315a5cec994670503f47eb9e5334abd8f0cc39e962f3cd473a598ad6a43f7b759c21cf651a79540fb750bd503cf57885dc3667e459b85a9f097f6df4ca09a02469a03510416b2cbbefe85749bd65507b75b1117d5ca5e0d735c0c1b7b45ab8c8157f45c24bd49662e120928303373d325dbcf1f03fed350835f536aff7618e9bb4648aab46d01efd754eb28d29ca992164441363908e4bbbf5b02143ced589e12d84bcf6a261395df7cca5aa6e214345f13f83aeb2f4a4dfad0d73f9ffe6e35875e8ff2464753981fffac133fb4201e2c6f55d1e43ef069799e232694c45c5a54b820ba99f340b0a93df45ab1d1495d793dbb0a7b0d613b6c13b3da03658c81eb4bc5d8a7639ad049c492e6539e96d1f396ed602f19eb6399be0709b51fbe4fdd6e08d489a7aa0b09dc16b5e616f4c3f3a2dc1ec8f65a60924cd73cbf7a3f0142f5bb734cbb64ea53f43dabd9b4392b7b1fbe4796246798890b47e27dd5fee1829bd61331fe1ad8f4586f9a4ce5f3721a5558cbc819b7ca51e9164cfe7ef999c6411f1fc0168c77b0002cfde70332cbdfbef4c68caee1b9a8c82cb6a2b09eff1a5895d3afe86c0006bc7b3ee0071a5842569965789f48043630e38be9592b22042d749ff20faa39903ba413334f632eb6de108aad4c2254175accded2c7741f705e48f8eadd7dbb7ba7c0540ec26c0ef082d891bffbbf7c89ccd0977ccb8d15390df589ff3772fe82306726f4ee19991d65c2229f01877efd6c954d4ca2bcd8dcaee480321c1a85c6ab8a2caaa9421130373cf5a0822c66ba5dce887f1b593d81b1405ff3004915756d173aaf61dae6784b81c4058995ad602aa48b3b52fb47da201a5a00be978568ea85497303ee78ebd88d828489e65b58df8f5bf14c4977bcfb31dc2918182607e1378c6d82e0a1bfeadae833327382f2fadfa0a5f3f89a3020a5bc29c82db42c4240702fb4d5f00f18e112eea046ead3d5be8f1be8a902f66081117465d77449a7be7d5edad7722378d8c09268d57dfba5480c0b6caf435ed54dc754fb644490edef453b83db2272830d9ec810abc4701cd9bc8d7b8aa9e5353dd50f5f4db8a7ce0a48a1c71e9c1d92b090e802550e786c6761ed3500c837d4c1908a1b63fe30f7a0bcee16ebcaf9fc170864d6cbedeacf541ea4b732125454f449bd5250fa2006a502a4a8b41b254b742aa6aedcae6dc2909e3847299ec1fe930de2c196938f74bf56a662bf91dc0a570f90b10b78518a3f3c922f9f564e40774d64df921be04e9dcdafff6e62a12491787400caba82a6a3b627806e7162dfcdadd929156621e74f74d4fe033c93fc6a65972b299742c6bc42612462b2ca0ebd8e14397b2ef6c35d409f2c30d49f5166b40f42242c2bf16955810fc2a17f9b059fedfc75f75010be5a73e73668c97cff681b2ce70d995e81fa6b0971b0dfb4e9a208621d9e8b12d95b17c1b1a908fbca18c6a83663d5e0f651ebfda414e8be9b65ae8fd17fdecee3521a7863cbc3d86fd97fa53f8c2a4736c88a559f59956d3b533e29938b3461bab6efbe3b7beb9a5feb14b03288501b45f5f307bb10a87c5ed41d42f71dd9eb3f4059c9b9f502df4b500e6ee8bf1f2c606da6fa029348a074594f089570c13a07f70bf9a1e7ba4e194541f65f37865452544bf7a21b2ea660057d0cf1fc9dba7ed31a0d94af875f040891419ab39900f8d911c7b9529392fb8d3905a64efa661fd4ee3c7830ce615ba853054fe0f1679f372b1a1d38dc028c0f4f06dd17fae4d699f513ec97b9188f5d5e6846866258759222aef85f84c6796011acf82b28563f87da5f11483ff1b4ddd242a301fd338990da890fde12a6a255e4fb9a99d75cfce7712c95ecb80891e31888d4d7c8acd8273fa30f10c43905632b95955986af6e299a282934e33766a71e7b62841225df3e5892ab79809ed001bee2a3383dab4c3e25cbf517f187c7906eef77421a9f3ded2f837ba9199851c5a0b4eeb4969ed102a9667164f119debc15cd90316c28866258987d66b2f794b36713db21a4dfee3c1dcb8f9f9adc7f1f2897923d56de3b200c7167d9b8a65e1dd91a01a546088ae9408bee4213ca01a7d2c5e53274c7bb23a7eacee66abd6f609f40c2d26649effb4c210dc1144cc8aff5a6f0a1abc46d6b0b2c34a8034e0e30c9ac885ba749fcbc81dce786314060926368f38a2983cb33f877bd4757c55edc5b25940b44c3e4056686da11e6c4c4013052ba7c129db04769affab6d82788873e05e694e34ac6ae37660d5aed3b9d8662fd5f30eeb5f1e72469d8987ea83ce3dcc9cfdb0e680db617904c0e37a45ae09342ebebe7e03f3b1525db92474867c0d0012291ac0a36e58778320de037b1d4b0cacc6d1ba1c9cb7ac8e0da2970aa6ed91f86c1dfeec9a85e36ebe252a0604b1a7af776be0b476a6983b0ffee73a81f7819fdd0923a1e397067fa3d9582f0b978eff87a3eda103824b5fc9c4cb44f74ac3f20574a76566053a78005368c65dbdbc2061e42c816397dd10663a6479d613dfc84622655f3f5a18eab4ffc6cd25491212b0ecd71a6e30f2e4fa605b4a4388d89c91d1802dc9aaa3c58f01bc8df411ea98fe8b0e0401c948577e1c07265984fde54af924fbb72d67484a29f852a0ef5fc692c804011c02a72a39916bc8e31e62c9db86d3e8c8f56e9e713601bfbd92a1449f3551ac6008053b5d0e38f1195c60fbed89578070fd4bf603b7f64e52acc3f9b822f7740fcb0f2a8acc61ff3ba1129f95b88b8e0d499d6e16ad37c8a1dcf8c1241566906b53127b3d6cdc4fefdd7c2c8104199c53233fbd324fa8f413c5b9d1c3c3a1e06e37004fa7e81c15b57706479fb4f8f1062260c55641eb0d69cba7a0fa1a8406017da0ed2690b90453aaf0690ce9d45b0cbdb0368dea2227a41f1bbe3640dad7daa1810e93551209c41549469d43b490c7df94ab013d8da85be9329401973e92e057167ef8f123db28ea9d0bc7fdeec88800b859f321f7c20382c677014f5b58939424ec7859923972c530420516c64a8046ad5d319e7fbd768678fe70f5d9d18eb123448ba6842e72980b0640db7a43303e93ba2175b6811f48e6f0f7612318618b2672b498fdd3a99fef436cd2f286e0d6486a35841490bd5c2759312bbef2f6526f483e99570e8c008cd20a6874cd95c43b40236dcf91b413f6280af6a3cc85598caa4f3c9139e7943c0f4ba9b5568672b8dfd55ac444f392c0c655242cdc603832bb94bf79ddaa27c2d68a47b288f4855577ce5dd99f8ce2341ffd8c91b80408a69939f8ed76d60cd6ee087a0680c244659a095780d0672fb357dd5a89cd81e32deffa2c3398cacbb1bad2f4817e81e4486bb36ed8ea9ddbfc11606da312210c2d028aed418b592668d3e252a41cc9565dd04e1ed8c4e388df59f2d29e359ee1116ee7d18afaed7adf7d3092c78317c984716f19094521555775a2aa8b70ac8ef2aea256c5c8f1bc25f3003252313e82e383e7ceef4716c31ebbe004f5c3b2a22df345ab074814b828aa58580741786225f3923e32b9108f8fa7aa52c71404189dbbb11c4785265415b1cdf01ef150518fc706c8fbaf67465b0d7027b00fe840bbde11a56c933a0ba9ea6505e95f15603b2e1647bac5275a1a7b2aa1e75956dca4d17d0189200ad2f949c8a5e1aebbfbda0e783ecfd0895ddb77f3feb70b2a84816e8376416e529e237148dc19aa38d848efdb9bbdbe727c8a93e87d2d7bc0833ed8ff895b209748a815c883861acca54a6b20e8de73acf7390fb66d75da528e533d6b9fe165f9b5223805129b636d77ce08fcbdd3e7b86b10acc3d3cfa4b796e096d231aa304483bef3fdf9ead69652d07fe42f639c784df3719439793a07e2fa5a9b600d56acc99c576046e11049d1621d035bcd13cb2229d19775e66b5f06ef9fcf26460d222d14f73d701edf388d8f72f036398eb37fc9164de1b61993d46c2328cd279019f08f8021424c1d281ec12ab79ed3664a54145ca2fbf9b7caa72951652ad561855662d057ec0fe8caf19bb05d1ecaad74ce8de7b67bad11cebe0861f488dbac1d9a8fd5747fbbbfb8f3ec21602952f53e653b4d2c8240dedf03e772efad18443a067b05b425a28129761013d488de80a33ef4f6e0956a4a42b97381bb420126fe4ccb0ffee141ef14c408550b5a01aaf483774fc20eddda40dc69e949da603e8e07a4cd18cadc6d727d0b075bb347fe7a195fa12b1f601f97ab9ea7f3362d10da9520f36252a4ec3b2f54d4783adedd959def5b20e03d3b4345ab6d875a6673e593c47d84601af3d595f4da9405475714bce60551e13ea873879d8fd66fb0ce0ac42787f732857812bbf1c930e4c5b80db985fae99efa2165cfe8a33f661bfe9c953980d8afe5bcc5e0294bf34a33077177368e9e0896485037d9d1c847613864e7fc073b9feb617c395247a00dfda26481d2a343a9e5c4980bc4142e28e1298704bf4bdb9d259d46c62a2aade82c1c3fabe8a8f966d62ede13dfade1704f4dbe04a03be19bff201b0382bdc120217f987fb19435890f96146b83f7295265aecc6d3048b00c834de1d0196e8ed65126ae63cb069e27020c6b5cc0efb5471e4ae6a2ccb0bd3deff061e9e51c5d5380eee8baf1ea3571c23d7760f8b8a5b65b2f4489a57a97ed97a32454620cee7b3c50f0dd7ee1d6264eb85521457fd0c9621e547a47ded1f6a9d7cc4cc9dcb8406fddf062da8d5a04d89ab94a2d8242896700af77a270db8b2865d8a046921e7c7daf1ad91b9797d741f743ec89fa4fa67f6ae6437968645caccc2e7dd300a35e78f135dfd5670b174641bbb278346dbbc61b3227637a9e4b369ad66ba841e70a5d63887b16ef63c42dd277b077542d08d00d5531eb4fc62251626d95aadae9abd0f93f8fe94aedaa63349fcd276967c1e68b3174f439ec8557261d14d9d69c4a522f097cd0370db04249114b78db7e32b4ccf25dd0c1578f928c70b8f33dfa99bb8be1b3f5f55e98946d537ab311769aaa166e5bf2f4d1d5d6de2b1d12d9d58dca2309fdc65e1c7cd396cfcdd185b129bf5c5047a82cf38f95bfdf7154805acbe4c8ee7ce1599952b9eb4a985559ac2788bbec916181bdc9bd839dff8e0848118cc8c576939b8737948702d8a2c52b1899dcc08d3241864174358de05f876af1763c5a29498c69a06d32907bbac664acc25aaeddd0d8ea8d200b9801b405377783c3d0304fff0c7540bffc6ac73de41b50e288e8087e04296b51c48c26ea18ebcaf3a9b185320a1167809e2907f7d7efd798f55788826644b96e0df7fff851a5cb4e691e7eb6e53fb0a4cd798a286b79438028108b897fc87489579de1f9f23fdc7a62c247178cde7a00aa1b3a70b360e2c33e88df61591bfee2fe1a01b213a1c47c3232538f17c481563e669cff2fbca8987738d354b3679365d55de81c81dc900e4d6f4718fd803148f1794596205ac92a738535a0c38c2693eb838a4f40edb963650c113a84633563dc0f1463150cb109063a90512f539c6d4d2548e79ad44dc65adaa49526613b0e28f16ea444a77f89a6d236c3f5389b2b8ebe9f508f8bec4a667c8cf532ba275bac7233fdc4bdb4c09b9e26e9d865fb9aceb202e513c89fff47e3fb6af864886df3193213e8b589ec7e93c53d02844b840c03880c64e2b6069c11d6b10f29224ea9e67af61530c1f6b098d4cd6dbb64ea8c82e4fa79878deaf1e81e2b83eb01d3ffc6912ba9b4d39945105ca063bc864238d810a85153054479ba8a059b36061de3103efe5ba7ffb2ac8a2bb525840d83a4993d809e29c370db7939bf85c023d3b8bade2706c659969b1b1b0f1947a538faeeb260248c88d01b5b716698bad1ff21b0e2fded0ad9942b7019a89868f9a4714586a94837cfae676e79e5efe93ea68cc24aa70ef71551116ea2a77153df3d72fee457dd59219fb6d3f506eceaa923790274bc9a1500854057dd25bae0fb443064efe7add63822e2496bc839ea48064cd405ec093b8c9c110e9f72f34883abc5b165c5840ba4cd7c1cac9e5a0cc1fd64369163295173180ca138ca0e20b14fdfa475960321d11390aacf6e62ee7f8202b4301fe59644551bffe082c9b77c067b8947fdeedefd189ef93dd8e40f2ae1fc25eb211b1a35fa4af44a98c54672d0294870aa350c5aac6e42d563cc720b4800b87a61bef2d1ff940b8cd0a31d1c7f185fac1d68190acec41d2ff239786f72a52fe6673ba1ce063df1e867dcf57a43656af0b2a9b5f9bc27b6d8dae617660892c68301bdcad8dd4c6f6002801d1e41273b686be69b5ed8d499f8415619913d0a7f8f80187cc74f470d721de434bcea79e77c1459bb9bc2a98d61e88fb79c0c5e3313e221d17945cb4b07846ebf41e3c3dffdd5192378e3ba520ff0847414fec431b916af64e559d654295c9578233eb5573af63088dc4547252dc3755e371405e7f246e23795b73318c46845cf1580f2a39bab6a7440363de4b88ae644e7a606d89f8d8d56868cba3fdcefd277e5a63af710cdafec9e7cc3e31eb6cb2d7ad43c8f926e74f7e15acf41e7bc44d3c715fc02f077e52c8cb7c34b2a75b8df2608cf2a7826763d0f0079724bb7143f9a89c9090486fd6ed0ebdd758a72ef79a445829550b20bf09dd333de487b0c800c8a375e3d649abcabca2d5dbc851690bd6e5f5768f599a62e92c438b94a29855c1647f7038ec8ccdf85f9dbed2dcb18a8b996ea788de58cb39a772f89c02593d540378878dc2462eb79263b77f0116993996aa64c51687b6fc78164d73be1b96cfe30632d72a09331a8a14beac84f59288888de2ce53987ad21395551b8621c93fb45eee3dd98e8dd85622a8d54ea704bd24304dcc6ca08e42eb1338e5d555a7789cb362f0b4ae9d044b19db03d229070701903905af3130a10c5981e216f18e7e97d8f35c29bf1056dec57edbac3052acec9b36409813ae7cc96cfb2c97a5c12d2f4ad779443353a30270c9e9ea4081b044b23f320d4b1e4cbd29938126a69407e3d0b5301b4d1b39ad01b01a8c9e210ac3fb6d91c7d3e7cce97323de96ccbcc7748ea79d89bcf44e44bf37d7eb952d4d0c216555485047209e5d859b84d35d24a28e5517684f760b18ad3df5c0afaa30403fe7ddce0e685554e7188d4c44cc836f1fb2ed35f6c9d9785921832cb0f9d75aef7861db80d2d363ee2982e9e3298122f70d67bb50c0228aad439e5f02c6b27731402b8b612aae9bd3c57ceb3d9f7ac783fee64e01ae0a7eb1a375d9668e5ff2752c82c92171d63c40aec29c0430d6b48cd05feb144229e46d0fdcc46c5e14aa74d061917755fc718cb62d828ee0e13203a4e7b08892631acd296e222ec7b0ab639e7c88f4aa2245a28663fead62a48c8c76829af4edb9bffe92af8d4ac1cc8c506000aa5a4058de747dccb0813d336c5138ca4e46fffc85359a633743fba0602f1e68b9461fd6dbd830ce230af7f88780cc16d781a7f5e11826e40c4b0a05b389cdd6c6e2daf14b6e77e75be7f29f92a3d52fe33588f64d117d1465719bf5698b0a1255b7fc3ac35eb11c5b5a1a00f0c7e7e1bbe24fece7259175ad8d9dc9404aaed6e42574f9bf7966d79af8d0c52e4536b1fa10c045ded3747b8f6a1199d51b94b471c5d816f580317e35dc1a165e276faa7c9223d1b17746d7171a0c88faf280ec5f357bf1e541d6559b67305831764b87bc1799536fb8ae5f02fdba24c0b82ceac531be2c24c6d7c196a860c6cc633f24547b2e7f6340b270592a5f3baead242be77e74ec775a0f84d5cb453058ac495e3f10bcf8fa13de3a431ba463f78f9ab5e517a10471cb10ead7db411b3fab37a40d72d64a154a740f3a2376cbff85fc38520d449def2418b28067e66cc848534d8b799618635f32d588fe79c7c280647f31afa9ffe6b52e5bca27bf06321ca507b55d1c18598e231c502d2828e1eff47102915100f60580f8bca68662434f1c837f92b889a0031efc107d163145422eb29f6c4ba1808718562cc9339742ae8559802813d84d4fb66f6ac82cc95805dd180c53764ac898916681d76daece871a7157254a4b8b9cbc425c00971de28beffc82d3808dc8836855b6f037e1f41c6dc252d48ef208039124659f941654b2e9591d9485a406f9ccb35fd2dab9aef5820c1f6bbac70b7077871d9d70648b6f73983549bc4a0d9302f55f751b7101ebf50bbbd4b661c365b5e69176a4ad56be9e090fa508961e4af96446c4591c0767d94bca40d710039496ebffbb72579a286a403c0bd80053b055c6a9691f288893681032b52317d91045e4c83751d7a1f1b19beeaaa64eae3eff3c9c2ef5ff72b1f4f38724be56add686354bc08aaf95c6a676b8d52e5dc08af00666b4b026ad1696e170138c9385eaf244d892dfba540729cb86990e4aa5272b1321843257414196997cc4be6b4ba47fef808e6df8584645ac938073e5e6e9f0ffa41a2ca9a615f92b8d69a0a8aa10657202f5194b144fe0c51d37f7f0fdc1877fc7f950da24ad343d15bda39312a49fe2ae6fd7cffcd9ea725152daf598c7e018839133db4f79d5ea3538a145f87aedda727fe6a86b9ce4a76759270e0fe0182ed61f0e5c7f935d99189b91da8a773953145b262698e844733fc187f2610e3b464b2fb5289884c37ee439bf8a4331d79ed095c0ed0ad713e18505f7a89ad0cffcd845d2c08ff27dd38ee82080f9e3dd638f3ca123b5a3c6e56056d5dc657bd1b8f2efafbdf6701e8b9ddc532532f362ef0bd40909bb4d674075b4bbf1f86829537e8f505be9cd6eab7e24548528f1efe72c5bd87307234e5cba3ae272b8dc1172dbd79689aff2d8c317f33706175cda70ed43a4dbfca22a2884b0dc01d1fe209264944bfe3625a508a79ee4b6b4ab78f7792e02923778bc16c251fb0b0200365c26d37ac3cb43e9df1e9c4f1478b5f67d06f8856cef41dcc021c94f9ede1c134e6ba4dce444226764bb0564adf6eb1a7d6c239180db7557b0252d972c85ed70a49a93d914938958544d3ec2f255f1378ea0f76ab37be315b18b74b1a77336a775901a40e7b57fd8957947a12b4976b46da4f663a5d8bc8b430a40734222babcdaf0826fc7ef8f6a9f2e4fa3437e9f4babd6ba4e95ce5930dc62916d4ab04755bc35fded8606bfa665d2f7e55e5805d53b258a90987984b5f7ceb1b4534a4c4b055d0f4c1c722e3a670b6d7f5281d66c916affb860bac3fca2868e7e3045b32805b916fc02b240dd1ae1a298c53a3da776b9dff9bb5ef6c613ee18dbb5fc9f5cd59be7d65b8cceec4e151bd80666299f82a3f6af2a1a79465ad204a0b1948953591cdd612659646564b38941ca13d3c098b07ba89a7ff8543d0bc3bdff13cf4732099a4b9951e831a3bbc8a8b36e9307edfc4cee146b1d8b68195525c291ab1963a5b87e8697fa55812d37664c9582b3ca7a9ee391371d2f56f3eaf76dc48584c9c09ac089eac6b5ec1537fee2cf94cb51fa99c0cc419fdd8390be3770ab2a67f1e31393b3ecd8fc332421d0906563fb98fa683ff5fb0be94ca76bcb6d57646d6965d2449f4d039e0db4626e6a1c048ae49532b144b340fec1792e5818a026b99f0ef0553aeceb66edc48af7e625e90bf2227cd8514932f5ed2097c6d106075641a71b360e6d7d1a1fa1c013590baac1a78d6529601329bce7acd86b1aeb41f8f325ada41e2e3a4403e6960744346282410c11be14ce4257f295d3a9258c55f06590626560638cc6053228633828a1743f53dcff056a38a9aeaf5f1cd75370b66c42f7065213e8634d47e1bef5abcfbe17b800a5b76ed39d36a47c53c86a0a0f88382a02612b017287dda9619e6339e9ac3f4b9f5be4854a75c635f174b196af9142935b025f15a7260c223b1e364a3eaf13a542fe203365f5917f0f876603ada354cd03bc01bf6e059ff8dcd118847ac6ef5d08b7e4e5e2cdd653439d9d478adc4ff13288a0c91089ab21321382b27bda4fb8b5dd4a3cc976da2e54bb7010a9c505c31fc0a1360c07820be446ed8ad928fc66f876d088d5d6f4696fae6841ea9f33df819228c2cc1bb30e8c40effa60d1c60e87d4a1fd44fa84a5853958fca7e8ac5e82acbd8d06c21eae627498d25382fa13e4296e10edaffa1d93f12d039ee40e92d8fd3a10698ccc2041ca3a66d4509cf703b279f5bb3f78d78c12df67d2589a8ce038314333b66a83c23599c4025a520e51f9c0948c71cc2d7e75bfbe12a9d38e8fbd5b035c3142f13039d6e88c26818ea5a470d7c5ef2d837b15aacc78ee3a6f318579f7acf462681a8ad232e124472915efde9c244eafccc8a9a1d09de7f8cab34d2f73ecd14e97ab29faa8d9aa1f9ea49124c2fb5dc2a32dfeccf07cfc296c700c4fe5b9f534ae6e0b493869a37a0b2b7bd52136ab18dc353ad64b737f9599d297a7daa4eb9e55314680899818ca5ae94bc7dd4b73aa08eaafa1c62692c930224b78a7e4e822e45df3a59b4e40a5aa4ec28c8e006567ca8258847367cec2c6805e80ce05400731dc03dde685ae7ff4fcb4e04150ca9c5e049f13f1141fa44b5dea5ecc72f6810f767c121fba9965c77adbc2e030ad607e6a390b0aa87cc0dd803c9948ff4c04beaa97665678060e6db08f56fd028326e790acc0a591447752bbecf491f517baa0f40443cf1b88fce5d00cad64d5e57eb560e8506de15355dec8c2b26b165905f2b51688871e5f3afecb44c124b168aeba8281916ba02dc3be7f5460b707af23d58d02f183e203df7fe88325acf3d2943e4bbe91e0fb88a3ff751cb06d2e794725e4db5fafe39cb495a0c8a0501443502471a8e7f8a9c8421df02223d53509778847e167d97dd68cfe204ee539132d76af20266678a10bc16b11468c6a6a5f40b0873957bc191a9d10b82a920575b82ce4e58a0479557862b01f45d03ecc2f27dce3fbb52e2d1c93da43e4a9bed6fbcb0f5e2cedc5e81195a1d190e8f5017b31bf23b72d0c43a98fe7d3edaf73f86924ecdc8867873865d8b6cfb863b53b03c32d78cabd9e479d2c27215ccc602f9741b32d00891b105249a5cfad02934caa18c7e58a417c89436e96467aeda8d1d02c0c5d4452a416c08cf4cde828c7d785ada86f70d2b4888fa29e3002f694e20e716acccee10418b899f801bf8bdb4d4f59b4364c81d679bbc320727e96a2886f44e3981e868d3acbe41953456ee8b11753494a42f5f300c4b828acdaf934b0dde7ca11d16679508bdcb26b4076394a0aaf354fa52ed2682249fe314f3602e1f007fa0ccefe5dba6a44c129814f8675e5df56d8775b2d00e600ad0b0e479bc6ad700c988524a74dd7c812b50551fb3489728226be75f8eed9c6c9710f775e79e9bde14f9001165508ab396d768cce276ef00d8db55d442bda122f95bb0178565ac255f4af405a15db9bfc6cfd5c1b2f68653139117b0148882093cc88714b0eee34f57c2996f86ccf041b50899a81150b27dd7c5689375e1d4b1b01af41f85ad0d01103a86dc00518a59162e844d62261405e88466e56235c68362cd494f911d19fa35a7f822dc0b6792c1c223a154bc4a8d4edc83360ddd712ea1a167495bd52d6106e6181a718bb43030ed2fb99bfc9f5bfcff4a07d4a0e619a3cf1a040b13e0ef3e2c16b61f4623eaf18bffde11e92787ae084bb4f8bbe2436b3a4712aa0aa5b4bee0510b8d37e2bd9ce01363f0e508673ae8a8d3d219a2ce0dcc9e86b7a24eeb0c90d318d1c8076f95e8a71d8789168883df1222cbd4268a9c140733bd38480d81368c7c2c651b6db2fb173e3f65730ac0065494b65559122e2ac5cb728dffefbb2e65aa4e6d9edb35817f3fccfd93e8ded386bd84390b8ff3715fed7fe74926d47bfa58fbb2197566bfd92ebec79ccaa9a39baff8383ced50f20aaae8327af95030973e7df5fcd88c0a31c305ca757fce474b5f324ff336603b57cd4727f4490c1f23d1ade63ce31f6acf8e5c0df2b03ca776680612e7a1bc704fd36f6f965e273f53bef5e511ebf5b17622314b8e2047972487d7b8720d2f7d6a71ee286e184a581fca76a9bae8d97e6360c8ead0ef34ffc50675468ddeea417a8972cfa6cdb526d85c68008e1b2ea3e7b807aebc0bb556771887d1746440f0a663500d6fd3b23fc1ff49f5a51c07012768b72c014401903cf93972673d8510cab32adde23a08fa75d7471cbb7c71db8fb960b8211a267050941553a041e6f6720795f0350e7d1825e475dae9e3d5e68bdbb5fad2cb601650378109f78745a26fbad7293ff7991610aab5b3fcfa13319462c51510304122eaffbb82f98c0a8c71e7a34f4e51265fa88580d4abcf9c95be253ae11b20ecd2a609a1f4816dcab90484e8bd3a05f5e0a673e4dec1597a73f4175f0d25c2eda3c55be941c19f70300474ef81640107ed56d68e4822e4537247af429116a8ccfac0df9fb83bfeb00f1422f65aef799da5fab8d1ac3550e9fa355da214d311895a1cbef1e4b3b17a44fc295e5f205de5b8d856647bef46f55eede9800714c3cd837ccd78b94d4b259a3f19fba1974073e768ed7bd8b09e76ebdb9dcfc59274a3f6d6e054cb1390a2cd20aaadb010634a1e313526ef38f5b4ece5126196a4150f36a71ca48303c751110e11e323e0d9e30ec247ecd543d4e80777db192cbbcf4efb87390ea2f8c9a1723730b942932aa30c77ef539c5b339c778985ee853df04b7d61ebfd56585f70ad61e7480c6dbdbdb221a955b73b96b1f89c881d2ecd42b62784afad5bfb2316d634fa1c16268bf0099935e79ceec7802431674c5de4772f8a8401b5505b178220a1c8e7c987bcb76e05cf15080f1264d4a00433308fd3a60ff3d5ffe1a981a3c62bec546693abdb25aeb0340f92d2fd60f033d2f480eb12798d004cf6ea0823d78c203f03142cae7b9b6b77c15a9e16a9b2f9191a7695f63e50126e840d6804ad196165d44e6589b06320ae92ff8989bf9030133d92cb84fd6a92154d2c64531d6b969c9c6a0081bd44933c90a47f87c707441a110aa61bbeadbd27fd05adac952fe2736a74b1c9f9fd667199669737af1426378674b28a69aac5acccf9ac8a9b742e6d963fda5860a44353cfb6ee997bccf767aac64dc1d727131eafc2aa62a7a93b5e6871cfa62b7c9736eba560cd48b0158a51dbbebc2210d6eb833b6773c717f2d547ee301f5becd1d6f592a93f51afbc156e8f174bec1ab9d95277dd03752160bebb292a2b35abc2e23e3f84ee58298dd35dd553a563cb8b4e1d395b202442a66b32eb43d027dd73770c425328dba66dfb00c17819d4f8ef3faadad36a007d11f040ced200ce50d154223f883aa868f64a288ea51beab656ea83b07b1238f3c5d313ca6692c148e6958f4d0f76a9e76f630d57aab7b535f32c1903ad1e1ba60ea0650953ced64ae39e8fbcc72d89010fb6573db8c76b26ce760320efb39891a0c163a73f805e641c24a78f557c10bb1547d870c063a688585904fabb32c91ef403757b0f354035ac78b8bb9bbe0985304f0c7ac9aea4665064917f9713e828cd20706d653f385e13e6e0e1a328d05d56c29c02df9036b3ff3f90ea35142663ee359bc4fec06421f6339ec42d97eb5a84cf3c513ff0d7f3f4de05082d8849aba0c6a24f0bc84f27c3ee146b32282954c17a5e3ff4d8e885f01e1a4f14d051658cc43984d62e6fc064deb409a6b5c4011e661cba13c247408f9a34e984e0a6beabd98525d636fa6f4c28ed368e66135ac51915f351a395afd0cae95987a798156314b3244dc66ad4f6a40615f358ee32e939a237ef680ba6d626230ba64199c36ad3712a12c61fe04af6df06b291d3496fd44acb9b22279a50bc0703bc4ee3ae7f4054a84f31dcde57bcfe06e2cb931ccdb462cd954927d8dcc65800f7221202695bea6bf4459a1b30ef6b466d41277b9ad3313539736341f8ba0e2a62b794b4d20db2d6845eeb79363bcc79cedd04be8d1c974b21e50a63444fe9c45b33d49fb65508b5eb36f7fc1986ef59183cb4546895da0cf940624bff6adee117724237d67946ec622a67f3554d59ab6493470499fad2f2bebf3d7036e1a84f3ff1b100e1dc00e484045c5914b07de8144d32ced9efceae8b3f8a0b05b280238441d8d87d5b3fffc03570203f6483e6a5d4172f666a6432e90a27e1f2cf7781632644c8662aefbda99efe6c7301bf4ed1394d6b8c3b27c6c938dbd7a0b2915a834fced04e1f8ce11c8a3868d809875401c3ffb4024dba9be6d62c1f89153f4b79ece857645c5f5fd7128e8cd577ec69d8e27238b01770b8c67c2f19e7cb805532408feee9e3bfa2d61e38e0b3c922bf0b96bf694375a5b54b3606ed687a24fd01ec1a11a9e10426d1659b3640707b734c66033e9afaf0129048ed18600b047aeb8c3fa6019227947773a050132b9b893f14c1072b1f5c9d0e13b622ff22ff6680570bf1ec6885a682c21a2f41bbbce4bb41e26cf3fc14812a20cfefc7012f781566a0158209cddae41e45d002df08b9aa9430432d89dcebd745da3fba42f9cab1b19eaa5a4f288a3c84ec20fddbbf6481b7b563d0627eca4b47d1d0289ddeb3c12da2e4300a7433bb838c175a3f370465eb5daaa887f94ae0bde4e53e86eb7ea01ceee6f7f8bc0be87d2df66093b81445c9a2b1603eb2564fb202bf6f37c23bfe9aed1ab333fa0c2cfa8368a270d2d2b958f4767e96d32013ab6c9ff6d3f9d98d5db5272ded3766728bcc3b53315920ff41bdfbc8514a55cacacc32e6c68cfc1532cf4eb11d1c0525ab0b18f5a06dbe0dd4b120787dcd790b5b6d371ac6b15deb846d058f3005fd2b246821abdd7f5e3b45c246fd9a127cda48925146d8c0e6693be9607561a13bbb18f48d05a28ec344fdce901101fb61c37ae8e436598d297b3c9e02cba88cb99b2764b917f68aa4d73826f3b0726ca0d411bcb307e735886a2fc0d12f9c5c1251dbd4b40e0e52fa8b0563ebe9208171e51ee31ea2937882789d7d2d49652b98a3d2d23c58d18f00460e8791362c23d2c307093fcb06399985083f1efc245eb4638e3d8125533965533bb821cbeb0690e10bb82497b885295547006abd391149292ed066682cf328f73467a83f94fd69075897bef03f31c69ffe42a11d14ff7ae473b544d28bea16fef585b5bc07d905017dbd3335a1359ece0e7ccf5f6544c7c4a40e634131b45d6584d9c8b74fa18ed993d71f0eca521fb04a4f3707165d02bfbd58770b38343351e4e0cb65eec3a0023032d133e13574d9380fd7a2970c3180bdb5dc44eb906e1f5c49ca34394b360826798180688b407f0c6ff10eede4780a0ad7b455675a9fc5fc5306de1d6c93e70316eb1cf7e800e0fc8a91f03ee430e29e00ec8961933e685baaab12ba529c0f4a074b2fd621c85075d59cf70401f3af75cfcb294ee3c8b0b039ab2d24acd095a5b211f5ac4b8d5213f022b4dd18e1a4937562182f9af87def00f91e413ab8a6dd87e416541fbd0942575d48716847f41b234ed497217f5cf399b1ba7c612349a0f9a06f8762e7776d4d1daa4a75528cb94fec91c0d6c1aed4b4f52af06ff4452bd6dca1bd8ab369612a1a6400fa45e8741d102d8149019a730b07e86ef330dd855d724b7b16181d863a3815bcf10664b9ba01d37c48576546c88731591bd3887f0414ea82eea7ca0d91180da1ba98aae3c1bd067a8b23f52e5c1c92a060b4ec7f578869176abccbd685e514a52cade89b052fc86e50a07bd8e06cd5ce4167c86014285d4dbd12de7f456ea25c6ae26eb01d764becf6c84389172178b62e989dd8ba56f82eef7272e7b8c29b621f671353c411d71467fd33c55c271073fdaa931b04d5a8e6c1a1dabb33b9a0238c880d138a5d5a3e9f7af2dde8093cbe1e3f33aac41af867de19559359db38f04b51a4eae40e0ad3ca138b74f21e734c58fa0b873390929ad486ebe43969972beb2d25e02573f008a9a66d5cba759001aa3caf0e7897310628973e3c9f8ba0cda1be857dd6853a9e7c12b76c8fd3bf8ebb297d6fc74e0f530029844701eb6cb4bb3ec5b4912eb0035086c57596a3f6a6c49c995b6b5f82a2737d48d76298e05812ae3c2f6c09d0025997d5b5ef4942ee63dcac88d91fcbef3a228d8bf25460548ed154058cfd5b7e6d957dc98d175f3559b68c0c276f4f4685931dbd6cf1ee6b57b112ee3cfd60a7e08af20a34fe89fe356f982afa09b91e75ae8abe53e66de81b81d87cd1a34d295fd78121e780f8f1e048173fbdbf62f7d676c9fa6b6b36e590bffd58ef047770c0b3ef7cfa0daaa89fd02ae680dee758fef01ee5978d3cd3ad3529e410d18af7d6c531c48a51534f8192064e6f0833d430f682f3d66390428a89de890b2b50aad3191e6a65426b65cc297a6aa2be5ac812d89c51d61a685fc01b71b935bf00d9845eeb4e14f4606dfad0f7d680d8e54f1d9faf59fa1489149064872b7be386772fda0ff694b2bf8402ac5dfe503f2999bc23e27255da088cc1404cd7c982b7b14831d8cef13337dbf735fe23c345f9e4ec08411532c12ac43372604770d92da4039f25075047f5131373336a290ac8dcfe3baad60bcff7d1197d90f1462d46a73144ca83992248576d9e6920788e7725427e8b828dfc01789df5329b5fe2fae1d17117160f6bebe00581d520dc04cfd075808e742c5d15b0e744a99977444d8ed5a643deb88a1436e0da280bb168863e25a3fd1628ef0928294b491a1e08a1e918ad3e2bc9a94c6bc5c9402c56b1553aa4a022a4fe74864346afcad67b33078e7cffdfefaebf5b780448ac72a1ff160e6b7c34b5c793135205d4b60fb70c2d451afcd00c0c54a9d3f7a4807490d1f6961eb1d590484981c610af4eac562b457b646ebf4df33213d783ea983968a1d28e45023ab1956a501b03974fcd1bd1788e093f4b3875ca7d51958a6c86e55da01be2cc263738ba1c03a295cd7e4af9058613b9a6634e593088bb59a99f01b3f35f64fcd0b9106bc565790b302a228761378e5893201cf5c48e3f9cf7eddf570eb4380f32a68177b800d99645495adcfc68dd214afd93da1bc6f45ced2e86bdcb859b621a928a0a2fb14866245f3b948e4c1ddeb2670acfb003f4a1891aaa38cef56e23e3128e59beaed99a5757d1f8249e3508a41562c5359a02ed33314e5626f842162661066472f9c7265405541fcf12e6cd96e2ceb514731a4504127a2717b2c6e927758dac1ee4643bfdba21bb3a24bef6d3ef93d11fa6b74f9be386efe89c00c09bc4ae38396e8a5e4659824706776fe21b2ef6513c5d3ea8cd6b54c3183cdbe3dda0d1606c163d26a5f0f93f2b0b8c013c33e10a6af0f367d147a41e6656de50e214c4442071ceb4d5929e933513d1793fed8941cfcd02e80113f2bccbaa66e5e18b4583e82a5b9c417d73e2ff4c9b1b2ea6c4672bd3a70c79139fb88db8e58e154bce642e2a58f9a5a914e84b2d2d61943db7198ee02abe48f5c159e7169783fdbe77751ea1d45975f41bb9757494186672b961804d51fe89fca8c7c8719e61dafa3a3390a24841bcac5e4d198e3da7b0af6432a818aa8b965abcb3b119300989b98cdd5b57fdb3a000bc79c17c10f4343a0a1ca713837a346847871a9282f98d4edc4b3171b5a3a5a16d91f6a722823674b972010ab3ef97d276f684cf87c4ade95614f496aa03acdf91f873221578a71a0b9fed312abb7f4906fc32d1e4d81407974e9f64eeda7bd9d9d6a71ac620a498430371cba08cad925b1dce38ff41031135973bbf4c24224cd7c8079cf8295e436170f51d124ff2e914e2dea909a1f3a29fd2847f7bdad22829ec34fac4c5b9ac033d80e247ebce14cf9bea3e5cdc6ac766445c47838b97fc9c1587280001aba51f003d0a483d74b8b5965e16340d78a0365f0b292d1583abe847df1d1949c7207dd547efbbbd57ea4c4919cad1a4c32f68366d3c4e21fd35684a521d45c51cbaf6bad7770db02e6ac00cf692294a087c68723e5e450a73bd3211b08a80ac1236a019aca7e2caa960b95b263b4251f5b074f35682779237bab34db35d32152cf516d4f6ee803610a8d367782f79528dbe0c563eae1545937e33dee758669e37e12da7fe58dbcd42cf6938e3fffd3e265baf26b15f26e168bd1aad4945d86ec8abc26a32f706dbe682550c95031dfca452e06c01a008026a1564f735c522aef8d5cb37a4cd65cb8ae6b4217850525a9abfb08804f486d6ad503e19ee29b74902fecb85cc050cf1253fc18589c117875fa0fef6687ae9f4e7fd9c245ac486cf47828eda2f618a66b4e2ec474d1d22d520092e3c67d8840b6baa1ec53501ce5e3a500ef2bd6e143b70bcdb44af115d725101c9c2f8dc2fab1718de49488861f1d36b4306d7fbac310de61a021edc0a9a19ab123884f0683158c7eb8591d677a85368d7ecae6f5126364b5de143fef46d51f43c71f8d1fb9340377fd9501ed09c86500a9e31ab55bbea78612da43d1df500b313585861925259d732c7d9052e6f78afbfffce899d780e071d67b2ed8bd88db9905d427cbc514069d96a9511597f4a0c16007b883df5079eeb87020d2c776252d044ff318d39f9bced7429566651c5b6d2d4ea62dd118fc446fcab0f2e30713d81a64239b2f149b0b35aa061687252bf9bc9b254186fc0cc520693aaa2209dcda6b1ae4d89e2828f7d4201805ce88e19d41c498474ab84d2681e2beb9851d83ad7d0b8caf7025f3e3d37d9efa65c32abfd240ecf9fd67cf49da37ae9136261c31798edcaf438d106aec29c97f2c8ed33e39cfde839ace3f5a9a0e452a8ea2da4070b5a8672a67b626b5481923ebf0df0674ac73f43eedabe42d419f4779b7cfd72a88cd623f00eb90637575bc01131bc901d3a2dc2950706597037dc63d2ecba79a5dbfb1548e58d6ab5d7c728a1eaeff50aca3b82ef4474e81b6d86edb6335b4d714e627c168ffb4d9a5b6b2568de269b29bb774b01879ba5dcfd39efe89db7b5812e354f5d5c1013098e0900fbfa3c48c5e94a16f6446bd29a1ac2161acd77c23a90a1b58efdb75c43ddbfd72e8d91ada9ddcfd88c177d4db88db87d149d6d7ab07f540a3a95452b81ef1c24220371f2d342821961b110e6d63477d3be3b89217d87997bf6c399e06e369f8fe7ab01930fbd390330036002d4f58d83e189d8645825a30ea0f270dc8a6d918de08de0d601e16b213e80aef6f10aac0620f9b5a03beaee64074a0b1c991b10481e97203ba4c80599ef0851e7733220fbbab3b0843ecbd0d5503543209101474f10cb16487926b3054dca6550607b0e4ed3d80a232fb42249301fe9f0bd9490ac37923ec75f6d741d697b2e50067bc25e9389043fd5054e25808591168002b838c6e48501146c5c309abc7e12f5a6c0f5a20681f22c8ff44d5b99eb74399bc31420389e7784894921f5fce76ba0980d7707685236e844d7fffcc58b292bbf46ad5ab852b247f5cf588e63456ccecd1a559f4b7f15363816cf59ed08f41be6e85f7c60f9a75b82c53fd9dca883eb96679aa293adac69a9847cd738be39454d673920c2136845d1597d6276cc779eda7991f643e12a17920fe865c0ec9581d228222f675bf801dc2257475f7179f1834ed6ddd80bb14a8536972a9c7e738105c92683aef0d2f3e8ec2639aa38dea7a7081722945ed653e77ffc614ee1c65df42260d8676718b9b56c0ded3bc610b274971387b58eeb45d1e7d83526bc601c794ac6651e656054c740db17e35132d51b7603897aacd66c19da280704526bbd586296bb10da9e588e1b3b8d3fa045ff89e0d3d5a1a44a290d004689c7cc55861ceba19a4bb0e3c143d72c0039985bbf45d5e4d73e9de7b221caa7f1118d3d559f05fff2bebcd979f522400a0971df502d863e56e47323ade9ba556a3272a2df1a1314d5df62985faf8a6d10dd09ede76a22f050fb0737b184e5af3cdafb4cdb7bbdc6e970d102aabf8c07b0da3571cf02a3ae007c92c8f16e96dfb757f4343acd8760c2a2862c103341c0c2d1963eee17ef7fabad9a2da02485ba59d5cd8b87bd9f90c42f26d59f91f268ce466054719095263f0415b7d83b8533b58a19754bf8fa5d7fec323fea451fc1cc59ba2d1911ed458b4eab5749e9f3f198328c35adf29d226e7d61a10b4340e8fdf0c03b2fa27acd5f13906b7b2e764aeccfd1ea0aaf86b16379b143fae152e65be01c70b08032927e9c9e97e1038e446ff7bdf8ea8e01dca41c0d02b3c19e4a05d6b910e2e4b1d49a94ff3533411697f5bbb9d161343f57f243ca99979057920466500978ac1394a316592541c1646760f307c6827bdb791f68636aa61c1d4a792e8132a144839d6b153b46a3daaf931aa4dba051520f5c566bc4eff88574ecb3090687e29052897e9fb0d04bae27cc52c6082003f1b2663302a5f31bd32cd93c1cf9b2f9d0d80d7678f02069cd371d0526ea5c5d15c6eb8dc511f41f8419288e4d6775d91321041f6fbc60fcd459bf1f62e22ed5d981ac67aba7ef24b935b9b7f99935cd169ab680c480a6eee4e4142b1df8e0ed5b45797666ac1fc651655cb9f60a7c3a3d4de5f61ed8c60f0c1be93bb7d097a8bf8457734978ef9d0dee7a610929a9554424e46728d390f81f40d04767ae9330a7870a6815203a651eb7f38674735975f22cb31bc8f8a9736f6a47fa989bdaf5dfdb6f1c85468ee9c6c83a34b17095359082074dbaf9bc6a75023c20c756f4cb6ee96c4711586ee048612b0683f256eee6fec26f70a142746f8c206761fe7701bc159d6ec7df1750a8bdaff8042717153d277d03bb0d073a0050e3ce9bfd7c15403d15ba5bf5f9116864ef154859fc56e8e3736f005cb08037944ac02d141c1152b207f1ff888f5769570b9e4ad7d27e7217fb5206f70a6b2ff8567bb59d415b7eb59cf92129913b37f7e6d5e6859977acac684fb543bbe8768dd268b55af5ddda349c9194c4f6f6a0b6c67f1a8a8883f8ee7ae2fc75dcda6ea04641781abb82a590154dbc379e46f0fe26c298604df3f0ab6aaa2a78a339a17549799e6151cf9e2df9ea4abb1afa9d2eceac218dd9d8fb53ed2029a29c9a83c0ae2f80ba9009d823276310905e94edf1bd4153338eff0762b161afcc0c544288336a921067b6404d93f3e7265f2d925dcef743c10c1decd57b5b2463107acdcbeb62769466af481aba05611de01c14d1676a863f1524215d69a92ebb85a5ea72a185591dbf54e52562680ff471e2e9bf0e4e4390e11c7420f119cfea5dbf5014680e51a59a88117c6f240c9ecf4aeabc87894a3189b97f1c74a9b32f048d5ed563b250788a29531618bf5487e22d7ac7513011289b5ce50145a2302fad966a0daa07dca8618c51ab3e1c6ed9da49b4585d0d63c1b258a2891dfc661cc5c0d48800997a3cff78ad897df861f1ca3d1eeac5050736854af17743596da40bef44b0b7071365f95e800698588a0f14144a1ce82ee4174b5ff6bc3aa2a0b15e9ae06aa737ce5699478416604e591724ab46101ad934b1e2e18a9bf49cfbc978fdc9650fc53ed3ca99e8be473c34503b42298711396503064c46688684ddc15ca90ef549e0f129b33a26c8683bfb960dbf5cdbbb28fe8159fb7c3ad1b1efcc54590ba8b9c3d0244560caa34856b0ed193d8d7c1bab3fdb2787bb2ec65cdadf63c4caec3e099be7c995fef33b89187b8e84a8da98bdc66143c66d51956a81e6b2b31ce330cead939645b53638397236131ee49496deb2669cb0375687619fb7ce3e383ffc4ee232d7845898d64c11271183c980bcce78fc408a9d197b2c183ad03e5bfa0d8eba2965af066d53230f51ee9464c1159c4b895d7a1117c9a3bcfa8f726e4a774ad92bdc402ac51096aba3a45b63e39248be3dd8ed7b917f17478fbea2806aa264cd9273a00d5d0c1c2f552bedfd669113f4e28720c58053a1b1b15fa250938afa60fffb64e6ed3f4ffc496bde2a59458deb8b965e5b7ef34e4f6785f439d37085ac73bd418c40a3847c253482fdce71a40dc87498589f44e4cb9b0cd1a68f8ae7d438f34a40fcc2322c43204af8b30dc007b2d5b8cffe1f07690479f1d9ab7061391e2e5f50197939b79846c5b42cfc041fa3fd89f1270adbe4f6bab9f012aa8cbad760d31f73bbcd72e8820af2564bb8b7bdf8ddf4b7e533b32b8714f1c29a6722f4c12b6c24d4e2a277fd518855e81a9b2e8bad921f26862156a3431d46877bc5a4ca0aac4440b7caf9a93a98b004af9ba5e379d5f7137ac347f69562144b0e1e0c8c450fa54b8b5279c6910876f116782e3df322e28f6a653fa1b2c1de6d8c34e8111c35e1f65b757cb0a1dea5b8d973073cd2185f9d1860f66af239ebed2dd70d98eb668708da500aa5665d1a8baca40a6b4f891d677190a024ee0ee4b0a557e2c9f42ef5ee278b015ba64aef8c299bebd9ac38f17111844c28897d1198cb3c36628cc0d5bf730da45eb5d28c749b5c2c7c1cbe4dae976c1d3f82b82970bd32e394bd0f723d8f0e5d9660d05e7eb774de240fca1a18b6763983f890a789fdd0fe569e21cca074e179010bd852330e87bde85af4051969731077af7c68ab22c20736b1fa01e3a5c66da49b94afc251bdf4f45b10cff057b5cdbf776a358662c1af76645c791c832f8b1520f96d5910c7b61c1c92f10e16bed44eaff80e7ad860b41e4fa13e25d270181aef528be19113a05774f1b94ba6153de6396fd90f627e9750dd4abea9ebac912ab2a0ac58ca6ec211e1e717ea40454ad803c91f975370dfe494abbed3835282044b228dbcc814b1a749f832d074f4c263a8ac0ef3534c79b2b0b90dd52a7c183123c9fbfe5b19784226b33af1de6fd3f205fe892446b8270879b565d588c7d457e7efbae5719257fbc4113ecc18db70084dcd1f0fe21d9aa205eb1d52a01e85b51cfdab314a28cdc8cf3b2e244daa908f085429e83464b033064ee1919de5fc40e9dccd02223045e17bffab98c6bfa271ef2b67ef070b9a8682aca2daffe8d6e74b9fa33d5450034ca5add4bb635058307cda9499d0d5dc34f54e34c1ef2ad400d9b5bb5f88934c33fe72d2a8d2a00cedaad43384252f1915316d620be880c4d61c127dadcbc5e7488d90aa0c85d2d279f0b666e867c1910c379a49fa7e137e8e2fe3b3265b21cf5f1782f5a029dbfba768f4932e2f8ddfbeba5b30d78e7413d7e342a731accd1bc3d264df3c02a4653ed1746e9c028f01aaa7a574301e9623214eab7a440873119d343c2ec8764a49cf0048fbddcaa223218b5c9864387bb93a935e9c3c734be58388ebe149c5cef7ae33c033fce0898a67d1950e0d33dd4b1bd8d9400866bac5501596fc867a49fbab10798b868904999a89e70ff0271c21b97292464711733d02bb36ca7871f8f7c35c1bf8b7267332619b638877268121dcec4606f4d4d92543116dd7e46ba16b92842e07e4aa4e44be4a5bf1e03c51d506a2074ba784dc44fa75acbb2dacaca14d8fe6388e39ea4a0990b042a1b74d50b3423ef139ab250d1135bde4cb5855631325e7ff0128de3b8d38d5fa05d316deffe32278ec1e03f4108f3cc8f452f92de7bcd9dadce199f8cbe835ed4a4607d704dc78558880772326a09363199b484196227dd3b7270bbc3dccaf3ec6369a15e1af49be8f7ee05215a6091bc302982058bd9d71e94740dc9c91f150b5637166acf1aaff46d840bcf767f050cc4506f83c1c7e68577f9161ae26c1969c2040c4a77958ca94398e265073860c3c3d79cb17872c79bb3764cabea5aac83c6d56a07ccfdbbbd4ef03e4769678cbaf3127be592cd72dff52619378b9f4c3000f1c87963532f708ad9813833c75e3f4a6000f73a090d71f23a7c309243c72f710ba6be80e630f0958e88339227b1e61d52ab9596b5a2638e9c5066d9ed736ca0a3ce50f44ce489eabe495f51a4199cd03f3288f8a43e9006cf5f780acc0704e2632920b0c42ebe78f3ee111af844145732a0dad7ef97070cc31ac56d437481019a7c5f7040eff12e54932b93bca31e2b48c1c66510c6f526e105be4df342a7af3d4ba67b34d3ec9dcd4c41004d6a9e97e1580487e6c8b8c47e1203a21902a0631c60c368131b26b47e288053c0ce2e000fd7a3dfb2c4c2713417c497044fe3bf568721430918d7b4e42d153306ec73aebe3dc5f99f75ffb6c79744f9160f5c900924d30f055177501012af9bcc336d43102cee69de6c1c8455cc681d3ceb3cfcee9c4e730fa6f1ff820c852452dcfff056da173aae2bf084768dafaf41675e1ddfb3faefe4dee6530ae875ad7308c4f3f5f29b81dc53df5b7f5e73e85e820fbd525139339556a74d58c73a95989feef38fb5d47c08f06d8b1ae9b11aa3951ff563af36d0df0b055f31fadb48b7a357cc81412afed4e3617203b119518327b3327b1ac3c395eda230fe4ce3bcc6803f18d125b8114abc3b4951d68167b162cea79afde3b5f3562f476ab2eef4f5bf7721c291f0a735cbf8270e4ba8c67d6a335035da719c7497cc66f3838a0793733a70b5c0d51ce44c021b6db58ff05ac789632d60b14c5cb27626d45a817506ee666f33a151d279bab763e41c5bd689399c8d073f37befdaa6c8722dcf8e6a5804a8dd3e7b45d2ced3a8cec6b44999843eea3cbba369ce910a9a1328e3ea33b07d337d0753b871e9bba71cb57bc759c135dcc7af55481f66ff8ac526a385d2758c257d130a4b164843b68701c256d297e3cad3abc6337b0d5c2818ca3a462e3392a5af94669fa3bc2569121f8e7008d9de0a6d03b36146c879b8c88ec16ce18bdb87df7e32f9968d9d4c46e93910a0641595f0b9b2064f172b72f4e10c3bce539ce354b1907637662dbdb4a04ea1d356fd72803c59ed9fc4193fa6ae2dbe63d350ee3449507f9d5eddb46baf9e7423b2b96161b906b9ec3bee93874041611a6da42608d6ce0fa9772ab7ab4187db44da64d43ba9b042e3cf67e03df3d4da1ab4e6dddd88b67acc217a6f862accdc31a7e72734d746ca3f6acf057c76a7b186722c2a7f92c90898cbd8d3274f48abf51bd4201d945ed6d02c2f78a2fbccc1df7d0b3a85b2ab844bad79a4a5159e47f42377073e8352b2d53f4c5fb619d4991e68c4e437e786151ebfaeaf9636e3e52de9102c94c178f6f342fc4af00ebe1bad0a1ef364741defee3c8332d29f18e74c0aed322cba3a197f198964ac786b915ef3cff31fcc137d6b325139044027c8475c05ca792491c698e1eaba282d208d610a8c03f7c7043cbb0b8c9f10ae1306a430ebea2fb481fb075a1adeccc065a4dd73414d349423e4c50373148679147363573f548d332ae37068e256d02ee5cfcdb876dd5b3abc385d9ede4ca242c45b529109ee1435c92b56937ec88176a2bc1c5b9aad296b2f419ca9dc209093eb416362e78c43bf8d5181b6328ea76a3cc17d0ec43a49003fd7e52e68e1a0032e62ccc7572ef465554c73b8820ccb20abff190d3e110e47ead9ae27fb60dc3c81fd28a9ad8a242ef796a1e9e2c62d518c9190e0e906330d513b9cec28a1935d0d588696bcb26d91550d8919bf8cf23a0f36440804e7d6aa9aecaeed4a2c2e4e6907a4e9d4d860988bf8ccd1d98b233f714bd94bb8eb937843e4227c09c9e2fc28c1f89ddc43fe61de6dff42d37b439145e43bbd804ea620e5e7330d628b9945d21f123a72048bbcebc602fa117282d5c0ab9bac708ea2f66f591346fd817bda617bbbbc119f7aabd34fbace9016b1890796c1695ee99a3d9fdd5a2b6f2c98435f78a933fab6aa256a4de057995b021dce7b43ea4d8b9a98fce772488404c31b9adea5d90451c0f019c97180e37ce535d6d6c96f1e7a04993c35f81c7da761f8cb497b4bcd0e021a0f00a2dc8ec820735a1897e993d7a90c277e16c7ea5c82538099665d80a20e70015bbaaa19e721469b2589207bd724df160d93da97296f45ce6a321d4e67f588669cc170a90aa25ca31bc347a7545ec326eff1393af99c34b623bd0dff50ba8224e9c6029704c59ccc9528f6fc6ef5ffbc4310efcc0657bcdd6a65c6bdd50b5f0127df3108b465a0633fc9cbf852f03685c7c94195e69bf1d2141511c35df2ebb27fd9b502f74a156b42c5a4f8306d7c939949354955d2f7b28ea2c023f2ab1c70774069585584850c3294b29eb9901f2cdf0848a91ec5b8779cca857ca4dedc10cee2cafa9e7ae69f1982e3cb61dcf0388b0cc5480387b35834ac872b3ec2a1e884d87e69fd5042b9a6afdf7cd2b9ba3036b892317b7610173435355118326318fca6ba617cf235871173f4c40c40923c74a0fa0317295a68ddf578bc6dd62a741419db11e5e777f3fa04cc90b984f1e5d0b1d62ce82e5938ec646ee63be37d1f9fa7febde4b59bc26f729dbb544ebcf1c88d49c340bfe22532149be2cdcbfcd845aa3b13089c702af57d3d98b26da291ba0321a346a0d9feeaa29508295c1dad5b7ee551b43d429efa1cfa240a8b9e3c26ada35fa8d91b4048a527c685c837a9d3fa5ddefb7d3a5ff7a3e3258a9c355cecf85e6c5ba25c5266bade45f24ec3dab5111dc9aae32f1792235346627eab332e264be60cd3e6283ccfc9ab0db22e8bc07f820869e9c680216ebf5b5c727ed9e06411a4880d9c5ccb1c3872f927490c56f8f08e5e9b2b5e984075bc77ffab6fc45a3eb75cac65b1f70a7fc2e4c005996b0c730616ea2a067aaecfec12940807bd54551fad5367cd095076a7f29adf5b313ecc4e8bb66c9961f7a72ad5cc652dfe2e5a4f32e685d7c8f05afd3b7ec908efb463c35569608a374e87a5448739eadbf7e46d5cd753568687e1d70ab26dae28db5b751785986a622ffc7e0fa82881951b03b959887a84cfb3bdb85360a35dd97d3962b391426ec4061ec7f1368a4a8ff7f10567a3547434e7aae50066735a415ff526641730422e60daced33a6d60cdebc7a846bc289a85e736e57752fb27a34321032224b5b162b5793d7c2b021f2ef81ce4a4a1b50581d1badaa0d45891b7aae5cd16c15ff00b9654a4b172d3ab53e73ac3ff6cb5c9d91abfbca3afa79214b4f739ff43e9b9579dab7a525d0bad6d465e5550e714c61a9904c63c546426abeec2a56df123eac4bd34a2c0765d1da01a5f0397245bf0756d2b968feb672cbd165d5541bebb7b545c7575066fd190eea74b1d7cd362fcb8e385b2948ed372b18671ee5958d5d82194b1f53decf2c29a23472be3847ec8c4a357c7cbe634deafc95dde04c6332e3c12ed8f89a76fd9608a4cf2e7fbc14bdf02e30a6587af96e2ead3585e353b3b5678627086c171a0777583ac2191937b832b2b36592cfd216cc7c996db0624beb3d41054a41e71fab877db15261191042da61ab55543c1044adca861aef37f2d8acc6827404b408207f2a2683050854dcf59333e749e8650917d0fdef6de6256425192407cfb5e35bfa9e4a8b0d046889b7e4738fb3ad368f8e14430c6c30f19edf16e689eaf2d9d38bffaca1b05588b85a1e49cd2433b222e929e781fb5eb62cc3fb4844e95d46821b004c12f183fe236cbf8306aa58227a388bba193f0188230c022295cd2f466839e486dcc33b3028d7b6242a6665d4388fa14fcd27132746a57495fa70013cd0f241d87b69d1b7c9af03c059b84a1df597f70737fa3b6664392d1ee53282d7ff960ad2e9a0ce6f0b424c3bb6cd04e290ce0abf38e37a4123cfe91e01769f1689bbc6b8bfd0154ec2eb73c4e673396efaad94d4f109a91681e0d412eb511298fa5715f25a32da6b5179e3ae714b293f6fc030f4c88f5ea2fcdfdeec3049ea60e5ce848f1f3363ed60d0073e1ed85359ed31e8bf56346ae4fa6b46cbfdbe281a61ff6174f931150657325ff017bebfa93bdd38a1d8a63ec53a977d479132088ea99675c20ff785a8bf1ba173109c3724537400640ae3ac9729115b913c5fbeab5a601fb8901cf6c2fa21bfc9d13720313ef67b218f8419ea0dac689afc79228b20785be4b6a455b21c5519e992dea520910009e324a420cbb97aa6a9db39d31a9dd068d260bc641fc120e3e564377232c00022f1e1716f25ca63faad184982479ca190e7ec9cb4eb071f137192335b7aa08a4019fad1b856f51a3d2a7cb818a68f3ba27c7e62f63c7ac811f7d2f7918ef050cd6634d340af0c2008c59baa20dec786cdbf5c844b76e486c2961b6f8f51f4b7586be332533107ebf2d81dfda99bdccce1301324e0f4c6bde3f37537cec2bb50d34de4edf748e8d67a2dd3b1daeefd93cfcfc271b66688ae8b3e7f6910147d67935dbf7d0380c01df173f0c7168e5f14215de79936663daf8cb69531854bb0dd40ce52f8905727a4b11f351e118c64f530b622bdd98227438b9db8fbba0b75a13f97ebee6a3e70086a86f98c03e9f01f0cf3fd5343340b67b5d987ce7cab6b773c9a2813610e8b4964ff5d1679212a0398404807a201ef9979f7fa52e0f2fcaa7dd4f828531a0023975876a650ab6d844ee4e6d9c5a73c30f10f62152eccbd52f109525c7f5514757a3b16ff7abc12892236cb8d39e1c915af6660bba3af3026b8dfe6154d600bb2a626dc026a520f99891c8b5c2ad2680c59f574d454808473194d9160c2052f15d740d8e419e0af8770b96528782475e0285eacdbfba042eb5e1fe61c1e7ae90f50dda6d0d0d51aee07d45cb9b587f34aa58d80b45e01ecfd67a762bc5a5e5474281df572b0c5832cdce146e89e6f1baf7eb69b08ffe6153651dce35ea60efa261916215c614bdaba34e9538219a801e1fc119603f8a8407f74caa181cb283f3604766db96e347f9c46e051ffe4d779dce41f49443b0fcf010f30461a21dbaf41e66c3e3f1afc2c719d3677f26a70abe9a8606f1f6153a926eabf0cc32cf23f7297ad6a62d59a2647c8e7fe7bdabad41eccb49132deea9d9eb557ff120da740766b1fe11b231e533c157bdf64d51d173e7485a76b0f9f1d50086a3f2d467550ef64bfdb4d6083a8fca9312f0f135539f81a756bc375393ad6c9ae81781a63f360b2a2af16345461e5c52a4a0ffcea1e15c64c6e546f0a80ae9bae68b28227a90e73564069c2d01d7dcf22b8b1974d0d1de869b4118a9907aba78334d0d975844b2e845ab1b184cce1d68ec3795b5c525aa78ad3208145b8d52b979ef526b823d7466048602d6baa5be67756cbd270ea1cd8a645561e722d1639f87909b5cf64d7dc9cf3f342fa5aef8a03646c3b5520349203f5bb82c7e02257e33a8a58975028c0ba633cbfb3f7834e95c5694116c37ce56f2d2266179c0743f13080880c655cfcd588a2b4c242f75385950bd2c8ade190557c77fabf28146432a2319acf881aa4209b84b00a5105b94ccc392bd1d64ccc030303a7f91011d735216ca986ca89ea7bc1289c87234587264102af979225bdebb7c9b4045590cb5b0c9f363c35249bfe186e35dab00eafd7245d30c5f10d20a1ba5164d90adf1bdd58a8f93f799d303fcb685311d311670e83fdca95434ea31414e08b07f55168f5a1374e5385abf8dd3fd1d2d429410f240d6b3a7eb72487813c7ee6a4b86561cdde8df4d644fcd6c9b273c14f55bcac4ba97a2f0db2488b53df71c379212c1e3d5582df18e7a3b346bcb3a55b2a7874300662579b8035a6735c3049f53b7990c271f1303739d29072310ac8c2441f845269967f5911a7b93bdc3a2ed05bfceb59264e48e9d1746cdaf36850313e53bc7822bbc0f396479c80f2cf148f39e4c314d503db93c7ae055d8fd468dc6ded649a2869e2e65095e15b899d97455db791d62dac4de7e777a283621c96a0a034f2e6134f1810a094b218ec2ce493480cc2830a122d5be8f95b1463f58421b9394cdf61ed02860a1794dee083e47fa09aa574a0123173ba2b61e256d65ea5021af06f85d69f52b3eec0d2446b98b284e08c322f1056177fb5e979bf183c9922e40d2d55abef5bd16b83536eba3aa985737b7c4fcb205436c36b959924b4627977d07ee83adf216d9e00286a6702b6bd3d9cb0ac0ff36480167305c9771d1c0cf3c8a1ebf6a712417213fe5931dc3a072a1b748added33208c477fc1399a0e355bf3b90cc1cb1a9717156f677a4243da4560e9cf2aac8a5e24b290bff3c9d97872be44f585510a64b6d83228950bfaa665646b989fa0a23c3d5931ed6506751c3128529f8e34736c48f1d9c089636d997c750a8ce707f9b50fe2b05d5487994e35554c03e744c3fb502763411438e3c6140d05e68dcddd1de6127af86338747226805eff11227bbafe9bc2b2969dcf03c96126a7acc21e5b22f7903b71180aa686547f04b488b1d150ea19a9e34ef17f3863a86d67043065f0036dee17de4bfde8d343bae9698fe8c4d1506f45bed090d2fd0aabd6d2ad50e9f0d2f44081e98552be75e9a29a4e9a09a5e4c99c45f65ffa1b03a00c1db16ea0ab1eaa08602963d17a8f61c3c8b4d18885f75a6793a48ac685955ad2185e21d4dd23540244bb06d5ba4dbd98c9ccdf5c7c723fc5be2e489a33304d5db5c3719a59c9166a46d1c9f8faf33697f49eb8e71b681ae320042ca78840d217491c9bff717f3b329f3cc20075fc192b1b407523da66c9bf4c1b223859fbe5955dcd82ce87401265e5a167cb31797f7334768a6fceced9377800be78d1be73a72290acd6cffc7e825966f669019b97945b1888750e6e6cfdd77ac6603815e8bc3847a55225832980e64c6c5c0275758b617aeb72dab19d322f84daf50caf57a4b127792e6df6e9808ac69f5388f50f4dc70e9f9b59efb6de42c930e6687ea21457cb968ace209ce883a734c0c5a927e890a808017ba751894a32686a49b62b712c01ecc0e67ec595f2a54d795279b068534607010f6bcaebc64c1222bb505eb7b1657e7803b499d822ee71f20e320f6537cdba2e212ab9ec619a64859fc10231f443a22b2d95fd0bd65ce74281b66b556178b4d93de2474dc860ac79bd363c7e4e8584b3cb5fa47a5ecb526325ae2d8a611dda0afe2d730eb43c747815ac2b409e5369e6ad9cdde496e74ad29eb99fbdabba4b2bc9e6d67ed4ac4622fb55a288f910f7e08385e5e0f829339b35673914134535bc9b1043b27cd113cc66eda8f45be33206f47d98b904fdf9473d272b0b3938b4d7ec9ef1c019d53f4f5a8bb3687899d0892a91d400716d8b674e35450afd06845f0294da56da2c5f13596baf45cfb3b2bd9ba52dcd0925b7e159348bdaa953c77719ee937ac2bcb4425b6a11c4c333f178f5686da728d24483eac74ea47348a390c92dee6337be9aec4b67ee3868f72536b43e167074bfa0e42eee7657687e164c7701f3ef6f1565c8f377630e3a8b21187b2b05eeb96eeaab09867ae0cf9c5fc8532d255be8162894367f90e14d16186af01eb5884f0e9cb7edc37f007a8815435bb5c31a279f4fd85003e4d65422555b329160b6a7c733693db4b5161ae4807eeae6b72d5a76b6c0d1d4932ecbb237c3b3ffd92080413b7f1b1458dd9f6aeb1b6bfe361085ab5637bb870be0d10ec3d771a03fe66775eac51e6d8a03669eb86a7e2d41ccc0ba5143eb44b95676b09a2e2d2051671db0a58bf8684cc4546b5bcee9bd4ef043a19c4ce0823a5b8e4b27d8d2cd37c7deca4252cfab87e096bdcf944910e7a40900466c43c4cc5fe1cd99145c122ec8a7f32d1e022d502e0ecc98610cfe2942f779c30573f45a182b020392ec90f62cae745b3288f298108d551ac975cf59e95fa7f286fddbcaacd3c5b8efed490006165df1e9a1561737a3988de1b16dd56976b83c936cb6b036fb2bb1dc41c24136049ba64032993ccadba3fbee02f7a5660655a7517b7e21bd149803e3ce6aec4fe506586967665a83c2d217080ff44b7745ca49bcb1b51c636a1e2ab20cd99e425f70e5c07bd3edb70402f185b7d3d452e0c882e1729f77089bb2c08750bc339e714ad78ab6e6fe22a53349484dcfa69ca5868b23c910d474b679357183f56b393501f2c39f119060154075faa10d3370097efa73b9b91de6f04d44957c1089fc596a4a05500da0e2efebe56aa5cf10802943f272d7ac1cad7f6e205dd293d578f4449ba930a3c686d1950c5d22c69803d352a0b08de7f16dd1c76d6bb677f5ab40cd3bf26be4f116a5cfab72353e68c21812372ae0df268ac83f74d1ce25f9b334ba89ae86fded3286985f397e103f63d50b56f1d48319664e339bf4bc58d7890f26fb4f3678edeb7aca0671eca739b1be71cb8d00aab559d4b751e0f5426395fb772f0b3199254d77ba487942eb564a3d40ca7dfdfb47bae71d9de139aefe83901718245d993f7703de3d6f7c9e563df010dc1438689c9b49109fd00ddadb50e02400df10a53baafbfb131d0dbc8e16a24341ebc875dbf01b0277190a76d3120831209082fdbcbe39b99422f1eef84dfc306a532a163dbdf5df192c3e9d1a50f48beb750cd5786bad75ca87acb2e29ec7ada151d38efc6b9f50b1593363bc65e7685753290c06491f9cb1ae4d7090dfeb737d810235fcac5275725868801646de707e45e6a0031562ebd1841950872b68833e9e3ce72f7edbb459baba61fe7caa9b54c9bb959ae025c6876ff5e1304ee77a3b852661ed415871f264e6e6bf3940d7f7290974abe6090a10c556a279fe9377cb4502f1cc4902a531dce6b7627f218eefb4a2302abea69c74782be4cd25789cac3924295885b4b65327545fecc0c17781f73631041082db98a3fd1d919e4541c1049fe5c47267e9f227404d391679f52440acacc5e443eea73ce0e1ed6046da05ba24669cc0075fd9224a9fdecb916142fee5affbca01506079784ad725657bd86fe8f279b203a4fd89768c206112b828357d19d9c9075181d7fd99c8496d5c38125c25731113995a7a0a10b949bb523fc5c95b51de4b79adc34f3452570e1886ecacfbe23a88304f5168a473a5efc4dd80feab4f1bb9d0b085ff2c64ef9d272cba751cf9f0daf5c2ab1471a8f165f7d853e65ef4bc3c6bfb004e76ff1226c6d3e68cc0c228276b972c3a088ccb82461c3345d4bf3f824d7b389ecf7b554a4acd57502a8308a007b1b82c3d2d23dfb8f620029c1e36b5c8f24aa1009a784e0dabd4a2ba76b4a01a6113cb6e8f18526cd95932a760a2ff2be53caedcb1574fb8989ff0e8cb5e64511dadf9b7203670b75028e052ef9a072ca9e9dabd7c9cf7f8275cd95eeebfec339a28c7ff34b3a0d3a1932ccbd64538dda8e1969 Hey, password is required here.","tags":["年度总结"],"categories":["随笔"]},{"title":"2023年度总结","path":"/3216805600.html","content":"c8f9345acf8a8db129dc4f70a76800da3f60eeb4a3e3ffa5d5ac92af02cdad3ed6f748c8c5f826809eb025b5f895c858476e7010d41cd75f560cc3975ba11b364f27778053467c684c51c4509de9c8a9c3bb6ed980b32d4223cd993608cfb2d9697ae5b4ecde5f5d84ee2efe14a99173c54798ba5da32030a3b207828a25ff7c880312209a9203a87f8398f1fa4392a8e9c4f4da2529e8ad32d34742cd7afbcfcf073a0b9ca3a99173a412a01a96f31e4f556b8c85282448fcd574e5d1a63e043637e09262d39083a79ec2e5e2625a9a0ca4570387edc0c55a2443498d2c5bcd6ffd6edcf73d5b1781bce2eff638b94877fbe4019f6cf845f3b66be8bf002405e5556ba1db8138b6cdbfa3673acc3c314f7496322d71dced2d45997f00822261738ebb6617ae1ffe7de544d664d2195ac34a49bdd8a1ca3261d2562f3db390e63efe45e282ffe61133c3c8936e6cc90fdeaf3e3cfa1ac1b9c29f55d6d0c0399a689d06abf5245c2a8bdaecdf0df2ebdca45262f8396b2619a909a87fdb900a922f28159a7840b49fd084265147c84083cae1d50fec714d5be9104f30aed4e0278947f39b69157b4f8060831fb7366158abd1c7803fcc87ce63fd2fe994d80b65b1bd1f28cc4d240314aa77e4c0baf0e12d473d3007cdf13f4730f2ddecad37e0ceb006f5feab0f1c9f133a18130954bcb111dab8f4aae634e7662ca019fbd837d8f19541b66213a7544e8ff0172a1651490242f438ed07fa0f13afb83179c0644fe0f82b3a8a50d589529b67fe0feac66c6f1538dff853b056ef7726a08b9a9b1e54df94f031edc4e89d68ab364b3ed97f5d718de6bdf376a70271f3598468793dd5aaeec1c5eb8eb77669ffd51df99ae364078f5bee6563368a3fc74a81008112d702dab99f452c4c311ebc4d5133d5a4932f14074e1920f246f79303efbef64673de7f02ae99f709f14a6e41987f3de2963a6f20afb9da70381b795307dabad246870137b453f19a5a19fb91e33a752f1c5f8d881d0e2a09cefd29307c1c67aad40d370c9b635456ea512ec74d08af85c5e465e1f1372296009572413083311b4366c4f748736eaed5c2b075c9bdb1c98ec72834f9b90826296bb1efcce22b190321dcd9cba54d6690979219a36daf35b027c4efea4210d500c42431f32cb8feb3d5986eaed0c1d349a4ad7e809a86092545138e563cde9221adda0805474e9d9f4405b23330e12d333d33f7285c3754b48dbd9d45e15600d786112f2e89ec658b985622ae139065014ff24b7d7c22c01321d1796aba5dd779b792d889223633c24b4654b435bd59144470123b759e664545854b949429832f0263bdbab7435572ba9c6b6e50a734e8dc6f17085fa6e46a7ec8656d63e9b5efccb4d8054fe31a1fec0caab3576fa79fde8322fd0c09c4d69c5fb514a28c9159c3c153fd722cab7961b2009bfb877fb0b1b74c7988d57df98c0a7fea6dc1ca92fb451ef0f339a6488779ad1281d37a548c8d73e2946f78ed1c6424f714492103d5037475e62e77b3c26bda616453ca4a841dd952bbb9a87ec7e9233b3fd7f193e69e18ff501696ce595191206d258382e5e468b8c9e9c259c69e0de35ca6e2eb2fb6e559c175cf63b6637ba808398c42a74fe8d9b0245e32ed37ec3a2043f3ebd6ceb9650e4b90644162900a3ad87dec1fbe7d5f5ca8d0deb459972f5f2fa30e45dab889987f7b232e73d6ca9d3ccc1e908673d29462198aaafe5025bdfa7fd373865d13a0ffdd45c047434140003771d5f1fdc6ed6a3a909d615f5490dd3c886be0a324c9490fd2fc49f3e87e7bf7d7103504ca9797d6cda504d46c47d177994bce7cdbc0a2a75e3a1ab65071fa9e1be9ada42dab83e00c1a76f772c96b8036be1c2e540e8768a73f670a3da2ade44ef733af8d8dd1517a3d23fdf09a178974da6d6b5f4a96d0f8cfa1c07f13fc766a48807724cefe24dcfa7fe4f08d8b604469036b8ea3a89e1f4289a1b086dca70b752147fd80b808bdc28ba6fe40c28462433a0b08f9905703a707d7e32435d369d07fd68606f2737105eb71d75603a6500274c9d14b870ee093744b0d1bd1e0ba00260efa38118f8f328df10e1c8fe4a968e0a791e67898d74477ffc7328bfb389bebbf7d01095081ea566920a63f272763122a142e7974b1c10fe09373eeb4529966016292404f317e28588d8f5fc3c2a6b7a029ef124adfaca626c47fa934a705238ca33e0df2348a0febbfa35d2e0aa05c6b23382dc8196048e0270928c0a496a2cce37e6e213df56b1b6c714fc32e02d79637a3c217290feeccbcf9d26a3e41cd20815e023107bc9b827c7dbea699492f0435f81075ebf7d4b9eae4ff6ec7b6cc31c0a2d17a36c923e54e0ac29eb9ac45c68816d9a4cafb0a22f995503c57a235309f56af5e13c14fb6c2db2fcd84536edb07c56eaecaa4b098df14c28bd72cdd58407d72835860be71ebe78b18e4083383530cd0322983751d3de0ac5761da7e3506d5818b64ebc0a650bc9896bdf0f8c1f2a0cdde51f111dcae8d0b7c77850cdd81ac26d574461a81476255f9890afa0c92563aed5b3a43c5784bcd88f6c4631e39bbc262025f2c06051489fd5c1fc25a3d0f2a474aa5e19ab7813ae5cfe2a8f0931b4a51b8b58c7e325d29058a4845720497c0a4335ff53d14b1da67d3d975afdda96a5879938889ed53df48810eb7dc0a5a512de7db0580fd536d1dee64cfaa810cb93a5cfcb086238a5ce7674d792126e3cbd9a10d665c7fa2eb0214786694180654304ed22a74f82c1202c70c024d1a1dfebfe50ebedb894903a2b5a1f32128725edfff3ecf938c6934624f2800fb246bdb82b6c06884cf0bf3ece93cb6f437c92dbba0d211bd24d09b6dcae226d0255a4845165060422176cdaaaff36deb9c86abc3a2a0829e41404eb016afb2a1a3ee189b58a6b52dcca894f220de9d4c487be9298fddd68d8b9a89f504f75dd0052bab4e7337c9eab6eb9cb2771a4b77d31874c6f7aaf6361d3b018fec8835e721c47ffc34259343de7e2b40a44895f85625b772cbdf0048d76b8d9f41789bddf1d865f032aeb5d245806a3653f702a4a7b07a00ba367a89102b6df9e0a904eba19e56e0520fe8fe4d4f997a32af7b5c8498d84b5bf6b13bfb61d4817f81d0dad6652587dd557b770a1c17d2557056c746769aeaba9b3270d563099066bb4e8f8a2d2ad1b617ada373bdfc13ead56d2b183efebdae0ed05943acf4830b5fe6d3d3997006949550e185d9b6dec1e9dff7e755d36f1609500b655975dd12eb3b7a1ce0d195928f6fac657ddece1b644bbbde5b46489adbba029ac5946bb4a1b40d2a3c6696f7883d16775ba530ec67dc75544a242a0c51b27639744139d1799997b70bba17eb206c76246ee682c31268879d32762a0b811aa1c32978d7145d29dc360771ceb5c64edb4ef116fc4d8ba458bdc9e2b462302e16ed5b060998febc5801e50955804473842459503379ab054e8ef04691eca8bd236bf4d743d309c6c27ff2ffdd24cf9e6a2eb56feb0ef9797fc12e4b3c78ddaf193fe0a35d108091585b099a20b21d23c4a8f2a3056105fda2c1ff6c33ab55f9ce35d17ade0c9c9f5c2667f859fabe21b1d66caf8b4563df409c2d79e5c48dfe64af81390b10a762b34fcae2cdb9e021e3008c3106cf1c10833063bc687715a61bb580964ba179c65a4ac590797947ae1b5be6ea7161922821af566adbeca0da4dbf24355877c17942a8d2c9693b4725e59f3c92b85ca57c084d9f7404b781e014022c74147f6735cebf0d6c382db83e1c9be25f7047e4cea52302b7fc56f1a92bba56e1352a49edb0bd49f9c9fd99c037ea831d468fff5696310999012b92aadf951e4dc2d4d911e48c14a789d96a8a669dc373cbeaa814fe4b66438df3fb91ea2244b5b3bf5cc108ff710c56036d3a7377a2553e49200e780f37c660c5ac5f80c94099461f1d13b17ff902e0e4d6ff02146987de92b8a992f1baea8773b8a00e3f382cdaab92b962e0695579aa851c6efd488379d2bdba4ba7dd3b2572a860c12bbfc707f656cbd5a91dfb0c8af4000ce3712516a779a9c0fc89003389a141b649918ffb6d21c550787fee81958d28855638f5af5fe4bab1dc3cdad66d9e399dd088a79631778eddf077c9e394f4cb3472286216e0409f7cd248662c234513664ec7201b7def663d6f9212d87932e36513657f304b96469e6c6fc259efcf009a8cff2511068ba41f0a712a848df6aa96d50c02ba7cbdabba68434a958e42e5f75141dc4741fc5071307d0e8ff6e560d60c731def4e16aede9cd13389a6f88519a7c28cbcba89f2344f27bf0ab80eafb6072f929403f3b35d2f56612678765187cecd4c1851218bcd166012c55fcaaa8bede79b9f6a6c5f95ed4477604b1a543a139983d2e540a9499fd0266182a1fa8f1ed8d12a96bccfa6e602a47d7d48ddf1b606a383aa15a51e7609a651c846106a2e701b15354735302434f3c876dfe1e446913592699f5c41d9fc618292d2960e3181d8df3e1e183ae4c010d7801591b9d06ff3141331c89fff2b124b59e6c0e5512e3ca2efa80703048e12fa3d58e5cb7d7120fc6128672af4d3ad6594622cf8f952410535cf7a041381862927946b5d453af215d09c5244f91d12751b9a1842e1682a6d094eef516714968a87da34d2e7509968947c6cfa8aae384a2aad80d0a94f3d869d499b61fcd1329815d83be7140a113364f931aa2c7e51cff0ca41223d6c9da29531efba5f45cdeda948a0757adb402a976874a7b22abe8c01fc80f0187a4e329dd0065dcbdc66024528c034e4fb124d047c91845e1ad226aa4390683c6611d6cf017f5174f67ac4b154e355dc2b2c4421b1f8f388cff5316c457404efe00278b3e3a3b7aa177b9d91bee120b36b8e01cbaf3d4156189b50eed37c9cdcf056d0827e4ce97dced1742e43384de18c8382c6877d4f1536bae02b46cbfddcc4d1a0903006fbb27efff16a6a9b5b85e70aa1d91f822522a43fb972b569b79675a6004ffc27b0e7181c1be43dedb635d9d2128315284771240ca2cff099ea1f1b089767c8f36a4af422c7642da010c457ca66f1ab675f3cac5cd0d703b309b17867075836bdf45aa69e2b8a144255a4a27a0078a9751cedc45c57c24093e6baa77e97dcf29bd3e18af3d850bb7eed1f82112ad66502c107d2c0464011488a62aaf157bf646b2bab27e111cf9914bbacac1a9b4593ec43b61486a5c11cc3fdf5e5362e2b382da862b5622daac8fbc8aaf5329155b056adda4d7c52fe38ab0327ad0556e4d5263a92fdfdee49eb26cc3a4972e9bde7c3edafa73912c00db0c087ae5656bbd5ad1244ba2654c9d40ba092ef465db386d2f8724253d287421773c08379ea1c4d616d4040faf14e94aa113d4f33a537fb3c395034ed516daaafa0a02cc7d4d739d82c167c395579df6c74731d5cca39f49a10d482d6bc0bd8620f3d5dcb947b70642395ff1687676db78cb54ea71f08fb4344fff755d7bd987edc801ed81c9a8f9cd35b857663e91dd1a788896deebbb5811bfb1355bd63dbf565ff3cb1c36933fd45e108a1d00c71ff4fe35b655102017170763d6842986ca4e6d3ecc09118633990aaa0d760206d392b600c457393a270a2cb96d028294eee349e1de3158075ba16667621aded687a4b25c828943dcc31dc5179c5cc66e021532cf0be0d517b540094b55f7220405c1360e6768b92fb97a9e77e688b085ccbc5b6be2d31593c920728af20fc4b14d98a02d160bbf23f635525d3cecf8207446e873637353d72320da7145ff165f4868d3758d1cddc4af089cbfb9ee21dad0ef6d637935d5c1ac6eeabfe7df1d8dd6fbad19af3f937cbef1dad3ab2da0b9e62992f8ee13819ca622ff52933b3bf7375898a281425463947f4caa1c8e6bf8698b318e4016cbfbc632b6806d863feb91fba1507f96e004e1ef83b25f3b1ef2155a38fc90acea85ca0939599ecb731c04ab9598902d59d06287248cd03214226f55851684d199d9855327c7a2fceb7ad1097edfab5f120c5430d3e64e3b202f03abac1dfaa693394e12f0f5084439e6804b61d4e718673a7a3164ef0cc4ee1c7390a28643415789cff46e60510eeba9de3bf2f99f92b6d9d8ae74430c01b36858663c5088f217b420cf09d3e5f739fbe4261f257b3777945dfb7b665fe9d6b50060dce5b6b3f24690002e49a49025d81476c0de29c539a5c64c06c8eb4730878e2fe9cf7d27922e3422df2991092c3d312c5cb2e9074c060a0f73dc5619c1a714e73e5ae8d8f1f407d816bd92430729aaaeee7c366cdb55beb887d087ebee613fe78a6155800a376769886e41a94fd04b35eb37e3f71ec130383d91b9f9374118c325c00077df8de35a5ccd70ef8421d5ec6543dadb56d3cfa759f25a63de6f887b24c7ba76ba0b9dee708b24ea2342297d642f6464b07d1a541886256a25a7400a544eb352c2a798ef3dff3f58f21813664555babbc1645ca681e5db03f55ebdbf5ea7372323a46bffffcae84e9a9bfdbe6a8d8eecb74bee026fa1ea57e745c416f7292ecfba99d37aebfca11c741a8d0d0d89aab2d2f1ba5886fbb39439af911191eb08eeb28d1895e97f152bf4a493f101aa13def244c06f52093428601643b4b8624e6f56a2058590b9ed2f07c878c6d6b98a48dc57e5fa59ba2e24951046f5314795029e91466426d907b1b244940ded50229608542375e48dbc9d4232195031e63c217bc3a0b45d3a83ff1f5fc533ad78f7cb72cb815374ccf7ca5c8c675aeda27ad926f324cddd8d29b33a010e8725dcbac73b5b0dd216bb6f4511d80564805233a69e69d28365a1cedad1f37967904adb882e4841e5ffcc49bb82601440483f067e7948bc5d602217cd956cf8e9f38f31400b2bfbbb8f92fa4e3d1d7d9cbc3c704037094d3fbcea10828db02e3ca127d9029820a4a9e349b42d0a32e925e8f752f18f35bc6b3bd8902f124b629dc180b24bdc4d9788dac4c4ef2a14fec72842f96fc8676d3f472d8179d0050857ee483dab927cd36bbf3c1bc120091a749185867d1750716a742b5df0bc94fc2a3a9a017cb1058a103c3b4b69d3cbf4c4670b2538e867f5ef382e30718c61ea78a5ff2612c0124dd0402be654b01c17f66dc64f2a6243be3d8ab9e5f4e738798d0bd234ea6952e278c711cb1545d4ebceb8f4c02c064b0b24655e92678add53906c4fee166d68afbcc0097535b69bcc0c868f9e3bf419c060159de34263145a6cd9ca493fc2b11365c611feee9a2a9c5d20c622eaaf6bdea4d754f3e630fd1c23b89473e8efdc3d09ec8acb660d16b9aef9ca5a764584e8c547c3dbdf69c45a21e0081700e2b6d83365d0142f82ca80f10f2ec9be90daf93551c5df186b5688323c29d476038b004f105a8c14574e36457551a570563f9a6e99cfb9fd0b441fa1c3bcb5dc183bd3c37d14d836e12d8f64bc02928b8cb3a152bee60936c9afc37366bd9d2a4cf3a903031cc0c3df037f02eb630a1a8a581d3ffabbdbde757fe8e034da50df33ad5d121251bdffd576c4e154644c3f0eb3f3c58f2bae6ee62e900fe46e91c1b8570f89d54542aedf9748d7e6abef31563add7bc44a8eea16a49317eeccd9bdc33a18978f8c74ce686f66c403a326ccfdf255b24bedabbd2da3e6352cb7bb7d9d672e51626c9e242da42ecfcc6199e39988c2bf3e19377dea31ed01f158b2b66885f95d627d28221e7304266bbd1b768d6de7409e47febbeaed8175882b904dfda75111eedc257ac1ce89720a079bf8a31d717a0ad7db5e1bf007d2b5cfa182fb0e31c335de4365e029f3eacd46653a46678a5dd35529826f15dd2aa083d06fedbdcb6e6f342355e94f94db01c3651c7ca836c6e57c9f6bb5d567ec15c594b452d010287b576d2c2995817f23126b4be219f23f64573a991d9a82f3b11e0f10974a794f010e613df0a5423ba88374e13b6e899b254eba12bc330fd8eefe9d30d286a548e34cf493f39c01153615a4a870813f4a9a3829ffd87cd76064ffbaaf12e0cb96c685fdce1e7b73e5a82de88ed8ad25cdc4480c789d107af4919810c5b6c90c83b799cbab0d950659d4d2a5dc3b2426bcdcf623a2f4b84a62f9468e159ccc513ca64bb52aef433cad0774cc7e677638ec5840f520a7ee172221e73f44ff5002538535ed5ca71fe9dbdbb9f42cf9d401209e5e776265863a182f0260225575039acd1cd4a6699230a35a00b76988e73f0a449bf99dea6c3d10550fcdbfff856f4da5d392ab1c6c0aef0039c029bbb96b045e106ba73fb0bbecb3811a119122b5685e4447509ecb4bdeba7f9b3a1756275ab247c56849b4da5434a87e2c98d98b437e3a9d403cf917a7ae94ecee3cf4bbbabf6f0922d0f139db0c4cee14701f840aa22d5eba6f9af9ded874781c25a7977843a664d1605451e3d4b5919da66090ca89a64d2bd8714cfd7b9d959f25be28ae02d392ef04f341c3a1684409a074a5fe49547d7803eb14f0b7365d7ef6d7314134e36a4ba30e5f3974f2f8fdfa9c733e9baaa2608e793a837b49e05dda1ad7def413eb32c4408e4364dde505dcaeebecff9c983eb73d0fc4e8138adcf368d8dd6d1bb58dfa96acce919ec77e104bd43efd77ea2e42f079fc8b5ba227faa402ccf312bfe8a154773b72627af83fc25fc7f313f275003b30a59a8ef2a40d864132ea25af7b027fb1aa8e974869e959552ef325db2ce6572f6477d49abafc17a957a53bcd26b5a10426204bb1b129c844005ddc9033c509d6fbe8c1e3bc508a6596ce63df8900f8945b2bcc1c13ce27cedec2c3f7c23b88f3a6eae854b6d7cbe412f96d0bdfbf80361412462d019655a3ec8d5f167403ced8a2e974c43e2f2960e0bbdbd47a21290d4acd1f14a1a6b550440aa993b4e5b3585f840706e8b2a1e1ab40e51aad43c3585a56f711800134756edd751b9d72269bd34f068586dbea213bfee31c72da01e80843a4076c9e47d4180df289959105ba019bead00befa3de21853bfa9cd8cad4742f3db07b2122ae4b9ca69865cf6ff290b151347afe6a4e907d31fe8aa29c6f40d89db03488575fd313f07212bc5b2addc3e7f4d449eb59dd867dc6fb26bae9563e4a25d16b2973d784212430aa843ea2c7863eada775e2f8124fe0af788048294b14adddfd880bf91eea19c0b19e5e9e04dbb90ab37b50766bebeb1fd430b312675fd7a4c997436ab27bf79a3bf1ada3692a43c61aca7bdbf9252bc7ef929d3aad187e4a47f94f15a1deb9984a52e16a361f90d26d26723f9635faaffeec02d4ec6a999edd650d473af9b8764556d062d4fdc86ab0049884bee57d9989ed0aa58076a8bdf4261b60e56d51c62eae431117fcd6af82c0fefbe6dfee63a8117693aa4a0218e652e28f3e0379ab4319b3a6b6003dee566f0962c670913ad87dfe4ea7fb876adde846be04fcec7f22ef34e836dd4da2cc44d10203e66116575eeb2850da2344549d2e8a878a7644e3b842fe10fc4d4264150aa37bc72a94268dd0122fdd7fd1fd05ddefb1a77539dd9e0271cc131fbc33c83e0d1df14527f7d0e1d0ce906fe8edbf818884e87a3cd83b96198fe244f0e161cf3b731f1417ff039631a72d28d29eebf32e06db4bab05dbee3ded4aeba4fecfa7e0cef4850958baafbfe69556de26631562a80249f2337c46569ad8a323a4698240b72da42347e0c97ffe4bb9e2660b1ffd79f155c2c62084230aa1d09a3ccd7b7d9c5cf254b83de613ebbeaeb34631d294f970319d5b5ecbd0821c9ddea817cd34a206b3ae3140fd6dae20d3b085359803afd7c7cafd422ed9dcffdfa50245ff388afa48e53e642815a8c5f25a79225e814da133962c3f2c826269c7f684e1db2a83a273247d56bb2d188e92a6c892d0b2e8eb6112ba7ff01c929ded7ada15e1436b310cc148898298d91e6fda2ee8ba8299cf678c551e4ceba79517d10349ff2df525f78abbcd38382907a6fe390e92b87cb59b8e26c6095f827bff8ffbe010d136bfed0f64b76d293c4d7e734879b40060fc3377e5572f3cfe5697ddb04f368ca57d5b44051f7b6fd6c0837f99d3838626b56b874ee304e31a1e43c197337b7851b5ef3c8a40eb61dfc16f54588e88d4eb11a71cff118881ceb48561623e0c30d3b04b22cef97085e4c2c988998835061ad71ed7aecae89a0aace93fd48ff266b64c357322f99c138073be06fea1e9e85edb89c7ed3c201f83c0b423c8dd7129cf5a7d31232816d821b830162d420aff18f0e05a508d29c6e80d235ec380bdcd1c1ba5ab2754d69efcb639beb44a4b180d59cb26aee9241df5f0ce2c5e9ba01c523b98a37bc0ae2132bbaceb5c912622e9c954fc12da92687f0476a17f52920a96e9f2945ac36f61133eb9a085d8d52aa643c66cab425a81226965d2d4604e02bd5ea1569cf4d5f120b285d211ec91103b170b9e788eb6f5868432adbe5294e1e1875dedad421f2f7fa19111534c36838aad60facf9aea82eae172d3f1d4a6af99b93ee379f3942a05085a542673527f80e47b8458440930a2d8d52de4e76375bc1af35c692ad056561c6a829d2e52f5a76aedaef73eb07f59449b976c88cd139b4ab57bbea68dcc803e53ff3437cc3ca67caf2a97068c3bf3db357153fdaeaa5534a06c054808020b9080a3f76145d3b423883b6ee8ae164f87e8a43a12c7991e51872ab7d894f688f8702b294a64f09e66fc555d98dfe3b9b615e144fec1cd8321aff051ab3ef4e6e9afb620a2116dd70f7b899fa4a2c95e513e5a353d7a15f41f6fd3a34292def1415e7ebadb451d1876b774b0840ee6f18c5fbd7820c3175ede8556ddc9eed026054eaf45866a68a660d195a3d8fdf04ab7ef387aa5654f0b11e40c97f8718ce3bd85cd74d26bd4a6bc15b257e8e0a38ad8db24d266602b3de0a1225df4c8467672dbc5d025ac05d189c57014c596549e52073a27727372ba450bfaa3a7cd201344f464f854fc4ad8fd6d99b45d455568168051cb8a10fcc044165597ea2dade18faac965092ea8a8104a0e25a33ff9391991b1bb937e75878897320adb49f3db48ae0de2ec9bc3498274fea0f59cd70d98cf2bcffde41b847a041f322f0cdfdff7f18941b68c0b50e3194ae7cdf2d6e4f0110c6e0543d2bd3131ca609411171b7a9dfd4fa7353ec5223ac0dc326cc9662e2018cdffdae9a54dad90e15414801ffd956e82fb7cdac3d4bad847ef728511cbd44739c2c9077879a99f085bf0a6f4495da73c7f9e275f0e30777bf19c062d7ed9cfa10592f4fdd5f6b6541277d066153d5b8ad3b2d5acbdae6d02806a3f0c0dc8dab19f001eab63f73ed06c4186dd2b0f14e801cf7e23177a92f60cc59d14517db173e6f991d77b653185705be12abf007fad7022c751ca3f663069271ad6b0a48f48ca175ed87c37a7b6499db85dd8a5fa638ab0b26d9710067274842d1ba33f5cc8d27f760d99d05cb3dbae76450b3170ed6924110f2b57ea9f80524340d710232330f5d98458e9724663b2da45b2a68ee549358f652c92119ccc274d92e643fbafce7190cbcb10a678b45f4e9b7ede5f7d09377858ca3c147a1931ce0e4cf6fa863b648947642840c2db33e89e467a46347290d3745bebf374631dd65ede4bdc4a53a862398b125e623b86511635559571e2267745057e9834982beaadf1194849db977c586a64fa1b37645396a73c7045693ae3e5fc2823bb77a3b087f2f22d83fbecfc9c2aee9fdb498cafb1a2b119ec0cc01c82aed6a0044f64bb6589a08f79b32f2c0b0b738f8bbe37ff6c0cf1c8d480ff318c4ae5eae1fe4a0a38e23450f41d2e8680d2918e0fdfd05d74569c7862f1b6f36297da755323a08067d869421f946946cfb941a01f6ca3952621925b77738f433eb626b36588fab2e9a15e88c4e52eebac9948a70f0230b9b4526daa804a0d323c0232c87bde6b5da8d330cce3b69daf6b396b6cbaf40f2ea421559e0a8e4e3f121b52b5f4b6d2029639cf2c4c3d8eb03277f0274433dba4670911559f5a5d33b01d108f3a9646debe5ee675dbfd6abb23aa93a02addde01234ef0cd7a9685ba25873f840182868b42f9bf67d75355003e90348069d157144ed4f61d704eec7af554513466d3f288b3dd506aa68f2d88ac190129c193ba705d85b6669aab7dbbd216ecdba5d2f0ce3e844241b3e29beee0d4bcd9ced480eaf16568c4ed97e58c7c74a5e474e18a56d0f99dd794086b9c84119e3670a1d05d0fb5000d03644db62222f53d2af7328fada5ea9886d4a0c675de3bb02cdf4ae593c28b66df335f616140487339f947a03e7df1c306ec54d6826afe1ba147cef1ea141be53c6d4cbf885c9aedbd8e700373a2e20520b610a0cdfe6dac4d8a96b8fb53a5a414ccf37e5be9103fac029a9ec0b9eb3135b2d27fbe61d09eb1a68c49fa3bbb94d26c11f9cc44af145574b6d9f3f4a9b364c91b8435816bc065863429ef6896921fcde52ea571c6cc959d75ffd246009681866b8ae6e80e50a88c4f5ad7832d26f6a9a0e762f586e2a07a4990fee6da15b8293f06391a298758179536a99e4a30ccc30da3dbcaae7c06105c69dec14dd1950a48a8bfb2125562b2a2b1c51c611753ba10638e63c77e1b7650e9e25030e472e3f1bea7f076eb794734b6f8a29b375d0a421c11a4c6ee962d90cd93061748fdba2c231a158d448861e7e08c750f8c987b4378809a58d7277086df636a4f15abe7400ba532a8b4659f37b69003062fb73b0929e3e7ad8d94497cb156186bf8d019f020f057292537e75f6a4d1c46509b021ff70287436cd4b7ba406d228406fe9ffb67b99e1e5d0a8fb53c8071fc7efeb12a7f2a68c2e79aab3eec4e884fdae93f6aade0aa36f641a04c6f0a2a19d416fdc55454511db27b22e841dee76ddded869a4d6ab01cc8c3077631820e4a44398fe950917ce906dc62befd6e6f81bebbddb7f3735331f4380daac6b88aab7a4dcd3acd895f7ef00a755cc1f6b1eca50e184773541b23b62c8d9bfb5185854380a0cb902858e7c1348db1a7179ae8c1b802a7eed18f5b160a3175c0be4be0c6f5fdf87366ea4d360096cac86ceb336553ede044b9e3d9309c69cd07c2d4a2daf56604f87e7dddb871d7b8a2e77e64f4cbb72a78f255d23f2152f5821074d2759fb958a6918e87993848b179956845f3395dbb28a1b39cc36b51d4004118dddbc7dfd39d49873ed43f9b4380f128226cf9a4f74518cad10c44445e114e496a365ca0423c396aa0fb663faccdf3099b5d9281c8950ccf5f005df52a80dc4a7901e8b972246298740b06e091e0fc5eb0b436ac308989a7a748f15e6c268ac9dc82d41d0b993268f1da4eae9bab0aa077fb1c8240631ec65559e2f7d2dcb554a941fab35dcb7ec5c98e937093c88d6f2a4f09b127d67b3eacd1cbc41b52f5ed39c7ae87b2f9b0c8490a393b993093fd68805ba6c58f0eeba0b9a9b12a1ec901ff669f8bff286b1728f67b1cd528f02298d9e3d7a9071c064bc629a97072217664f844a67224999ad032adaa9b0789ea798933142a8ca31bc057e87f378bd34c4a0878c61cea202413bb4dc78e4c6c96a46816a1143b802f9131a41ea5377514c29811410397cc0114035d968bcaa40f62026e2baa1c5bb2f1e8902559dbaa8c986d3c96780274611a3c6aa9f70b4a005fbfd21ff5e5ba728b72819155c7c3ee90c93ef8b182dda457bddf94f4061cc1ea901b45a1d12514831197721f737a6a0729313a5aa11b3b600d4df5f889aa06cacacb29de5f714e6a4177d1a826df80d587cfaac515d32909d6442a1b513384c48b2830bd5076a0fb0593fe6f0865624bad64c6102b847ae42a4845cb8a7ae895d3f98dff5e165299a5ce67595e3ba2d6919aaf34b9e1b92e36df1644b71f02fd458659589be1e5f2b73150ef9a415b21a66454db2574e334b43c1250e38654d4b8828f88f53244f97ca041581a5c71187685b0d4ce7f35767e3d655e8adfbd3d3e0193e6c53520c54d85b1c082e7ebe003d107c244f603a58ba8fcff96886c8db961c9e466f22cd911e26c52bd949a85e959364b605573050faacb3e043de050f0866bcdf2a8d4a83bb49ac3c97c18a0eb189460a1099525f375a9930f0a546e701c4c16b8e1af7c7014290ed19dcd2975e425e73c25290b37d7aa0d60dc08ffcfcac7caf3fb8346e2393bfb0d0be5c441c9b59c32b7d0286ede9b5cf3aa837516a5dfe436169229244b9421c7c295d8960a749fc2c3298708b9d0f1e3ab72eb56124c7d52aca8ffc815371ee405b64e095c5f3b79b3827a4d1bff3d0c67c23c15ea8122de64c81528827924eaec087aee615f22b51c8d7ed27d42781555fbfada84eb080e1781fccf8aa14242ce370e534843bed304739ec3d1b9ef2cd78772b06156554753d56b5a529a57f30ab5e99a4eae1e46b11435c01ff0158c9011fcacc90a3c6a49bc0ba97929f04a323c2bb1b3efb552e9ee1796ebed1ffabf35b02ffd29a5a5e54e50f3284a75f70486d768bd16e4961b7f075249767682da71b7ccbda8e5223e466e883cdd4e1445d565c266752a703dafe3648830cbaa63342fef5e1f0fd4cbdab37130b0baf1411606c6fc8ca252e0a358d3a81605b6fd56ac931c225f4b6ab8a48bfcea16ed1177f8495de14a1abb86cf865894b995c1a9692ed7ecd0b52c2cb7d5134fa67fb9071edf9571badeeacc1662cf7659397ac5f5799682f9263774df9c8ac0762f867a4f835cb6a792ee856627ab884195acb4432f647dc5a78b12cc5e914d10d18d8172433a5f959a071b84165d685d31f02c6ddcbf816bb851f84604238b2bcab1a1608d23972566286018ae85e19f1dd146d55026afc66452946fdd8d6b756bb9399d22ee430a3252fc70594ef8562e2fe8f96247087ee8d8273fd86d0f4a2ada77dc7329c20cd660b08bd195f9e1d6cd49db69ef2c72f251fade24591f46048f0e27c70760b919e9bd55c53b487a0f982e50766f3849265957c0de7e9015cf45ae70cc0dbb2ad27a8131f1334ce94e87f8b3c3d3107ab7281bba58cc866d2e9e86c7c1a596941629ba653cd90a332b67a19159352a37ad187439de44f15d1c1fe525c57f8da886254dbbac9dd19fabd0548499e80b47a0d6603fbdcc73a2b8cc83ef700a73eb7a394eded2f1778fc64aca409246569e1e96dacb3cca8c760f05bab5ed35707879f0b4246dc4fe7cf1ee7799ebbc73f6ae8ebfdf1829341091fb4059bb8e4490eb819823b62fb257418dbde8503c2ee35d4fe0dd392e7acafa76e90b9566358101258eb2132d0a15809ce3292ceb51328cb1bc285fa16db9abc51e30a78188723986136fcb9af14dfcefe218b94860093581ca1a37f95b289325ca97b8743d26143799e953d82e7b5e2b0e2c58058e4f937b8b167dee50847d94210b3dbee5c9ed3d075696c297bb0c625945c94b4dc62315b18d5e78da4f6adf2f74d55f875b6d7213dd1ac85f2336373d386014bb72024b178b1bac04b07c0ef29215d0ed947ddbfdee702d7e65634804170f1071309d73a8e4bbf9cc4a1cbd8216d1cd83f80e5090e9498324a12b061182c873c246237fea73758d94f85f0894d0500ee2c9df41e4a1a18c51d4ecb9ad6cfc44d32ad9cf7f3541ff3e95325e213dff086568cc612da55994db48811deceed243ef8007925cafc78a8b891927511938083be8dea0fc3792b7d8d9d1391e920a173d0f219cb30fbcedf010b6b18113c8057dc0c710eb57f2021cc6330d1f41015b89ebf2a1e042921626a673eff10cf5cfa6261883855b4e9769fa11fe56184b44b74bcc0de271805898d5d206b75031765cb688274a7d966cd44443f1bdd9a0df1163c7f45c966d90accc49020925d90811eb5fc6a6b63eed01c87ff31225dd5acf864799ec7680e6f8e37281d2563bc8e4377d51e6808ff90de4e923fe6f0865eba55f1eec7c0618bd18ceb94bcce490e0b021ddec1748c3eb0b067e461d15fd719900490cc05c341028ed6c092b1a4c22b514f1f5347c7c020f614232720c35084f545c003a2d8b7c09dd4881e68bc4806701d71acef353e352b4ca11fd524e634ac8e6b5f72718095a0477d9ed521e34210b56f4f2594031acfc5c83803a43bebc0307fe5c9548fea6e1f8dc7c41c0d1e1eabe3364b44a215bd7c1a04d8c2ce18e69b3f6d065a9a0284a1c952b2f3bafcc0c23b730dcdba89f3fb8810dad0588444a2e4dca9b6e50589c3c3b10107a6a063a8111c282c625c81a22dbc4c608f6d48456413ce6cf0b33e676c2abe37dd7b310edb84cb1a0849b1f6e1bef0a4c5362eeec4c3d976c4d59cc8d90b2bd26282bf7747fd4ee54e97f6c3d87c1b734255bbb8ac24d40f570db94911611e837285e2958712672ad6aa0db49be191ea1ae50d2a7ceca0b1e79b828da43e2aad9060c895e3ec1836a734bf1def3654bebda0bebe62f6b8285279bbf13b2c2976b56c1c6b5b927a99a2a7c75e29a55c76ca5cd2bc159d1df4cf39d498ec3e2aebd8ee67ae9216c4d287609e82780e1b57ef2693e265dab2cba443d2ba9bb2e3ce8114290a8b80c413bea20a9b17f6fca785dda100917c07feea83b729ff78711cf6c0b089a747a74c41a19860f96cd9e89c8dfd4eb31071242268f30025824c347aa2913e4485727d260143bad4bf33cae2dddaef69e27fe57cea7a2699b8cdf5d1da65898dec02a56e18ce949bfdc048102a77adca599341e775dc494b9a818ac9ca77b5f98b19d740d9881f6f2eba55b655033316caf40b7e13f5f81ad9267dd9c8da98d3f0169988f988d7fcfcea7046cbe1ebc303ba06e7e4c531fbc5b5ef0109631e3d05e11f1e8ea3eab481f99e190c4bd5c4a5847c1666044e0562f346dc8bd969a98ea3a5f8cc33433d257339346a062b25cf160d8e1dafc8a0347cd27dc0fd982d6a26b5b112aadd46f77eebb234e3c22e6e79f42ba002bf9040db0970068b109ec70e939ac222d63b03a52e50e976c586e7efac6b23e27a977c1b127b9aeec879b2bb190fe2a587b658dfc5c5e0aca2fc25ad84bef6c2fd4ce310f8d70cb94a0bf743bc8670bf7db2690f135c6efaa00b67d92750857b1b06ef15f94d19fe3ca552a1ce54eb745caa67282f8bc9d596280142b4b97c7e8e44806c702482ca33e258b0bd8e280804e7e22d35d0607965cfce0f8ed64072cf9ce940780f4e48141d447fbf840b7ed8b3e8d1527289f2c935f0e07b6e02aa9c83b86d7f349e59e8b7819b6f593f1405afe6bb0ddd040292bd54b309ed9d3ffed62853fcffee0d3e0e680339bff9e6b3798da292cab76a4924d0e551e50d90c3c29c77a95d283995413813156a648d1038002f92cecaf5d6efdcf3c39ed9656758962155425bbaadfd05b5388f7f21d44e1108a82c6dff4e04ae10e0f8f5eb3eeda50aac62e17e1202a9c164b3062f2a34dd17a8511c85c861799750bebe10b1ade3f435ac47f487d95dcca47703857dba199e9ebe2eff55964cce89a726d15b57d8e96835758c21b5cb11c2d18f196c69557951a97edffd7c470433f6187672bfad45021ed79f2fa506a01289eb7faf1ee4bb874403252567d7001468a697658075f5ece6d6d1ce2289c6838fee960844674a5b7b77f9121984e8c6b9434a85330c6c4a24b0abe5eefe642c844e085223cf81bc32bde694bfee67ae2a29531f7a069fe3aa54528db822c5c6f6867bd3b34982713db6bf3d0f64bb0d80b6fbd74e389ec7fd3a57483aa0de890bd7821cdab69d7309086b615fed76cc80da618f402d95093a3c8a9452dff2e426e8f563d51373600b40dd4b79ef83efcf8c0987abd412b78850f928048bfc43b90fdd3e296a0897874ecd2c8a8a14e0b45054c3999f0d919fe020f36fb6374d4d20396a7cfa6ebe0029171ca0ed752d5900a80458c06b999933b5ba08b6ef379b94824b5a83565f82f32520d0e0bfd8ca3ed048f21e37a94907dda2f753b64d711746a3bb7cb240793baf9c10460851db6913f8e41e37740f9a61c0a56925a82029124cdd65cfabf8f1d763f4cad16146ec6b96335db4b9f170b28ee47338d905a3f0248613bc2df5dba92661725509470a6aca82ed697bd81294d17f0871b980d9f6727910b1c29d3f4e97f0273cd34b5c1edc4866b9473af39725713562dbcb84ff7de76e32f9e688b40f76805338267f7780605e0b54dc76d794d0db5897f03c0f06dda61447c4652074acc1b9ba9af6bf6ee806c9543987944e81584ea2b44d0c48f816a3a64d6d11ab1371cab7471a74656dca4db9e5689c0029f116127a7f0e61e56c5131ce3c706f452c344903fdd7114bb0addd93e1b32a44920ccd40b87897e3b195510cda9fa2fe3bd290bcd126ed07fcf232d58f474dfb5922805fe6b478e9021c713552ad4732a4adc0b8a896d023708dee5b5067fd57a5042656a075f32562449ce5e135cf13ddadf60a17d1a60ab53c50203d5ecf8a2f5bac813bf515f43125e19925e5351af4b1fe3cf5190e36d67d6f757f1386e9f49a0554552952ca55b739ed0aab8042b3a78d29797754889d191e9268170e05476145a256564588052383430b34852d275acc68f819d58eb4a2d3c241687a810013f358452b7c1b5d3fead22663dcb93abbdaabcdeecd23864ae4329a3e9197eb509131676c332cb7428b4cd765c4129288b7f8a1cd823a368843291e28bbf6c62cfc7992a7f6f095b8f26e5a091ed5153782b6d874c3b4bb0f1c6fae166cb3d92e581de7bf11d88f7f3e51b797470ae44adec3ee91f435bc8696b33ea5dddd6c0bd2bda51cddd3b5b0f7f55df6e9bd1ec7ec6523a73a163f07a5db1ef2a979f68c74dc31b1a8d99347f7471b20487ada63ff0e05f36aca5243af99aaaf147598d4792162e4600aadc3de582294cb4bc3b2940273a2909be09472a77d9635328d78a5137deda7a33798d041efa1de618b5d65d4174deeb437f57a5c97b900e5d85fa189e3c4f7b122df89d43e67b29cce8c577dd273c2509468521dfc99fd286ebb12b2dfdbff6f6a74c7ec866227e87a990021c84438bba499e7428e47a63757438cee867be8b704a73366f7577c09e9a208d5e9483b60b405116d62c5509dd59fd8d6f5c8919dffafad7974e94835cb19dbc498ab11a86f3bc3053468a057a11ece139dd32a3601870dd3cfdaace4c86ac432f2b8be5aac58d87e5305ec28a99124aba7426b508d880dcad4cc3478f6b073d62b1c5efd90972ed380d9a4233b0c061b36082693290346b421bb8ab0817113647f2c7cd90ceef9255b4a3fc9c68ca2540f14abc38744978ea1f3e028c7aed863ad97d530d068eec415853ef9a39d695d34840cda0e323081492651e8cdc11ba206f6fc85834e3b50e415a82663054f73d92f60d7069bf8c67e357c677467a61dd20fde1820a99ab472cbef2e07c299c314d7fb6b12eb3ad5ab28dfd82db2d9045bf7ff18174dabe53a04cb07ae65903f99e09520953a0d1bceabcaa7ca71a6df060fb853f2fbab690fb4a4b9ce27e28a0ef5f84ad13d829ca670ebb04bbbdac91f0f8acae57e9b300b06aaa476fcfd71806878b9c2ceaa077fc6c22373b1d6064af8c78394eeb2aa02230a9e5a0f5fc2b908c58f47f3f76ce11c0ec71514e6bee435275590bfc6c1fca02ee042678bcd3e2cba233af353c431f7535cee16261fa9111a06e66e0d1d14604c4b67f5e9aa7e369303d89c3f2d685253c481eb84d9735455609d742478e2e040e1b355261101d6e65aad7cfe90f39b289db775f21ceae8968e51a4b459e6e8c88ee7f16da49e962b75acc76ac30dbe9d2ed1ff9c842477d53e335fe60d6d7695a71a1dec030cabdefb4ac7104fb3dbd0d2582da2cfc7b958395cdceb25ce3a554d0c01afee10b05dd3dbbc5e0378f8a8acc7772ccd4eeec58eb926180760bd731e7170c2b344f1dedab8460bd661e2922f62b7c15c314edad0aaaaf01b24d243dec7be18c967d8d153e77018e25f7c8616ad5e6ac077f400d593040883c862b94129e30c6c81666389bd322bc635d976b8b79faf80765856cc86d083df7e2327e562a52edbb0719dbd15977dc3f78c95d86b4c18e572f990eb60e9c68c730538056dc89e42fd1d6d68d5c667ef3a063c7f7fdd6c75eb5eff813d9f7819e07dce8d83b8d17cfbd3a33837afa898bcb8dbf65b19f0395740752cde9eff62c86baacc5cd6340302d99cf5bee57ec5a52657ee88abd7edbd94a8c715f0a4a9409eb5c92f23bae4a9c0c4f6475b9ae4fb42f932adad270917997e14829402089fb093d448fc2053e5d7714016573e0fcbfa089597b4ab1ac42990e011da8974d62fa7d985c951f8ae03953434e67948e42292f09fbecb048495331ac78a38d5009ea662f6c350c0012c68ca2c9cad567ce122cfebbec7d462298987f48f62a5b5f2b608c9e4b4e403a483fca10d9d6bb5ef2f1916e5f667d0e48decd162fd658e7d0ac290221bf8562555e8a76caa22c52ae52f0239870e2cfd99e0e308ba4c23d37817597f46f2c3fb54676774dffe853dc467e9e07f52e0f364fce37111917e62749f443bf54b25d7ad9c73f5e8bb3961b75bad68087f0bda1912d84363565aeb7c0fdc1e0d30154bcbb7349015bd19e31988934e435af2b66548204b42893b89b5b06ced287fcd7b880e3d93814e7aaa6d76f16647b12bfcbc88f89a0ae886f62eae98f501a73d5212b0f9c18ca1f459e10796451676287bc5613c842c436beadb497f0df14180def0e3d235856496525b845108e7b15947235722969a264166f7cc8ebba1ec2ab2b2f71f22cc9106559f84f7ad23319c14ddc2ee643f85da19831cad71c7909c756bbedf6c329699b86456b6df64e00382c2e5a46c1f8d03a51553f86c444e3676a78902132bb49bdb618eae3ab404895c33001b2ed8b914e2f5038675fda2ba8aa9cceb9bc4d622e4b46e4675dd6aa8ca279b15c529126cc91adf48ee0548ef0432741e9a7b649ace8530cefb938a95b765f9a5f40c4f55ba68072265d4b3a5436a5c84ae2f773a56a066a3fc10856b4c130f7760a6d66ac3671fbc29b05054853a20190713f512f383b55f5dfc718a1d9100c859c84b4d49dc356d33a51acc28fea60aa9660350eb74b64aadc4e789ba870e51effd2b18512c8a8e06ae485ee76e84c403329740340f86c75cc4d7d23e340b50f6a58b974ba7812ce4684393c5a743d98b3b6ae47f9109f79f804fc89ca902db9ef9856202fffe84c78d2989162dfc2c4ac0d1ed735a263cea2f316c19401defec0103de6f88cd9d953ca05571eeb36fde499e9499ec16a2eb65b6b13b3f9644e0097f99f3a65aa4b368c5ecb0a767fc64db400b1e7fef0eb20a68637cdc93c149590f402886a0a435454742d171773982e342c4489c0f6ec9a825d158db876532692ff5722cf28130c4a55ed4f4e1d12eec97add446afc48875ed3ddcabf2db07a5b7595d68a2de01af64fae045d0b22df7be2fd9780307850ed18cfb29a7d88d03b25c46cbe48605088d9bd32a512fa01e040cc60ddead3cf0dc1a9932d1400efd6d8ff2401a77cf01071a71b34fd6b18c825134d540f747a16382a4d8d3b7689673ef4858e49e581542512dcbf69aeeafd5e44e7aeecb63783e204b0f78fd6d76ed05a424f7d2044e6f430ff9a5a0939260d593fa7b50404810624d7252ab12e3db2c7f5b2a34c6a74062c6302b8dc0d9c3177397515ab111bad602387eddaf79274c5a6eef68d95567103f31d47a31f7858fbe24e18ed5b9df42ed2875b0314d085c0faf77984ae66fe687ac033593abc89da57a0e8f0becfc8471b58d59346a1d14495535f39956e25dfbcc6e90de8b67896b84ac98f539b0610d3b286d649c83e0ab1911c4171ba48f96f32823f2ce8804d662a4e5c5e94e07a6cf10d1b939491258d23527ac09eacfa7794ed77f2bae1bb263c06698e05ab290c3ae4e469056e2de91844622e36ab511c9609cdd61ea64ddd00a1cc68202af8009640774abaef5d7cfb351a5d95cfa11b4bc45ed86f1182dd4199e8125408ff78750ae9b0ea4279144d583bfb17e87887fe8c7cd45eb619bd18b86e9701b6f2fedaf3d92036ee7e457061bde694441f53f61652e3a0a99a3599de68fd7f9af048f7a8ca0bac69a8e1dfcf48f872b2d8524ebf36db0cb3e07e1d96335c324773feee0777f534a32e7e63a6b5751fdddee0647ce2330d6ba59dff0b9c5e5540d4eec0f2b718ee79e8a99ffabe3bb2f7cf989716d4e5e5e6b65a6a6daf40f90de7041f7fb30a53466e5ec4919e884408457c069ba5ad45836ab8edb6c5314462b41281005a31cd7f2b226225612fd9942a2bf265f378a535c9b6cae27e40b0331e6c6938ad7c3938e57bd90d75e108700c2b40ad59aa3cd3f5d9c5db64a38b3f9d9c04885d150fa87897313ff4fd24c547b05e78fead6faff7112afbcd60cea8a6636d5cf410b2606b017c3440a1aff0030a32766bd134d66301fdc011289f0e3ed4ae030105d663fd2afcd1f2225bb5d1e88bd212175fe45a4bbb8ce6031dae9765a05084626ac8576caf77a5812f9642389f57e259454008cac057ffb542672b58d65b5754278ca23100e46383ea486ed04704d9ac9db7b4a72b50bf417ec7aed201dd421b77da326c3ee34b565027e0c38c853070edcd9d7422fbf2c4a7faab67eb5ccff6296351d035aa16c40cea5ffba5996491ea848816b5bfa4c9f082aa33e55aeb5511c4e6d63fd38a89ff467583160bc17e69a215a68acf44ebb1fd0c744779aac7d285d2ddf0beba1955e56f2c7a205be322570d3e22fc35762a978dda4ccb2ca72689f1434c1ff9f75a8cf9dc0e9b896f05c0cd5bce4df689d8865314b24a1211e5d831e84616fe5651f72fd4a4c517881ff3a8cef51cdeee41ada3aa36814233ef98ac372f7c1d7513a6495de19190fdf3091a4a38099e835cd82beb35c90401c417e1f2e3e63dcb3f1a17bfda0cce6d40428916837918d17eb117a0a09c979f826d582835686b984b0b41dc7a4c24b8b00fca6578b25f2530829fb4022a33aaaf73107a6bec80c5b0f11e91c473ddaf193e7ac24807722e90664eda57e21359cd135b3d6746a966a98c9e2c5fd547d820990a752c17a859caed37651884bb14aee83675e1100f1c78f3f58de69785eb0ff67b60bccd81b3d39e3fbad4d60bcf6efc785919d8ba7b3ecbd335bcdbc9ee9b260c960554e9878fe8cadf39209815c70b20738ef4ef6be7fe15f96c17d7d7efaf01931bdbabe64075b32a84191954b76652ee2087d1a524a5fbbf162e3189e65b4e3a8dcd69131ffd4294bca55c2bc5a3015f2b71ce53dcabdd084b119ac8bc786f0528daf325598e64d8741ba9d49add64c1e9a35141f22f516312872d49822522d133f336c69f99f2ca5034c866ae1c4c76e88770a9314f095e0154df36d33de8138d55f05346f283ea72c04d715bf728f78c139cdee643cbd6792f90d5ece8767f912631ca756d0285996c8bd1fe8744959e262cd839b942648bbc573b2760c028ba3063d0c6c3eba6bc0542faa605106222bd7dab293aae57466fc2e8d8782ea7cee743699b4410fd75379ec906fe7299f0a2c038cb636898f444d94d7636651b05bbf3ba8135ab1f7ab15131371eb371405424fdb5b774d8d0fae84bdbfcb7d10aa330d8707190eddc5a5930fa4688d02b824b15dcbe047467fbf34138b5d19658ac1cfb6ce02eed4f584a0e528eb91fd42347e4d052f025fa36915785fdf0f9e750a67c4b825279d8ed156c198439b908733e0925dacefb316bf696da36fcf9864d6700038cf76af70dc20e99f049f1e7216ff08aab17d5b87ae3e5f5bd6c41a20b640e708ef7b145fd5ab9618a4722c4bc58603f1e88912ef513fa7acb734f482c540f422943e358dcacd662bd216fc1d948992921d9ce7f3c0434fb7d933b9ccfcb211b52dc88730f1346c48f4a3f549160f3185efdfdcf2c7600bb3b748cba90b964251de99d3061af494bb49003aa834efaf5bbce07f3fa36a94a94d0feb1b748b5e641d4906b517b8d46156e3221bb6413ca88f55bafc59ad0631407b0e238da6a8626bf7c645dc9c1603972986e65b5b0de35bc2e31177da894c4bb941eb87826cfaf6e31a28cae6f8c6573f95d61aa6adf598139d9892a2c620856c4050071e962e983bac58a8e6dffa58ca76d9d2d352fb770abb6437b19579ece64a6ade34a57f62d3d40450bc5b0997f18c67f31e5102364bce10df1d8bac99fc2101f761ae315cced25629d4113eadfa621224b563489f321102cb2c1835d96476d35549608c533fe3cef79296134e4f2cb1fffe040c9441fbf425b047a0d604669049ec88d344a62c1ef8338802d5d1ab0618957402bd5f436260818addb7419a8b0e3fe2d633e3e86a1f535e9f938961f5a78e8051eaebbe8a4b82797dff605d01fe88db2e185140330e7114d5ec5219f5dfb4186dc3b96ce498ef476efef8147be0973f5af6bda5a97d125be2888b00734742b70a64b9399a8fd65067e075cffd6656018b4c86c7c063085e9e0defdc1a62f9b68dd7724b51c6e09b78c22d8222092a42f12d683ba11e6bba13263d5dcc025164a7ac0ab14951ff6605899719d567915e39213e5ae6767356a6882ce9509f1d94b9913da962b9329ec1885d3b52589ec0839354b0e5c7ce3d53932e7e7ae0bf6d1b4b85d47d6f2e149bed36e98e1c1991fecce34cdd6119bc6b83cf6bdcbaf26812345ab1bd90fc732f672c8917818f6c46e541f0e3eb14e6d77484aa8aeec3817ea75fbfce3435b6dc1e1a35b7c7da9cba3b306a8b8abf93f3a18d44bfa94a89f4a561a41bb59e2bc56d5c57f496365dfb54927149745c5e7665e226253e5823c7004ca7e9cb8e6e625b11cf24337b4064e17586efb8cc7ff7749017823893b548b53a8ec81d76c12e2090e3c907a463ec2f372ff44a62cb84c875dd655f365e28e86a5e788cacc3baf9ce8c5192dbb144ad6dcfa2de48f09c6cd146f71f40f78af0deabdd1999d1e0275373067f9252c4fa71f03e5142c5a0d40f9c9e1174a62180916681798f65cecf86d1c70328a92cc747e27916cca9117c28ff78015cad7120debe7fec017867d7075f1f6ee3ed33678694eaa8e4e6a7ea2e9e5dab9b8a0ac8554f0bbeef00175499fac29189235576e4abc2905202beed9f057dd55a4e1892a85b198fa425f540c8f4b21062d07c08b8b0e7eae366e3da64a03d564fc12e75f4c2977345f52941200f23d4a198d24459364fdf5d39349411b577c80ebf6bb21796323881112f13c8a0a82473bad2d14ae88f4649fff4c8bf92cc00f4b26e7898a347490ae596d212d97dd3c7c8753d2d62b37ed9fe34d0e06a5baa4caff2b26e844f278437b6c4764ca029a4902832a11e18433be6cdac8e0ca4e2a0d2c994a326246aeebe3d2f766bbaae1c6ff3c3d22b3b38f46259c3ca49b16e72d402b1245520a1f0bd8058c352f8da42dcc4426202540e5eb1240abd1667e5d40e3b0f1ad79a8a949b9b9f5dcc47cc4749ef86c8b632dd07b8b5f322a7cf7e0202e338598c9cd59eeec201bcdfaf32ae3557e2862efcc5af52c970fed6c4fe69f1fc38db531ae031862a8505d6927bd1f9d81be98bb029bc6ef10244e8e82a6494297307567916aa2b127961f7e6460c693ffdf7a3cd47f4136208d4a7de933d30a2fe821e26b0d0f6de772431d9d0ad4a5731f51f85aa847a872442a4da79fbd36de1e6d63ce1f2690c156b8e65f3dbdfacc54c0b946ab729a3adeb4d5edfeafa9aef4d0a521985b727a4b488c59ae07a6a61ea04c541a5d5d9a082e376d1c8ee42225bf16806e5922f6999d89bf1c3a1baaf61b8edde919bf0047d14b68c865fe056e48da812552242830e52c26e94d7a13148658742442f6d270ce002bd803824eb21233bcac0171a0197c0791c87cffb41b53185fbeb9d556a779b1996321f9df24f863cca634e6070a5db0550057aa6f5d6d77a6f36ad10d580d0a0612ba84a929affe20deb7eb9fe7fde9537276ba08ae82ab659a342a57d4a85a8f676858688286a2f38d35b9f8445e58fc21e308380f443f7f5a60707c30e67b992485e2298268adc1124bf53c391441927898a7207064177b2e495b298c804b80496b1eaf6feb8739c301deabff2b12c76eecf4a5466074f2908a4b03045127cbd8b3124b98facd5c2da7a9dd5ecb6eb07b6f65a69f7a9a857157ee8d14d91f3620215f8f140fa810e3225c9b47d457b78464bad955d3af75bb0d6c74f6ce839cecc18bf13668d6557d6da29c731a8e3b0283f172f8a1803da7b6d51f397c5a38c49e3e95182522d99df5c196226d9b42d62f139b741e195b0635d788ee3b2c743fbe7f9f992e02ac7aedf06cbaa64833a9a4f931c787928f4415cdc0bf10c8c1ca68843c53d411dadd907a4a5e5daa6f7319a28fa28d21e955915a3718efa2199982b85715f75059397afae7c182927e3cf11068b533c273b1f3fb80067060a8c082dc467c4a68ca1320d367d57cdd6b2ee13e1fbc2a6c4e96420053a5bbd3269d709e9365b2222fe565419d2398897e3d89cb74d899e3da6a20e9a758ae2708b06064c59f3db33586f30975abe9e5d5a46433be0e51656105f4fe7da29389cb549dc089cc80b3f92af557ea98b09c8c53b9b0e796814b964f5df4251188d8972e4c01cb261d1080abd00d6c33059923f458e20777a2cf78a9d1ff0bbc838dbd998571a0423afbada03433fa0a2ae4b33a2e7172202546a823d132d8ff09ca299ed92673491f26fe5794c01937692e5f5f164ed4a772ab2244acd17cf50bcff62c25b66f5a6afe79c943e5f0072519d2c244f8ea71fd35d3b41b52566916538a06c094af9f38b90813be4ce9174b10edc4cfdfe2be26db1e11a670fed15065b854189169b8a9bf9f35447d6fa832f149b6203c308703c83dab17fabc2442361737f90dbdf457066dd59dec94da47a7859191f9f87f52f0e41e0548a6ce24277bf612e36baae9b624682d564db7057304eb9eb073536766dfd3430a4ccf8992b9d0451da0f87f7e30e5166f872ac2224f5f48e9bebc2e7f056923ebc4088123ed3c510d65094cdc63e81468623cdc3aecf9c425f3f3ef971eb2d36a92ea4e5e751b282e5282c0127f8158fefa60c54217d518c61a798758f75f743dd7ada5ad6ac797191d40f7a0d17d3f29eef2ddd84593b58198334012c6b56e3dd3d7daa5bb61e9c4db74a7bc14492a19a482580fd36c0bc8be715ce3b38d48d97b975d97a4c491fe7154d5e01eb8a2786bc1a423d3af4e20a7e7229f5f803ddb871f2615e2e08a661d3812d54b9fb4e6f3bef8ff8de6b3a7e4e9aabd2d6fbf94a006c27d5b59c2c9f2f1796941b4b91bc27bd6bbdaed6063bd99fd041a82a0671b1624f865b750364b535e15b1fa9fc8a4ca30cf27af98941cb24e73b23d2a37891736d7a81a0453a50f45883ecc0901c04a60f426fb4b09cfb4bd078a295972ccb144641fa95e67a06548fb9ac188be18275078d85316ede39f924a7c8d2876664520ff1e1de08ddc23d1f95323ad5d19f97c989848ccb4a57ee16f928036c68a2a1d3fd1aa006292c69a56c0d5ab96007837e7d8209235b9ab64560e93e08e77f36bc946644a0f42457f37c21699ffe7e9dba03c781d564f78f3702c289f2db66211bfaf783c52eab6e8839e5ab891bcc3b88f8dca14f0a7b7f43e8eacb3ef5b189169b420fde71b88fe5018add9adbf10b10236acf4d60af80e0588bda21f72ba8d48492fd899be64ed4586cd27ca9239efc721f5dd3a737d379c85da0e57bf3359b63b4eece0cff3d65c6be641558f74c0d818d22a21ebf2dd90f1bfd8190be11cdbdae6eeb03334ed390ce2a9b501d81d11cce6809f4d315695aef6074c323df5e14d8013fffd89c60988bb60526aeb396186d47dbd7a4242e371ee25ae21538d6c7c6f1b826472a07973d3623280fcbaa67608437ca47ead780500e37fc03b3766a59ef5ee8d4e616b20179f7f30c0ced73a6ede1af95d06ed8378005e1779de73b19d3e37e34583c9440e47a8baa53ba98843ed57a26d61dd1043a1a3f636a8cb3950c6777c1df50054006b4ed943e95da29379daa9efa9231e997989e5f720dcc63debc7a1b4bfad8e8da9c5dc1b57c65308ff4ce7fdc61854673e025e93b1e2a92bd79690a722170e7aa91dba49566afc6e148350b2c04ec0a4ebe5e984064f3312fec81bfba36c452ec5a0c4d169d0b6417eb8ec5e76b1b8d94e9df47159624cacd14e2568f76f1ce170a18741b7c9310f7e60de88b052ce283e16ed673338a542fb59c1cbb5ac25eb5864bae9430d28645b1cc28c0093115536728ad61ade94a03b3c26fb97890d7a1119c91eafa6924db4328fe562ee808be70b0bc1e2cc946e757adfcc25581ceff0056d2d4ca252381473da9304396a90ce03f4dc61889de09268c4e7eb1d0fd8ca3a8a604efe46ab192b32aac8ef447bdf6445e406bda04180ad647edbded6cd7e9c088e44e306403973177faf01464875da477726c300f491b2f9463453e1769b10ed86428083c6c51ad2b756be9c84960aca6cf43d0b266e4ef7df01087542a0be976aa66384ccd7016a2d097da78d71471a45dc9454e0708bcaf4cfd455d5bdf47c7b2bdccbd772bc4ce5e409658841172a4422e08bd3436a71c6b11495c80d8a6273b7febecf0b9bc7826d42df7b4ba0de3e2bc24efad94693c03a7efca70492b50adf66dfb4abeee65022ced6d253a92845079b9f76955e2d62fd9500c68cc5d903d9a695c9b3365683d1d33314df31c4f25015a6263071ea2a93d4b50872b82b5006cc14b2e3dda1946d52c595ec1a1e3be5b298bf7956c4de40b43badcc8a7c7a48f922c236d0bb99e7dc209b4234a9074e42fce79bd146e2ee68b58e62b29a7feb30ee50288c0afa234cc5531805eb7a664025274e7e10e563183f93989f4e1666373d272fef898601d2e3e0a996c72aac8a41cb146f21450bc721fa73efa779c0394dcfb8d45611f9a17f611c62852c33fbd840c3e999922ae6c4895627fff9be613dfbd7dd188f797672d3b7db1b669114a8267716b3ff64156a1c0b1c9102804b74d348e456dcab0366a05cc1f998e013adca3ec02ddbb3edbb1e6ca9a287a3194a0cf2af221ad5c726f718f95acf32cee214e84ffa899d0b39655d8db6ab75d1f1e8dc1ce08bd4ee4b097052f96702df9cfbfddd59d26f0704d948813ad8fa4fcb239e7cab94a98cb524b7acc8fa9235931794aab2cad73d13dfd7e9be3a6230240da896f55cc87d95dd00f67c10694588343de7a0b8671297c26cf56fd2559fae0d1371ac562d97bb5492b9de9b70c34312962ac4a69b6f80bc002b505ea8964dea52812a36682d1564521be81525c6b1d4f85a0a07ce0838d9e19e8ee15e848dbc584a83dcaa57f1974741e2d6eefa02edd2161eb9966fdace98080c31d4ceb49e2561f48033338300acc805dcaadabb4771d4b0b544625d65d1d8b6d2d52fd8ead5678335e9424606a1fe32f7788048df2d53add5129ea520c3f40bc86cc1cd81b68f732a8d8aba8217d1d249be7cea7312e555e81c6ee831dadec4cc57c1be66ad75220a22c9ebd9943183a1e73cac60b2c3e55d3a1ea5cdb0c11805590a4124bd06f5e6b585dddeb50ef6324ca9575164f87faf56a9fd257a4b84857d536455d040cd97ef3d210b4d6a90d6ee6a88144a1e003829f2d9f32097e5c078b2f2e4c2e3bde99ee28163951ecf8bdfca640c28adb7dc0b0b471f28af4745cc5e79b26f0a26f804812223f20e5b1c50d5490abb8c3543e0d4c1a4dea5fda2502f4f4f9eea0ccc35539c80eb3e75cc71ebe93e8b8d1a479ec3a7a765171eb5bb9a94a821b551f0a2d8b56f051e2fe3d7c76744b8b2ba430f107b7034492a8e6f040ac41ffa254c34b12fa14a65b18ea33eccca002f57ca20437ded4af2f670dd4d9fad25240eae5844cc8ea93b37c2ae6af4ef4c02087ed0d84cd084873996db08017cd444a1d90579126895a4bc8bce07b359e69de033bb090f36a1ed7c02ae9cc594c6077da6bc4030f08d393086792714a48da0c7496101365535f38595aebbb4f0b9659187b45a9a3f75757ef1b744f2c9838c68e485ce160fa2323d7efeaf7fc4910f772319d6bcb71dfcfb88f889417a57acf82f822f456592ae0f6a8523c63c94020b0359c3d807642a141ea1d9356e8a51a9e05e9adcb06c2b0c0c5328d2bcdff5b17f8d325731548339df22b13e6e51287d11567b837ac46669eb354031e29291d66a49b2bd525e5bf2173ce0d64fce7d58fd4921dfab2c5dc9eea549319206158f059483b6257a220134699f7e30ffe569b866f7049eea736d058e8cec323a60921377d6222c785659eaa373d89e2c4da37aa2cfdeebae3c375c96ba04463a218360b041f7ba273f6785ec63ff0a4816921cb2ff5d91ec76702c0bbab16988ecec91a9f3028238110052a7492b824391d2a060b0f7e2feb4b8fec0c3ffc376740c9514a7df728193973006b8c70002f80e837a22b968b05958a620cbf7ddd1913b8594b44bcae438b1d6f9930c7dac6150d8717320dfc1232d4a930a96862320402ba4695d0bebbdc4ae622005baa52ee420ec49b00a3e54616c39ae003001e2383c15c052b4223bac23d71a4e8cbcdc5456820cfcc2752241a32527762dafde2fc1894462e03cf7e579e287add603abf048cab8585732235fa66923b00650e6c6e6e4d2bcb7f6fd151f2c42e67882f87a5bae81285f81178fa2d45b081a5440f3c7f07d330fdabc74a65c44bd0669b021fd6ff9d9f0b04f69158e7984443397fd481c8f4a1d85072f441398de8a621e124b5bcc10277823c7326e0ff4bf5914e105fb4f20b978fa9533afff7a432cb440a0fd76d8593a4984b4120a932d18a5814c4ae419e08e58792f35eae845e70d6ab321c631354c6109170735fe615101fe503e851bbd8be3c9a78581d5b1911be774eb84b956ce4e830eadcce49f535efc3a6784cde001038004f12213c294ffdef646b0d0b1897f6f74a622bb6a7ab3c8b5da6b3017d261f8cfc8becba7249ae554545a9d5d9850875b153a6cb7790b9b5c058818cfb062c02376f1d04ea074b82c44d87598e17baa3b3266a7693c5ac5d487e8e11710e2eb21e5e3b46c50a403ddd0738e982238a40c6c1930ee8ed1ee95b80138ca05f9d745081217e2065e0e5b95710580a18a3bf453ac2b1025ad6280895df66498275288465cc0a5aa879c575ca30692d0c2d0749316ab9ee4f81d7eca1514e9cf8c67a3c5eada9ec63edc09759a747c4748a2f45beeb0b66229f7faa04f29d495e7ab3bd980133fd07e0c636649510afc3b3d751d45f7bd7b867f245d78ba81488605537392d7c8b1f3f34f2a25166e6cf1b04679aa07d7f5185066ca61334c599e0c1f3563ce73925a8c564404514f0b8a2d00601a7cc7a8378a95e1e0219ffe9c1c68f9ccfe7b2fec72f99cfb6b9341bf6ebbda4a8a491f87785587aa9a590c3712c280b44bc7c19c3bc1f7e704d3fda9c6b8d784f77099ce298a59b8085a1435198266e74890354cd3366390353228b4d085e8776211953d63b3bc9c6ee8eff3fd471d0bddc9a06cfd58f91f9c42c4c1d992615661325ee70980a6c0da2e2d77f763e455ffd1ad839a78758c82ccc96a6f353cc005f84907de43638dcceb1101a2707b3b58881eaab578d3d1a01d9c198df5dc65895de0cf3d4884f3ee23882b4e86a8c1f57e97feaa8f8bf4a2a1b227a22f7ef55c401f78b3016b470ecad13d365615c532442f4c935c1892413cadf6498a0473bb0ec32ced5bb4c18f992107776efd013879f475d0c8fefabb77b77dbbb2b74fc649c3ba81cb4cab68811e8a44cd4fd700bbbedd059df15444d052b95dc26858d8d6a20104de5f1bf722b43842bacb47541b97dcfac652ab6ebe6e891a2aaca557618462bd18f1c23c37f262cb7a60c5541f24f8f8b2ac1a79057c236d04c9ba87b40a5779b95f200044acaf3134e689afa77a68e2fabc81220d24d72de64946d962c Hey, password is required here.","tags":["年度总结"],"categories":["随笔"]},{"title":"美股投资原则","path":"/268856862.html","content":"原则 永远谨记『高收益，高风险』。 市值低于100 亿美元的股票，不要碰。 刚上市的股票谨慎购买。 中概股和港股谨慎购买。 抵住诱惑更加专注，不要妄想抓住所有机会。控制好持股个数，美股不应该超过 10 个，港股不应该超过 2 个。 购买股票应该像买大件家电一样，操作不要太频繁，购买也不要太过随意，购买之前一定是做足了功课。 谨慎抄底大跌的股票，先搞清楚为什么大跌？好的股票很多，没必要冒这个风险。 卖股票原则 [短期投资] 对于投机类股票，可以不设置止盈点，但是必须设置止损点（铁律）。止损点设置在 8%～15%。 [长期投资] 股票卖出与价格无关，卖出原因： 因为买入逻辑没有了。 需要资金买入更好的股票。 股票涨得太快，卖出为了降低风险，分散化投资。 抄底原则 考虑是否卖股票，参考卖股票原则。 当股票下跌时犹豫是否加仓，优先考虑的是「风险是否能承受」而不是分摊成本或者赌反弹。","tags":["股票"],"categories":["投资"]},{"title":"比时间管理更重要的，是注意力管理","path":"/1344029253.html","content":"阅读原文个人笔记 你如何过一天，便如何过一生。 你是否觉得自己时间不够用，每天都很忙？ 为什么每天忙碌到持续怀疑人生？！ 好像年初的读书计划一半都没完成； 明明计划好了的一切，最后事情还是一团糟； 很努力地付出，但最后就是没有什么可以拿得出手的工作成果； …… 如果你持续有这种忙碌无果的无力感，或许是你在时间管理上出现了问题。 我们身边有太多已经开始混日子的人，在本应奋斗的年纪，把自己很多时间精力放到游戏、逛街、购物和吃喝玩乐上了，他们生活得很好。 那没钱没背景没人脉没学历的普通人如何通过奋斗逆袭人生？ 短期内提升智力是不太可能，只能提升自己的能力。 通过改变自己的时间分配，舍弃掉一些对未来没有建设性的生活内容，锻造自己某些方面的专业能力，才能为人生创造更多可能。 如果你对未来没有期待，生活足够优渥，就不需要做时间管理。 如果你希望在每天有限的24小时内，摆脱忙碌无果的无力感，更好地把握未来，最好的方法就是开始时间管理。 如果你希望通过努力达到收入提升，不妨照抄一下。 01 期待未来，从时间管理开始“重要紧急四象限是最没用的理论” 几乎每个知道重要紧急四象限的人，都做不好时间管理，因为从实际的落地上，几乎没有可操作性。 亲情&amp;友情&amp;爱情，谁更重要？ 健康&amp;休息&amp;运动，谁更重要？ 领导信任&amp;同事支持，谁更重要？ 公司内发展&amp;公司外社交，谁更重要？ 自我成长重要么？达成业绩重要么？ 愉悦自己重要么？照顾好家人重要么？ 当这类事情堆在一起同时并发了？我们该如何判断取舍？ 四象限作为知识点，只灌输理念，不给达成目的的工具。 只是“知道了道理，依旧做不好时间管理”。 如果一直停留在浑浑噩噩的讲道理，那么对未来的期待怕是到死都不会变为现实。 时间是资源，管理是动作管理学有个说法， 之所以存在管理，是因为资源的有限 。 时间肯定是有限资源，我们需要通过学习对时间进行管理。 而不是一味地抱怨：“我每天上班累得半死，没有一点自我时间”，“我挤不出时间来，我啥事都做不了。” 你感觉忙了一天，细数后并未做什么，可以发现部分人是“真忙”，但是还有部分人是“假忙”。 英国教育学家赫胥黎说：“时间最不偏私，给任何人都是24小时；时间也最偏私，给任何人都不是24小时。” 你有没有想过如何正确的进行自己的时间管理呢？ 通过时间账户看清时间分布一定要清楚自己的时间都用在哪里。 时间可以分为九个账户，分别是精力恢复、收拾自己、通勤、工作、学习成长、锻炼、情感、社交、消遣娱乐。 时间是有限的，我们除了需要清楚地知道时间的重要性， 明确1分钟、1小时、1天可以做多少事情 ，学会争分夺秒，还需要区分事情的轻重缓急。 明确时间账户后，可以细化我们对生活中时间的理解与复盘，进而调整不同账户的时间投入，调整自己的身心状态。 时间是一项投资，日积月累能给人带来个人认知收获、能力成长、收入的迁跃。具体方法请继续往下看。 时间管理需要养成习惯养成记工作日志的习惯“ 聚沙成塔，集腋成裘 ”的道理每个人都懂，只有量的积累，才能实现质的飞跃。 坚持记工作日志是不可缺少的职业习惯，把当天的工作收获、经验教训用文字的形式记录下来。 每天检视自己，让自己获得管理的能力和技巧，从而更好地利用时间，实现更高目标。 不在工作时间内干私事很多人都会上班时间想着家里的事、忍不住刷微信、注意力不集中或者收发私人邮件、QQ聊天、上购物网站等。 这些看似无关紧要的事却能分散自己的工作精力，占用大量的工作时间，从而让时间在无形中溜走。 今天你缺乏上进心、得过且过、安于现状，明天就有可能被淘汰。 既然在工作时间内完全不考虑私事是不现实的事情，就应该对这些私人事务进行有效的统筹安排。 合理地安排好自己的工作和私人问题，努力提高自己的工作效率，为自己的职业前途提供更强大的动力。 挤出一切可以利用的时间为什么每天都是工作8小时，就是没有别人的效率高？ 仔细观察不难发现，早上或者是中午休息到办公室后，有人在办公室闲聊一阵之后才进入工作状态，而有些人则能一来就进入工作状态。 别看每天只是短短的半小时，但是时间一长，差距自然而然就显现出来了。 一定要要求自己尽量挤出可以利用的时间，效率最大化。 今日事，今日毕鲁迅先生说过，耽误他人的时间等于谋财害命。由此可见，自我拖延时间无异于慢性自杀。 寒号鸟明日复明日的坏习惯，终落得个冻死的下场。 工作生活中拖延的习惯一定要杜绝，做到今日事、今日毕，特别是在无人督促的情况下。 当然，也可以请相关的同事来督促你，开了局、动上手就会发现——也没多难治。 人与人之间的差距在于可支配时间的多少如果用时间来衡量人类进步，那就是每个人的人生，每天夺回了多少小时属于自己的时间。 1850年代，工业革命后，一名普通美国工人每年要工作3400小时。 到了2017年，一名普通美国劳动者每年的工作时长，只有1757个小时。 两者每天相差4小时。 “可支配时间”是人生重要的资本人类的文明的发展，正是在社会的不断进步下，用这些“可支配时间”堆积而成。 所谓“可支配时间”的增加，并不是说绝对闲暇时间的增加。 而是 相同的时间下，减少低效的、无意义的劳动，转而将时间花费在更有价值的事情上去，帮助我们更好地将时间为己所用。 时间类型有四种：必要时间、健康时间、工作协作时间、可支配时间。 我们可以发现， 个人的可支配时间越多，个体就越能获得更多的社会资源。 挤出了时间资源之后，把时间分配给哪些事，那就属于投资选择的范畴了。 只有我们挤出属于自我的、可支配的时间，人生才可以有选择的机会。 大家可以发散思考，什么样的未来是自己想要的，对未来有哪些期待，向目标发力，把自己节省下来的可支配时间投入到对未来的建设之中。 三个习惯，避免浪费时间避开一切排队排队是一笔不小的时间成本，上班路程上的时间损耗，中午吃饭的时间损耗等都是生活中常见的排队情形。 人与人之间对待这些时间的区别是不一样的，有些问题可以通过钱解决，而钱对年轻人是很重要的资源。 错峰行动是在不增加经济负担情况下的更佳策略。 巧妙投资健康睡眠不足是职场人的常态，也是“啤酒配枸杞”“敷最贵的面膜，熬最晚的夜”等养生方式流行的原因。 健康账户还包括饮食、运动投入、情绪稳定、工作压力管理、家人健康身心守护等内容。 合理的调整生活时间的次序，改变生活的习惯，规避排队…… 持续地，自然而然地，被动地，不经意间地把时间投入健康账户， 健康越稳定，意外就越少发生，做其他事情的质量也更高 。 降低无效社交随着年龄增长，你会发现，很多事不是凭借兴趣或是面子来选择。 要尝试避开充满炫耀和攀比，只为了吃喝的聚会，更要慎重对待突然冒出来的邀约。 当然，对于一个靠专业谋生的人，或许某些场合的社交是不必要的，或者说，频次没必要那么强。 人是天生的群居者， 非必要不社交其实很难，要根据自己的实际状况进行调整 。 经过修炼，时间也有复利同一段时间，复用到多个时间账户你在一段时间内同时干几件事，会不会每一件事都干不好？ 任何观点都是在某些场景上才可以成立的。 像写PPT、讲课、做数据分析等高专注度、需要支付高智力密度的事情上，肯定无法同时做多件。 低智力密度的事情就很容易并行，不妨运动的时候刷课程视频，通勤路上听听书…… 有些世界上顶级的运动员，他们在练习的时候，能做到一边运球练习，一边在iPad上解题，目的就是为了快速思考、观察、决策，兼顾许多的点。 总之， 低专注力的事并行搞，高专注力的事专心做。 当你身体和思想，同时在线，就可以达到一段时间被我们复用的效果。 控制娱乐消遣，让内啡肽胜过多巴胺抖音一分钟，人间一小时；爽剧不刷完，完全睡不着；确认过眼神，熬夜“吃鸡”人…… 娱乐消遣是生活的避风港，是新型社交方式，更可以成为教育不好自己孩子的成年人的替罪羊。 毕竟人是社会性动物，戒断娱乐消遣很难，不妨改成控制娱乐消遣。 非工作赚钱需要，不安装娱乐消遣APP当然很难，所以可以把应用藏在比较难找的角落，关闭所有的桌面通知与推送…… 尽量减少在这些应用上花费时间和精力。 控制消遣，可以设计断点坐车吃饭的时候可以刷B站，朋友圈，因为这些时候都有打断点。 但是周末躺在沙发上，晚上睡觉前刷短视频，肯定会越刷越兴奋，这个时候是没有打断点的。 给自己设计合理的时间断点，避免无止境地时间损耗。 设计堕落约束规则如果想刷剧了，就去跑步机上跑步；如果想干点堕落的事，就给自己肉体增加点运动量或者惩罚。 当然也可以请身边的家人，同事，朋友来监督，最终的目的还是希望时间能够更好地利用起来。 02 时间管理的进化论同样的时间长度里，为什么大部分人忙忙碌碌，最后却是碌碌无为；有人却读完了20本书，写完了10万字，到底差别在哪里？ 同样是24小时的时间，有的人成为了马某某，有的人靠短视频“自救”，到底差别在哪里？ 好的时间管理工具可以让自己受益终身。 别再做无法执行的日程表啦小伙伴们有做过日程表吗？你平时做的日程表是不是这个样子的？ 这样的日程表是无法执行的，因为一开始它就是为自己规划了一个不断受挫的计划。 这类日程无法对抗意外，需要各个时间点都踩准节奏。 如果有中断或者延误或者突发状况，则剩余的日程安排基本就会失效，最后的结果就是无法执行日程。 职场人，特别是需要从事具备创造力工作的职场人，应该通过任务流去管理自己的日程。 有效日程表的打开方式：记日记，做复盘，列任务 当你困惑：计划没有变化快且碎片时间多，虽然每天很忙碌，但是时间不够用；不知道如何戒除懒惰，如何拥有强大的执行力去养成好习惯；上有老下有小，没有足够的时间支持生活平衡和职业转型……的时候，应该解锁一下日程表正确的打开方式。 这个流水日记表包含流水日记区、思考复盘区、待办事项区，它与普通的日程计划表最大的区别在于： 有复盘，有行动指引 。 其中时间段有两种颜色：白色和绿色。 白色时间段属于与同事们的协作时间，此时自己是无法专注做一件事的。个人在公司的职务级别越高，负责的范围也就越广，这些时间被填充的也就越满，可以理解为必要时间。 绿色时间段，理论上不会有人找，可以自由安排，可以理解为可支配时间。 当然， 不是每天都必须要复盘，丰俭由人，按需定制 。 也就是说，这个复盘内容并不是当天必须填的，而且正因为不是当天复盘，过几天甚至几个月之后再回顾这个表，完全会有不一样的感受。 填写和记录三个区域的关键主要负责收集与整理的流水日记区 流水事件关键词：记录各时间段发生的事，尽量精练，不超过15个字。 过程-感受-反思：记录各时间段的想法和感受，也可作为流水事件的补充。 通过流水日记区观察到自己在那段时间里的可支配时间被分配在哪些事情上。 哪些事情是主动做的，哪些事情是问题发生后，被动拿出可支配时间容错的。 在日记区并不仅仅是记录这个时候在做什么，更重要的是旁边一栏的“过程、感受、反思”。 举个例子，昨天傍晚和妈妈电话通了快2小时，日记区就是“陪伴家人”，通话结束后感受就是这个电话打得太久了。过了一天再看，其实底层是和妈妈聊天、吐槽，能让自己感到放松，自己也在逃避做一些自己不想做的事。 流水日记区的进阶用法有2个： a.打标签要清楚自己的可支配时间用来做什么，可以用打标签的形式进行。 标签可以根据自己的需要制定分级关系，例如职场社交、团队建设、个人成长等属于一级标签，各自的子项属于二级标签。 b.扩列记录如果你对某些事特别执着，可以把流水日记拓展更多的列，比如单独记录自己每天的金钱支出、饮食摄入情况、实际睡眠时长与运动时长、要收录的金句，以及每周或每天主动联系到的有价值的人，等等(见下图)。 如果一些特定的事件能够固化，就值得扩列记录。 这样比较容易达成一些正向的目标，比如1个月联系4个细分领域的高手，并输出采访日志；每天强制储蓄，30天收集90条金句，并用在文章里；连续达成30天的运动、写作输出、早起等。 不建议一次扩列太多，因为记录成本太高，如果一件事无法完成，就会对自己的信心造成伤害，产生挫败感。 凡事三省吾身的思考复盘区 二次复盘反思：往往是今天受了某事情的触动，是今天值得反复思考的部分。 三次复盘反思：往往是二次复盘反思的延伸思考，亦或者是对这段时间的反思。 生活中有太多的“只给鸡汤不给勺子”的事情，我们每次看到这种事情的时候不禁感慨：这个道理、观点、心得、规律非常对！非常好！可是我们应该怎么办，怎么做呢？ 怎么提高自己的认知水平？需要进行不断地琢磨！ 怎么不断地琢磨呢？就是需要填满我们自己的“思考复盘区”！ “思考复盘区”就是那把勺子，是帮助我们攀登开悟之坡的梯子。 二次复盘甚至三次复盘的厉害之处就在于，加入了时间的变量，我们能更理智地看待一些当时被情绪裹挟的事，能让我们建立起抵御负面情绪的铠甲。 因为事情过去之后再看，会发现绝大部分当时接受不了、愤怒、难过的事，都不过如此，时间仍然在继续向前走。 令你省心、靠谱、有洞察的待办任务区待办任务区需要我们着重思考自己有哪些事值得做。 DDL (Deadline)：几时交付。 相关人：可以是自己，也可以是其他人。 核心诉求：相关人想要什么结果。 待办任务：服务于核心诉求的行动关键词。 这里写上去的每一个任务都是自己给自己加的，并且是根据当天实际发生的事情推演出来的。而这个“核心诉求”则是锻炼了人的逻辑思维和看问题角度的丰富性。 为什么要叫“核心诉求”？因为很多时候人不会直接表达自己的真实需求，能从一个表面上的诉求洞察到核心诉求是一个极为厉害的能力。 核心诉求的提炼，一方面提高的是超预期交付的能力，另一方面则是需求洞察，不论是业务上还是社交上，都非常能拉开人与人的思考深度差距。 待办任务区的意义有三点： a.省心，用记录减轻记忆负担人生和游戏一样，有各种各样的任务需要完成。 脑海中总装着很多事，就会很疲劳，很有压力。 大脑是用来思考、判断、决策的，而不是用来记事的。 养成记录的习惯，长期往复，你记录的很多事情就会固化，这些固化的事情不会占据我们的时间。 例如，每月发了工资理财，还款，公司有直播，活动，分享会等。 这些内容很多都可以做到颗粒度极细，做到周级别，前提是占据好对应时间段即可。 b.靠谱，努力做到凡事有交代靠谱，是一个很高的评价。 与省自己心对应的，是省别人的心。 如果你给对方交代一件事，对方忘了，结果会怎样？下次很难再敢去找他。 好的记录习惯能让自己省心，更提升自己的靠谱形象。 每天都查看一下待办事项，做到凡事有交代，件件有着落，事事有回音。 这里除了记录还有比较的功能，不是所有的待办事项都是必须要完成的。 每件事情都应该有自己的价值判断，决策水平非常影响自己的人生际遇。 c.洞察，挖掘目标的需求本质核心述求需要记录的是，相关人想要什么，尝试着推演与洞察， 一定要养成推演（或者问，或者猜）出对方核心述求的习惯 。 洞察的精准也十分重要，当别人需要安慰的时候请给予安慰，而不是自我出发点的建议；别人需要开水的时候，不要给冰镇饮料…… 03 写在最后无论是修身齐家治国平天下，立心立命继绝学开太平，还是把时间浪费在美好的事物上。 这一切的前提，都是拥有时间这种宝贵的资源。 捷克教育家夸美纽斯认为，时间应分配得精密，使每年、每月、每天和每小时都有它的特殊任务。 如果把人看作一个系统，那么这个日程表就是对系统运作进行数据记录，然后复盘的时候对数据进行标注。 随着时间推移，就能得到一份自己的运作数据，根据这个运作数据再给自己设计操作系统——用完全理性的方式把人当AI机器，这样的理念真的很酷。 本文来自36氪。📝 重要紧急四象限是最没用的理论 几乎每个知道重要紧急四象限的人，都做不好时间管理，因为从实际的落地上，几乎没有可操作性。 📝 通过时间账户看清时间分布 时间可以分为九个账户，分别是精力恢复、收拾自己、通勤、工作、学习成长、锻炼、情感、社交、消遣娱乐。明确时间账户后，可以细化我们对生活中时间的理解与复盘，进而调整不同账户的时间投入，调整自己的身心状态。 📝 时间管理需要养成习惯 📝 别再做无法执行的日程表 这类日程无法对抗意外，需要各个时间点都踩准节奏。如果有中断或者延误或者突发状况，则剩余的日程安排基本就会失效，最后的结果就是无法执行日程。 我们应该通过任务流去管理自己的日程。","tags":["时间管理"],"categories":["读书笔记"]},{"title":"终身免费 ORG 顶级域名申请","path":"/2502663362.html","content":"前言有时我们在云上搭建一个网站，需要有对应的域名，那怎么办呢，有人说去买一个啊！确实可以去买一个域名，但咱主打的是一个省钱，有永久免费的域名为什么不薅呢。 说到免费的顶级域名，可能很多人会想到 Freenom 家的 .tk 域名吧，他家太难注册就不推荐了，今天给大家推荐另外一个 .EU.ORG 的免费域名（虽然他们的【官方网站】界面很Low，但是不要怀疑，就是真的官方网站）。 EU.ORG 是欧盟组织下面的域名（EU 代表欧盟），是 1996 年 9 月 10 日由 Paul Mockapetris 创建的域名，目前个人和组织都是可以免费注册的。虽然 .EU.ORG 看起来本身像个二级域名，但是已被大部分 DNS 服务商（包括谷歌、Cloudflare等）认定为顶级域名，所以我们就放心大胆的使用就好了。 注册账号1、在浏览器打开 EU.ORG 官网； 2、由于这个网站服务器是在欧盟（法国），注册账号的个人信息就填写英国那边的，这样容易审核通过。那英国个人信息怎么获取呢，用这个随机地址生成器来获取，点一下“随机地址”，需要记录一下全名、街道、城市、电话这四项内容； 3、注册账号填写好，前面填写的邮箱会收到一条激活邮件，把邮件里的链接复制在当前浏览器打开激活即可，同时记住下面这个临时名称，后面要用。 4、点“Validate”验证通过； 注册域名1、激活后，登录账号进行注册域名； 2、输入上面获取到的临时名称和之前设置的密码，然后点“Login”； 3、点“New Domain”，开始注册正式的域名； 4、注册域名过程中，需要注意的是：填写的域名要完整、填写域名服务器选择第第一个即可。域名解析提供商可以是阿里云和腾讯云；我这边填写的是 Cloudflare 的 NS，可以直接填写上：sid.ns.cloudflare.com，grannbo.ns.cloudflare.com； 5、完成到这里就基本完成了，接下来需要等等网站工作人员的人工审核，快的话1小时左右，慢的话可能要等到第3天（比如遇到非工作日），所以需要耐心等就是了； 6、注册成功后，你的邮箱会再次收到注册成功的邮件，里面写有.EU.ORG就是你的域名了。 域名解析待 EU.ORG 登入页面出現你注册的域名后 就可以使用 Cloudflare 进行域名解析了。","tags":["建站","域名"],"categories":["折腾系列"]},{"title":"Cloudflare 解析 ORG 域名","path":"/1263441363.html","content":"前言我们有了自己的域名，那么怎么让域名与我们的 ip 产生联系呢。 这个时候我们就可以使用 CDN 服务商来进行 DNS 解析。 但是，我之前申请的是 .org 这种顶级域名，这类域名在国内没有获得国家工信部备案审批，不能在国内备案。对这类不能在国内备案的域名，是不能用阿里云腾讯云这些国内注册服务商进行 DNS 解析的。 怎么搞，这时就得用上 Cloudflare 这样的 CDN 服务商来进行 DNS 解析了。 注册账号进入官网，右上角默认的是 English(US)，可以点击 English(US) 切换到简体中文，然后注册一个账号。 添加站点登录到 Cloudflare 账户后，我们需要添加一个站点，也就是你申请到的域名。 选择域名解析方案进入选择套餐界面，选择免费的解析套餐，点 Continue； 更改名服务器Cloudflare 会为你提供两个新的域名服务器（Name Server）地址。 你需要在你的域名注册商处更新你的域名服务器设置，将现有的域名服务器替换为 Cloudflare 提供的地址。这一步使得你的域名流量经过 Cloudflare 的网络。 比如我是 en.org 的。登陆 eu.org 后台，找到Nameservers 将上面申请的两组 Nameservers 填入 Name1 和 Name2 确认提交，等待 NS 记录生效后，Cloudflare会进行验证。这可能需要一些时间，一般是 24 小时之内会有 Cloudflare 的邮件通知。我们可以先回到Cloudflare界面，点击完成。 安全性设置（可选）设置 SSL 安全为 strict 设置自动 https 重写在SSL/TLS-&gt;边缘证书中开启“始终使用 HTTPS”。注意，这里的“始终使用 HTTPS”选项不能和 nginx 端同时开启，两端只能开启一个，否则会出错。 打开速度优化 设置 DNS 记录完成上面的步骤后，点击 DNS ，进行主域名的 ip 解析。通过 A 记录解析我们的 ip 地址。设置好解析记录后，等待 5 分钟，就可以 ping 通这个域名了。 记得把代理状态设置为仅限 DNS，即不开启小云朵。 小云朵开启表示：完全代理，让 Cloudflare 完全代理网站，这样可以避免用户检测到真实的服务器 ip，每次检测都是 Cloudflare 公司的节点 ip；小云朵关闭（灰色）就表示：不使用 Cloudflare 的节点代理，相当于直连到你的服务器。 特别是如果你使用了 Nginx Proxy Manager 进行域名反代，就不能开启小云朵。","tags":["建站","域名"],"categories":["折腾系列"]},{"title":"获取网页 logo 图标","path":"/430851967.html","content":"前言最近在做自己的网址导航，需要提取和显示网址的 favicon 图标，使导航链接除了文字名称，前面还有更明显的 logo 标志，使选择和查看都更加便捷。 网页 logo 图标一般是指 favicon 图标，作为缩略的网站标志，一般显示于浏览器的地址栏或者在标签上。 如下图红圈的位置， 即是 favicon 图标。 favicon 的格式不一定是 ico 格式，它可以是 png，jpg 甚至是 gif，不过 ico 格式是所有浏览器都支持的。 实操那么怎么获取网页 logo 图标的 URL 链接呢？有三种方法。 法一最常用的方法（适用于 90% 的站点）是，直接在访问网址首页链接后加上 /favicon.ico，例如：https://www.baidu.com/favicon.ico 法二第二种获取方法，需要在浏览器界面按 F12 键，进入开发者模式（建议使用 google 内核浏览器）。在默认的 Elements 中点开&lt;head&gt;...&lt;/head&gt;。 找到 &lt;link 中含有 favicon 或 ico 的链接，右键点选 Edit attribute（即编辑属性）以复制该链接，粘贴到空白页面后回车后即显示该网站的 logo 图标。 说明：有的链接前缀格式是//开头的，建议使用作为 URL 链接时前面加上https:， 法三第三种方法，使用第三方的网页图标在线抓取网站，比如这个。 以上，你学会了吗？","tags":["logo"],"categories":["工具脚本"]},{"title":"禁用 Windows Defender Antivirus Service","path":"/969299867.html","content":"前言禁用 Windows Defender Antivirus Service可能会降低计算机的安全性，因为它是 Windows操作系统的内置防病毒和恶意软件保护工具。但没办法，我的老电脑内存顶不住了，只能忍痛禁掉。 关闭注册表 使用注册表编辑器。win+R，打开”运行”对话框，输入regedit.exe打开注册表； 浏览路径HKEY_LOCAL_MACHINE/SOFTWARE/Policies/Microsoft/Windows Defender； 右键单击Windows Defender文件夹键，选择新建→DWORD（32位）值。将新建的键命名为DisableAntiSpyware，并双击该键将值设置为 1 。 关闭组策略 win+R，输入gpedit.msc，打开组策略编辑器。然后浏览路径计算机配置/管理模板/Windows组件/Windows Defender防病毒程序； 双击关闭Windows Defender防病毒程序选项，选择已启用选项以禁用Windows Defender Antivirus。最后单击应用按钮和确定按钮，并重启电脑。 电脑重启后 Windows Defender Antivirus Service 就不会有启动且占用内存的情况了。","tags":["windows"],"categories":["开发运维"]},{"title":"Nginx Proxy Manager 实现公网访问家庭 NAS","path":"/2431342973.html","content":"前言有些小伙伴建站没有用云服务器，而是移到了自己的 NAS 上。但是运营商是封堵我们的 80，443端口的，那如何实现公网 IP 无 443 和 80 端口外网访问呢？ 我们可以用 Nginx Proxy Manager 里自带一个端口转发功能，绕过封堵的 80，443端口，实现从公网对家里服务器的访问，在此记录一下。 实操在 Nginx Proxy Manager 面板里点击Dashboard-Streams-Add Streams，分别填入以下信息： Incoming Port：入站端口，填一个你要用来代替 80&#x2F;443 的端口Forward Host：转发主机，填本机 ip：127.0.0.1Forward Port：转发端口，填被封堵的端口，80 或者 443 然后点保存。设置以后，从外网访问你部署在家庭服务器上的网站需要在域名后加上你设置的入站端口。 比如原来你访问在地址栏输入的 url 是https://www.domain.cn，443 端口被封了访问不了了，按上图设置之后，在浏览器地址栏输入https://www.domain.cn:9443就能访问了。 同理，如果你没有上 https，要绕过被封堵的 http 的默认端口 80，就把转发端口设置为 80 即可。然后访问的时候在域名后加上你设置的入站端口即可绕过运营商对 80 端口的封堵访问。","tags":["建站"],"categories":["折腾系列"]},{"title":"Nginx Proxy Manager 上部署静态网站","path":"/2175112272.html","content":"前言众所周知，对于一些 Docker 搭建的 Web 项目，NPM 能够很轻松地给他们做反向代理。 然而对于一些静态网站，小伙伴们可能不知道怎么用 NPM 来展示，这篇文章就来简单和大家分享一下，如何用 NPM 来托管一些简单的 HTML 单页。 实操因为我们已经有 NPM 在运行，监听了 443 端口和 80 端口，避免为了一个静态网站而建立另一个 Web 服务器。 托管一些简单的 HTML 单页是一个简单的、低流量的需求，使用 NPM 已经运行的内置 nginx 就可以了。 放置静态网页找到你用 docker compose 构建的 NPM 目录，比如我的是~/data/docker_data/nginxproxymanager/，进入里面的 data 文件夹，建立一个空文件夹 12cd ~/data/docker_data/nginxproxymanager/data/mkdir web_html 然后将网页文件 index.html 放置在该文件夹下（注意只支持 index.html，php 不支持） NPM 配置登陆 NPM，在网页里新建一个 Proxy Host Details 填入 Domain Names：域名 Scheme：http Forward Hostname / IP：docker 容器 ip Forward Port：这个随便填，最后都是走服务器80口出 SSL 填入 SSL Certificate：SSL 证书 Force SSL：勾选 Advanced 填入 123location / &#123; root /data; # index.html 所在目录&#125; 保存，然后就可以通过域名访问你的静态网页了。","tags":["建站"],"categories":["折腾系列"]},{"title":"Nginx Proxy Manager 在线申请 SSL 证书","path":"/376257426.html","content":"前言我们知道，Nginx Proxy Manager 反代域名使用 HTTPS，需要 SSL 证书，我们可以用 NPM 的一键申请证书，但这样每个域名都需要单独申请，太麻烦了。这里介绍一种申请泛域名的 SSL 证书，一级域名、二级域名都共用一个证书，省时省事。 验证方式NPM 中 Let’s Encrypt 证书申请有两种验证方式：一种是基于 HTTP 的验证方式，另一种是基于 DNS 的验证方式。 HTTP-01 验证关于 HTTP-01 验证的详细描述可以看官方文档。 这种方式最简单，不需要任何关于域名配置的额外知识，但是必须使用 80 端口，绝大部分人可能用不了，所以这里就不说了。 DNS-01 验证关于 DNS-01 验证的详细描述可以看官方文档。 此验证方式要求您在该域名下的 TXT 记录中放置特定值来证明您控制域名的 DNS 系统，这需要您的 DNS 提供商提供 API。 申请 SSL 证书进入 NPM，点击SSL Certificates - Add SSL Certificate - Let&#39;s Encrypt，输入以下配置： Domain Names：输入一级域名和泛域名，example.com 和 *.example.comEmail Address for Let&#39;s Encrypt：选择 Cloudflare 登录邮箱； 点击 Use a DNS Challenge 使用 DNS 申请，DNS Provider 选择 Cloudflare，下一步就是申请 Cloudflare API Token，可以先往下看。 点击“I Agree to the Let’s Encrypt Terms of Service”，然后点击“Save”，就会自动申请 SSL 证书了。 申请 Cloudflare API Token打开 Cloudflare 官网并登录账号，在页面右上角的个人头像下拉菜单中点击“我的个人资料”。切换到“API 令牌”，点击“创建令牌”； 在 “API 令牌模板”中选择“编辑区域 DNS”后面的“使用模板”； 进入模板之后选择需要控制的域名之后下一步并创建令牌； 此时已经添加了令牌权限并生成了令牌，把生成结果填入 NPM 的dns_cloudflare_api_token即可。 最后一行可以看到 SSL 证书已经申请完成，有效期3个月，到期会自动续期。","tags":["建站","halo"],"categories":["折腾系列"]},{"title":"云服务器添加虚拟内存","path":"/4224994049.html","content":"前言最近翻新了下自己的博客，部署了些 docker 应用，结果小鸡内存蹭蹭往上涨，2G 内存眨眼就没了一大半。贫穷的我真不想掏钱加配置，只能添加虚拟内存来缓缓了。 什么是 SwapSwap 说白了就是把一块磁盘空间当成内存来使用。它包括换出和换入两个过程。 所谓换出，就是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存。而换入，则是在进程再次访问这些内存的时候，把它们从磁盘读到内存中来。 一个很典型的场景就是，即使内存不足时，有些应用程序也并不想被 OOM 杀死，而是希望能缓一段时间，等待人工介入，或者等系统自动释放其他进程的内存，再分配给它。 除此之外，我们常见的笔记本电脑的休眠和快速开机的功能，也基于 Swap 。休眠时，把系统的内存存入磁盘，这样等到再次开机时，只要从磁盘中加载内存就可以。这样就省去了很多应用程序的初始化过程，加快了开机速度。 缺点就是，swap 是存放在磁盘上的，磁盘的速度和内存比较起来慢了好几个数量级，如果不停的读写 swap，那么对系统的性能肯定有影响，尤其是当系统内存很吃紧的时候，读写 swap 空间发生的频率会很高，导致系统运行很慢，像死了一样，这个时候添加物理内存是唯一的解决办法。 详细操作定义 Swap的大小及位置选择你 Swap 文件要放置的位置，比如我直接在根目录&#x2F;下创建，然后设置 swap 分区的名称为 swapfile。 12cd /dd if=/dev/zero of=/swapfile bs=1k count=2048000 上面 swapfile 为你创建 Swap 文件分区的名称，你可以根据需要改成你自己的名称；bs 即 blocksizes，每个块大小为 1k；count&#x3D;2048000，总大小为 2G 的文件。 建立 Swap1mkswap /swapfile 启动 Swap1swapon /swapfile 检查是否正确1free -m 设置开机自启修改 &#x2F;etc&#x2F;fstab 使其启动时自动 mount，这个操作与 Swap 分区法一样，在 &#x2F;etc&#x2F;fstab 中最后一行增加如下语句： 1/swapfile swap swap defaults 0 0 删除 Swap分区如果不再需要swap，可以清理该分区： 1swapoff /swapfile","tags":["linux"],"categories":["开发运维"]},{"title":"Halo2.0 博客搭建","path":"/3594890502.html","content":"前言之前在 Halo 1.0 时，是直接使用 jar 部署的，每次更新啥都还是有点麻烦，这次直接使用 Docker Compose 部署，省时省事，建站必备。 环境搭建因为是使用 Docker Compose 部署，所以需要安装 Docker 和 Docker Compose 。 Docker 安装主要是参考官方文档安装。 Uninstall old versions1for pkg in docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; do sudo apt-get remove $pkg; done Set up Docker’s apt repository12345678910111213# Add Docker&#x27;s official GPG key:sudo apt-get updatesudo apt-get install ca-certificates curl gnupgsudo install -m 0755 -d /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpgsudo chmod a+r /etc/apt/keyrings/docker.gpg# Add the repository to Apt sources:echo \\ &quot;deb [arch=&quot;$(dpkg --print-architecture)&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\ &quot;$(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;)&quot; stable&quot; | \\ sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullsudo apt-get update Install the latest version Docker packages1sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin Verify that the Docker Engine installation1sudo docker --version Use docker without sudo123sudo groupadd dockersudo usermod -aG docker $USERgrep docker /etc/group Docker Compose 安装主要是参考官方文档安装。 download and install the Compose CLI plugin1curl -SL https://github.com/docker/compose/releases/download/v2.23.0/docker-compose-linux-x86_64 -o /usr/local/lib/docker/cli-plugins/docker-compose 可能服务器没法下载github的链接，可以本地下载 docker-compose-linux-x86_64 这个文件，改名字成 docker-compose ，然后 scp 传到服务器/usr/local/lib/docker/cli-plugins/这个路径下 Apply executable permissions to the binary1sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose Test the installation12docker compose versionDocker Compose version v2.23.0 创建容器组 在系统任意位置创建一个文件夹，我用的是之前 1.0 时候的 ~&#x2F;halo1mkdir ~/halo &amp;&amp; cd ~/halo 创建 docker-compose.yaml这里创建 Halo + MySQL 的实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859version: &quot;3&quot;services: halo: image: halohub/halo:2.10 container_name: halo restart: on-failure:3 depends_on: halodb: condition: service_healthy networks: halo_network: volumes: - ./halo2:/root/.halo2 ports: - &quot;8090:8090&quot; healthcheck: test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:8090/actuator/health/readiness&quot;] interval: 30s timeout: 5s retries: 5 start_period: 30s command: - --spring.r2dbc.url=r2dbc:pool:mysql://halodb:3306/halo - --spring.r2dbc.username=root # MySQL 的密码，请保证与下方 MYSQL_ROOT_PASSWORD 的变量值一致。 - --spring.r2dbc.password=o#DwN&amp;JSa56 - --spring.sql.init.platform=mysql # 外部访问地址，如果设置了域名反代直接写https://xxx.com，没有就先把localhost替换成服务器ip，后面设置了域名反代再修改 - --halo.external-url=http://localhost:8090/ halodb: image: mysql:8.1.0 container_name: halodb restart: on-failure:3 networks: halo_network: command: - --default-authentication-plugin=caching_sha2_password - --character-set-server=utf8mb4 - --collation-server=utf8mb4_general_ci - --explicit_defaults_for_timestamp=true volumes: - ./mysql:/var/lib/mysql - ./mysqlBackup:/data/mysqlBackup ports: - &quot;3306:3306&quot; healthcheck: test: [&quot;CMD&quot;, &quot;mysqladmin&quot;, &quot;ping&quot;, &quot;-h&quot;, &quot;127.0.0.1&quot;, &quot;--silent&quot;] interval: 3s retries: 5 start_period: 30s environment: # 请修改此密码，并对应修改上方 Halo 服务的 SPRING_R2DBC_PASSWORD 变量值 - MYSQL_ROOT_PASSWORD=o#DwN&amp;JSa56 - MYSQL_DATABASE=halonetworks: halo_network: 启动 Halo 服务第一次会自动下载 halo 和 halodb 镜像123456# 进入 ~/halo 目录下，启动 halodocker compose up -d# 关闭 halodocker compose down# 实时查看日志docker compose logs -f 用浏览器访问http://ip:端口号/console即可进入 Halo 管理页面，首次启动会进入初始化页面，可以设置密码、导入文件这些 Halo 1.0数据迁移安装插件因为 Halo 2.0 的底层架构变动，无法兼容 1.x 的数据，导致无法平滑升级。所以需要使用官方给的迁移插件，才能进行数据迁移。 点击侧边栏应用市场，搜索安装一下几个插件： 站点迁移 站点迁移：https://halo.run/store/apps/app-TlUBt Markdown 编辑器插件 StackEdit：https://halo.run/store/apps/app-hDXMG ByteMD：https://halo.run/store/apps/app-HTyhC 友情链接、日志、图库插件 链接管理：https://halo.run/store/apps/app-hfbQg 图库：https://halo.run/store/apps/app-BmQJW 瞬间（原日志）：https://halo.run/store/apps/app-SnwWD 导出 Halo 1.0 数据在 Halo 1.0 后台，依次点击系统-小工具-博客备份-数据导出，将json格式数据下载。 数据导入 Halo 2.0 安装完插件后，点击左侧菜单的迁移进入迁移页面。 点击选择文件按钮，选择在 Halo 1.0 导出的数据文件（JSON 格式）。 如果在 1.0 中使用了云存储，会弹出选择云存储的对话框，选择之前创建的存储策略即可。 最后点击页面下方的执行导入即可。 反向代理做完上面的操作，你就可以通过http://ip:端口号/来访问你的博客了，和之前 Halo 1.0 内容应该差别不大。但是你肯定不想暴露自己的ip和端口到公网，那就需要用到反代神器 Nginx Proxy Manager(NPM) 了。 NPM 介绍顾名思义，Nginx Proxy Manager 就是一个 Nginx 的代理管理器，它最大的特点是简单方便。 即使是没有 Nginx 基础的小伙伴，也能轻松地用它来完成反向代理的操作，而且因为自带面板，操作极其简单，非常适合配合 docker 搭建的应用使用。 Nginx Proxy Manager 后台还可以一键申请 SSL 证书，并且会自动续期，方便省心。 下面我们就来介绍如何用 Nginx Proxy Manger 来配合 Halo，实现反向代理和 HTTPS 访问。 NPM 安装 停止 nginx、apache2、halo 1.0，不然会占用端口12345678# 关闭进程sudo service nginx stopsudo service apache2 stopsudo service halo stop# 禁止开机自启动sudo systemctl disable nginx.servicesudo systemctl disable apache2.servicesudo systemctl disable halo.service 创建一个文件夹来存放 NPM 的数据和证书1mkdir -p ~/data/docker_data/nginxproxymanager 修改上面 ~&#x2F;halo&#x2F;docker-compose.yaml 文件，将 NPM 和 Halo 部署放在同一个文件1234567891011# 参考原来的布局，在services子类下添加 app: image: &#x27;jc21/nginx-proxy-manager:latest&#x27; restart: unless-stopped ports: - &#x27;80:80&#x27; # 不建议修改端口 - &#x27;81:81&#x27; # 可以把冒号左边的 81 端口修改成你服务器上没有被占用的端口 - &#x27;443:443&#x27; # 不建议修改端口 volumes: - ~/data/docker_data/nginxproxymanager/data:/data # 冒号左边是创建一个 data 目录，用于存放数据，如果不存在的话，会自动&gt;创建 - ~/data/docker_data/nginxproxymanager/letsencrypt:/etc/letsencrypt # 创建一个 letsencrypt 目录，用于存放证书，如果不存在的话&gt;，会自动创建 这样就可以通过docker compose up -d来启动 NPM 了 NPM 访问浏览器输入ip:81就可以访问 NPM 的网页端了。 默认登陆的用户名：admin@example.com，密码：changeme 第一次登陆会提示更改用户名和密码，建议修改一个复杂一点的密码。 至此，我们已经完成了 Nginx Proxy Manager 的搭建，之后就可以用它给我们的 Halo 或者其他 Web 应用做反向代理了。 NPM 配置依次点击Dashboard - Proxy Hosts - Add Proxy Host - Details，分别填入以下信息 Domain Names：填我们 Halo 网站的域名，首先记得做好 DNS 解析，把域名绑定到我们的服务器的 IP 上 Scheme：默认 http 即可，除非你有自签名证书 Forward Hostname/IP：填入服务器的 IP，或者 Docker 容器内部的 IP（如果 NPM 和 Halo 搭建在同一台服务器上的话） 通过ip addr show docker0查看，inet 后面跟着的就是 Docker 容器内部的 IP Forward Port：填入 Halo 映射出的端口，这边默认是 8090 Cache Assets：缓存，可以选择打开 Block Common Exploits：阻止常见的漏洞，可以选择打开 Websockets Support：WS 支持，可以选择打开 然后就是申请 SSL 证书。参考这篇文章进行申请，这里只讲怎么使用证书。 点击SSL，SSL Certificate选择上面申请的证书，打开Force SSL，点击Save即可。 至此，你已经成功完成了 Halo 的反向代理，快尝试使用域名访问一下看看吧！ 参考 https://docs.halo.run/getting-started/install/docker-compose","tags":["halo"],"categories":["折腾系列"]},{"title":"岛屿问题","path":"/310434385.html","content":"前言我们知道，DFS通常是在树或者图结构上进行的，而岛屿问题都是网格，能不能用DFS呢？可以，记住，凡是网格的都应该想到用DFS，岛屿问题就是一类典型的网格问题。 一、岛屿数量（中）题目给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例 1：输入： 输出：1 示例 2：输入： 输出：3 提示：的值为或 题解首先我们要清楚DFS的基本结构，先看简单的二叉树DFS遍历结构 123456789void traverse(TreeNode* root) { // 判断base case if (root == NULL) { return; } // 访问两个相邻结点:左子结点,右子结点 traverse(root-&gt;left); traverse(root-&gt;right);} 可以看到，二叉树的DFS有两个要素：访问相邻结点、判断base case。 二叉树的相邻结点非常简单，只有左子结点和右子结点两个。 二叉树本身就是一个递归定义的结构：一棵二叉树，它的左子树和右子树也是一棵二叉树。那么我们的DFS遍历只需要递归调用左子树和右子树即可。 二叉树遍历的base case是root == NULL。 这样一个条件判断其实有两个含义：一方面，这表示 root 指向的子树为空，不需要再往下遍历了。另一方面，在root == NULL的时候及时返回，可以让后面的root-&gt;left和root-&gt;right操作不会出现空指针异常。 那么对于网格上的DFS，我们完全可以参考二叉树的DFS，写出网格DFS的两个要素。 首先看相邻结点。很明显，网格结构中的格子的相邻结点是上下左右四个，即(row-1, col),(row+1, col),(row, col-1),(row, col+1)； 然后是base case。根据二叉树的对应过来，是超出网格范围的格子，即row &gt;= grid.size() || col &gt;= grid[0].size() || row &lt; 0 || col &lt; 0。 根据分析，可以得出网格DFS遍历的框架代码： 1234567891011void dfsGrid(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int row, int col) { if (row &gt;= grid.size() || col &gt;= grid[0].size() || row &lt; 0 || col &lt; 0) { // 防止row和col越界(上下左右) return; } dfsGrid(grid, row - 1, col); // 上 dfsGrid(grid, row + 1, col); // 下 dfsGrid(grid, row, col - 1); // 左 dfsGrid(grid, row, col + 1); // 右} 这里有个问题，怎么避免重复值，比如下面这张图，dfsGrid遍历时会一直在这里不断循环。简单的方法就是标记已经遍历过的格子。比如岛屿问题，把走过的陆地格子的值改为2。这样就能得到一个网格DFS遍历的通用框架代码： 1234567891011121314151617void dfsGrid(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int row, int col) { if (row &gt;= grid.size() || col &gt;= grid[0].size() || row &lt; 0 || col &lt; 0) { // 防止row和col越界(上下左右) return; } if (grid[row][col] != '1') { // 遍历到海洋或者已经遍历过的陆地,退出 return; } grid[row][col] = '2'; // 去重,防止多次遍历 dfsGrid(grid, row - 1, col); // 上 dfsGrid(grid, row + 1, col); // 下 dfsGrid(grid, row, col - 1); // 左 dfsGrid(grid, row, col + 1); // 右} 有了网格DFS遍历的通用框架，我们只需要用两层for循环遍历整张二维表格中所有的陆地，连续的视为一个岛屿。 12345678910111213141516171819202122232425262728293031323334class Solution { public: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) { int res = 0; // 两层for循环,遍历整张二维表格中所有的陆地,i是行,j是列 for (int i = 0; i &lt; grid.size(); i++) { for (int j = 0; j &lt; grid[0].size(); j++) { if (grid[i][j] == '1') { dfsGrid(grid, i, j); // 深度递归，遍历所有的陆地 res++; } } } return res; } void dfsGrid(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int row, int col) { if (row &gt;= grid.size() || col &gt;= grid[0].size() || row &lt; 0 || col &lt; 0) { // 防止row和col越界(上下左右) return; } if (grid[row][col] != '1') { // 遍历到海洋或者已经遍历过的陆地,退出 return; } grid[row][col] = '2'; // 去重,防止多次遍历 dfsGrid(grid, row - 1, col); // 上 dfsGrid(grid, row + 1, col); // 下 dfsGrid(grid, row, col - 1); // 左 dfsGrid(grid, row, col + 1); // 右 }}; 二、岛屿的周长（简）题目给定一个row x col的二维网格地图grid，其中：grid[i][j] = 1表示陆地，grid[i][j] = 0表示水域。 网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。 岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。 示例 1：输入：输出：16解释：它的周长是上面图片中的 16 个黄色的边 示例 2：输入：grid = [[1]]输出：4 示例 3：输入：grid = [[1,0]]输出：4 提示：为或 题解这道题最牛逼的一点是你要想到，岛屿的周长就是岛屿方格和非岛屿方格相邻的边的数量（如下图所示）。也就是说，在DFS遍历中，从一个岛屿方格走向一个非岛屿方格，就将周长加1。所以，我们可以修改下网格DFS遍历的通用框架： 12345678910111213141516171819int dfsGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int row, int col) { if (row &gt;= grid.size() || col &gt;= grid[0].size() || row &lt; 0 || col &lt; 0) { // 从一个岛屿方格走向网格边界,周长加1 return 1; } if (grid[row][col] == 0) { // 从一个岛屿方格走向水域方格,周长加1 return 1; } if (grid[row][col] != 1) { // 过滤掉已经遍历过的 return 0; } grid[row][col] = 2; // 去重,防止多次遍历 int res = dfsGrid(grid, row - 1, col) + dfsGrid(grid, row + 1, col) + dfsGrid(grid, row, col - 1) + dfsGrid(grid, row, col + 1); return res;} 题目限制只有一个岛屿，那我们计算一个即可 123456789101112131415161718192021222324252627282930313233class Solution { public: int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { for (int i = 0; i &lt; grid.size(); i++) { for (int j = 0; j &lt; grid[0].size(); j++) { if (grid[i][j] == 1) { return dfsGrid(grid, i, j); } } } return 0; } int dfsGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int row, int col) { if (row &gt;= grid.size() || col &gt;= grid[0].size() || row &lt; 0 || col &lt; 0) { // 从一个岛屿方格走向网格边界,周长加1 return 1; } if (grid[row][col] == 0) { // 从一个岛屿方格走向水域方格,周长加1 return 1; } if (grid[row][col] != 1) { // 过滤掉已经遍历过的 return 0; } grid[row][col] = 2; // 去重,防止多次遍历 int res = dfsGrid(grid, row - 1, col) + dfsGrid(grid, row + 1, col) + dfsGrid(grid, row, col - 1) + dfsGrid(grid, row, col + 1); return res; }}; 三、岛屿的最大面积（中）题目给你一个大小为m x n的二进制矩阵grid。岛屿是由一些相邻的1(代表土地) 构成的组合，这里的「相邻」要求两个1必须在水平或者竖直的四个方向上相邻。你可以假设grid的四个边缘都被0（代表水）包围着。岛屿的面积是岛上值为1的单元格的数目。计算并返回grid中最大的岛屿面积。如果没有岛屿，则返回面积为0。 示例 1：输入：输出：6解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。 示例 2：输入：输出：0 提示：为或 题解从上面两道我们已经知道怎么计算岛屿数量和一个岛屿的周长，这道题是结合了上面两道。因此我们可以对每个岛屿计算它的面积，最后返回最大的那个面积即可。 12345678910111213141516171819202122232425262728293031class Solution { public: int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int res = 0; for (int i = 0; i &lt; grid.size(); i++) { for (int j = 0; j &lt; grid[0].size(); j++) { if (grid[i][j] == 1) { res = max(dfsGrid(grid, i, j), res); } } } return res; } int dfsGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int row, int col) { if (row &gt;= grid.size() || col &gt;= grid[0].size() || row &lt; 0 || col &lt; 0) { // row和col越界,都不算岛屿中的陆地,面积为0 return 0; } if (grid[row][col] != 1) { // 遍历到海洋或者已经遍历过的陆地,面积为0 return 0; } grid[row][col] = 2; // 去重,防止多次遍历 int res = dfsGrid(grid, row - 1, col) + dfsGrid(grid, row + 1, col) + dfsGrid(grid, row, col - 1) + dfsGrid(grid, row, col + 1) + 1; // 加1是因为第一次肯定是一块陆地才进来的dfsGrid return res; }}; 四、最大人工岛（困）题目给你一个大小为n x n二进制矩阵grid。最多只能将一格0变成1。返回执行此操作后，grid中最大的岛屿面积是多少？岛屿由一组上、下、左、右四个方向相连的1形成。 示例 1:输入: 输出: 3解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。 示例 2:输入: 输出: 4解释: 将一格0变成1，岛屿的面积扩大为 4。 示例 3:输入: 输出: 4解释: 没有0可以让我们变成1，面积依然为 4。 提示：为或 题解这道题是第三题的升级版，现在我们可以将一个海洋变成陆地，从而连接两个岛屿。那我们就需要先统计各个岛屿面积，找到最大的岛屿；然后把一个海洋变成陆地，再统计一遍连接后各个岛屿面积，找到最大的岛屿。 因此需要两次DFS遍历：1、划分岛屿，给每个岛屿标号标号要标什么呢？假设我们在所有的格子上标记出岛屿的面积。然后搜索哪个海洋格子相邻的两个岛屿面积最大。例如下图中红色方框内的海洋格子，上边、左边都与岛屿相邻，我们可以计算出它变成陆地之后可以连接成的岛屿面积为7 + 1 + 2 = 10。然而，这种做法可能遇到一个问题。如下图中红色方框内的海洋格子，它的上边、左边都与岛屿相邻，这时候连接成的岛屿面积难道是7 + 1 + 7 = 15？显然不是。这两个7来自同一个岛屿，所以填海造陆之后得到的岛屿面积应该只有7 + 1 = 8。可以看到，要让算法正确，我们得能区分一个海洋格子相邻的两个7是不是来自同一个岛屿。那么，我们不能在方格中标记岛屿的面积，而应该用map记录每个岛屿面积，给每个岛屿标记map的key。如下图所示。这样我们就可以发现红色方框内的海洋格子，它的两个相邻的岛屿实际上是同一个。 2、填充海洋，连接四周的岛屿和上面类似，要遍历每个海洋格子上下左右的格子。又因为我们已经有map来记录了各个岛屿的面积，所以只需要在遍历时发现是岛屿，加上对应的面积即可，不需要再全部遍历该岛屿的陆地。要注意的是，我们是将一个海洋变为陆地，所以海洋会占一个面积。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution { public: unordered_map&lt;int, int&gt; area; // 存放各岛屿面积 public: int largestIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int res = 0; int index = 2; // 从2开始是为了和陆地的1做区分,防止多次遍历 // 不同岛屿用不同的数字标记,统计各岛屿面积,同时记录最大值 for (int i = 0; i &lt; grid.size(); i++) { for (int j = 0; j &lt; grid[0].size(); j++) { if (grid[i][j] == 1) { area[index] = dfsGrid(grid, i, j, index); res = max(res, area[index]); index++; } } } // 连接岛屿 for (int i = 0; i &lt; grid.size(); i++) { for (int j = 0; j &lt; grid.size(); j++) { if (grid[i][j] == 0) { res = max(res, linkland(grid, i, j)); } } } return res; } int dfsGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int row, int col, int index) { if (row &gt;= grid.size() || col &gt;= grid[0].size() || row &lt; 0 || col &lt; 0) { return 0; } if (grid[row][col] != 1) { return 0; } grid[row][col] = index; int res = dfsGrid(grid, row - 1, col, index) + dfsGrid(grid, row + 1, col, index) + dfsGrid(grid, row, col - 1, index) + dfsGrid(grid, row, col + 1, index) + 1; return res; } int linkland(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int row, int col) { unordered_set&lt;int&gt; around; int linkarea = 1; // 海洋占一个面积 if (row - 1 &gt;= 0 &amp;&amp; grid[row - 1][col] &gt; 1) { // 左 around.insert(grid[row - 1][col]); } if (row + 1 &lt; grid.size() &amp;&amp; grid[row + 1][col] &gt; 1) { // 右 around.insert(grid[row + 1][col]); } if (col - 1 &gt;= 0 &amp;&amp; grid[row][col - 1] &gt; 1) { // 上 around.insert(grid[row][col - 1]); } if (col + 1 &lt; grid.size() &amp;&amp; grid[row][col + 1] &gt; 1) { // 下 around.insert(grid[row][col + 1]); } for (auto i : around) { linkarea += area[i]; } return linkarea; }};","tags":["刷题笔记"],"categories":["算法交流"]},{"title":"回溯算法","path":"/929892390.html","content":"前言回溯算法本质是一个暴力穷举的过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”（即回退），尝试别的路径。 回溯法有“通用解题法”之称。 它适合于解一些组合数较大的最优化问题。同时涉及回溯算法的题目都有一个共同点：列出所有满足的情况。 另外，基本所有能用回溯算法解决的题目总能画出一个二叉树来。我们称这样的树为决策树。解决一个回溯问题，其实就是一个决策树的遍历过程。所以在回溯法中，深度优先搜索是一种很重要的工具。 算法框架遍历整个决策树时，你只需要思考三个问题： 路径：你已经做出的选择 选择列表：也就是你当前可以做的选择 结束条件：到达决策树底层，无法再做选择的条件 以『全排列』为例。我们可以直接画出全排列的决策树如下： 根据这个决策树，比如说你站在红色节点上。你可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你⾝后，这个选择你之前做过了，而全排列是不允许重复使用数字的。 所以在这里：[2] 就是「路径」，记录你已经做过的选择；[1,3] 就是「选择列表」，表示你当前可以做出的选择；遍历到树的底层，即选择列表为空的时候就是「结束条件」。 框架如下： 123456789101112131415result = []def backtrack(原数组, 行数): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: # 做选择判断,排除不合法的选择 continue # 将合法的选择加⼊选择列表 路径.add(选择) # 回溯下一行 backtrack(原数组, 行数+1) # 撤销选择,将该选择从选择列表移除 路径.remove(选择) 上面的框架中，为什么要撤销选择呢前面我们就说过，回溯算法本质就是在遍历决策树。大家可以想一想，你的一次选择结束了，你肯定要返回当当时进入递归时的状态，然后进行另外的选择啊，不然你不返回状态，其他选择怎么办。如果不撤销，按照下图的角度，你只会得到一个结果，就是用于遍历的左子树。 代码示例12345678910111213141516171819202122232425262728293031class Solution &#123; private: vector&lt;vector&lt;int&gt;&gt; result; // 存储结果 vector&lt;int&gt; track; // 存储当前路径 public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; backtrack(nums, 0); // 回溯函数 return result; &#125; // 路径：记录在 track 中 // 选择列表：nums 中不存在于 track 中的元素 // 结束条件：遍历完所有行, 即 index = nums.size() void backtrack(vector&lt;int&gt;&amp; nums, int index) &#123; if (index == nums.size()) &#123; result.push_back(track); return; &#125; for (int i = 0; i &lt; nums.size(); i++) &#123; if (find(track.begin(), track.end(), nums[i]) != track.end()) &#123; // 排除不合法的选择 continue; &#125; track.push_back(nums[i]); // 做选择,将当前元素添加到路径中 backtrack(nums, index + 1); // 进⼊下⼀层决策树 track.pop_back(); // 撤销选择,将当前元素从路径中弹出 &#125; &#125;&#125;;","tags":["常见算法"],"categories":["算法交流"]},{"title":"回溯算法问题","path":"/2199921100.html","content":"一、全排列（中）题目给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 示例 1：输入：输出： 示例 2：输入：输出： 示例 3：输入：输出： 提示：nums 中的所有整数 互不相同 题解1这道题可以用『回溯算法』来解决。看下面这张图，应该就好理解了 123456789101112131415161718192021222324252627282930313233class Solution { private: vector&lt;vector&lt;int&gt;&gt; result; // 存储结果 vector&lt;int&gt; track; // 存储当前路径 public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { backtrack(nums, 0); // 回溯函数 return result; } // 路径：记录在 track 中 // 选择列表：nums 中不存在于 track 中的元素 // 结束条件：遍历完所有行, 即 index = nums.size() void backtrack(vector&lt;int&gt;&amp; nums, int index) { // index为当前枚举的位置 if (index == nums.size()) { // 遍历完数组中最后一个数字,把当前组合加入结果 result.push_back(track); return; } for (int i = 0; i &lt; nums.size(); i++) { if (find(track.begin(), track.end(), nums[i]) != track.end()) { // 排除不合法的选择 continue; } track.push_back(nums[i]); // 做选择,将当前元素添加到路径中 backtrack(nums, index + 1); // 进⼊下⼀层决策树 track.pop_back(); // 撤销选择,将当前元素从路径中弹出 } }}; 题解2上面的解法中，排除不合法的选择是通过查找track中元素来排除的，速度有点慢。简单的方法就是维护一个数组，用来记录每个数字的使用情况，遍历nums时直接判断数字使用情况来排除不合法的选择。 123456789101112131415161718192021222324252627282930313233343536class Solution { vector&lt;vector&lt;int&gt;&gt; result; // 存储结果 vector&lt;int&gt; track; // 存储当前路径 vector&lt;bool&gt; used; // 数字是否使用 public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { used = vector&lt;bool&gt;(nums.size()); backtrack(nums, 0); return result; } void backtrack(vector&lt;int&gt;&amp; nums, int index) { // index为当前枚举的位置 if (index == nums.size()) { // 遍历完数组中最后一个数字,把当前组合加入结果 result.push_back(track); return; } for (int i = 0; i &lt; nums.size(); i++) { if (used[i]) { continue; } // 当前数字没有使用,加入组合 track.push_back(nums[i]); // 更新使用状态 used[i] = true; // 继续搜索下一个位置 backtrack(nums, index + 1); // 回退使用状态 used[i] = false; // 把数字从当前组合中删除 track.pop_back(); } }}; 二、全排列II（中）题目给定一个可包含重复数字的数组 nums ，按任意顺序 返回所有不重复的全排列。 示例 1：输入：输出： 示例 2：输入：输出： 提示： 题解这道题和『全排列』区别就在于数字是与重复的，那我们就需要在做回溯前先把已经枚举过的数字去重。 有两种情况，1、数字已使用过；2、前后数字重复且前面数字已经使用过（这个我们就需要先对数组排序，让相同的数字都在一块）。其余的照搬『全排列』的回溯就ok了。 123456789101112131415161718192021222324252627282930313233343536373839class Solution { vector&lt;vector&lt;int&gt;&gt; result; // 存储结果 vector&lt;int&gt; track; // 存储当前路径 vector&lt;bool&gt; used; // 数字是否使用 public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); // 先排个序,让重复的数字都在一块 used = vector&lt;bool&gt;(nums.size()); backtrack(nums, 0); return result; } void backtrack(vector&lt;int&gt;&amp; nums, int index) { // idx为当前枚举的位置 if (index == nums.size()) { // 遍历完数组中最后一个数字,把当前组合加入结果 result.push_back(track); return; } unordered_set&lt;int&gt; s; for (int i = 0; i &lt; nums.size(); i++) { if (used[i] || (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1])) { // 1、数字已使用过; 2、前后数字重复且前面数字已经使用过 continue; } // 当前数字没有使用,加入组合 track.push_back(nums[i]); // 更新使用状态 used[i] = true; // 继续搜索下一个位置 backtrack(nums, index + 1); // 回退使用状态 used[i] = false; // 把数字从当前组合中删除 track.pop_back(); } }}; 三、N皇后（困）题目按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 示例 1：输入：输出：解释：如上图所示，4 皇后问题存在两个不同的解法。 示例 2：输入：输出： 提示： 题解下面我用一个 3 * 3 的棋盘，将搜索过程抽象为一棵树，如图：根据回溯模板，1、定义全局变量二维数组board来记录最终结果。参数n是棋盘的大小，然后用row来记录当前遍历到棋盘的第几层了。 1vector&lt;string&gt; board(n, string(n, '.')); 2、根据上图可以看出，当递归到棋盘最底层（也就是叶子节点）的时候，就可以收集结果并返回了。 1234if (row == board.size()) { res.push_back(board); return;} 3、递归深度就是row控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。每次都是要从新的一列的起始位置开始搜，所以都是从0开始。 123456789101112for (int col = 0; col &lt; n; col++) { // 排除不合法选择 if (!isValid(board, row, col)) { continue; } // 做选择 board[row][col] = 'Q'; // 进⼊下⼀行决策 backtrack(board, row + 1); // 撤销选择 board[row][col] = '.';} 4、看一下皇后们的约束条件：不能同行、不能同列、不能同斜线。 12345678910111213141516171819bool isValid(vector&lt;string&gt;&amp; board, int row, int col) { int n = board.size(); // 检查列是否有皇后互相冲突 for (int i = 0; i &lt; n; i++) { if (board[i][col] == 'Q') return false; } // 检查右上方是否有皇后互相冲突 for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) { if (board[i][j] == 'Q') return false; } // 检查左上方是否有皇后互相冲突 for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) { if (board[i][j] == 'Q') return false; } return true;} 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution { vector&lt;vector&lt;string&gt;&gt; res; public: /* 输⼊棋盘边⻓ n，返回所有合法的放置 */ vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) { // n x n的棋盘，n行，每行1个元素，大小为n的string // '.' 表⽰空，'Q' 表⽰皇后，初始化空棋盘。 vector&lt;string&gt; board(n, string(n, '.')); backtrack(board, 0); return res; } // 路径：board 中小于 row 的那些行都已经成功放置了皇后 // 选择列表：第 row 行的所有列都是放置皇后的选择 // 结束条件：row 超过 board 的最后⼀行 void backtrack(vector&lt;string&gt;&amp; board, int row) { // 触发结束条件 if (row == board.size()) { res.push_back(board); return; } int n = board[row].size(); for (int col = 0; col &lt; n; col++) { // 排除不合法选择 if (!isValid(board, row, col)) { continue; } // 做选择 board[row][col] = 'Q'; // 进⼊下⼀行决策 backtrack(board, row + 1); // 撤销选择 board[row][col] = '.'; } } /* 是否可以在 board[row][col] 放置皇后？ */ bool isValid(vector&lt;string&gt;&amp; board, int row, int col) { int n = board.size(); // 检查列是否有皇后互相冲突 for (int i = 0; i &lt; n; i++) { if (board[i][col] == 'Q') return false; } // 检查右上方是否有皇后互相冲突 for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) { if (board[i][j] == 'Q') return false; } // 检查左上方是否有皇后互相冲突 for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) { if (board[i][j] == 'Q') return false; } return true; }}; 四、复原IP地址（中）题目有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。 例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “192.168@1.1“ 是 无效 IP 地址。给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。 示例 1：输入：s = “25525511135”输出：[“255.255.11.135”,”255.255.111.35”] 示例 2：输入：s = “0000”输出：[“0.0.0.0”] 示例 3：输入：s = “101023”输出：[“1.0.10.23”,”1.0.102.3”,”10.1.0.23”,”10.10.2.3”,”101.0.2.3”] 提示：1 &lt;= s.length &lt;= 20s 仅由数字组成 题解用回溯的话，把递归树画出来就清晰了。 从字符串的开头开始，每次尝试截取1到3个字符，判断是否是合法的片段； 一个片段的长度是 1~3 片段的值范围是 0~255 不能是 “0x”、”0xx” 形式 如果是，就加入到当前的IP地址中，并继续向后搜索，直到找到四个整数或者字符串结束。 如果找到了四个整数且字符串刚好结束，就说明找到了一个有效的IP地址，可以加入到结果集中。 如果没有找到四个整数或者字符串还有剩余，就说明这条搜索路径不可行，需要回溯到上一步，尝试其他的截取方式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution { private: vector&lt;string&gt; result; // 存储结果 public: vector&lt;string&gt; restoreIpAddresses(string s) { // 剪枝操作 if (s.size() &lt; 4 || s.size() &gt; 12) return result; backtrack(s, 0, 0); return result; } // 回溯函数 void backtrack(string&amp; s, int startIndex, int pointNum) { // 如果已经找到了 3 个点，且剩余的字符串也是合法的，则将结果加入到 result 中 if (pointNum == 3) { if (isValid(s, startIndex, s.size() - 1)) { result.emplace_back(s); } return; } // 枚举下一个点的位置 for (int i = startIndex; i &lt; s.size(); ++i) { // 如果当前位置是合法的，则在当前位置加入一个点 if (isValid(s, startIndex, i)) { s.insert(s.begin() + i + 1, '.'); ++pointNum; // 继续递归查找下一个点 backtrack(s, i + 2, pointNum); --pointNum; // 将加入的点移除 s.erase(s.begin() + i + 1); } else { // 如果当前位置不合法，则直接退出循环 break; } } } // 判断字符串 s 中从 start 到 end 位置的子串是否合法 bool isValid(string s, int start, int end) { if (start &gt; end) return false; if (s[start] == '0' &amp;&amp; start != end) return false; // 判断字符串中的数字是否合法 int num = 0; for (int i = start; i &lt;= end; ++i) { if (s[i] &gt; '9' || s[i] &lt; '0') { return false; } // 计算字符串对应的数字 num = num * 10 + (s[i] - '0'); if (num &gt; 255) return false; } return true; }};","tags":["刷题笔记"],"categories":["算法交流"]},{"title":"数组排列问题","path":"/3805883677.html","content":"一、下一个排列（中）题目整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。 给你一个整数数组 nums ，找出 nums 的下一个排列。必须 原地 修改，只允许使用额外常数空间。 示例 1：输入：输出： 示例 2：输入：输出： 示例 3：输入：输出： 提示： 题解怎么说呢，首先你得读懂题目。就是按照升序排序，然后依次选取次大的元素进行排序组合。 举个例子，所以下一个排列就是 这道题记住思路，就很容易解决。1、从右开始遍历，先找出第一个索引，满足，如果不存在，就翻转整个数组；2、再从右开始遍历，找出第二个索引，满足；3、交换和；4、最后翻转。 比如，下一个排列是什么？我们找到第一个索引是；再找到第二个索引是；交换，；翻转，。 123456789101112131415161718192021222324252627282930class Solution { public: void nextPermutation(vector&lt;int&gt;&amp; nums) { if (nums.size() == 0) { return; } int firstIndex = -1; for (int i = nums.size() - 2; i &gt;= 0; i--) { if (nums[i] &lt; nums[i + 1]) { firstIndex = i; break; } } if (firstIndex == -1) { reverse(nums.begin(), nums.end()); return; } int secondIndex = -1; for (int i = nums.size() - 1; i &gt; 0; i--) { if (nums[i] &gt; nums[firstIndex]) { secondIndex = i; break; } } int temp = nums[firstIndex]; nums[firstIndex] = nums[secondIndex]; nums[secondIndex] = temp; reverse(nums.begin() + firstIndex + 1, nums.end()); }}; 二、上一个排列（中）题目给定一个整数数组来表示排列，按升序找出其上一个排列。 示例 1：输入：输出： 示例 2：输入：输出： 示例 3：输入：输出： 提示： 题解跟下一个排列一样，只不过求的是上一个，而不是下一个。 举个例子，所以上一个排列就是 所以只需要根据第一题的代码，只用把遍历里的&gt;换成&lt;即可。1、从右开始遍历，先找出第一个索引，满足，如果不存在，就翻转整个数组；2、再从右开始遍历，找出第二个索引，满足；3、交换和；4、最后翻转。 123456789101112131415161718192021222324252627282930class Solution { public: void prevPermutation(vector&lt;int&gt;&amp; nums) { if (nums.size() == 0) { return; } int firstIndex = -1; for (int i = nums.size() - 2; i &gt;= 0; i--) { if (nums[i] &gt; nums[i + 1]) { firstIndex = i; break; } } if (firstIndex == -1) { reverse(nums.begin(), nums.end()); return; } int secondIndex = -1; for (int i = nums.size() - 1; i &gt; 0; i--) { if (nums[i] &lt; nums[firstIndex]) { secondIndex = i; break; } } int temp = nums[firstIndex]; nums[firstIndex] = nums[secondIndex]; nums[secondIndex] = temp; reverse(nums.begin() + firstIndex + 1, nums.end()); }}; 三、交换一次的先前排列（中）题目给你一个正整数数组 arr（可能存在重复的元素），请你返回可在 一次交换（交换两数字 arr[i] 和 arr[j] 的位置）后得到的、按字典序排列小于 arr 的最大排列。如果无法这么操作，就请返回原数组。 示例 1：输入：输出：解释：交换 2 和 1 示例 2：输入：输出：解释：已经是最小排列 示例 3：输入：输出：解释：交换 9 和 7 提示： 题解这题跟我『上一个排列』差不多，主要是它找的排列是两个元素调换位置的，不像『上一个排列』那样，元素可以全部重排。 那首先照搬『上一个排列』解法，最后交换 firstIndex 和 secondIndex ，不用 reverse 逆序排列。 123456789101112131415161718192021222324252627282930313233class Solution { public: vector&lt;int&gt; prevPermOpt1(vector&lt;int&gt;&amp; nums) { if (nums.size() == 0) { return nums; } int firstIndex = -1; for (int i = nums.size() - 2; i &gt;= 0; i--) { if (nums[i] &gt; nums[i + 1]) { firstIndex = i; break; } } if (firstIndex == -1) { return nums; } int secondIndex = -1; for (int i = nums.size() - 1; i &gt; 0; i--) { if (nums[i] &lt; nums[firstIndex]) { if (nums[i] == nums[i - 1]) { // 防止有相邻重复元素出现,比如[3,1,1,4] continue; } secondIndex = i; break; } } int temp = nums[firstIndex]; nums[firstIndex] = nums[secondIndex]; nums[secondIndex] = temp; return nums; }};","tags":["刷题笔记"],"categories":["算法交流"]},{"title":"LRU缓存问题","path":"/1876725769.html","content":"一、LRU 缓存（中）题目请你设计并实现一个满足LRU (最近最少使用) 缓存约束的数据结构。实现LRUCache类： LRUCache(int capacity) 以正整数作为容量capacity初始化 LRU 缓存 int get(int key)如果关键字key存在于缓存中，则返回关键字的值，否则返回-1。 void put(int key, int value)如果关键字key已经存在，则变更其数据值value；如果不存在，则向缓存中插入该组key-value。如果插入操作导致关键字数量超过capacity，则应该逐出最久未使用的关键字。函数get和put必须以O(1)的平均时间复杂度运行。 示例： 输入[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”][ [2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4] ]输出[null, null, null, 1, null, -1, null, -1, 3, 4]解释LRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // 缓存是 {1=1}lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}lRUCache.get(1); // 返回 1lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}lRUCache.get(2); // 返回 -1 (未找到)lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}lRUCache.get(1); // 返回 -1 (未找到)lRUCache.get(3); // 返回 3lRUCache.get(4); // 返回 4 提示：最多调用 次get和put 题解1题目要求实现一个可以存储key-value形式数据的数据结构，并且可以记录最近访问的key值。首先想到的就是用字典来存储key-value结构，这样对于查找操作时间复杂度就是。 但是因为字典本身是无序的，所以我们还需要一个类似于队列的结构来记录访问的先后顺序，这个队列需要支持如下几种操作： 在末尾加入一项 删除头部一项 将队列中某一项移到末尾 所以我们可以想到链表。链表有顺序之分，插入删除快，但是查找慢。那是用单向链表还是双向链表呢？ 对于单向链表，哈希表的结构类似于{key: ListNode(value)}，即键所对应的是一个节点地址，节点的值是value。对于单向链表，可以在常数的时间内找到对应的节点，但是如果想删除节点或者将它移到尾部，则需要从头遍历整个链表，对于这种情况需要的时间复杂度也是。而对于双向链表，可以在常数时间内在任何位置插入或删除节点，而且可以方便地维护头尾节点的指针。 因此，这道题就用一种新的数据结构：哈希链表。双向链表可以用来维护缓存中数据的访问顺序，链表头部是最近访问过的数据，链表尾部是最久没有访问过的数据。同时哈希表用来快速查找键对应的链表节点，以及在链表中删除或移动节点。 双向链表可以直接用list&lt;pair&lt;int, int&gt;&gt;表示，它是C++标准库中的一个容器，可以在任何位置进行常数时间的插入和删除。哈希表直接用unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt;即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class LRUCache { public: // 构造函数，初始化缓存容量 LRUCache(int capacity) : cap(capacity) {} // 获取键为key的值 int get(int key) { // 如果哈希表中不存在该键，返回-1 if (hash_map.find(key) == hash_map.end()) return -1; // 否则，将该键值对移到链表头部（表示最近使用） auto it = hash_map[key]; link_list.splice(link_list.begin(), link_list, it); // 返回值 return it-&gt;second; } // 插入或更新键值对 void put(int key, int value) { // 如果哈希表中已经存在该键 if (hash_map.find(key) != hash_map.end()) { // 更新值 auto it = hash_map[key]; it-&gt;second = value; // 将该键值对移到链表头部（表示最近使用） link_list.splice(link_list.begin(), link_list, it); return; } // 如果缓存已满 if (link_list.size() == cap) { // 删除最近最少使用的键值对（即链表尾部的键值对） auto last = link_list.back(); hash_map.erase(last.first); link_list.pop_back(); } // 在链表头部插入新的键值对 link_list.push_front({key, value}); // 在哈希表中添加映射关系 hash_map[key] = link_list.begin(); } private: int cap; // 缓存容量 list&lt;pair&lt;int, int&gt;&gt; link_list; // 双向链表，用来维护最近最少使用的顺序 unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; hash_map; // 哈希表，用来快速查找键值对}; 题解2上面的双向链表是直接用标准库list&lt;pair&lt;int, int&gt;&gt;实现的，当然我们也可以建立Node、实现双链表。首先定义一个Node结构，然后创建一个头节点和一个尾节点，分别指向链表的第一个和最后一个节点。你还需要定义一些函数来在链表中插入、删除和查找节点。下面是一个简单的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// 定义双向链表节点struct Node { int data; // 数据域 Node* prev; // 指向前一个节点的指针 Node* next; // 指向后一个节点的指针 Node(int x) : data(x), prev(nullptr), next(nullptr) {}};class DoublyLinkedList { private: Node* head; // 头指针，指向链表的第一个节点 Node* tail; // 尾指针，指向链表的最后一个节点 public: DoublyLinkedList() : head(nullptr), tail(nullptr) {} // 在双向链表头部插入新节点 void insertAtHead(int data) { Node* newNode = new Node(data); // 创建新节点 newNode-&gt;next = head; // 将新节点的next指针指向原来的头节点 if (head != nullptr) { // 如果原来的头节点不为空 head-&gt;prev = newNode; // 将原来头节点的prev指针指向新节点 } head = newNode; // 更新头指针为新创建的节点 if (tail == nullptr) { // 如果尾指针为空，说明链表为空 tail = newNode; // 更新尾指针为新创建的节点 } } // 在双向链表尾部插入新节点 void insertAtTail(int data) { if (head == nullptr) { // 如果链表为空，直接在头部插入新节点即可 insertAtHead(data); return; } Node* newNode = new Node(data); // 创建新节点 tail-&gt;next = newNode; // 将尾节点的next指针指向新节点 newNode-&gt;prev = tail; // 将新节点的prev指针指向原来的尾节点 tail = newNode; // 更新尾指针为新创建的节点 } // 在双向链表中查找给定值为val的节点 Node* search(int val) { Node* temp = head; while (temp != nullptr) { // 遍历链表 if (temp-&gt;data == val) { // 如果找到了给定值为val的节点 return temp; // 返回该节点的指针 } temp = temp-&gt;next; // 继续遍历下一个节点 } return nullptr; // 没有找到给定值为val的节点，返回空指针 } // 在双向链表中删除给定值为val的所有节点 void deleteAll(int val) { Node* temp = head; while (temp != nullptr) { // 遍历链表 if (temp-&gt;data == val) { // 如果找到了给定值为val的节点 if (temp == head) { // 如果要删除的是头节点 head = head-&gt;next; // 更新头指针为下一个节点 if (head != nullptr) { // 如果新的头节点不为空 head-&gt;prev = nullptr; // 将新头节点的prev指针设为nullptr } } else if (temp == tail) { // 如果要删除的是尾节点 tail = tail-&gt;prev; // 更新尾指针为前一个节点 tail-&gt;next = nullptr; // 将新尾节点的next指针设为nullptr } else { // 如果要删除的是中间节点 temp-&gt;prev-&gt;next = temp-&gt;next; // 将前一个节点的next指针指向后一个节点 temp-&gt;next-&gt;prev = temp-&gt;prev; // 将后一个节点的prev指针指向前一个节点 } Node* delNode = temp; // 记录要删除的节点 temp = temp-&gt;next; // 继续遍历下一个节点 delete delNode; // 删除节点 } else { temp = temp-&gt;next; // 继续遍历下一个节点 } } } // 打印双向链表中的所有元素 void printList() { Node* temp = head; while (temp != nullptr) { // 遍历链表 std::cout &lt;&lt; temp-&gt;data &lt;&lt; \" \"; temp = temp-&gt;next; } std::cout &lt;&lt; std::endl; }}; 完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586struct Node { int key; int value; Node* prev; Node* next; Node(int k, int v) : key(k), value(v), prev(nullptr), next(nullptr) {}};class LRUCache { private: unordered_map&lt;int, Node*&gt; cache; // 哈希表 Node* head; // 头节点 Node* tail; // 尾节点 int size; // 当前大小 int capacity; // 最大容量 public: LRUCache(int capacity) { this-&gt;capacity = capacity; size = 0; head = new Node(0, 0); tail = new Node(0, 0); head-&gt;next = tail; tail-&gt;prev = head; } int get(int key) { if (cache.count(key) == 0) return -1; // 如果key存在，先通过哈希表定位，再移到头部 Node* node = cache[key]; moveToHead(node); return node-&gt;value; } void put(int key, int value) { if (cache.count(key) == 0) { // 如果key不存在，创建一个新的节点 Node* node = new Node(key, value); // 添加进哈希表 cache[key] = node; // 添加至双向链表的头部 addToHead(node); ++size; if (size &gt; capacity) { // 如果超出容量，删除双向链表的尾部节点，并删除哈希表中对应项 Node* removed = removeTail(); cache.erase(removed-&gt;key); delete removed; --size; } } else { // 如果key存在，先通过哈希表定位，再修改value，并移到头部 Node* node = cache[key]; node-&gt;value = value; moveToHead(node); } } private: void addToHead(Node* node) { node-&gt;prev = head; node-&gt;next = head-&gt;next; head-&gt;next-&gt;prev = node; head-&gt;next = node; } void removeNode(Node* node) { node-&gt;prev-&gt;next = node-&gt;next; node-&gt;next-&gt;prev = node-&gt;prev; } void moveToHead(Node* node) { removeNode(node); addToHead(node); } Node* removeTail() { Node* node = tail-&gt;prev; removeNode(node); return node; }};","tags":["刷题笔记"],"categories":["算法交流"]},{"title":"双指针问题","path":"/2727742723.html","content":"前言双指针具体就是用两个变量动态存储两个结点，来方便我们进行一些操作。通常用在线性的数据结构中。特别是链表类的题目，经常需要用到两个或多个指针配合来记忆链表上的节点，完成某些操作。 一、合并两个有序数组（简）题目给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 示例 1：输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3输出：[1,2,2,3,5,6]解释：需要合并 [1,2,3] 和 [2,5,6] 。合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 示例 2：输入：nums1 = [1], m = 1, nums2 = [], n = 0输出：[1]解释：需要合并 [1] 和 [] 。合并结果是 [1] 。 示例 3：输入：nums1 = [0], m = 0, nums2 = [1], n = 1输出：[1]解释：需要合并的数组是 [] 和 [1] 。合并结果是 [1] 。注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。 提示：nums1.length == m + nnums2.length == n0 &lt;= m, n &lt;= 2001 &lt;= m + n &lt;= 200-10^9 &lt;= nums1[i], nums2[j] &lt;= 10^9 题解1首先我们可以用双指针+额外存储空间来实现O(m + n)的时间复杂度。因为原有数组已经是从小到大排好序了，所以直接从后往前遍历。 1234567891011121314151617181920212223242526272829303132class Solution { public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int p1 = m - 1, p2 = n - 1; // 双指针 int sorted[m + n]; // 额外存储空间 int cur; while (p1 &gt;= 0 || p2 &gt;= 0) { if (p1 == -1) { // p1遍历到头时,记录nums2[p2]的值 cur = nums2[p2]; p2--; } else if (p2 == -1) { // p2遍历到头时,记录nums1[p1]的值 cur = nums1[p1]; p1--; } else if (nums1[p1] &gt; nums2[p2]) { // nums1[p1]&gt;nums2[p2]时,记录nums1[p1]的值 cur = nums1[p1]; p1--; } else { // nums1[p1]&lt;=nums2[p2]时,记录nums2[p2]的值 cur = nums2[p2]; p2--; } // 向后更新sorted sorted[p1 + p2 + 2] = cur; // 从最后一个开始,m+n=p1+p2+2 } for (int i = 0; i &lt; m + n; ++i) { nums1[i] = sorted[i]; } }}; 题解2首先题目里告诉了我们nums1.length &gt;= m+n，所以我们可以直接原地修改，把nums2放入nums1中，将空间复杂度降低到O(1)。建立三个指针，两个指针用于指向nums1和nums2的初始化元素数量的末位，也就是分别指向m-1和n-1的位置（设为p1，p2），还有一个指针，我们指向nums1数组m+n-1的位置即可（设为tail）。其余的跟上面一样 123456789101112131415161718192021222324252627282930class Solution { public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int p1 = m - 1, p2 = n - 1; int tail = m + n - 1; int cur = 0; while (p1 &gt;= 0 || p2 &gt;= 0) { if (p1 == -1) { // p1遍历到头时,记录nums2[p2]的值 cur = nums2[p2]; p2--; } else if (p2 == -1) { // p2遍历到头时,记录nums1[p1]的值 cur = nums1[p1]; p1--; } else if (nums1[p1] &gt; nums2[p2]) { // nums1[p1]&gt;nums2[p2]时,记录nums1[p1]的值 cur = nums1[p1]; p1--; } else { // nums1[p1]&lt;=nums2[p2]时,记录nums2[p2]的值 cur = nums2[p2]; p2--; } // 向后更新nums1 nums1[tail] = cur; tail--; } }}; 二、字符串相加（简）题目给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。 示例 1：输入：num1 = “11”, num2 = “123”输出：”134” 示例 2：输入：num1 = “456”, num2 = “77”输出：”533” 示例 3：输入：num1 = “0”, num2 = “0”输出：”0” 提示：1 &lt;= num1.length, num2.length &lt;= num1 和num2 都只包含数字 0-9num1 和num2 都不包含任何前导零 题解可以使用双指针来模拟人工计算，步骤如下：1、创建指针p1指向num1末位数字，p2指向num2末位数字。2、p1、p2数字相加，进位就用add来记录进位值，无则为0。3、若产生进位，则当前数字为(p1+p2)%10的值。4、若遍历过程中，num1或num2当前已无数字，则用0补位来计算。 1234567891011121314151617class Solution { public: string addStrings(string num1, string num2) { int p1 = num1.length() - 1, p2 = num2.length() - 1, add = 0; string nums = \"\"; while (p1 &gt;= 0 || j &gt;= 0 || add != 0) { int x = p1 &lt; 0 ? 0 : num1[p1] - '0'; int y = p2 &lt; 0 ? 0 : num2[p2] - '0'; int res = x + y + add; nums.push_back(res % 10); add = res / 10; p1--; p2--; } return nums; }}; 三、删除链表的倒数第N个结点（中）题目给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 示例 1： graph LR 1 --&gt; 2 2 --&gt; 3 3 --&gt; 4 4 --&gt; 5 —&gt; graph LR 1 --&gt; 2 2 --&gt; 3 3 --&gt; 5 输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5] 示例 2：输入：head = [1], n = 1输出：[] 示例 3：输入：head = [1,2], n = 1输出：[1] 提示：链表中结点的数目为 sz1 &lt;= sz &lt;= 300 &lt;= Node.val &lt;= 1001 &lt;= n &lt;= sz 题解很简单，可以设想双指针slow和fast，fast先移动，使其和slow间隔n；然后两者同时移动，当fast指向末尾的NULL时，那么slow-&gt;next就是要删除的节点。这里有个问题是，我要删除的节点是头节点怎么办，那此时fast移动间隔n后，肯定是指向NULL，所以直接加个判断就能解决。 1234567891011121314151617181920class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* slow = head; ListNode* fast = head; for (int i = 0; i &lt; n; i++) { fast = fast-&gt;next; } if (fast == NULL) { // 判断要删除的节点是头节点 return head-&gt;next; } while (fast-&gt;next) { slow = slow-&gt;next; fast = fast-&gt;next; } slow-&gt;next = slow-&gt;next-&gt;next; return head; }};","tags":["刷题笔记"],"categories":["算法交流"]},{"title":"Pyinstaller 反编译","path":"/1915330816.html","content":"前言上一篇介绍了如何用Pyinstaller打包python文件成bin文件，那问题来了，我们拿到一个Pyinstaller打包的bin文件，想看代码怎么办，这就要用到Pyinstaller反编译了。 方法一、获取pyc文件我们第一步采用的工具是pyinstxtractor.py，可以将Pyinstaller生成的bin文件解包成pyc文件。之后把这个文件复制到bin文件同级目录下，运行如下命令： 1python pyinstxtractor.py xxbin 运行后生成xxbin.extracted文件夹 ，里面有一堆so ,pyc等文件； 我们还注意到此目录下还有一个PYZ-00.pyz_extracted文件夹，里面都是引入的依赖库，但是注意，里面文件都是.pyc.extracted格式，是加密的，需要进一步反编译 二、pyc文件解密在反编译python生成可执行文件bin时，引用的类库文件经常遇到使用Crypto 模块AES算法加密，解包生成的并不是pyc文件，而是加密的pyc. encrypted文件，当然它也无法查看编译。当然，它也是可以解密的。 第一步，获取Crypto的key，这是打包时由开发者指定的。解包完成后将在根目录形成名为&quot;pyimod00_crypto_key.pyc&quot;的文件，将它转为py文件即可查看key文件。key是必须文件，否则无法进行解密; 第二步，对于不同pyton版本头文件（header）也不相同，2.7~3.10如下所示： 123456789101112Python 2.7: \\x03\\xf3\\x0d\\x0a\\0\\0\\0\\0Python 3.0: \\x3b\\x0c\\x0d\\x0a\\0\\0\\0\\0Python 3.1: \\x4f\\x0c\\x0d\\x0a\\0\\0\\0\\0Python 3.2: \\x6c\\x0c\\x0d\\x0a\\0\\0\\0\\0Python 3.3: \\x9e\\x0c\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0Python 3.4: \\xee\\x0c\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0Python 3.5: \\x17\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0Python 3.6: \\x33\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0Python 3.7: \\x42\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0Python 3.8: \\x55\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0Python 3.9: \\x61\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0Python 3.10: \\x6f\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0 第三步，编写解密处理的脚本代码，将加密的pyc. encrypted文件转成不加密的pyc文件。 12345678910111213141516171819202122232425262728293031323334import globimport zlibimport tinyaesfrom pathlib import PathCRYPT_BLOCK_SIZE = 16# key obtained from pyimod00_crypto_keykey = bytes(&#x27;0000000000013983&#x27;, &#x27;utf-8&#x27;)for p in Path(&quot;PYZ-00.pyz_extracted&quot;).glob(&quot;**/*.pyc.encrypted&quot;): inf = open(p, &#x27;rb&#x27;) # encrypted file input outf = open(p.with_name(p.stem), &#x27;wb&#x27;) # output file # Initialization vector iv = inf.read(CRYPT_BLOCK_SIZE) cipher = tinyaes.AES(key, iv) # Decrypt and decompress plaintext = zlib.decompress(cipher.CTR_xcrypt_buffer(inf.read())) # Write pyc header # The header below is for Python 3.8 outf.write(b&#x27;\\x42\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0&#x27;) # Write decrypted data outf.write(plaintext) inf.close() outf.close() # Delete .pyc.encrypted file p.unlink() 三、pyc反编译为pyLinux下可以使用uncompyle6或者decompyle3来将pyc文件转成py文件，这里使用decompyle3，直接decompyle3 xx.pyc &gt; xx.py即可。 当然，有个在线工具可以直接pyc转py。 四、Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#!/usr/bin/env python# coding: utf-8import osimport sysimport pyinstxtractorimport globimport zlibimport tinyaesfrom pathlib import Pathimport reclass Main(): def __init__(self, parent=None): self.exe_file = sys.argv[1] self.pyc_dir = &quot;&quot; self.key = &quot;&quot; self.files = [] def exe2pyc(self): # 将exe转化为pyc文件 sys.argv = [&#x27;pyinstxtractor.py&#x27;, self.exe_file] pyinstxtractor.main() def get_pyc_dir(self): self.pyc_dir = os.path.basename(self.exe_file) + &quot;_extracted&quot; def encrypted2pyc(self, root): CRYPT_BLOCK_SIZE = 16 # key obtained from pyimod00_crypto_key key = bytes(self.key[0], &#x27;utf-8&#x27;) # key = bytes(&#x27;0000000000013983&#x27;, &#x27;utf-8&#x27;) for p in Path(root).glob(&quot;**/*.pyc.encrypted&quot;): inf = open(p, &#x27;rb&#x27;) # encrypted file input outf = open(p.with_name(p.stem), &#x27;wb&#x27;) # output file # Initialization vector iv = inf.read(CRYPT_BLOCK_SIZE) cipher = tinyaes.AES(key, iv) # Decrypt and decompress plaintext = zlib.decompress(cipher.CTR_xcrypt_buffer(inf.read())) # Write pyc header # The header below is for Python 3.7 outf.write(b&#x27;\\x42\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0&#x27;) # Write decrypted data outf.write(plaintext) inf.close() outf.close() # Delete .pyc.encrypted file # p.unlink() print(&quot;change %s ---&gt; %s&quot;%(p, p.with_name(p.stem))) def pyc2py(self, root, files): for file_name in files: if file_name.endswith(&#x27;.pyc&#x27;): if not self.check_if_file_exists(file_name): if file_name.endswith(&#x27;.pyc&#x27;): part_name = file_name[0:-4] part_file_name = os.path.join(root, part_name).replace(&quot;\\\\&quot;,&quot;/&quot;) os.system(&quot;decompyle3 %s.pyc &gt; %s.py&quot;%(part_file_name, part_file_name)) print(&quot;change %s.pyc ---&gt; %s.py&quot;%(part_file_name, part_file_name)) else: print(&quot;%s already exist, skip&quot;%(file_name[0:-4]+&#x27;.py&#x27;)) continue def get_key_from_crypto_key(self): for root, dirs, files in os.walk(self.pyc_dir, True): for file_name in files: if file_name == &quot;pyimod00_crypto_key.pyc&quot;: part_name = file_name[0:-4] part_file_name = os.path.join(root, part_name).replace(&quot;\\\\&quot;,&quot;/&quot;) os.system(&quot;decompyle3 %s.pyc &gt; %s.py&quot;%(part_file_name, part_file_name)) print(&quot;change %s.pyc ---&gt; %s.py&quot;%(part_file_name, part_file_name)) with open(part_file_name+&#x27;.py&#x27;, &#x27;r&#x27;) as f: for line in f.readlines(): if &quot;key = &quot; in line: self.key = re.findall(r&quot;&#x27;([^&#x27;]*)&#x27;&quot;, line) def check_if_file_exists(self, file_name): part_name = file_name[0:-4] + &#x27;.py&#x27; if part_name in self.files: return True return False def exe2py(self): self.exe2pyc() # 恢复当前目录位置 os.chdir(&quot;..&quot;) self.get_pyc_dir() self.get_key_from_crypto_key() pyz_file = self.pyc_dir+&quot;/PYZ-00.pyz_extracted&quot; self.encrypted2pyc(pyz_file) for root, dirs, files in os.walk(self.pyc_dir, True): self.files = files self.pyc2py(root, files)if __name__==&quot;__main__&quot;: if len(sys.argv) &lt; 2: print(&#x27;[+] Usage: exe2py.py &lt;filename&gt;&#x27;) mainFunc = Main() magic = mainFunc.exe2py()","tags":["python"],"categories":["开发运维"]},{"title":"Ubuntu20 安装 NVIDIA 驱动-Cuda-cuDNN","path":"/3716413998.html","content":"前言最近想在Ubuntu20的工控机上安装NVIDIA显卡驱动，把吃灰的GeForce RTX 2080 Ti用起来，顺便装一下Cuda和cuDNN。 解决一、降内核因为显卡是2080Ti，所以先要降内核。Ubuntu20是5.15，降到5.4.0-80比较合适。 二、安装驱动方法1：1、直接终端上输入命令来看所需的版本 1、直接终端上输入命令来看所需的版本 1ubuntu-drivers devices 2、安装推荐的那个驱动 1sudo apt install nvidia-460 装完之后，你可以在dashboard上搜索nvidia，看到有 NVIDIA X Server Settings的东西，那么驱动就安装成功了，如果没有，那就重启一次电脑看看（如果一直卡在登录界面，就得手动执行官方的run来安装，看方法2） 方法2：1、更新软件安装驱动前一定要更新软件列表和安装必要软件、依赖（必须） 1234sudo apt-get updatesudo apt-get install g++sudo apt-get install gccsudo apt-get install make 注：Ubuntu20默认gcc是9.x，这样后面装Cuda11.2时就不用换gcc版本 2、到官网下想要的版本，一般2080Ti装460是一定可以用的（或者去这里下想要的版本） 3、卸载之前的nvidia驱动有两种方法，根据你之前使用何种方式安装来卸载 1sudo apt-get remove --purge nvidia* 12sudo chmod +x *.runsudo ./NVIDIA-Linux-x86_64-460.32.03.run --uninstall 4、关闭nouveau 1sudo vim /etc/modprobe.d/blacklist.conf 在末尾添加blacklist nouveau和options nouveau modeset=0 123sudo update-initramfs -urebootlsmod | grep nouveau # 如果没有输出，则关闭成功 5、停止显示服务器为了安装新的Nvidia驱动程序，我们需要停止当前的显示服务器。最简单的方法是使用telinit命令更改为运行级别3。在终端输入以下linux命令后，显示服务器将停止 1sudo telinit 3 进入黑漆漆的文本界面tty（如果进不去，就按Ctrl + Alt + F1~F6中的一个 (分别对应进入tty1~tty6)），然后输入用户名和密码。 6、禁用X-window服务 在文本界面中，禁用X-window服务,在终端输入（Ubuntu20自带gdm3，不用再装lightdm） 1sudo service gdm3 stop 7、执行run脚本cd命令进入到你存放驱动的目录，输入命令： 123sudo chmod +x NVIDIA-Linux-x86_64-460.32.03.runsudo ./NVIDIA-Linux-x86_64-460.32.03.run -no-x-check -no-nouveau-check -no-opengl-files# –no-opengl-files 只安装驱动文件，不安装OpenGL文件 nvidia-smi看是否装成功 8、重新打开lightdm 1sudo service gdm3 restart 然后退出文本界面到图形界面，输入sudo telinit 5或者Ctrl + Alt + F1&#x2F;F7&#x2F;F8进入登录界面，登录进系统，然后reboot看是否还会卡在登录界面 三、安装Cuda1、确认Cuda版本根据CUDA Toolkit and Corresponding Driver Versions查找所安装nvidia驱动对应的cuda上限（cuda是向下兼容的）。我们的是RTX 2080Ti，驱动装的是460.32，所以这里装cuda11.2.2 ![CUDA Toolkit and Corresponding Driver Versions](https://cdn.staticaly.com/gh/FelicxFoster/PicXImage@master/Linux_10/CUDA Toolkit and Corresponding Driver Versions.2evmku1kmkg0.webp) 2、确认gcc版本 1gcc --version 根据官网提供的版本信息，确认Cuda11.2要gcc9.x 3、下载cuda在cuda-toolkit中查找对应版本的cuda，下载run文件 1wget https://developer.download.nvidia.com/compute/cuda/11.2.2/local_installers/cuda_11.2.2_460.32.03_linux.run 4、安装Cuda执行指令 1sudo sh cuda_11.2.2_460.32.03_linux.run 进入安装，开始的一大堆文字都是End User License Agreement，可以CTRL +C 跳过，然后输入accept表示接受协议。接下来就是安装的交互界面，根据提示一步一步进行就好。 12345Do you accept the previously read EULA?accept/decline/quit: accept- [] Driver# 不用选上Driver,这是显卡驱动，不用重复安装 5、配置cuda环境变量在 ~&#x2F;.bashrc 的最后添加 123export PATH=/usr/local/cuda-11.2/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;export LD_LIBRARY_PATH=/usr/local/cuda-11.2/lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;export CUDA_HOME=/usr/local/cuda 然后source ~/.bashrc 6、测试cuda 123cd /usr/local/cuda-11.2/samples/1_Utilities/deviceQuerysudo makesudo ./deviceQuery 显示 PASS，安装成功。 四、安装cuDNN1、下载cuDNN在cudnn-archive中查找对应版本的cuDNN（需要注册成为开发者），下载2、5、6、7 在cudnn-archive中查找对应版本的cuDNN（需要注册成为开发者），下载2、5、6、7 2、安装cuDNN 解压cudnn-11.2-linux-x64-v8.1.1.33.tgz 12sudo cp cudnn-11.2-linux-x64-v8.1.1.33/cuda/include/cudnn.h /usr/local/cuda-11.2/nvvm/include/sudo cp cudnn-11.2-linux-x64-v8.1.1.33/cuda/lib64/* /usr/local/cuda-11.2/nvvm/lib64 安装其余三个deb包 123sudo dpkg -i libcudnn7_7.4.1.5-1+cuda10.0_amd64.debsudo dpkg -i libcudnn7-dev_7.4.1.5-1+cuda10.0_amd64.debsudo dpkg -i libcudnn7-doc_7.4.1.5-1+cuda10.0_amd64.deb 3、测试cuDNN 123cd ~/NVIDIA_CUDA-11.2_Samples/1_Utilities/deviceQuerymake./deviceQuery 出现GPU的信息，表示安装成功 五、问题修复因为是降内核，所以可能会导致内核有部分驱动丢失，导致USB摄像头无法识别。此时可以通过命令查看对比与过去高版本的缺少的内容： 1dpkg --get-selections | grep linux 一般是安装modules-extra-5.4.0-80-generic即可 1sudo apt-get install modules-extra-5.4.0-80-generic 六、参考1、Ubuntu 20.04 Ubuntu 21.10 安装显卡驱动\\安装CUDA和cuDNN2、ubuntu降低内核版本","tags":["linux"],"categories":["开发运维"]},{"title":"链表处理问题","path":"/600145628.html","content":"一、合并两个有序链表（简）题目将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1： graph LR a((1)) --&gt; b((2)) --&gt; c((4)) graph LR d[1] --&gt; e[3] --&gt; f[4] graph LR a((1)) --&gt; d[1] --&gt; b((2)) --&gt; e[3] --&gt; c((4)) --&gt; f[4] 输入：l1 = [1,2,4], l2 = [1,3,4]输出：[1,1,2,3,4,4] 示例 2：输入：l1 = [], l2 = []输出：[] 示例 3：输入：l1 = [], l2 = [0]输出：[0] 提示：两个链表的节点数目范围是 [0, 50]-100 &lt;= Node.val &lt;= 100l1 和 l2 均按 非递减顺序 排列 题解很简单，定义第三个链表，然后依次比较两个有序链表的每一位，小的先接到第三个链表后面。最后遍历完后，如果两个链表中还有剩下元素的，直接整个接到第三个链表后面。 1234567891011121314151617181920212223class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* dummyNode = new ListNode(0); ListNode* pre = dummyNode; while (l1 != NULL &amp;&amp; l2 != NULL) { if (l1-&gt;val &lt;= l2-&gt;val) { pre-&gt;next = l1; l1 = l1-&gt;next; } else { pre-&gt;next = l2; l2 = l2-&gt;next; } pre = pre-&gt;next; } if (l1 == NULL) { pre-&gt;next = l2; } else if (l2 == NULL) { pre-&gt;next = l1; } return dummyNode-&gt;next; }}; 二、合并K个升序链表（困）题目给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。 示例 1：输入：lists = [ [1,4,5],[1,3,4],[2,6] ]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 示例 2：输入：lists = [ ]输出：[ ] 示例 3：输入：lists = [ [ ] ]输出：[ ] 提示：k == lists.length0 &lt;= k &lt;= 10^40 &lt;= lists[i].length &lt;= 500-10^4 &lt;= lists[i][j] &lt;= 10^4lists[i] 按 升序 排列lists[i].length 的总和不超过 10^4 题解1根据之前的合并两个有序链表，遍历链表组中的元素，两两合并即可。 12345678910111213141516171819202122232425262728293031323334class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* dummyNode = new ListNode(0); ListNode* pre = dummyNode; while (l1 != NULL &amp;&amp; l2 != NULL) { if (l1-&gt;val &lt;= l2-&gt;val) { pre-&gt;next = l1; l1 = l1-&gt;next; } else { pre-&gt;next = l2; l2 = l2-&gt;next; } pre = pre-&gt;next; } if (l1 == NULL) { pre-&gt;next = l2; } else if (l2 == NULL) { pre-&gt;next = l1; } return dummyNode-&gt;next; } ListNode* mergeKLists(const vector&lt;ListNode*&gt;&amp; lists) { if (lists.size() == 0) { return NULL; } ListNode* result = NULL; for (int i = 0; i &lt; lists.size(); i++) { result = mergeTwoLists(result, lists[i]); } return result; }}; 题解2题解1是按顺序合并，每次合并完的链表就会加长，下一次合并又得遍历一遍，所以时间复杂度会高。这里可以联想到排序算法的归并排序。当然这里我们不用排序，只用归并，然后一一合并链表。具体怎么做呢。比如lists=[[1, 2], [3, 4], [5, 6], [7, 8]]，首先拆分成[[1, 2], [3, 4]]和[[5, 6], [7, 8]]，然后两组分别组内合并，得到两个链表，再互相合并。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* dummyNode = new ListNode(0); ListNode* pre = dummyNode; while (l1 != NULL &amp;&amp; l2 != NULL) { if (l1-&gt;val &lt;= l2-&gt;val) { pre-&gt;next = l1; l1 = l1-&gt;next; } else { pre-&gt;next = l2; l2 = l2-&gt;next; } pre = pre-&gt;next; } if (l1 == NULL) { pre-&gt;next = l2; } else if (l2 == NULL) { pre-&gt;next = l1; } return dummyNode-&gt;next; } ListNode* merge(const vector&lt;ListNode*&gt;&amp; lists, int left, int right) { if (left == right) { return lists[left]; } if (left &gt; right) { return NULL; } int mid = (left + right) &gt;&gt; 1; ListNode* l1 = merge(lists, left, mid); ListNode* l2 = merge(lists, mid + 1, right); return mergeTwoLists(l1, l2); } ListNode* mergeKLists(const vector&lt;ListNode*&gt;&amp; lists) { if (lists.size() == 0) { return NULL; } return merge(lists, 0, lists.size() - 1); }}; 题解3因为最后返回的链表中数组是按由小到大排序的，而C++自带的优先队列priority_queue，可以自动帮我们排序。所以可以拿小根堆先遍历参数中的lists, 因为小根堆top()返回的是最小值，因此可以通过不断吐出小根堆的值，重新组装链表。 1234567891011121314151617181920212223class Solution { public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { ListNode* res = new ListNode(); // 小根堆 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; queue; for (auto list : lists) { while (list != NULL) { queue.push(list-&gt;val); list = list-&gt;next; } } ListNode* temp = res; while (!queue.empty()) { ListNode* node = new ListNode(); node-&gt;val = queue.top(); queue.pop(); temp-&gt;next = node; temp = temp-&gt;next; } return res-&gt;next; }}; 题解4题解3用的是C++自带的priority_queue，我们也可以自己定义类似的queue，从小到大排序。 12345struct Status { int val; ListNode* ptr; bool operator&lt;(const Status&amp; rhs) const { return val &gt; rhs.val; }}; 其余的和题解3类似。 1234567891011121314151617181920212223242526272829class Solution { public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { struct Status { int val; ListNode* ptr; bool operator&lt;(const Status&amp; rhs) const { return val &gt; rhs.val; } }; ListNode* res = new ListNode(); // 最小堆 priority_queue&lt;Status&gt; queue; for (auto list : lists) { while (list != NULL) { queue.push({list-&gt;val, list}); list = list-&gt;next; } } ListNode* temp = res; while (!queue.empty()) { ListNode* node = new ListNode(); node-&gt;val = queue.top().val; queue.pop(); temp-&gt;next = node; temp = temp-&gt;next; } return res-&gt;next; }}; 三、相交链表（简）题目给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。图示两个链表在节点 c1 开始相交： graph LR a1 --&gt; a2 --&gt; c1 b1 --&gt; b2 --&gt; b3 --&gt; c1 --&gt; c2 --&gt; c3 题目数据 保证 整个链式结构中不存在环。注意，函数返回结果后，链表必须 保持其原始结构 。自定义评测：评测系统 的输入如下（你设计的程序 不适用 此输入）： intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0 listA - 第一个链表 listB - 第二个链表 skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数 skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数 评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。 示例 1： graph LR a[4] --&gt; b[1] --&gt; 8 d[5] --&gt; 6 --&gt; e[1] --&gt; 8 --&gt; f[4] --&gt; g[5] 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3输出：Intersected at ‘8’解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。 示例 2： graph LR a[1] --&gt; 9 --&gt; b[1] --&gt; 2 3 --&gt; 2 --&gt; 4 输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Intersected at ‘2’解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： graph LR 2 --&gt; 6 --&gt; 4 1 --&gt; 5 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。 提示：listA 中节点数目为 mlistB 中节点数目为 n1 &lt;= m, n &lt;= 3 * 10^41 &lt;= Node.val &lt;= 10^50 &lt;= skipA &lt;= m0 &lt;= skipB &lt;= n如果 listA 和 listB 没有交点，intersectVal 为 0如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB] 题解直接看图更好理解，1、指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历；2、如果 pA 到了末尾，则 pA = headB 继续遍历；3、如果 pB 到了末尾，则 pB = headA 继续遍历；4、比较长的链表指针指向较短链表head时，长度差就消除了；5、如此，只需要将最短链表遍历两次，当 pA = pB 时，即找到位置。 1234567891011121314class Solution { public: ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) { if (headA == NULL || headB == NULL) { return NULL; } ListNode *pA = headA, pB = headB; while (pA != pB) { pA = (pA == NULL) ? headB : pA-&gt;next; pB = (pB == NULL) ? headA : pB-&gt;next; } return pA; }}; 四、重排链表（中）题目给定一个单链表 L 的头节点 head ，单链表 L 表示为：L0 → L1 → … → Ln - 1 → Ln请将其重新排列后变为：L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1：输入：head = [1,2,3,4]输出：[1,4,2,3] 示例 2：输入：head = [1,2,3,4,5]输出：[1,5,2,4,3] 提示：链表的长度范围为 [1, 5 * 10^4]1 &lt;= node.val &lt;= 1000 题解这题其实是个大杂烩，寻找链表中点(快慢指针) + 链表逆序（反转链表） + 合并链表，这三个的合集。 举个例子，链表 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6第一步，将链表平均分成两半1 -&gt; 2 -&gt; 34 -&gt; 5 -&gt; 6第二步，将第二个链表逆序1 -&gt; 2 -&gt; 36 -&gt; 5 -&gt; 4第三步，依次连接两个链表，得到答案1 -&gt; 6 -&gt; 2 -&gt; 5 -&gt; 3 -&gt; 4 第一步找中点的话，很明显用快慢指针。快指针一次走两步，慢指针一次走一步，当快指针走到终点的话，慢指针会刚好到中点。如果节点个数是偶数的话，slow 走到的是左端点，利用这一点，我们可以把奇数和偶数的情况合并，不需要分开考虑。（快慢指针参考环形链表问题） 第二步链表逆序的话，有迭代和递归的两种方式，迭代的话主要利用两个指针，依次逆转。（反转链表参考反转链表问题） 第三步的话就很简单了，两个指针分别向后移动就可以。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution { public: void reorderList(ListNode* head) { if (head == NULL || head-&gt;next == NULL) return; // 快慢指针分出两段 ListNode* slow = head; ListNode* fast = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) { slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; } // 后端反转 ListNode* reverseNode = slow-&gt;next; slow-&gt;next = NULL; reverseNode = reverseList(reverseNode); // 合并链表 while (reverseNode) { ListNode* tempHead = head-&gt;next; ListNode* tempReverse = reverseNode-&gt;next; head-&gt;next = reverseNode; reverseNode-&gt;next = tempHead; head = tempHead; reverseNode = tempReverse; } } ListNode* reverseList(ListNode* head) { ListNode* next = NULL; ListNode* prev = NULL; while (head) { next = head-&gt;next; head-&gt;next = prev; prev = head; // prev 移动 head = next; // head 移动 } return prev; }}; 五、排序链表（中）题目给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。 示例 1： graph LR 4 --&gt; 2 --&gt; 1 --&gt; 3 —&gt; graph LR 1 --&gt; 2 --&gt; 3 --&gt; 4 输入：head = [4,2,1,3]输出：[1,2,3,4] 示例 2： graph LR -1 --&gt; 5 --&gt; 3 --&gt; 4 --&gt; 0 —&gt; graph LR -1 --&gt; 0 --&gt; 3 --&gt; 4 --&gt; 5 输入：head = [-1,5,3,4,0]输出：[-1,0,3,4,5] 示例 3：输入：head = []输出：[] 提示：链表中节点的数目在范围 内需要在时间复杂度和常数级空间复杂度下，对链表进行排序 题解1要实现时间复杂度和常数级空间复杂度，看之前的排序算法可以知道，符合要求的只有快速排序和归并排序。 首先是快速排序，回顾数组的快排步骤：1、确定一个分界点；2、调整区间：使得左边所有值 &lt;= 分界点， 右边所有值 &gt;= 分界点；3、递归处理左右两段。 那么链表也可以同样的操作：1、首先找到链表的中间节点；2、然后将链表分为左、中、右三部分，分别存储在三个链表中；3、然后递归地对左、右链表进行排序；4、最后将左、中、右三个链表拼接起来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution { public: ListNode* sortList(ListNode* head) { // 如果链表为空或只有一个节点，直接返回 if (!head || !head-&gt;next) { return head; } // 定义左右指针和中间节点 ListNode *left = new ListNode(0), *right = new ListNode(0), *mid = new ListNode(0); ListNode *i = left, *j = right, *m = mid; // 这里用中间节点的原因是，如果每次用最左边的节点，对于纯递增和纯递减的case就退化为O(n) int pivot = getMid(head)-&gt;val; // 如果不考虑超时限制，也可以取最左边的节点作为中间节点 // int pivot = head-&gt;val; // 遍历链表，将节点分别放入左、右、中间链表中 ListNode* cur = head; while (cur) { if (cur-&gt;val &lt; pivot) { i-&gt;next = cur; i = i-&gt;next; } else if (cur-&gt;val &gt; pivot) { j-&gt;next = cur; j = j-&gt;next; } else { m-&gt;next = cur; m = m-&gt;next; } cur = cur-&gt;next; } // 将左、右链表的末尾指向空 i-&gt;next = j-&gt;next = m-&gt;next = NULL; // 递归排序左、右链表 left-&gt;next = sortList(left-&gt;next); right-&gt;next = sortList(right-&gt;next); // 将左、中、右链表拼接起来 cur = left; while (cur-&gt;next) { cur = cur-&gt;next; } cur-&gt;next = mid-&gt;next; while (cur-&gt;next) { cur = cur-&gt;next; } cur-&gt;next = right-&gt;next; // 返回排序后的链表 return left-&gt;next; } ListNode* getMid(ListNode* head) { ListNode* fast = head; ListNode* slow = head; while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) { fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; } return slow; }}; 题解2上面说了，归并也可以解决这道题。回顾数组的归并步骤：1、确定分界点mid = (left + right)&gt;&gt;1，逐层折半分组；2、然后从最小分组开始比较排序，合并成一个大的分组，逐层进行 那么链表也可以同样的操作：1、用快慢指针的方法找到链表的中间节点；2、然后递归地对前半部分和后半部分分别进行排序；3、最后将两个有序链表合并起来 12345678910111213141516171819202122232425262728293031323334class Solution { public: ListNode* sortList(ListNode* head) { if (!head || !head-&gt;next) return head; // 如果链表为空或只有一个节点，直接返回 ListNode *slow = head, *fast = head; // 定义快慢指针 while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) { // 快指针每次走两步，慢指针每次走一步，最终慢指针指向链表中间节点 slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; } fast = slow-&gt;next; // 定义fast指针指向链表后半部分 slow-&gt;next = NULL; // 将链表断开 return merge(sortList(head), sortList(fast)); // 递归调用sortList函数，对前半部分和后半部分分别进行排序，然后合并两个有序链表 } ListNode* merge(ListNode* l1, ListNode* l2) { // 合并两个有序链表 // 定义虚拟头节点和当前节点 ListNode *dummy = new ListNode(0), *cur = dummy; while (l1 &amp;&amp; l2) { // 当l1和l2都不为空时 if (l1-&gt;val &lt; l2-&gt;val) { // 如果l1的值小于l2的值 cur-&gt;next = l1; // 将l1接到当前节点的后面 l1 = l1-&gt;next; // l1指针后移 } else { // 如果l1的值大于等于l2的值 cur-&gt;next = l2; // 将l2接到当前 l2 = l2-&gt;next; // l2指针后移 } cur = cur-&gt;next; // 当前节点后移 } cur-&gt;next = l1 ? l1 : l2; // 将剩余的链表接到当前节点的后面 return dummy-&gt;next; // 返回虚拟头节点的下一个节点 }}; 六、删除排序链表中的重复元素（简）题目给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。 示例 1： graph LR a(1) --&gt; b(1) --&gt; c(2) —&gt; graph LR a(1) --&gt; b(2) 输入：head = [1,1,2]输出：[1,2] 示例 2： graph LR a(1) --&gt; b(1) --&gt; c(2) --&gt; d(3) --&gt; e(3) —&gt; graph LR a(1) --&gt; b(2) --&gt; c(3) 输入：head = [1,1,2,3,3]输出：[1,2,3] 提示： 链表中节点数目在范围 [0, 300] 内 -100 &lt;= Node.val &lt;= 100 题目数据保证链表已经按升序 排列 题解1、首先，使用虚拟头结点dummyNode，让它的next指针指向head，这样可以避免对head进行特判；2、然后遍历链表，有重复元素head就跳一位，就可以达到去重目的了。 1234567891011121314class Solution { public: ListNode* deleteDuplicates(ListNode* head) { ListNode* dummyNode = new ListNode(0); dummyNode-&gt;next = head; while (head) { while (head-&gt;next &amp;&amp; head-&gt;val == head-&gt;next-&gt;val) { head-&gt;next = head-&gt;next-&gt;next; } head = head-&gt;next; } return dummyNode-&gt;next; }}; 七、删除排序链表中的重复元素II（中）题目给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。 示例 1： graph LR a(1) --&gt; b(2) --&gt; c(3) --&gt; d(3) --&gt; e(4) --&gt; f(4) --&gt; g(5) —&gt; graph LR a(1) --&gt; b(2) --&gt; c(5) 输入：head = [1,2,3,3,4,4,5]输出：[1,2,5] 示例 2： graph LR a(1) --&gt; b(1) --&gt; c(1) --&gt; d(2) --&gt; e(3) —&gt; graph LR a(2) --&gt; b(3) 输入：head = [1,1,1,2,3]输出：[2,3] 提示：链表中节点数目在范围 [0, 300] 内-100 &lt;= Node.val &lt;= 100题目数据保证链表已经按升序 排列 题解跟上面第六题类似，只不过这里所有重复的都删除，不保留。1、可以用个标志位，判断当前节点是否需要删除；2、遍历链表，有重复节点就将head右移，这样head就指向了重复节点中的最后一个，同时标记该节点为要删除的；3、根据flag进行删除即可 123456789101112131415161718192021222324class Solution { public: ListNode* deleteDuplicates(ListNode* head) { ListNode* dummyNode = new ListNode(0); dummyNode-&gt;next = head; ListNode* pre = dummyNode; while (head) { bool flag = false; // 标记当前节点是否需要删除 while (head-&gt;next &amp;&amp; head-&gt;val == head-&gt;next-&gt;val) { head = head-&gt;next; flag = true; // 标记当前节点需要删除 } if (flag) { // 对于要删除的节点，将前一个节点的next指针指向当前节点的下一个节点，这样就可以将当前节点删除 pre-&gt;next = head-&gt;next; } else { // 如果当前节点不用删除，则pre不需要改变指向，仍然指向当前节点的前一个节点 pre = head; } head = head-&gt;next; } return dummyNode-&gt;next; }};","tags":["刷题笔记"],"categories":["算法交流"]},{"title":"环形链表问题","path":"/2408095554.html","content":"一、链表的中间结点（简）题目给定一个头结点为 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。 示例 1：输入：[1,2,3,4,5]输出：此列表中的结点 3 (序列化形式：[3,4,5])返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。注意，我们返回了一个 ListNode 类型的对象 ans，这样：ans.val &#x3D; 3, ans.next.val &#x3D; 4, ans.next.next.val &#x3D; 5, 以及 ans.next.next.next &#x3D; NULL. 示例 2：输入：[1,2,3,4,5,6]输出：此列表中的结点 4 (序列化形式：[4,5,6])由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 提示：给定链表的结点数介于 1 和 100 之间。 题解利用快慢指针，快指针一次走两步，慢指针一次走一步。当快指针走到尽头时，此时慢指针对应的九三中间结点。 123456789101112131415class Solution &#123; public: ListNode* middleNode(ListNode* head) &#123; if (!head) &#123; return NULL; &#125; ListNode* slow = head; ListNode* fast = head; while (fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return slow; &#125;&#125;; 二、环形链表（简）题目给你一个链表的头节点 head ，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。如果链表中存在环 ，则返回 true 。 否则，返回 false 。 示例 1： graph LR 3 --> 2 --> 0 --> -4 -4 --> 2 输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： flowchart LR 1 --> 2 2 --> 1 输入：head &#x3D; [1,2], pos &#x3D; 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： flowchart LR 1 输入：head &#x3D; [1], pos &#x3D; -1输出：false解释：链表中没有环。 提示：链表中节点的数目范围在范围 [0, 10^4] 内-10^5 &lt;&#x3D; Node.val &lt;&#x3D; 10^5pos 为 -1 或者链表中的一个 有效索引 。 题解利用快慢指针，快指针一次走两步，慢指针一次走一步。因为快指针快，慢指针慢，所以如果有环快指针最后一定会追上慢指针 12345678910111213141516171819202122232425262728class Solution &#123; public: bool hasCycle(ListNode *head) &#123; if (!head || !head-&gt;next) &#123; return false; &#125; ListNode *slow = head; ListNode *fast = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123; if(!slow-&gt;next) &#123; return false; // 稍微加个判断，减少下用时 &#125; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if (fast == slow) &#123; return true; &#125; &#125; return false; &#125;&#125;;// 另一种表示方法是ListNode *slow = head;ListNode *fast = head-&gt;next;// 两种方式不同点在于,一般用fast=head-&gt;next较多,因为这样可以知道相交点的上一个节点,可以用来删除等操作// fast如果初始化为head-&gt;next,则相交点在slow-&gt;next// fast初始化为head,则相交点在slow 三、环形链表 II（中）题目给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。不允许修改 链表。 示例 1： flowchart LR 3 --> 2 --> 0 --> -4 -4 --> 2 输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： flowchart LR 1 --> 2 2 --> 1 输入：head &#x3D; [1,2], pos &#x3D; 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： flowchart LR 1 输入：head &#x3D; [1], pos &#x3D; -1输出：返回 null解释：链表中没有环。 提示：链表中节点的数目范围在范围 [0, 10^4] 内-10^5 &lt;&#x3D; Node.val &lt;&#x3D; 10^5pos 的值为 -1 或者链表中的一个有效索引 题解这道题是要求入环点，首先要判断有环，这个就直接照搬上一题。主要是怎么找入环点。可以看下面这张图F为第一个节点-F到入环点0的距离；a为入环点0到相遇点h距离；b为相遇点h到入环点0距离；当fast和slow相遇时，因为fast每次走两步，slow每次一步，所以fast走过的是slow的两倍，设slow走过为S，则S&#x3D;F+a，2S&#x3D;F+a+b+a，故F&#x3D;b；现在让slow返回第一个节点，fast处于第一次相遇的节点，此时slow从第一个节点出发，因为F&#x3D;b，所以fast和slow会在入环口第二次相遇，即为所求节点。 123456789101112131415161718192021222324252627282930313233class Solution &#123; public: ListNode* detectCycle(ListNode* head) &#123; if (!head || !head-&gt;next) &#123; return NULL; &#125; bool hasCycle = false; // 先判断是否有环 ListNode* slow = head; ListNode* fast = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123; if (!slow-&gt;next) &#123; break; &#125; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if (fast == slow) &#123; hasCycle = true; break; &#125; &#125; // 有环则找入环开始的节点 if (hasCycle) &#123; slow = head; while (slow != fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return slow; &#125; return NULL; &#125;&#125;;","tags":["刷题笔记"],"categories":["算法交流"]},{"title":"Ubuntu 降低内核版本","path":"/1567026574.html","content":"前言最近要把工控机从Ubuntu18升级到20，同时要用Nvidia显卡，结果Nvidia驱动死活装不上，后面发现是Ubuntu20内核太高了，不支持显卡驱动，因此用到降低Ubuntu内核版本的操作。 方法1、查看原Ubuntu内核版本 123456# 原Ubuntu18内核版本$ uname -r$ 5.4.0-80-generic# 现Ubuntu20内核版本$ uname -r$ 5.15.0-60-generic 2、查看要安装的内核版本 1apt-cache search linux | grep 5.4.0-80 3、输入命令进行安装 1sudo apt-get install linux-headers-5.4.0-80-generic linux-image-5.4.0-80-generic 4、查看此时内核版本 1dpkg --get-selections | grep linux-image 5、修改grub启动项安装成功后设置启动即可选择对应的项，在此处遇到的问题是按ESC一直无法进入Ubuntu高级选项，没法选择Ubuntu内核版本进行启动。解决方法如下： 把 GRUB_TIMEOUT 设置为 -1 ； 把 GRUB_TIME_STYLE=hidden 注释掉； 将 GRUB_CMDLINE_LINUX_DEFAULT 改为”text” 1sudo gedit /etc/default/grub 输入命令，更新grub 1sudo update-grub 6、重启进入Ubuntu高级选项此时选择刚才设置的低版本的内核，不要选择recovery mode。到此ubunt内核版本降低完成。注：如果想设置固定内核，可以参考Ubuntu 修改启动时默认内核版本。 问题按照上述过程重启后进行加载驱动，可能会因为内核没安装完全，少了某些模块。比如执行命令sudo modprobe mtd可能出现错误提示如下所示： 1modprobe: FATAL: Module mtd not found in directory /lib/modules/5.4.0-80-generic 此时可以通过命令查看对比与过去高版本的缺少的内容：查看命令： 1dpkg --get-selections | grep linux 后面deinstall即表示没安装的（只需要看当前内核的module） 此时缺少什么就安装对应安装的版本内容即可： 1sudo apt-get install modules-extra-5.4.0-80-generic 此时再次去安装驱动，执行命令： 1sudo modprobe mtd 发现上述问题已解决。","tags":["linux"],"categories":["开发运维"]},{"title":"动态规划问题","path":"/1625968864.html","content":"一、最大子数组和（中）题目给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组 是数组中的一个连续部分。 示例 1：输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2：输入：nums = [1]输出：1 示例 3：输入：nums = [5,4,-1,7,8]输出：23 提示： 题解1依次遍历数组，记一个临时变量，，如果，说明到temp这个位置都是负数（不用管，因为我们要看最大和，负数肯定小于正数），所以直接让temp归0；如果，记录这时的最大和，同时记录flag（避免遍历玩数组全是负数），继续往下遍历；最后取记录的最大值。另外，如果数组全是负数，就直接取最大那个负数返回。 1234567891011121314151617181920212223class Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int temp = 0; int sum = 0; bool flag = false; for (int i = 0; i &lt; nums.size(); i++) { temp += nums[i]; if (temp &lt; 0) { temp = 0; } else { flag = true; sum = max(temp, sum); } } if (!flag) { auto maxPosition = max_element(nums.begin(), nums.end()); sum = *maxPosition; } return sum; }}; 题解2动态规划四步走。1、状态定义：表示以结尾的连续子数组的最大和2、状态初始化：根据定义，只有1个数，一定以结尾，因此3、状态转移方程：根据状态的定义，由于一定会被选取，并且以结尾的连续子数组与以结尾的连续子数组只相差一个元素。假设数组的值全都严格大于0，那么一定有。可是有可能是负数，于是分类讨论： 如果，那么可以把直接接在表示的那个数组的后面，得到和更大的连续子数组； 如果，那么加上前面的数以后值不会变大。于是另起炉灶，此时单独的一个的值，就是。 以上两种情况的最大值就是的值，写出如下状态转移方程：$$dp[i]=\\left{\\right.$$ 4、状态返回值这个问题的输出是把所有的、、、都看一遍，取最大值 1234567891011121314151617class Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int dp[n]; dp[0] = nums[0]; for (int i = 1; i &lt; n; i++) { if (dp[i - 1] &gt;= 0) { dp[i] = dp[i - 1] + nums[i]; } else { dp[i] = nums[i]; } } auto maxSum = max_element(dp, dp + n); return *maxSum; }}; 二、买卖股票的最佳时机（简）题目给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1：输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2：输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 提示： 题解1用一个变量记录一个最低价格，在第i天卖出股票能得到的利润就是我们只需要遍历一遍价格数组，求出每一天卖出股票得到的利润，取最大值，同时更新最低价格 123456789101112class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int minPrice = INT_MAX; int maxProfit = 0; for (auto price : prices) { maxProfit = max(maxProfit, price - minPrice); minPrice = min(minPrice, price); } return maxProfit; }}; 题解2这道题是最基础的动态规划，下面讲下证明用动态规划解决。题目只问最大利润，没有问这几天具体哪一天买、哪一天卖，因此可以考虑使用动态规划的方法来解决。根据题目意思，有以下两个约束条件：1、不能在买入股票前卖出股票；2、最多只允许完成一笔交易。首先先定义好现金数这个概念，买入股票手上的现金数减少，卖出股票手上的现金数增加。对于这道题，当天是否持股会影响现金数，因为持股表示你还没卖掉，不持股表示卖掉了。所以动态规划的状态需要用到二维数组表示，一方面表示第几天，一方面表示是否持股。动态规划四步走如下。1、状态定义： 表示第i天，不持股，手上拥有的现金数 表示第i天，持股，手上拥有的现金数 2、状态初始化：第1天，，3、状态转移方程：第i天，对于，有两种情况 昨天不持股，今天什么都不做 昨天持股，今天卖出股票（现金数增加） 因此同样对于，也有两种情况 昨天持股，今天什么都不做（现金数与昨天一样） 昨天不持股，今天买入股票（注意：只允许交易一次，因此手上的现金数就是当天的股价的相反数） 因此4、状态返回值遍历到最后一天，不持股状态下就是利润最大化的输出，即 12345678910111213141516171819202122232425class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { int n = prices.size(); if (n &lt; 2) { return 0; } // vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2)); // 数据量大尽量用数组,vector操作太耗时 int dp[n][2]; // dp[i][0],下标为i这天结束的时候,不持股,手上拥有的现金数 // dp[i][1],下标为i这天结束的时候,持股,手上拥有的现金数 // 初始化:不持股显然为0,持股就需要减去第1天(下标为0)的股价 dp[0][0] = 0; dp[0][1] = -prices[0]; // 从第2天开始遍历 for (int i = 1; i &lt; n; i++) { dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = max(dp[i - 1][1], -prices[i]); } return dp[n - 1][0]; }}; 三、买卖股票的最佳时机 II（中）题目给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。返回 你能获得的 最大 利润 。 示例 1：输入：prices = [7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。总利润为 4 + 3 = 7 。 示例 2：输入：prices = [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。总利润为 4 。 示例 3：输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。 提示： 题解和上一题一样，状态定义不变，只不过状态方程有点变化。动态规划四步走如下。1、状态定义： 表示第i天，不持股，手上拥有的现金数 表示第i天，持股，手上拥有的现金数 2、状态初始化：第1天，， 3、状态转移方程：第i天，对于，有两种情况 昨天不持股，今天什么都不做 昨天持股，今天卖出股票（现金数增加） 因此同样对于，也有两种情况 昨天持股，今天什么都不做（现金数与昨天一样） 昨天不持股，即，今天买入股票（注意：允许交易多次，因此手上的现金数就是） 因此。4、状态返回值遍历到最后一天，不持股状态下就是利润最大化的输出，即 1234567891011121314151617181920class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { int n = prices.size(); if (n &lt; 2) { return 0; } int dp[n][2]; dp[0][0] = 0; dp[0][1] = -prices[0]; // 从第2天开始遍历 for (int i = 1; i &lt; n; i++) { dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; }}; 四、买卖股票的最佳时机 III（困）题目给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1:输入：prices = [3,3,5,0,0,3,1,4]输出：6解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。 示例 2：输入：prices = [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3：输入：prices = [7,6,4,3,1]输出：0解释：在这个情况下, 没有交易完成, 所以最大利润为 0。 示例 4：输入：prices = [1]输出：0 提示： 题解分析步骤参照第二题，但这道题状态比第二题多。一天结束时，可能有持股、可能未持股、可能卖出过1次、可能卖出过2次、也可能未卖出过所以定义状态转移数组dp[天数][当前是否持股][卖出的次数]动态规划四步走如下。1、状态定义： 表示第i天，不持股，不卖出过股票，手上拥有的现金数 表示第i天，不持股，卖出1次股票，手上拥有的现金数 表示第i天，不持股，卖出2次股票，手上拥有的现金数 表示第i天，持股，不卖出过股票，手上拥有的现金数 表示第i天，持股，卖出1次股票，手上拥有的现金数 表示第i天，持股，卖出2次股票，手上拥有的现金数 2、状态初始化：第1天有， 第1天休息： 第1天买入： 第1天不可能已经有卖出：、 第一天不可能已经卖出：、 3、状态转移方程：第i天有， 对于，有一种情况，未持股，未卖出过，说明从未进行过买卖。因此 对于，有两种情况，未持股，卖出过1次，可能是之前卖的，可能是今天卖的。因此 对于，有两种情况，未持股，卖出过2次，可能是之前卖的，可能是今天卖的。因此 对于，有两种情况，持股，未卖出过，可能是之前买的，可能是今天买的。因此 对于，有两种情况，持股，卖出过1次，可能是之前买的，可能是今天买的。因此 对于，有一种情况，持股，卖出过2次，不可能（因为最多只允许买卖两次）。因此 4、状态返回值遍历到最后一天，不持股状态下取卖出1次和卖出2次的最大值，即 12345678910111213141516171819202122232425262728293031323334class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { int n = prices.size(); if (n &lt; 2) { return 0; } int MIN_VALUE = INT_MIN / 2; // 这里除2是因为最小值加上1就变成最大值了,会影响max()函数的结果,除数只要比1大就行 int dp[n][2][3]; dp[0][0][0] = 0; // 第一天休息 dp[0][1][0] = -prices[0]; // 第一天买入 dp[0][0][1] = MIN_VALUE; // 第一天不可能已经有卖出 dp[0][0][2] = MIN_VALUE; // 第一天不可能已经卖出 dp[0][1][1] = MIN_VALUE; dp[0][1][2] = MIN_VALUE; // 从第2天开始遍历 for (int i = 1; i &lt; n; i++) { dp[i][0][0] = 0; // 未持股，未卖出过 dp[i][0][1] = max(dp[i - 1][1][0] + prices[i], dp[i - 1][0][1]); // 未持股，卖出过1次 dp[i][0][2] = max(dp[i - 1][1][1] + prices[i], dp[i - 1][0][2]); // 未持股，卖出过2次 dp[i][1][0] = max(dp[i - 1][0][0] - prices[i], dp[i - 1][1][0]); // 持股，未卖出过 dp[i][1][1] = max(dp[i - 1][0][1] - prices[i], dp[i - 1][1][1]); // 持股，卖出过1次 dp[i][1][2] = MIN_VALUE; // 持股，卖出过2次 } return max(max(dp[n - 1][0][1], dp[n - 1][0][2]), 0); }}; 五、最长回文子串（中）题目给你一个字符串 s，找到 s 中最长的回文子串。如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。 示例 1：输入：s = “babad”输出：”bab”解释：”aba” 同样是符合题意的答案。 示例 2：输入：s = “cbbd”输出：”bb” 提示：1 &lt;= s.length &lt;= 1000s 仅由数字和英文字母组成 题解1对于一个子串而言，如果它是回文串，并且长度大于2，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串“ababa”，如果我们已经知道“bab” 是回文串，那么“ababa” 一定是回文串，这是因为它的首尾两个字母都是“a”。因此，如果是回文，我们要判断是否为回文。只需要判断字符串在和两个位置是否为相同的字符，就能减少了很多重复计算。动态规划四步走如下。1、状态定义：表示区间范围的子串是否是回文子串2、状态初始化：根据定义，所有长度为1的子串都是回文串，即 123for (int i = 0; i &lt; sLen; i++) { dp[i][i] = true;} 3、状态转移方程：在确定转移方程时，就要分析如下几种情况。整体上是两种，就是与相等和不相等两种情况。当与不相等，那没啥好说的了，一定是false。当与相等时，这就复杂一些了，有如下三种情况: 下标与相同，是同一个字符，例如a，当然是回文子串 下标与相差在2以内，例如aa或aba，也是回文子串 下标与相差大于2的时候，例如cabac，此时与已经相同了，我们看区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是区间，这个区间是不是回文就看是否为true。 那么状态转移方程就是 123if ((s[left] == s[right]) &amp;&amp; (right - left &lt;= 2 || dp[left + 1][right - 1])) { dp[left][right] = true;} 4、状态返回值判断是否为回文，是就记录回文长度和起始位置，根据这俩就能输出最长回文子串 1234567891011121314151617181920212223242526272829303132333435class Solution { public: string longestPalindrome(string s) { int sLen = s.size(); if (sLen &lt; 2) { return s; } int maxLen = 1, start = 0; int dp[sLen][sLen]; for (int i = 0; i &lt; sLen; i++) { // 初始化,所有长度为1的子串都是回文串 dp[i][i] = true; } for (int subLen = 2; subLen &lt;= sLen; subLen++) { for (int left = 0; left &lt; sLen; left++) { int right = subLen + left - 1; // // 由subLen和left可以确定右边界 if (right &gt;= sLen) { // 如果右边界越界,就可以退出当前循环 break; } if ((s[left] == s[right]) &amp;&amp; (right - left &lt;= 2 || dp[left + 1][right - 1])) { dp[left][right] = true; } else { dp[left][right] = false; } if (dp[left][right] &amp;&amp; right - left + 1 &gt; maxLen) { maxLen = right - left + 1; start = left; } } } return s.substr(start, maxLen); }}; 题解2因为回文串是对称的，这道题推荐用中心扩散法。顾名思义，从每一个位置出发，向两边扩散，遇到不是回文的时候结束。所以可以对每个字符进行扩散，以字符为中心点，为中心点-1，为中心点+1，有三种情况：1、没有超出左边界同时与中心点相等，继续向左扩展2、没有超出右边界同时与中心点相等，继续向右扩展3、和都没超出边界，且的字符等于的字符，两边同时扩散另外，题目要输出的是子串，所以要记录的位置和最大长度 1234567891011121314151617181920212223242526272829303132333435363738class Solution { public: string longestPalindrome(string s) { int sLen = s.size(); if (sLen == 0) { return \"\"; } int left = 0, right = 0, maxLen = 0, start = 0; for (int i = 0; i &lt; sLen; i++) { int len = 1; left = i - 1; // 取中心点左边 right = i + 1; // 取中心点右边 while (left &gt;= 0 &amp;&amp; s[left] == s[i]) { // 没有超过左边界同时与中心点相等,继续向左扩展 left--; len++; } while (right &lt; sLen &amp;&amp; s[right] == s[i]) { // 没有超过右边界同时与中心点相等,继续向右扩展 right++; len++; } while (left &gt;= 0 &amp;&amp; right &lt; sLen &amp;&amp; s[left] == s[right]) { // 没有超过边界同时左右点都与中心点相等,两边都扩展 // 这里要注意, 在最后一次循环中left还是做了 // -1操作,实际上子串不包含这个位置, 所以下面start=left+1 left--; right++; len += 2; } if (len &gt; maxLen) { maxLen = len; start = left + 1; } } return s.substr(start, maxLen); }}; 六、最长递增子序列（中）题目给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例 1：输入：输出：4解释：最长递增子序列是，因此长度为 4 。 示例 2：输入：输出：4 示例 3：输入：输出：1 提示： 题解动态规划四步走如下：1、状态定义：表示中以结尾的最长子序列长度2、状态初始化：所有元素置1，含义是每个元素都至少可以单独成为子序列，此时长度都为13、状态转移方程：设，考虑每轮计算新时，遍历列表区间，做以下判断： 当时：可以接在之后（此题要求严格递增），此情况下最长上升子序列长度为； 这种情况下计算出的的最大值，为直到的最长上升子序列长度（即）； 实现方式为遍历时，每轮执行 当时：无法接在之后，此情况上升子序列不成立，跳过。 4、状态返回值返回列表最大值，即可得到全局最长上升子序列长度 1234567891011121314151617181920class Solution { public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int dp[n]; dp[0] = 1; int maxLen = 1; for (int i = 1; i &lt; n; i++) { dp[i] = 1; for (int j = 0; j &lt; i; j++) { if (nums[j] &lt; nums[i]) { dp[i] = max(dp[i], dp[j] + 1); } } maxLen = max(dp[i], maxLen); } return maxLen; }}; 七、最长公共子序列（中）题目给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。 示例 1：输入：text1 = “abcde”, text2 = “ace”输出：3解释：最长公共子序列是 “ace” ，它的长度为 3 。 示例 2：输入：text1 = “abc”, text2 = “abc”输出：3解释：最长公共子序列是 “abc” ，它的长度为 3 。 示例 3：输入：text1 = “abc”, text2 = “def”输出：0解释：两个字符串没有公共子序列，返回 0 。 提示：1 &lt;= text1.length, text2.length &lt;= 1000text1 和 text2 仅由小写英文字符组成。 题解动态规划四步走如下：1、状态定义：表示和的最长公共子序列的长度。2、状态初始化：初始化就是要看当与时，应该取值为多少。很显然，当或为空时，它们的最长公共子序列长度为0。所以，当或时，初始化为0。3、状态转移方程： 当时，说明两个子字符串的最后一位相等，所以最长公共子序列增加1，即； 当时，说明两个子字符串的最后一位不相等，那么此时的状态应该是和中的较大值； 比如对于和而言，他们的最长公共子序列的长度等于①和的最长公共子序列长度0与②和的最长公共子序列长度1的最大值，即1。 4、状态返回值返回，即和的最长公共子序列长度 12345678910111213141516171819202122232425class Solution { public: int longestCommonSubsequence(string text1, string text2) { int s1 = text1.size(); int s2 = text2.size() int dp[s1 + 1][s2 + 1]; // 初始化 for (int i = 0; i &lt;= s1; i++) { for (int j = 0; j &lt;= s2; j++) { dp[i][j] = 0; } } // 状态转移方程 for (int i = 1; i &lt;= s1; i++) { for (int j = 1; j &lt;= s2; j++) { if (text1[i - 1] == text2[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[s1][s2]; }};","tags":["刷题笔记"],"categories":["算法交流"]},{"title":"多数之和问题","path":"/2469441302.html","content":"一、两数之和（简）题目给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。 示例 1：输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[0,1]解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。 示例 2：输入：nums &#x3D; [3,2,4], target &#x3D; 6输出：[1,2] 示例 3：输入：nums &#x3D; [3,3], target &#x3D; 6输出：[0,1] 提示：2 &lt;&#x3D; nums.length &lt;&#x3D; 10^4-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9-10^9 &lt;&#x3D; target &lt;&#x3D; 10^9只会存在一个有效答案 题解当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。数组可以做哈希表，set也可以，map也可以，用哪个呢对于这道题，不仅要知道元素有没有遍历过，还有知道这个元素对应的下标。需要使用key-value结构来存放，key来存元素，value来存下标，那么使用map正合适而C++中map有三种类型，如下所示: 映射 底层实现 是否有序 key的数量 能否更改数值 查询效率 增删效率 std::map 红黑树 key有序 只能有一个key key不可修改 O(log n) O(log n) std::multimap 红黑树 key有序 可以有多个key key不可修改 O(log n) O(log n) std::map 哈希表 key无序 只能有一个key key不可修改 O(1) O(1) 这道题目中并不需要key有序，所以选择std::unordered_map效率更高接下来就很简单了，首先把数组中的元素作为key，value用来存下标；我们只需要查找map中是否存在target-nums[i]的值，没有就将(nums[i],i)加入map，继续遍历即可 1234567891011121314151617181920212223242526class Solution &#123; public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; num_map; vector&lt;int&gt; res; for (int i = 0; i &lt; nums.size(); i++) &#123; auto iter = num_map.find(target - nums[i]); if (iter != num_map.end()) &#123; res = &#123;iter-&gt;second, i&#125;; break; &#125; num_map.insert(pair&lt;int, int&gt;(nums[i], i)); &#125; return res; &#125;&#125;;int main() &#123; Solution s; vector&lt;int&gt; nums = &#123;2, 7, 11, 15&#125;; int target = 22; vector&lt;int&gt; res = s.twoSum(nums, target); for (auto i : res) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125;&#125; 二、三数之和（中）题目给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。请你返回所有和为 0 且不重复的三元组。注意：答案中不可以包含重复的三元组。 示例 1：输入：nums &#x3D; [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] &#x3D; (-1) + 0 + 1 &#x3D; 0 。nums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0 。nums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。 示例 2：输入：nums &#x3D; [0,1,1]输出：[]解释：唯一可能的三元组和不为 0 。 示例 3：输入：nums &#x3D; [0,0,0]输出：[[0,0,0]]解释：唯一可能的三元组和为 0 。 提示：3 &lt;&#x3D; nums.length &lt;&#x3D; 3000-10^5 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5 题解这道题只用求值，不用求下标，就不需要用哈希表了，用双指针就是最方便的。从小到大排序后，就可以用双指针了因为有需要三个数，可以固定一个数a，双指针遍历剩下的数组，求双指针之和target为0-a即可left为数组头，right为数组尾，大于target则right--，小于target则left++主要是去重，因为有可能数组中同一个数字出现多次，排完序后，相同的数字会连在一起，只要将当前的值和前一个值比就可以去重了。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); // 目的是找出a + left + right = 0 for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[i] &gt; 0) &#123; return res; &#125; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; // 去重a continue; &#125; int left = i + 1; int right = nums.size() - 1; int target = 0 - nums[i]; while (left &lt; right) &#123; if (nums[left] + nums[right] &gt; target) &#123; right--; &#125; else if (nums[left] + nums[right] &lt; target) &#123; left++; &#125; else &#123; res.push_back(&#123;nums[i], nums[left], nums[right]&#125;); // 找到答案时，双指针同时收缩 left++; right--; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123; // 去重left left++; &#125; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123; // 去重right right--; &#125; &#125; &#125; &#125; &#125; return res;&#125;; 三、最接近的三数之和（中）题目给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在恰好一个解。 示例 1：输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1输出：2解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。 示例 2：输入：nums &#x3D; [0,0,0], target &#x3D; 1输出：0 提示：3 &lt;&#x3D; nums.length &lt;&#x3D; 1000-1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000-10^4 &lt;&#x3D; target &lt;&#x3D; 10^4 题解和三数之和非常类似，求与target最接近的三元组，即差值的绝对值最小。和三数之和一样，从小到大排序后，固定一个数a，求双指针之和尽可能接近target-a即可如果a+b+c&gt;target，right--；如果a+b+c&lt;target，left++，同时和三数之和一样需要去重，只是增加一步，在和taget比较之前，需要先update一下三数之和，记录下最接近target的值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; int best = 1e7; // 根据差值的绝对值来更新答案 auto update = [&amp;](int cur) &#123; // auto的特殊用法 if (abs(cur - target) &lt; abs(best - target)) &#123; best = cur; &#125; &#125;; sort(nums.begin(), nums.end()); // 目的是找出a + left + right = 0 for (int i = 0; i &lt; nums.size(); i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; // 去重a continue; &#125; int left = i + 1; int right = nums.size() - 1; while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; if (sum == target) &#123; return target; &#125; update(sum); if (sum &gt; target) &#123; right--; while (right &gt; left &amp;&amp; nums[right] == nums[right + 1]) &#123; // 去重right right--; &#125; &#125; else &#123; left++; while (right &gt; left &amp;&amp; nums[left] == nums[left - 1]) &#123; // 去重left left++; &#125; &#125; &#125; &#125; return best; &#125;&#125;;","tags":["刷题笔记"],"categories":["算法交流"]},{"title":"二叉树遍历问题","path":"/3513594645.html","content":"前言对于下面这个二叉树，不同遍历结果如下：中序遍历：ABCDEFGHIJKLM前序遍历：GDBACFEJIHLKM后序遍历：ACBEFDHIKMLJG 一、二叉树的中序遍历（简）题目给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。 示例 1： graph TD A((1)) --&gt; B(( )) A((1)) --&gt; C((2)) C((2)) --&gt; F((3)) C((2)) --&gt; G(( )) 输入：root = [1,null,2,3]输出：[1,3,2] 示例 2：输入：root = []输出：[] 示例 3：输入：root = [1]输出：[1] 提示：树中节点数目在范围 [0, 100] 内-100 &lt;= Node.val &lt;= 100 题解中序遍历：左 -&gt; 根 -&gt; 右；前序遍历：根 -&gt; 左 -&gt; 右；后序遍历：左 -&gt; 右 -&gt; 根二叉树遍历这种，最好是用stack，把需要的入栈，再按条件出栈比如二叉树如下： graph TD A((1)) --&gt; B((2)) A((1)) --&gt; C((3)) B((2)) --&gt; D((4)) B((2)) --&gt; E((5)) C((3)) --&gt; F((6)) C((3)) --&gt; G(( )) E((5)) --&gt; H((7)) E((5)) --&gt; I((8)) 首先每个三角形的节点顺序必须是左根右，比如4-&gt;2-&gt;5，2-&gt;1-&gt;3。中序遍历的过程就是把左侧子树全部入栈，然后一个个出栈，并取值。这里1&lt;-2&lt;-4入栈，然后4出栈，取值4；到2，2有右子树5，5入栈；5也执行一遍中序遍历，即左子树7入栈，然后7出栈，取值7；到5，5有右子树8，8入栈。重复直到没有子树 1234567891011121314151617181920212223242526272829303132struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode() : val(0), left(nullptr), right(nullptr) {} explicit TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}};class Solution { public: std::vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; res; if (root == NULL) return res; stack&lt;TreeNode*&gt; s; TreeNode* cur = root; while (cur || !s.empty()) { if (cur) { s.push(cur); cur = cur-&gt;left; // left } else { cur = s.top(); s.pop(); res.push_back(cur-&gt;val); // root cur = cur-&gt;right; // right } } return res; }}; 二、二叉树的前序遍历（简）题目给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 示例 1： graph TD A((1)) --&gt; B(( )) A((1)) --&gt; C((2)) C((2)) --&gt; F((3)) C((2)) --&gt; G(( )) 输入：root = [1,null,2,3]输出：[1,2,3] 示例 2：输入：root = []输出：[] 示例 3：输入：root = [1]输出：[1] 示例 4： graph TD A((1)) --&gt; B((2)) A((1)) --&gt; C(( )) 输入：root = [1,2]输出：[1,2] 示例 5： graph TD A((1)) --&gt; B(( )) A((1)) --&gt; C((2)) 输入：root = [1,null,2]输出：[1,2] 提示：树中节点数目在范围 [0, 100] 内-100 &lt;= Node.val &lt;= 100 题解首先每个三角形的节点顺序必须是根左右，比如2-&gt;4-&gt;5，1-&gt;2-&gt;3。参考中序遍历，中序遍历是左根右，所以要左子树入栈-&gt;出栈-&gt;取值-&gt;判断右子树；而先序遍历是根左右，所以要取值-&gt;左子树入栈-&gt;出栈-&gt;判断右子树 12345678910111213141516171819202122class Solution { public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; res; if (root == NULL) return res; stack&lt;TreeNode*&gt; s; TreeNode* cur = root; while (cur || !s.empty()) { if (cur) { res.push_back(cur-&gt;val); // root s.push(cur); cur = cur-&gt;left; // left } else { cur = s.top(); s.pop(); cur = cur-&gt;right; // right } } return res; }}; 三、二叉树的后序遍历（简）题目给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。 示例 1： graph TD A((1)) --&gt; B(( )) A((1)) --&gt; C((2)) C((2)) --&gt; F((3)) C((2)) --&gt; G(( )) 输入：root = [1,null,2,3]输出：[3,2,1] 示例 2：输入：root = []输出：[] 示例 3：输入：root = [1]输出：[1] 提示：树中节点数目在范围 [0, 100] 内-100 &lt;= Node.val &lt;= 100 题解1首先每个三角形的节点顺序必须是左右根，比如4-&gt;5-&gt;2，2-&gt;3-&gt;1。参考前序遍历的根左右，输出根右左，然后倒序，就是左右根 1234567891011121314151617181920212223class Solution { public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; res; if (root == NULL) return res; stack&lt;TreeNode*&gt; s; TreeNode* cur = root; while (cur || !s.empty()) { if (cur) { res.push_back(cur-&gt;val); // root s.push(cur); cur = cur-&gt;right; // right } else { cur = s.top(); s.pop(); cur = cur-&gt;left; // left } } reverse(res.begin(), res.end()); return res; }}; 题解2顺便记录下递归的写法 1234567891011121314151617class Solution { public: void postorder(TreeNode* root, vector&lt;int&gt;&amp; res) { if (root == nullptr) { return; } postorder(root-&gt;left, res); postorder(root-&gt;right, res); res.push_back(root-&gt;val); } vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; res; postorder(root, res); return res; }}; 四、二叉树的层序遍历（中）题目给你二叉树的根节点 root ，返回其节点值的 层序遍历 。（即逐层地，从左到右访问所有节点）。 示例 1： graph TD A((3)) --&gt; B((9)) A((3)) --&gt; C((20)) C((20)) --&gt; F((15)) C((20)) --&gt; G((7)) 输入：root = [3,9,20,null,null,15,7]输出：[ [3],[9,20],[15,7] ] 示例 2：输入：root = [1]输出：[1] 示例 3：输入：root = []输出：[] 提示：树中节点数目在范围 [0, 2000] 内-1000 &lt;= Node.val &lt;= 1000 题解首先要知道遍历二叉树，DFS和BFS的顺序是不一样的从gif图可以看出，前中后序遍历就是DFS遍历，层序遍历就类似BFS遍历，不同的是BFS是输出一个一维数组，而层序遍历要求我们区分每一层，也就是返回一个二维数组那首先我们可以先实现BFS遍历，用队列来存储遍历的节点，因为队列是先进先出，顺序不会乱 1234567891011121314151617181920212223// 二叉树的BFS遍历class Solution { public: vector&lt;int&gt; levelOrder(TreeNode* root) { vector&lt;int&gt; res; queue&lt;TreeNode*&gt; q; if (root != NULL) { q.push(root); } while (!q.empty()) { TreeNode* node = q.front(); q.pop(); res.push_back(node-&gt;val); if (node-&gt;left != NULL) { q.push(node-&gt;left); } if (node-&gt;right != NULL) { q.push(node-&gt;right); } } return res; }}; 有了BFS遍历，怎么把每一层的分别记录下来呢很简单，在每一层遍历开始前，先记录队列中的结点数量n（也就是这一层的结点数量），然后一口气处理完这一层的n个结点 123456789101112131415161718192021222324252627class Solution { public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; res; queue&lt;TreeNode*&gt; q; if (root != NULL) { q.push(root); } while (!q.empty()) { int n = q.size(); vector&lt;int&gt; temp; for (int i = 0; i &lt; n; i++) { TreeNode* node = q.front(); q.pop(); temp.push_back(node-&gt;val); if (node-&gt;left != NULL) { q.push(node-&gt;left); } if (node-&gt;right != NULL) { q.push(node-&gt;right); } } res.push_back(temp); } return res; }};","tags":["刷题笔记","二叉树"],"categories":["算法交流"]},{"title":"元素查找问题","path":"/2832781272.html","content":"二、二分查找（简）题目给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1:输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4 示例 2:输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1 提示：你可以假设 nums 中的所有元素是不重复的。n 将在 [1, 10000]之间。nums 的每个元素都将在 [-9999, 9999]之间。 题解在升序数组nums中寻找目标值target，对于特定下标i，比较nums[i]和target的大小： 如果nums[i] = target，则下标i即为要寻找的下标； 如果nums[i] &gt; target，则target在下标i左侧； 如果nums[i] &lt; target，则target在下标i右侧； 所以，二分查找的做法是，1、定义查找的范围[left,right]，初始查找范围是整个数组；2、每次取查找范围的中点mid，比较nums[mid]和target的大小；3、如果相等则mid即为要寻找的下标，如果不相等则根据nums[mid]和target的大小关系将查找范围缩小一半。 12345678910111213141516171819class Solution { public: int search(vector&lt;int&gt;&amp; nums, int target) { int res = -1; int left = 0, right = nums.size() - 1; while (left &lt; right) { int mid = (left + right) / 2; if (nums[mid] &lt; target) { left = mid + 1; } else if (nums[mid] &gt; target) { right = mid - 1; } else { res = mid; break; } } return res; }}; 二、数组中的第K个最大元素（困）题目给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。 示例 1:输入: [3,2,1,5,6,4], k = 2输出: 5 示例 2:输入: [3,2,3,1,2,4,5,5,6], k = 4输出: 4 提示：1 &lt;= k &lt;= nums.length &lt;= 10^5-10^4 &lt;= nums[i] &lt;= 10^4 题解1最简单的，先排序，再取第k个出来，排序的话就用快排，快排也有很多种，下面是双指针法 1234567891011121314151617181920212223242526272829303132333435363738class Solution { public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { int ve_len = nums.size(); QuickSort(nums, 0, ve_len - 1); return nums[ve_len - k]; } // 快排 void QuickSort(vector&lt;int&gt;&amp; nums, int left, int right) { if (left &gt;= right) return; int pivot = nums[left], i = left, j = right; while (i &lt; j) { while (i &lt; j &amp;&amp; nums[j] &gt;= pivot) { j--; } while (i &lt; j &amp;&amp; nums[i] &lt;= pivot) { i++; } std::swap(nums[i], nums[j]); } std::swap(nums[left], nums[i]); QuickSort(nums, left, i - 1); QuickSort(nums, j + 1, right); }};int main() { int arr[6] = {3, 1, 5, 6, 4, 7}; vector&lt;int&gt; nums(begin(arr), end(arr)); QuickSort(nums, 0, nums.size() - 1); for (auto i : nums) { cout &lt;&lt; i &lt;&lt; \" \"; } return 0;} 题解2既然都想到排序了，何不用大根堆来实现。而且C++自带的优先队列就能实现大根堆，自动帮我们排序首先回顾下优先队列priority_queue普通队列是先进先出；而优先队列中具有最高优先级的元素将被首先删除如下所示，升序队列从大到小排列，top()返回的是最小值，即小根堆；降序队列从小到大排列，top()返回的是最大值，即大根堆 1234// 升序队列priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;// 降序队列priority_queue &lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt;q; 这道题就可以直接用降序队列，把nums存进队列中，让它自个排序，再取第k个就行 1234567891011class Solution { public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; maxHeap; for (int x : nums) maxHeap.push(x); for (int i = 0; i &lt; k - 1; i++) maxHeap.pop(); return maxHeap.top(); }}; 题解3面试官肯定不希望你调库，所以自己实现大根堆才是加分项首先要回顾下堆排序，忘记了就回去看这里大根堆就是根节点一定大过左右节点的值。这样我们就可以根据给定的数组，创建一个大根堆，让最大的值在栈顶，然后要找第k个最大值,就把堆顶的值和最末尾的子节点互换，并忽略该子节点，重新生成个大根堆，这样堆顶元素就是要求的值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution { public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); build_maxHeap(nums); // 创建大根堆 for (int i = 0; i &lt; k - 1; i++) { // 求第i个最大值,就把栈顶的值nums[0]和叶子节点nums[n-1-i]调换 // 除去nums[n-1-i]，剩下其余节点再调整为大根堆 swap(nums[0], nums[n - 1 - i]); adjust_down(nums, 0, n - 1 - i - 1); } for (auto i : nums) { cout &lt;&lt; i &lt;&lt; \" \"; } return nums[0]; } void build_maxHeap(vector&lt;int&gt;&amp; nums) { int n = nums.size(); // 堆排序最后一个非叶子节点(父节点)的序号就是n/2-1 for (int root = n / 2 - 1; root &gt;= 0; root--) { adjust_down(nums, root, n - 1); } } // 向下调整算法 void adjust_down(vector&lt;int&gt;&amp; nums, int root, int size) { // root最开始指向根节点,child是左孩子 if (root &gt; size) return; int temp = nums[root]; // 把堆顶存起来 int child = 2 * root + 1; while (child &lt;= size) { if (child + 1 &lt;= size &amp;&amp; nums[child] &lt; nums[child + 1]) { // 有右子树而且右子树更大 child++; } if (nums[child] &gt; temp) { // 如果child比temp大,child上去填到root的位置,更新root和child,看下一层 nums[root] = nums[child]; root = child; child = 2 * root + 1; } else { break; } } // 不管在哪退出循环,最后都要给空位root赋值 // 如果child &gt; size,把temp放到叶子节点上 nums[root] = temp; }};int main() { Solution s; vector&lt;int&gt; nums = {3, 2, 1, 5, 6, 4}; int k = 4; s.findKthLargest(nums, k); return 0;} 三、搜索旋转排序数组（中）题目整数数组 nums 按升序排列，数组中的值 互不相同 。在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。 示例 1：输入：nums = [4,5,6,7,0,1,2], target = 0输出：4 示例 2：输入：nums = [4,5,6,7,0,1,2], target = 3输出：-1 示例 3：输入：nums = [1], target = 0输出：-1 提示：1 &lt;= nums.length &lt;= 5000-10^4 &lt;= nums[i] &lt;= 10^4nums 中的每个值都 独一无二题目数据保证 nums 在预先未知的某个下标上进行了旋转-10^4 &lt;= target &lt;= 10^4 题解首先要明白这道题问的是啥，很简单就是从给定的数组中找出target的下标。那为啥题目描述的花里胡哨的，还有什么旋转呢，主要是怕你想不到，因为要设计O(log n)的算法，单纯暴力搜索肯定是不行的。那是不是可以用二分法呢？严格来说，标准的二分法只适用于有序数组，但题目给我们的是旋转后的数组，它不是有序的，所以需要对二分法进行修改变形。这个旋转后的数组有什么特点呢？可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。所以我们在常规二分查找的时候，可以查看当前mid为分割位置分割出来的两个部分[left, mid]和[mid+1, right]哪个部分是有序的，根据有序的那部分判断出target在不在这个部分。所以我们在用二分法时有两种情况:1、若nums[0] ≤ nums[mid]，说明[left, mid]是有序的； 则当nums[0] ≤ target &lt; nums[mid]时target在[left, mid-1]中， 否则在[mid+1, right]中； 2、若nums[0] &gt; nums[mid]，说明[mid+1, right]是有序的； 则当nums[mid] &lt; target ≤ nums[size-1]时target在[mid+1, right]中， 否则在[left, mid-1]中。12345678910111213141516171819202122232425262728293031323334353637383940class Solution { public: int search(vector&lt;int&gt;&amp; nums, int target) { if (nums.empty()) { return -1; } int n_size = nums.size(); int left = 0; int right = n_size - 1; int res = -1; while (left &lt;= right) { int mid = (left + right) / 2; if (nums[mid] == target) { res = mid; break; } if (nums[0] &lt;= nums[mid]) { if (nums[0] &lt;= target &amp;&amp; target &lt; nums[mid]) { right = mid - 1; } else { left = mid + 1; } } else { if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n_size - 1]) { left = mid + 1; } else { right = mid - 1; } } } return res; }};int main() { Solution s; vector&lt;int&gt; nums = {4, 5, 6, 7, 0, 1, 2}; cout &lt;&lt; s.search(nums, 0);} 四、搜索旋转排序数组 II（中）题目已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。你必须尽可能减少整个操作步骤。 示例 1：输入：nums = [2,5,6,0,0,1,2], target = 0输出：true 示例 2：输入：nums = [2,5,6,0,0,1,2], target = 3输出：false 提示：题目数据保证在预先未知的某个下标上进行了旋转 题解和上一题一样，只不过因为数组中有重复元素，二分查找时可能会有num[left] = num[mid] = num[right]。比如数组[3,1,2,3,3,3,3]，target = 2，首次二分时无法判断区间[0, 3]和[4, 6]哪个是有序的。对于这种情况，我们只能将当前二分区间的左边界加一，右边界减一，然后在新区间上继续二分查找。其余的照抄上一题。 123456789101112131415161718192021222324252627282930313233343536class Solution { public: int search(vector&lt;int&gt;&amp; nums, int target) { if (nums.empty()) { return -1; } int n_size = nums.size(); int left = 0; int right = n_size - 1; bool res = false; while (left &lt;= right) { int mid = (left + right) / 2; if (nums[mid] == target) { res = true; break; } if (nums[left] == nums[mid] &amp;&amp; nums[mid] == nums[right]) { left++; right--; } else if (nums[0] &lt;= nums[mid]) { if (nums[0] &lt;= target &amp;&amp; target &lt; nums[mid]) { right = mid - 1; } else { left = mid + 1; } } else { if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n_size - 1]) { left = mid + 1; } else { right = mid - 1; } } } return res; }}; 五、寻找旋转排序数组中的最小值（中）题目已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。你必须设计一个时间复杂度为 的算法解决此问题。 示例 1：输入：nums = [3,4,5,1,2]输出：1解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。 示例 2：输入：nums = [4,5,6,7,0,1,2]输出：0解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。 示例 3：输入：nums = [11,13,15,17]输出：11解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。 提示：中的所有整数互不相同原来是一个升序排序的数组，并进行了至次旋转 题解首先对于这个旋转数组，它的特点是：1、以最小值为分界线的左子序列是单调递增的，右子序列也是单调递增的；2、对于数组中最后一个元素x，左子序列全大于x，右子序列全小于x。通过nums[mid]和nums[right]比较，判断nums[mid]在左子序列还是右子序列。有两种情况：1、如果nums[mid] &lt; nums[right]，则mid在右子序列，即在最小值右边，所以right左移；2、如果nums[mid] &gt; nums[right]，则mid在左子序列，即在最小值左边，所以left右移。 12345678910111213141516171819202122class Solution { public: int findMin(vector&lt;int&gt;&amp; nums) { int left = 0; int right = nums.size() - 1; while (left &lt; right) { int mid = (left + right) / 2; if (nums[mid] &lt; nums[right]) { right = mid; // right左移 // 为什么right=mid,而不是right=mid-1; // nums[mid]&lt;nums[right]时,有可能nums[mid]本身就是最小值,然后mid-1就错过了,所以不要减1.比如{4,5,1,2,3},如果right=mid-1,则丢失了最小值1 } else { left = mid + 1; // left右移 // 为什么low=mid+1,而不是low=mid; // 因为我们这题是求最小值,而nums[mid]&gt;nums[right],自然nums[mid]绝对不会是最小值,所以可以+1过滤掉mid这个下标.比如{4,5,6,1,2,3},nums[mid]=6,low=mid+1,刚好nums[low]=1 } } return nums[left]; // 这里返回的是left,所以只能while(left&lt;right).如果返回的是right,就可以while(left&lt;=right)和while(left&lt;right); // 因为若循环条件为while(left&lt;=right),则进入最后一个循环的时候,left=right=mid,都指向最小值,接着执行left=mid+1.这时left便跑到mid和right右边一位去了,因此若要用while(left&lt;=right)条件必须返回 nums[right]或者nums[left-1]. }}; 六、寻找旋转排序数组中的最小值 II（困）题目已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。你必须尽可能减少整个过程的操作步骤。 示例 1：输入：nums = [1,3,5]输出：1 示例 2：输入：nums = [2,2,2,0,1]输出：0 提示：原来是一个升序排序的数组，并进行了至次旋转 题解这道题和上一题区别就在于数组元素是可以重复的，所以对于有重复元素的旋转数组，它的特点是：1、以最小值为分界线的左子序列是单调递增的，右子序列也是单调递增的（注意区分严格单调递增）；2、对于数组中最后一个元素x，左子序列全大于或等于x，右子序列全小于或等于x。同样通过nums[mid]和nums[right]比较，判断nums[mid]在左子序列还是右子序列。只不过因为有重复值，所以多了一种情况。有三种情况： 如果nums[mid] &lt; nums[right]，则mid在右子序列，即在最小值右边，所以right左移； 如果nums[mid] &gt; nums[right]，则mid在左子序列，即在最小值右左边，所以left右移； 如果nums[mid] = nums[right]，则不能确定mid在左子序列还是右子序列；由于它们的值相同，所以无论nums[right]是不是最小值，都有一个最小值nums[mid]，因此我们可以忽略二分查找区间的右端点。 解释下第3点，比如数组[1,0,1,1,1]，left = 0，right = 4，mid = 2，无法判断mid在在左子序列还是右子序列，我们采用right--解决此问题那这个操作会不会影响取最小值呢，事实证明不会： 此操作不会使数组越界：因为迭代条件保证了right&gt;left&gt;=0； 此操作不会使最小值丢失：假设nums[right]是最小值，有两种情况： 若nums[right]是唯一最小值：那就不可能满足判断条件nums[mid]==nums[right]，因为mid&lt;right（left!=right &amp;&amp; mid=(left + right)/2）； 若nums[right]不是唯一最小值，由于mid&lt;right而nums[mid]==nums[right]，即还有最小值存在于[left,right−1]区间，因此不会丢失最小值。123456789101112131415161718class Solution { public: int findMin(vector&lt;int&gt;&amp; nums) { int left = 0; int right = nums.size() - 1; while (left &lt; right) { int mid = (left + right) / 2; if (nums[mid] &lt; nums[right]) { right = mid; // right左移 } else if (nums[mid] &gt; nums[right]) { left = mid + 1; // left右移 } else { right--; } } return nums[left]; }};","tags":["刷题笔记"],"categories":["算法交流"]},{"title":"滑动窗口问题","path":"/2662471910.html","content":"前言滑动窗口是一类特殊的双指针类型题，只不过他的双指针是同向移动。滑动窗口和双指针最大的区别是，滑动窗口更关心窗口内的值，而不只两个指针上的元素。使用滑动窗口解决的问题通常是暴力解法的优化。很多时候滑动窗口会和哈希表一起使用。 一、无重复字符的最长子串（中）题目给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例1：输入: s &#x3D; “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 示例2：输入: s &#x3D; “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。 示例3：输入: s &#x3D; “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 提示：0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 10^4s 由英文字母、数字、符号和空格组成 题解对于数组或字符串寻找找最xx这一类的，都可以用滑动窗口法1、那什么是滑动窗口呢其实就是一个队列。比如abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当窗口右移进入a，队列变成了abca，这时候不满足要求。所以，我们要移动这个队列！2、如何移动我们只要把队列的左边的元素移出就行了，直到满足题目要求！一直维持这样的队列，找出队列出现最长的长度时候，求出解！3、具体操作使用unordered_set作为容器，unordered_set是无序且只有唯一值的容器；unordered_set.insert是在头部插入，当插入元素已存在容器中时，默认删除容器中的元素，按插入的元素排列 12345678910111213141516171819202122class Solution &#123; public: int lengthOfLongestSubstring(string s) &#123; if (s.size() == 0) &#123; return 0; &#125; unordered_set&lt;char&gt; lookup; int maxStr = 0; int left = 0; for (int i = 0; i &lt; s.size(); i++) &#123; while (lookup.find(s[i]) != lookup.end()) &#123; // 找到有相同的字母,窗口右移 // 用while是因为可能有连续多个相同的字母 lookup.erase(s[left]); left++; &#125; maxStr = max(maxStr, i - left + 1); lookup.insert(s[i]); &#125; return maxStr; &#125;&#125;;","tags":["刷题笔记"],"categories":["算法交流"]},{"title":"反转链表问题","path":"/2609717024.html","content":"一、反转链表（简）题目给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例1：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5—-&gt;5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1输入：head = [1，2，3，4，5]输出：[5，4，3，2，1] 示例2：1 -&gt; 2—-&gt;2 -&gt; 1输入：head = [1，2]输出：[2，1] 示例3：输入：head = [ ]输出：[ ] 提示：链表中节点的数目范围是 [0, 5000]-5000 &lt;= Node.val &lt;= 5000 题解1迭代法，记录pre节点和cur节点，不断交换pre和cur，同时cur后移 123456789101112131415class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* pre = NULL; ListNode* cur = head; while (cur != NULL) { ListNode* next = cur-&gt;next; // 这里到最后一个数字时没有next了,返回NULL cur-&gt;next = pre; pre = cur; cur = next; } return pre; }}; 题解2递归法，假设链表其余部分已被反转，怎么去反转它前面的部分。假设a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f-&gt;NULL；若e-&gt;f已经被反转成e&lt;-f，此时在d，我们希望将d-&gt;e变为d&lt;-e，所以d-&gt;next-&gt;next=d；这时d和e互相指向，要断开，所以d-&gt;next=NULL。 123456789101112class Solution { public: ListNode* reverseList(ListNode* head) { if (!head || !head-&gt;next) { return head; } ListNode* newHead = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return newHead; }}; 二、反转链表Ⅱ（中）题目给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。 示例1：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5—-&gt;1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5输入：head = [1，2，3，4，5], left = 2, right = 4输出：[1，4，3，2，5] 示例2：输入：head = [5], left = 1, right = 1输出：[5] 提示：链表中节点数目为 n1 &lt;= n &lt;= 500-500 &lt;= Node.val &lt;= 5001 &lt;= left &lt;= right &lt;= n 题解首先，凡是链表题都可以创建个伪头节点，如下 12ListNode* dummy = new ListNode(0);dummy-&gt;next = head; 参考反转链表，这题是特定位置反转，可以根据left和right取出需要反转的链表，代入反转链表的解法进行反转，再和前后链表拼接。 123456789101112131415161718192021222324252627282930313233343536class Solution { public: // 照搬反转链表 ListNode* reverseList(ListNode* head) { ListNode* pre = NULL; ListNode* cur = head; while (cur != NULL) { ListNode* next = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = next; } return pre; } ListNode* reverseBetween(ListNode* head, int left, int right) { ListNode* dummy = new ListNode(0); dummy-&gt;next = head; ListNode* pre = dummy; ListNode* end = dummy; for (int i = 0; i &lt; left - 1; i++) pre = pre-&gt;next; // 要截取链表的头节点的前一个节点 ListNode* start = pre-&gt;next; // 要截取链表的头节点 for (int i = 0; i &lt; right; i++) end = end-&gt;next; // 要截取链表的尾节点 ListNode* next = end-&gt;next; // 要截取链表的尾节点的后一个节点 end-&gt;next = NULL; // 截断链表,才能用于反转 pre-&gt;next = reverseList(start); start-&gt;next = next; // 链表拼接 return dummy-&gt;next; }}; 三、K个一组翻转链表（困）题目给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 示例1：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5—-&gt;2 -&gt; 1 -&gt; 4 -&gt; 3 -&gt; 5输入：head = [1，2，3，4，5], k = 2输出：[2，1，4，3，5] 示例2：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5—-&gt;3 -&gt; 2 -&gt; 1 -&gt; 4 -&gt; 5输入：head = [1，2，3，4，5], k = 3输出：[3，2，1，4，5] 示例3：输入：head = [ ]输出：[ ] 提示：链表中的节点数目为 n1 &lt;= k &lt;= n &lt;= 50000 &lt;= Node.val &lt;= 1000 题解参考反转链表Ⅱ，反转链表Ⅱ中是给定left和right进行截取来反转，这里可以通过遍历给定的链表，每k个截取一段链表，然后反转并拼接 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution { public: // 照搬反转链表 ListNode* reverseList(ListNode* head) { ListNode* pre = NULL; ListNode* cur = head; while (cur != NULL) { ListNode* next = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = next; } return pre; } // 微调反转链表II ListNode* reverseKGroup(ListNode* head, int k) { ListNode* dummy = new ListNode(0); dummy-&gt;next = head; ListNode* pre = dummy; ListNode* end = dummy; while (end-&gt;next != NULL) { ListNode* start = pre-&gt;next; // 要截取链表的头节点 for (int i = 0; i &lt; k &amp;&amp; end != NULL; i++) end = end-&gt;next; // 要截取链表的尾节点 if (end == NULL) break; ListNode* next = end-&gt;next; // 要截取链表的尾节点的后一个节点 end-&gt;next = NULL; // 截断链表,才能用于反转 pre-&gt;next = reverseList(start); start-&gt;next = next; // 链表拼接 // 开始下一次反转 pre = start; end = pre; } return dummy-&gt;next; }};","tags":["刷题笔记"],"categories":["算法交流"]},{"title":"Python 文件之 QT 界面打包","path":"/2425545972.html","content":"前言相信大家都试过用Pyinstaller将Python文件打包成exe，来发给其他没有安装Python环境的用户使用。但通常情况下，打包生成的exe文件都很大，因为Pyinstaller默认是把本地所有安装的Python库都打包进去。这时，创建一个虚拟环境就是最好的选择，然后在虚拟环境中进行打包。这里介绍打包QT5界面的操作。 解决安装Pipenvpipenv 是用来管理虚拟环境，使用 pip install pipenv 安装 pipenv，pip show pipenv 检查是否安装成功。 添加环境变量打包QT5需要用到QT5的platforms，所以需要添加环境变量。新建QT_QPA_PLATFORM_PLUGIN_PATH，路径是platforms路径。比如我电脑下的platforms路径是D:\\Programfiles\\anaconda3\\Lib\\site-packages\\PyQt5\\Qt5\\plugins\\platforms。重启电脑，让环境变量生效。 具体操作12345678910111213141516# 创建一个文件夹，来保存虚拟环境相关文件，并cd进入该文件夹下# 创建Python3虚拟环境pipenv install --three# 进入虚拟环境pipenv shell# 安装要打包py文件所用到的库以及Pyinstaller# Pyinstaller是必须要在虚拟环境中安装的，不然会调用环境外的Pyinstaller，这样打包没效果pipenv install requestspipenv install pyinstaller# 开始打包# -F 表示打包成一个exe，-i 后面接exe的图标pipenv run pyinstaller -F -w main.py -i shop.ico Pipenv常用命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 1.进入到项目目录[root@localhost ~]# cd /www/wwwroot/myproject# 2.创建虚拟环境[root@localhost myproject]# pipenv install[root@localhost myproject]# pipenv install --three # 使用当前系统的Python3创建环境[root@localhost myproject]# pipenv --two # 使用python2创建环境[root@localhost myproject]# pipenv --three # 使用python3创建环境[root@localhost myproject]# pipenv --python 3.6 # 指定某个Python版本创建环境[root@localhost myproject]# pipenv --python &lt;path/to/python&gt; # 指定某个位置的Python创建环境# 3.激活并进入虚拟环境[root@localhost myproject]# pipenv shell# 4.在虚拟环境中安装模块，并加入到Pipfile。可以不进入虚拟环境中，直接在项目目录下面使用pipenv安装即可。(myproject) [root@localhost myproject]# pipenv install requests(myproject) [root@localhost myproject]# pipenv install django==1.11(myproject) [root@localhost myproject]# pipenv uninstall requests# 5.运行python项目(myproject) [root@localhost myproject]# python Main.py(myproject) [root@localhost myproject]# pipenv run python main.py# 6.退出虚拟环境(myproject) [root@localhost myproject]# exit# pipenv常见命令# 创建pipenv虚拟环境[root@localhost myproject]# pipenv install[root@localhost myproject]# pipenv --two/--three# 查看项目所在路径[root@localhost myproject]# pipenv --where# 查看虚拟环境所在路径[root@localhost myproject]# pipenv --venv# 查看虚拟环境中Python执行文件所在位置（即显示Python解释器信息）[root@localhost myproject]# pipenv --py# 进入pipenv虚拟环境（未存在虚拟环境可自动创建） [root@localhost myproject]# pipenv shell# 安装与卸载包(myproject) [root@localhost myproject]# pipenv install requests(myproject) [root@localhost myproject]# pipenv uninstall requests(myproject) [root@localhost myproject]# pipenv uninstall --all # 卸载全部包并从Pipfile中移除# 查看虚拟环境内安装的包以及包之间的依赖关系(myproject) [root@localhost myproject]# pipenv graph# 查找虚拟环境所有安装包(myproject) [root@localhost myproject]# pip list# 导出虚拟环境内所有依赖包名(myproject) [root@localhost myproject]# pip freeze &gt; requirements.txt# 安装项目所依赖全部模块(myproject) [root@localhost myproject]# pip install -r requirements.txt# 检查包的安全性(myproject) [root@localhost myproject]# pipenv check# 生成Pipenv.lock，Pipfile.lock用来冻结软件包名称及其版本以及其自己的依赖关系的列表(myproject) [root@localhost myproject]# pipenv lock# 退出pipenv虚拟环境 (myproject) [root@localhost myproject]# exit# 删除pipenv当前虚拟环境[root@localhost myproject]# pipenv --rm Pyinstaller打包参数pyinstaller打包有不少可选参数，可以根据自己的需要进行添加。 -F：打包单个文件，产生一个文件用于部署(默认)，如果代码都写在一个 .py 文件时使用，项目有多个文件时不要使用 -D：打包多个文件，产生一个目录用于部署(默认)，用于框架编写的代码打包 --key=keys：使用 keys 进行加密打包 -d：产生 debug 版本的可执行文件 -p：用来添加程序所用到的包的所在位置，设置导入路径，可以用 ; ( Linux 使用 :)分割来指定多个目录。 -w：表示不用控制台窗口，使用 Windows 子系统执行，当程序启动的时候不会打开命令行(只对 Windows 有效) -c：表示打开控制台窗口，使用控制台子系统执行,当程序启动的时候会打开命令行(默认)(只对 Windows 有效) -i：将 file.ico 添加为可执行文件的资源，改变程序的图标(只对 Windows 系统有效) 注意的是，如果是打包QT5的界面，在其他电脑使用，还需要拷贝QT5的platforms，放到其他电脑（路径随意），然后像上面步骤一样添加环境变量，重启电脑，让环境变量生效。","tags":["python"],"categories":["开发运维"]},{"title":"排序算法","path":"/1935562632.html","content":"前言排序算法面试中经常被考到，这里对排序算法做一次总结，方便巩固复习。 table th:first-of-type { width: 15%; } table th:nth-of-type(2) { width: 25%; } table th:nth-of-type(3) { width: 10%; } table th:nth-of-type(4) { width: 50%; } 名称 时间 空间 说明 冒泡排序 1 按顺序依次两个比较，通过交换位置保证大的排后面，依次循环 选择排序 1 选出最小的数，放在首位；再次选，放在第二位 快速排序 1 先选择中间值，然后把比它小的放在左边，大的放在右边（具体实现就是从两边找，找到一对后交换）；然后分别对两边重复进行上述操作 堆排序 1 利用堆的性质进行的选择排序 插入排序 1 逐一取出元素，在已经排序的元素序列中从后向前扫描，放到适当的位置 希尔排序 1 选择一个步长，然后按间隔为步长的单元进行排序，递归，步长逐渐变小，直至为1 归并排序 n 逐层对半拆分，然后逐层从最小分组开始排序，合并成大的分组 冒泡排序算法原理1、遍历数组，从左到右，若右边的数比左边的大，则交换；2、第一遍：最大的数沉下去；3、第二遍：第二大的数沉在倒数第二个位置。 复杂度时间复杂度最差是，最优是两层循环，最差循环次数是，也就是属于稳定排序注：稳定排序：排序前后两个相等的数相对位置不变，则算法稳定；非稳定排序：排序前后两个相等的数相对位置发生了变化，则算法不稳定比如[5,5,1,4,3]，排序后第一个5还是在前，第二个5还是在后，即稳定 Code1234567891011121314151617181920212223242526272829303132// 这个排序次数是固定的，不论元素排列怎么样，时间复杂度都是O(n^2)void BubbleSort(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for (int i = n - 1; i &gt; 0; i--) { for (int j = 0; j &lt; i; j++) { if (nums[j] &gt; nums[j + 1]) { // 交换 int temp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = temp; } } }}// 优化，比如[1,2,3,5,4]，只需要遍历一趟即可void BubbleSort_2(vector&lt;int&gt;&amp; nums) { int n = nums.size(); bool flag = false; // 无序 for (int i = n - 1; i &gt; 0 &amp;&amp; !flag; i--) { flag = true; // 有序 for (int j = 0; j &lt; i; j++) { if (nums[j] &gt; nums[j + 1]) { // 交换 int temp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = temp; flag = false; // 无序 } } }} 选择排序算法原理1、线性遍历数组，选出最小的数，放在第一个位置；2、然后，选出第二小的数，放在第二个位置。依此类推。 复杂度时间复杂度最差是，最优也是两层循环，最差循环次数是，也就是属于不稳定排序 Code12345678910111213141516171819void SelectSort(vector&lt;int&gt; &amp; nums) { int n = nums.size(); for (int i = 0; i &lt; n; i++) { // 找到从i开始到最后一个元素中最小的元素,k存储最小元素的下标. int k = i; for (int j = i + 1; j &lt; n; j++) { if (nums[j] &lt; nums[k]) { k = j; } } // 将最小的元素a[k]和开始的元素a[i]交换数据 if (k != i) { int temp; temp = nums[k]; nums[k] = nums[i]; nums[i] = temp; } }} 快速排序算法原理1、确定一个分界点；2、调整区间：使得左边所有值 &lt;= 分界点， 右边所有值 &gt;= 分界点；3、递归处理左右两段。 复杂度时间复杂度最差是，最优是属于不稳定排序和归并相比，都是分治思想，但归并是稳定的，他是不稳定的 Code12345678910111213141516171819202122232425262728293031323334353637383940/* 看上面的图示, i 从左边移动, j 从右边移动,以最左边作为基准数 pivot ,所以先是 j 移动 * 这里排小到大, ve[j] 比 pivot 大的, j 左移,否则停下; ve[i] 比 pivot 小的, i 右移,否则停下 * j 和 i 都停下后, ve[j] 和 ve[i] 互换,继续上面的移动 * 直到 j 和 i 相碰后,都停下, pivot 和 ve[i] 互换 * 至此,第一轮探测结束, pivot 左边数字均 ≤ pivot,右边数字均 ≥ pivot * 然后我们可以分开左右两边,又按照上述方法排序 */void QuickSort(vector&lt;int&gt;&amp; nums, int left, int right) { if (left &gt;= right) { // 如果左边界大于等于右边界，直接返回 return; } int pivot = nums[left]; // 选取第一个元素作为基准值 int i = left, j = right; // 定义左右指针 while (i &lt; j) { // 双指针遍历数组 while (i &lt; j &amp;&amp; nums[j] &gt;= pivot) { // 从右往左找到第一个小于基准值的元素 j--; } while (i &lt; j &amp;&amp; nums[i] &lt;= pivot) { // 从左往右找到第一个大于基准值的元素 i++; } // 将左边大于基准值的元素和右边小于基准值的元素交换 std::swap(nums[i], nums[j]); } // 这时nums[i]是小于基准值的元素,跟基准值交换,就可以将基准值放到中间 std::swap(nums[left], nums[i]); QuickSort(nums, left, i - 1); QuickSort(nums, j + 1, right);}int main() { vector&lt;int&gt; ve = {6, 1, 2, 7, 9, 3, 4, 5, 10, 8}; QuickSort(ve, 0, ve.size() - 1); for (auto i : ve) { cout &lt;&lt; i &lt;&lt; \" \"; } return 0;} 堆排序算法原理1、将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点；2、将其与末尾元素进行交换，此时末尾就为最大值；3、然后将剩余 n-1 个元素重新构造成一个堆，这样会得到n个元素的次小值；4、如此反复执行，便能得到一个有序序列了注：升序采用大顶堆，降序采用小顶堆 复杂度时间复杂度最差是，最优是属于不稳定排序详见堆排序 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104void display(int array[], int size) { for (int i = 0; i &lt; size; i++) { printf(\"%d \", array[i]); } printf(\" \");}void swap(int array[], int x, int y) { int temp = array[x]; array[x] = array[y]; array[y] = temp;}// 向下调整算法void adjust_down(int array[], int i, int n) { int parent = i; // 父节点下标 int child = 2 * i + 1; // 子节点下标 while (child &lt; n) { if (child + 1 &lt; n &amp;&amp; array[child] &gt; array[child + 1]) { // 选出左右child小的那个，与parent比较 child++; } if (array[child] &lt; array[parent]) { // 如果child比parent小,交换parent和child,这样就保证parent比左右child都小 swap(array, parent, child); // 交换parent和child parent = child; // child下标赋给parent下标 } else { break; } child = child * 2 + 1; // 换行,比较下一层的parent和child }}// 向上调整算法void adjust_up(int array[], int i, int n) { int parent = i; // 父节点下标 int child = 2 * i + 1; // 子节点下标 while (child &lt; n) { if (child + 1 &lt; n &amp;&amp; array[child] &lt; array[child + 1]) { // 选出左右child大的那个，与parent比较 child++; } if (array[parent] &lt; array[child]) { // 如果parent比child小,交换parent和child,这样就保证parent比左右child都大 swap(array, parent, child); // 交换parent和child parent = child; // child下标赋给parent下标 } else { break; } child = child * 2 + 1; // 换行,比较下一层的parent和child }}// 创建小顶堆void BuildMinHeap(int array[], int size) { for (int i = size / 2 - 1; i &gt;= 0; i--) { // 倒数第二排开始,对每一个三角形成的堆,创建小顶堆 adjust_down(array, i, size); }}// 创建大顶堆void BuildMaxHeap(int array[], int size) { for (int i = size / 2 - 1; i &gt;= 0; i--) { // 倒数第二排开始,对每一个三角形成的堆,创建大顶堆 adjust_up(array, i, size); }}// 降序void MaxHeapSort(int array[], int size) { BuildMinHeap(array, size); // 创建小顶堆 display(array, size); for (int i = size - 1; i &gt; 0; i--) { swap(array, 0, i); // 这里交换顶点和第i个数据,就是把顶点的最小值存到尾部, // 在剩余的数字中再进行向下调整,重新建立小顶堆 adjust_down(array, 0, i); }}// 升序void MinHeapSort(int array[], int size) { BuildMaxHeap(array, size); // 创建大顶堆 display(array, size); for (int i = size - 1; i &gt; 0; i--) { // 这里交换顶点和第i个数据,就是把顶点的最大值存到尾部, // 在剩余的数字中再进行向上调整,重新建立大顶堆 swap(array, 0, i); adjust_up(array, 0, i); }}int main() { int array[] = {49, 38, 65, 97, 76, 13, 27, 49, 10}; int size = sizeof(array) / sizeof(int); // 打印数据 display(array, size); MaxHeapSort(array, size); display(array, size); return 0;} 插入排序算法原理对于数组a[10]，1、把a[0]认为已经排好序的；2、从a[1]开始向前和已经排好序的对比，小于排好的就调换，否则停止，并认为a[0,1]已经排好；3、然后a[2]又开始按步骤2进行，一直到a[10]。 复杂度时间复杂度最差是，最优是两层循环，最差循环次数是，也就是属于稳定排序 Code123456789101112131415161718void InsertSort(vector&lt;int&gt;&amp; nums) { int n = nums.size(); // 间隔为1，对数组从第2位开始，记为key； // 按间隔依次比较前面的元素，比key大就放到key后面； // 一个key比较完后，key=key+1，继续比较 int gap = 1; for (int i = 0; i &lt; gap; i++) { for (int j = i + gap; j &lt; n; j = j + gap) { int key = nums[j]; int k = j - gap; while (k &gt;= 0 &amp;&amp; nums[k] &gt; key) { nums[k + gap] = nums[k]; k = k - gap; } nums[k + gap] = key; } }} 希尔排序算法原理希尔排序又称 “缩小增量排序”，它也是一种插入类排序的方法。希尔排序属于插入类排序，是将整个有序序列分割成若干小的子序列分别进行插入排序。其实和插入排序一样，只不过比较间隔不局限于1，而是 n/2，其余都一样。 复杂度时间复杂度是，属于不稳定排序 Code1234567891011121314151617void ShellSort(vector&lt;int&gt;&amp; nums) { int n = nums.size(); // 这里d=n/2,插入排序d=1 for (int gap = n / 2; gap &gt;= 1; gap = gap / 2) { // 将数组分割为多个子表 for (int i = 0; i &lt; gap; i++) { // 依次处理子表 for (int j = i + gap; j &lt; n; j = j + gap) { // 按间隔处理子表 int key = nums[j]; int k = j - gap; while (k &gt;= 0 &amp;&amp; nums[k] &gt; key) { nums[k + gap] = nums[k]; k = k - gap; } nums[k + gap] = key; } } }} 归并排序算法原理1、确定分界点mid = (left + right)&gt;&gt;1，逐层折半分组；2、然后从最小分组开始比较排序，合并成一个大的分组，逐层进行；3、最终所有的元素都是有序的。注：&gt;&gt;1：除以2取整（进1法），&lt;&lt;1：乘以2取整 复杂度时间复杂度最差是，最优是假设待排序的数组元素个数为n，设高度为x，x意味着n个元素需要连续二分x次才剩下1个元素，即，），每一层的总比较次数为n，所以时间复杂度为属于稳定排序 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void MergeSort(vector&lt;int&gt;&amp; nums, int left, int right) { if (left &gt;= right) { return; } vector&lt;int&gt; tmp; int mid = left + right &gt;&gt; 1; // 分别对左边和右边排序，对应归并里的分 MergeSort(nums, left, mid); MergeSort(nums, mid + 1, right); /*对应归并里的合 * 可以这么理解，当left &gt;= right后，就是数组拆分完了，下面是进行合并操作； * tmp数组是用来存储每次排序后的结果，然后赋值会给原数组， * 这样每次合并前的左右两边都是排好序的，我们只需要比较左右两边即可； * 比如[7, 8, 11, 12]和[3, 9]排序； * 7和3比，3存入tmp；7和9比，7存入tmp；8和9比，8存入tmp；11和9比，9存入tmp； * 最后剩下[11, 12]，直接存入tmp */ int i = left, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= right) { if (nums[i] &lt;= nums[j]) { tmp.push_back(nums[i]); i++; } else { tmp.push_back(nums[j]); j++; } } while (i &lt;= mid) { tmp.push_back(nums[i]); i++; // 只要左边没循环完，就执行此操作 } while (j &lt;= right) { tmp.push_back(nums[j]); j++; // 只要右边没循环完，就执行此操作 } for (i = left, j = 0; i &lt;= right; i++, j++) { nums[i] = tmp[j]; // 再将临时数组放回原数组 }}int main() { vector&lt;int&gt; ve = {8, 9, 1, 7, 2, 3, 5, 4, 6, 0}; MergeSort(ve, 0, ve.size() - 1); for (auto i : ve) { cout &lt;&lt; i &lt;&lt; \" \"; } return 0;}","tags":["常见算法"],"categories":["算法交流"]},{"title":"使用向量叉积求点到直线的距离","path":"/2570302048.html","content":"前言假设有一个向量，直线上两点的点，，求到直线的垂直距离 方法向量，向量到向量的距离=是和形成的四边形面积（两个向量叉乘得到的是面积），除以底边，得到的就是高，即到的距离 123456789def point_distance_line(point: list, line_point1: list, line_point2: list): # 计算向量 point_arr = np.array(point) line_point1_arr = np.array(line_point1) line_point2_arr = np.array(line_point2) vec1 = line_point1_arr - point_arr vec2 = line_point2_arr - point_arr distance = np.abs(np.cross(vec1, vec2)) / np.linalg.norm(line_point1_arr - line_point2_arr) return distance","tags":["python","数学"],"categories":["工具脚本"]},{"title":"网易云在线缓存歌曲解码","path":"/106058906.html","content":"前言用手机网易云听歌时，网易云会帮你缓存歌曲文件，是.uc!文件，要想在电脑端回放，需要解码成.flac格式。这里提供一种方法。 解决首先将缓存目录下的.uc!文件提取到电脑，将每个文件按字节与0xA3进行异或，并对文件格式修改成.flac即可。 1234567891011121314151617181920212223242526272829303132333435363738import osdef getCurPath(): return os.getcwd()def getAllFiles(data_path): # 返回data_path目录下的所有文件名 return [f for f in os.listdir(data_path)]def isUcExtension(file): # 判断是否是.uc文件 if len(file) &gt;= 4 and file[-4:] == &#x27;.uc!&#x27;: return True else: return Falsedef ucToFlac(file): # 将当前文件按字节与0xA3进行异或，并对文件格式进行修改 fSource = open(file, &#x27;rb&#x27;) fOut = open(file[:-4] + &#x27;.flac&#x27;, &#x27;wb&#x27;) content = bytearray(fSource.read()) for index in range(len(content)): content[index] ^= 0xA3 fOut.write(content) fSource.close() fOut.close()if __name__ == &#x27;__main__&#x27;: origin_path = &quot;Music&quot; cur_path = getCurPath() total_origin_path = os.path.join(cur_path, origin_path) # 函数调用：将当前目录下所有的.uc文件自动解码成.flac文件 files = getAllFiles(total_origin_path) for file in files: if isUcExtension(os.path.join(total_origin_path, file)): ucToFlac(os.path.join(total_origin_path, file)) print(file[:-4] + &#x27;.flac&#x27; + &#x27;转换成功&#x27;)","tags":["python"],"categories":["工具脚本"]},{"title":"Ubuntu 修改用户名和 home 目录名称","path":"/3405114981.html","content":"前言最近想修改用户名和home下目录，有两种方法。方法一：修改配置文件（这种方法修改后，home下文件名还是原名字）方法二：创建新临时用户，使用临时用户修改你想修改的用户的名字 法一修改密码注：如果用户名和密码都要修改，请先修改密码，否则可能会出现无法登录的情况 1sudo passwd 用户名 输入新密码，然后重启 修改用户名12345678sudo gedit /etc/passwd# 注：找到原用户名所在行，修改为新用户名，但是后面目录里名字不要修改sudo gedit /etc/shadow# 注：找到原用户名所在行，修改为新用户名sudo gedit /etc/group# 注：将所有组中的原用户名都修改为新用户名，建议使用搜索功能确认全部修改完毕 重启后就行了注：如果发现无法登录到su，报错：用户xxx不在sudoers文件中，应该是group没有修改完全。注：这样修改之后，home文件下还是原名字，用修改文件夹名字的方法是不行的，会导致登录时输入密码后又回到输入密码的界面。 法二假设原用户是user1，home下目录是dir1，新用户是new_user1，新目录是new_dir1。 创建新用户添加新用户temp 1sudo adduser temp 授予root权限 1sudo adduser temp sudo 修改用户名和目录重启，登录temp用户修改用户名 1sudo usermod -l new_user1 user1 修改目录 1sudo usermod -d /home/new_dir1 -m new_user1 或者合二为一 12sudo usermod -l new_user1 -d /home/new_dir1 -m user1# 注：注意这里和上面在-m后面是不一样的 删除创建的临时用户重启，登录修改后new_use1用户删除用户 1sudo deluser temp 删除文件夹 1sudo rm -r /home/temp","tags":["linux"],"categories":["开发运维"]},{"title":"如何理解 if __name__ == '__main__'","path":"/539495985.html","content":"前言在大多数编排得好一点的脚本或者程序里面都有这段if __name__ == &#39;main&#39;:，虽然一直知道他的作用，但是一直比较模糊，收集资料详细理解之后与大家分享。 代码功能一个python的文件有两种使用的方法，第一是直接作为脚本执行，第二是import到其他的python脚本中被调用（模块重用）执行。因此if __name__ == &#39;main&#39;:的作用就是控制这两种情况执行代码的过程，if __name__ == &#39;main&#39;:下的代码只有在第一种情况下（即文件作为脚本直接执行）才会被执行，而import到其他脚本中是不会被执行的。 举个例子，下面在test.py中写入如下代码： 123print(&quot;A&quot;)if __name__ == &#x27;__main__&#x27; : print(&quot;B&quot;)直接执行test.py，输出A和B。即，if __name__==&quot;__main__&quot;:语句之前和之后的代码都被执行。 然后在同一文件夹新建名称为import_test.py的脚本，只输入如代码·import test，执行脚本，只输出A。即，if __name__==&quot;__main__&quot;:之前的语句被执行，之后的没有被执行。 运行原理每个python模块（python文件，也就是此处的test.py和import_test.py）都包含内置的变量__name__，当运行模块被执行的时候，name__等于文件名（包含了后缀.py）；如果import到其他模块中，则__name__等于模块名称（不包含后缀.py）。而“__main__”等于当前执行文件的名称（包含了后缀.py）。进而当模块被直接执行时，__name &#x3D;&#x3D; ‘main’结果为真。 举例说明，我们在test.py脚本的if __name__==&quot;__main__&quot;:之前加入print (__name__)，即将__name__打印出来。输出__main__。再执行import_test.py，输出test。此时，test.py中的__name__变量值为test，不满足__name__&#x3D;&#x3D;”main“的条件，因此，无法执行其后的代码。","tags":["python"],"categories":["开发运维"]},{"title":"Ubuntu 修改启动时默认内核版本","path":"/3958869895.html","content":"前言最近每次重启工控机内核都会变化，而我安装的cuda在另一个核，每次都会忘记切。 方法目前 Ubuntu 的默认启动版本为 4.13.0-26-generic，我想将其修改为 4.10.0-42-generic1、修改grub文件 1sudo gedit /etc/default/grub 2、修改默认启动的内核假设，在启动选择内核时，Advananced options for Ubuntu的子菜单如下所示： 123456Ubuntu, with Linux 4.13.0-26-genericUbuntu, with Linux 4.13.0-26-generic (upstart)Ubuntu, with Linux 4.13.0-26-generic (recovery mode)Ubuntu, with Linux 4.10.0-42-genericUbuntu, with Linux 4.10.0-42-generic (upstart)Ubuntu, with Linux 4.10.0-42-generic (recovery mode) GRUB_DEFAULT=0即为默认的启动内核，0就是内核索引，比如1就是第二个内核选项，即Linux 4.13.0-26-generic (upstart)，我们可以通过改这个数字来让系统启动时选择特定内核。 那我记不住我想要的内核是第几个咋弄。。。 那就直接改名字吧，在/etc/default/grub中修改为 1GRUB_DEFAULT=&quot;Advanced options for Ubuntu&gt;Ubuntu, with Linux 4.10.0-42-generic&quot; 3、更新配置 1sudo update-grub 下次重启系统就ok了","tags":["linux"],"categories":["开发运维"]},{"title":"gdb 调试 C++ 程序 core dump","path":"/356668589.html","content":"前言最近用C++写ros程序，老是有莫名其妙的core dump。而调试core dump最方便就是使用gdb，这里做个记录。 调试准备程序执行时, 经常会因为段错误（Segment Fault）而退出，操作系统会把此程序当前内存信息dump到磁盘上，即生成core文件。那gdb主要就是分析core文件。 设置core文件大小系统默认不会生成core文件，需要进一步设置。core文件的生成依赖于shell的设置, 在shell中运行命令：ulimit -a，从第一行的设置项可以看到系统设置的core file size 为0，即不生成core file。使用命令：ulimit -c unlimited，可以设置core file size为无限，但只限当前终端可用。 C++文件调试如果是单一的C++文件调试，直接用在编译时加上-g添加调试信息即可比如g++ -g test.cpp -o test，遇到core dump会在test.cpp所在目录下生成core文件，直接gdb ./test core即可 CMake文件调试如果工程是用CMake构建的，那么需要在CMakeLists.txt中加入如下代码： 123SET(CMAKE_BUILD_TYPE &quot;Debug&quot;)SET(CMAKE_CXX_FLAGS_DEBUG &quot;$ENV&#123;CXXFLAGS&#125; -O0 -Wall -g2 -ggdb&quot;)SET(CMAKE_CXX_FLAGS_RELEASE &quot;$ENV&#123;CXXFLAGS&#125; -O3 -Wall&quot;) 和单个C++文件一样，进程奔溃时，系统会把奔溃前的信息转储在一个叫做core的文件，直接gdb ./test core即可。另外objdump这个指令也可以查看core文件，objdump -s core。","tags":["linux","gdb"],"categories":["开发运维"]},{"title":"设置 VirtualBox 共享文件夹","path":"/2993632212.html","content":"前言自己的开发环境在Ubuntu下，但是工作环境在Windows，又不想装双系统，所以用了VirtualBox虚拟机。在使用虚拟机时，有时希望将Windows的目录挂载到虚拟机Ubuntu里，实现两个系统之间的文件交换（当然，要是你觉得双向拖放就满足了，当我没说）。 方法1、在Windows主机里创建一个要共享的文件夹，比如我的是E:\\VM\\share2、点击VirtualBox的设置-&gt;共享文件夹设置被共享的文件夹是E:\\VM\\share。命名为Share。3、进入虚拟机的Ubuntu，创建一个共享文件夹share_dir 1mkdir share_dir 4、进入共享文件夹share_dir所在目录，将Windows的Share挂载到share_dir 1sudo mount -t vboxsf Share share_dir 大功告成","tags":["linux"],"categories":["开发运维"]},{"title":"ROS 之点云数据格式转换","path":"/2845537480.html","content":"前言使用ROS处理点云数据时，经常需要进行数据格式转换，这里做个记录。 数据格式首先要了解点云常见的两种格式sensor_msgs/PointCloud2和pcl::PointT。 sensor_msgs/PointCloud2是传感器中用的，像订阅激光点云或者相机点云topic返回的格式。格式如下1234567891011121314151617181920212223242526272829303132333435363738394041header: // 点云的头信息 seq: 963 // 次数 stamp: // 时间戳 secs: 1541143772 nsecs: 912011000 frame_id: &quot;/camera_init&quot;height: 1 // 如果cloud 是无序的 height 是 1width: 852578 // 点云的长度fields: // sensor_msgs/PointField[] fields - name: &quot;x&quot; offset: 0 datatype: 7 // uint8 INT8 = 1 // uint8 UINT8 = 2 // uint8 INT16 = 3 // uint8 UINT16 = 4 // uint8 INT32 = 5 // uint8 UINT32 = 6 // uint8 FLOAT32 = 7 // uint8 FLOAT64 = 8 count: 1 - name: &quot;y&quot; offset: 4 datatype: 7 count: 1 - name: &quot;z&quot; offset: 8 datatype: 7 count: 1 - name: &quot;intensity&quot; offset: 16 datatype: 7 count: 1is_bigendian: Falsepoint_step: 32 // 一个点占的比特数row_step: 27282496 // 一行的长度占用的比特数，就是width*point_step的大小data: [ ................... ] // Actual point data, size is (row_step*height)is_dense: True // 没有非法数据点 pcl::PointT是一类格式，包括PointXYZ、PointXYZI、PointXYZRGBA、PointXYZRGB、PointXY等。一般处理点云就要将PointCloud2转为PCL格式，再进行操作。PointXYZI格式如下123456789101112131415161718union&#123; float data[4]; struct &#123; float x; float y; float z; &#125;;&#125;;union&#123; struct &#123; float intensity; &#125;; float data_c[4];&#125;; PointCloud2转PointXYZI有两种方法，一种是直接调用pcl自带的函数，一种是采用mencpy的方式，直接从地址提取部分点云。 方法一直接调用pcl自带的函数函数pcl::fromROSMsg(const sensor_msgs::PointCloud2 &amp;cloud, pcl::PointCloud&lt;T&gt; &amp;pcl_cloud)。注意这个需要添加头文件#include &lt;pcl_conversions/pcl_conversions.h&gt;使用举例： 12345void callback(const sensor_msgs::PointCloud2ConstPtr&amp; cloud) &#123; pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr pcl_cloud( new pcl::PointCloud&lt;pcl::PointXYZI&gt;); pcl::fromROSMsg(*cloud, *pcl_cloud);&#125; 我们可以看下pcl::fromROSMsg做了啥 12345678910111213141516171819202122232425262728293031namespace pcl &#123;/** Provide to/fromROSMsg for sensor_msgs::PointCloud2 &lt;=&gt; pcl::PointCloud&lt;T&gt; * **/// pcl::PointCloud 与 sensor_msgs::PointCloud2 间的转换template &lt;typename T&gt;void toROSMsg(const pcl::PointCloud&lt;T&gt;&amp; pcl_cloud, sensor_msgs::PointCloud2&amp; cloud) &#123; pcl::PCLPointCloud2 pcl_pc2; pcl::toPCLPointCloud2(pcl_cloud, pcl_pc2); pcl_conversions::moveFromPCL(pcl_pc2, cloud);&#125;template &lt;typename T&gt;void fromROSMsg(const sensor_msgs::PointCloud2&amp; cloud, pcl::PointCloud&lt;T&gt;&amp; pcl_cloud) &#123; pcl::PCLPointCloud2 pcl_pc2; pcl_conversions::toPCL(cloud, pcl_pc2); pcl::fromPCLPointCloud2(pcl_pc2, pcl_cloud);&#125;template &lt;typename T&gt;void moveFromROSMsg(sensor_msgs::PointCloud2&amp; cloud, pcl::PointCloud&lt;T&gt;&amp; pcl_cloud) &#123; pcl::PCLPointCloud2 pcl_pc2; pcl_conversions::moveToPCL(cloud, pcl_pc2); pcl::fromPCLPointCloud2(pcl_pc2, pcl_cloud);&#125;&#125; // namespace pcl 根据这个，其实我们也可以直接用pcl::fromPCLPointCloud2来实现 123456void toPCL(const sensor_msgs::PointCloud2&amp; cloud, pcl::PointCloud&lt;pcl::PointXYZI&gt;&amp; pcl_cloud) &#123; pcl::PCLPointCloud2 pcl_pc2; pcl_conversions::toPCL(cloud, pcl_pc2); pcl::fromPCLPointCloud2(pcl_pc2, pcl_cloud);&#125; 方法二当订阅得到的初始点云话题数据量过大时，使用pcl::fromROSMsg转成pcl点云再做处理，会用去大量的时间。因此采用mencpy的方式，直接从地址提取部分点云，可以有效节省时间。mencpy格式为void *memcpy(void *dest, const void *src, size_t n);第一个参数是接收数据的参数，第二个参数是数据的地址，第三个参数是数据的大小。根据上面sensor_msgs/PointCloud2的格式，datatype是7，所以对应的是FLOAT32。也就是说每个点都有x,y,z,intensity四个数据，数据类型都是float32，占四个字节。另外，point_step是32，即4x8。所以x,y,z占用前面12个字节，再空出4个字节后，存储intensity，再空出12个字节这四个数据的存储方式如下所示： x y z intensity 所有点云的数据是保存在uint8[] data中的，所以我们只要每隔32个字节，把其中对应的数据取出，就完成了ROS话题转换pcl话题： 123456789101112void callback(const sensor_msgs::PointCloud2ConstPtr&amp; cloud) &#123; pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr pcl_cloud( new pcl::PointCloud&lt;pcl::PointXYZI&gt;); for (int i = 0; i &lt; cloud-&gt;width * cloud-&gt;height; i++) &#123; pcl::PointXYZI p; std::memcpy(&amp;p.x, &amp;cloud-&gt;data[32 * i], 4); std::memcpy(&amp;p.y, &amp;cloud-&gt;data[32 * i + 4], 4); std::memcpy(&amp;p.z, &amp;cloud-&gt;data[32 * i + 8], 4); std::memcpy(&amp;p.intensity, &amp;cloud-&gt;data[32 * i + 16], 4); pcl_cloud-&gt;points.push_back(p); &#125;&#125; PointXYZI转PointCloud2和上面类似，直接调用pcl自带的函数函数pcl::toROSMsg(const pcl::PointCloud&lt;T&gt;&amp; pcl_cloud, sensor_msgs::PointCloud2&amp; cloud)。使用举例： 1234void callback(const const pcl::PointCloud&lt;pcl::PointXYZI&gt;::ConstPtr pcl_cloud) &#123; sensor_msgs::PointCloud2::Ptr cloud(new sensor_msgs::PointCloud2); pcl::toROSMsg(*pcl_cloud, *cloud);&#125; 同样，也可以直接调用pcl::toPCLPointCloud2来实现 123456void fromPCL(const pcl::PointCloud&lt;pcl::PointXYZI&gt;&amp; pcl_cloud, sensor_msgs::PointCloud2&amp; cloud) &#123; pcl::PCLPointCloud2 pcl_pc2; pcl::toPCLPointCloud2(pcl_cloud, pcl_pc2); pcl_conversions::moveFromPCL(pcl_pc2, cloud);&#125;","tags":["ros"],"categories":["机器人"]},{"title":"斐波那契数列递归算法的时间复杂度","path":"/1050747593.html","content":"前言一直以为斐波那契数列暴力递归的时间复杂度是，百度了才发现，实际紧界时间复杂度应该是。但其实应该也没错，毕竟求时间复杂度是只要求量级不管系数。 证明紧界时间复杂度证明斐波那契数列的计算过程很简单。就是简单的我们把计算所需的时间记为。然后记计算加法所需的时间为1，那么显然有这一式子可以进行变形。两边同时加 1，得到记，显然有明显这是一个斐波那契数列，只不过初项有所不同 但是注意，斐波那契数列的增长率与初项是无关的。证明如下：设某斐波那契数列的前两项为，令，显然这个数列的增长速度不会超过以为前两项的斐波那契数列。而这个斐波那契数列就是，即而是个常数，因此斐波那契数列无论初项是多少，渐进增长率都是相同的。所以的渐进增长率与相同，而，增长率也是一样的 所以百度可以知道斐波那契数列所以 量级时间复杂度证明我们可以根据函数递归执行顺序画出下图的二叉树结构（假设求第五个斐波那契数） graph TD A((\"F(5)\")) --&gt; B((\"F(4)\")) A((\"F(5)\")) --&gt; C((\"F(3)\")) B((\"F(4)\")) --&gt; D((\"F(3)\")) B((\"F(4)\")) --&gt; E((\"F(2)\")) C((\"F(3)\")) --&gt; F((\"F(2)\")) C((\"F(3)\")) --&gt; G((\"F(1)\")) D((\"F(3)\")) --&gt; H((\"F(2)\")) D((\"F(3)\")) --&gt; I((\"F(1)\")) E((\"F(2)\")) --&gt; J(\"X\") E((\"F(2)\")) --&gt; K(\"X\") F((\"F(2)\")) --&gt; L(\"X\") F((\"F(2)\")) --&gt; M(\"X\") G((\"F(1)\")) --&gt; N(\"X\") G((\"F(1)\")) --&gt; O(\"X\") 带X为将斐波那契数列二叉树补齐成满二叉树，根据这个二叉树，可以得出几个特征： 满二叉树层数为，这里，所以有4层 满二叉树第h层（第1层为首层）个数为 满二叉树总结点数为，这里，所以满二叉树结点为15 斐波那契数列二叉树总结点数为，这里，斐波那契数列二叉树总结点数为9 所以这个时间复杂度就是","tags":["常见算法"],"categories":["算法交流"]},{"title":"Opencv 合并视频","path":"/982081792.html","content":"前言最近在写个小需求，利用opencv将4个独立的视频文件并列合并成了一个视频文件，并在屏幕的4个区域进行播放。 思路代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243import cv2import numpy as npvideoLeftUp = cv2.VideoCapture(&#x27;./video/1.mp4&#x27;)videoLeftDown = cv2.VideoCapture(&#x27;./video/2.mp4&#x27;)videoRightUp = cv2.VideoCapture(&#x27;./video/3.mp4&#x27;)videoRightDown = cv2.VideoCapture(&#x27;./video/4.mp4&#x27;)fps = videoLeftUp.get(cv2.CAP_PROP_FPS)width = (int(videoLeftUp.get(cv2.CAP_PROP_FRAME_WIDTH)))height = (int(videoLeftUp.get(cv2.CAP_PROP_FRAME_HEIGHT)))videoWriter = cv2.VideoWriter(&#x27;./merge.mp4&#x27;, cv2.VideoWriter_fourcc(&#x27;m&#x27;, &#x27;p&#x27;, &#x27;4&#x27;, &#x27;v&#x27;), fps, (width, height))successLeftUp, frameLeftUp = videoLeftUp.read()successLeftDown , frameLeftDown = videoLeftDown.read()successRightUp, frameRightUp = videoRightUp.read()successRightDown, frameRightDown = videoRightDown.read()while successLeftUp and successLeftDown and successRightUp and successRightDown: frameLeftUp = cv2.resize(frameLeftUp, (int(width / 2), int(height / 2)), interpolation=cv2.INTER_CUBIC) frameLeftDown = cv2.resize(frameLeftDown, (int(width / 2), int(height / 2)), interpolation=cv2.INTER_CUBIC) frameRightUp = cv2.resize(frameRightUp, (int(width / 2), int(height / 2)), interpolation=cv2.INTER_CUBIC) frameRightDown = cv2.resize(frameRightDown, (int(width / 2), int(height / 2)), interpolation=cv2.INTER_CUBIC) frameUp = np.hstack((frameLeftUp, frameRightUp)) frameDown = np.hstack((frameLeftDown, frameRightDown)) frame = np.vstack((frameUp, frameDown)) videoWriter.write(frame) successLeftUp, frameLeftUp = videoLeftUp.read() successLeftDown, frameLeftDown = videoLeftDown.read() successRightUp, frameRightUp = videoRightUp.read() successRightDown, frameRightDown = videoRightDown.read()videoWriter.release()videoLeftUp.release()videoLeftDown.release()videoRightUp.release()videoRightDown.release()","tags":["python","opencv"],"categories":["工具脚本"]},{"title":"进程间通信之共享内存","path":"/3534901462.html","content":"定义内核管理一片物理内存，允许不同的进程同时映射，多个进程可以映射同一块内存，被多个进程同时映射的物理内存，即共享内存。映射物理内存叫挂接，用完以后解除映射叫脱接。共享内存的特点： 优点：最快的IPC 缺点：要编程者自己实现对共享内存互斥访问 实现编程模型：具体函数的用法可以用man手册（强力推荐） 写入内存进程 获得key, ftok() 使用key来创建一个共享内存 shmget() 映射共享内存（得到虚拟地址）， shmat() 使用共享内存， 往共享内存中写入数据 解除映射 shmdt() 如果共享内存不再使用，可以使用shmctl()销毁共享内存 从内存读取进程 获得key, ftok() 使用key来获得一个共享内存 shmget() 映射共享内存（得到虚拟地址）， shmat() 使用共享内存， 读取共享内存中的数据 解除映射 shmdt() 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112// write_memory.cc#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/time.h&gt;#include &lt;unistd.h&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &quot;./shmdata.h&quot;int main() &#123; int running = 1; void *shm = NULL; struct shared_use_st *shared = NULL; int shmid; // 创建共享内存 shmid = shmget((key_t)1234, sizeof(struct shared_use_st), 0666 | IPC_CREAT); if (shmid == -1) &#123; fprintf(stderr, &quot;shmget failed &quot;); exit(EXIT_FAILURE); &#125; // 将共享内存连接到当前进程的地址空间 shm = shmat(shmid, (void *)0, 0); if (shm == (void *)-1) &#123; fprintf(stderr, &quot;shmat err &quot;); exit(EXIT_FAILURE); &#125; shared = (struct shared_use_st *)shm; while (running) &#123; struct timeval tv; gettimeofday(&amp;tv, NULL); std::string time_ = std::to_string(1000 * tv.tv_sec + tv.tv_usec / 1000); // std::string time_ = std::to_string(1000 * tv.tv_sec); strcpy(shared-&gt;timestamp, time_.c_str()); std::cout &lt;&lt; &quot;You wrote: &quot; &lt;&lt; shared-&gt;timestamp &lt;&lt; std::endl; usleep(1000); shared-&gt;written = 1; &#125; if (shmdt(shm) == -1) &#123; exit(EXIT_FAILURE); &#125; exit(EXIT_SUCCESS);&#125;// read_memory.cc#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/shm.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &quot;./shmdata.h&quot;int main() &#123; int running = 1; void *shm = NULL; struct shared_use_st *shared; int shmid; // 创建共享内存 shmid = shmget((key_t)1234, sizeof(struct shared_use_st), 0666 | IPC_CREAT); if (shmid == -1) &#123; fprintf(stderr, &quot;shmget err &quot;); exit(EXIT_FAILURE); &#125; // 将共享内存连接到当前进程的地址空间 shm = shmat(shmid, 0, 0); if (shm == (void *)-1) &#123; fprintf(stderr, &quot;shmat err &quot;); exit(EXIT_FAILURE); &#125; shared = (struct shared_use_st *)shm; shared-&gt;written = 0; while (running) &#123; if (shared-&gt;written != 0) &#123; std::cout &lt;&lt; &quot;You receivr: &quot; &lt;&lt; shared-&gt;timestamp &lt;&lt; std::endl; shared-&gt;written = 0; &#125; usleep(5000); &#125; if (shmdt(shm) == -1) &#123; fprintf(stderr, &quot;shmdt err &quot;); exit(EXIT_FAILURE); &#125; if (shmctl(shmid, IPC_RMID, 0) == -1) &#123; fprintf(stderr, &quot;shmctl(IPC_RM) &quot;); exit(EXIT_FAILURE); &#125; exit(EXIT_SUCCESS);&#125;// shmdata.h#include &lt;string&gt;#ifndef __SHMDATA_H_HEADER#define __SHMDATA_H_HEADER#define TEXT_SZ 2048struct shared_use_st &#123; int written; //标志位，非0：read；0：write char timestamp[1];&#125;;#endif","tags":["linux"],"categories":["开发运维"]},{"title":"Opencv 录制多路 camera","path":"/3944038877.html","content":"前言最近在写个小需求，利用opencv录制多路usb摄像头数据，并将拍摄视频拼接显示在同一个窗口。 思路挺简单的，就是通过cv2.VideoCapture获取/dev/video*的信息，获取每个摄像头的frame后，通过numpy的hstack和vstack将两帧拼接起来。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import cv2import numpy as np# 0,2,4代表/dev/video后缀videoFront = cv2.VideoCapture(0)videoLeft = cv2.VideoCapture(2)videoRight = cv2.VideoCapture(4)width = (int(videoFront.get(cv2.CAP_PROP_FRAME_WIDTH)))height = (int(videoFront.get(cv2.CAP_PROP_FRAME_HEIGHT)))# 设置保存视频的宽高、帧率、格式sz = (width*2, height*2)fps = 30fourcc = cv2.VideoWriter_fourcc(&#x27;m&#x27;, &#x27;p&#x27;, &#x27;4&#x27;, &#x27;v&#x27;)vout = cv2.VideoWriter()vout.open(&#x27;./output.mp4&#x27;, fourcc, fps, sz, True)write_ok = False# while (videoLeft.isOpened() and videoRight.isOpened()):while (True): retFront, frameFront = videoFront.read() retLeft, frameLeft = videoLeft.read() retRight, frameRight = videoRight.read() if(retFront and retLeft and retRight): frameFront = cv2.resize(frameFront, (width, height), interpolation=cv2.INTER_CUBIC) frameUp = np.hstack((frameFront, frameFront)) frameLeft = cv2.resize(frameLeft, (width, height), interpolation=cv2.INTER_CUBIC) frameRight = cv2.resize(frameRight, (width, height), interpolation=cv2.INTER_CUBIC) frameDown = np.hstack((frameLeft, frameRight)) frame = np.vstack((frameUp, frameDown)) if write_ok: print(&quot;saving video...&quot;) vout.write(frame) cv2.imshow(&#x27;frame&#x27;, frame) key = cv2.waitKey(1) &amp; 0xFF if key == ord(&quot;w&quot;): write_ok = write_ok is not True if key == ord(&quot;q&quot;): breakvideoLeft.release()videoRight.release()","tags":["python","opencv"],"categories":["工具脚本"]},{"title":"动态规划","path":"/2819424305.html","content":"一、概念动态规划（Dynamic programming，简称 DP），是通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。换句话说，就是给定一个问题，我们把它拆成一个个子问题，直到子问题可以直接解决。然后呢，把子问题答案保存起来，以减少重复计算。再根据子问题答案反推，得出原问题解的一种方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题。 二、核心思想动态规划最核心的思想，就在于拆分子问题，记住过往，减少重复计算。来看一道经典DP问题『青蛙跳台阶』，从这道题就能体会到DP的思想。 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 可以这么理解，假设跳到第n级台阶的跳数我们定义为。要跳到第10级台阶，要么是先跳到第9级，然后再跳1级台阶上去；要么是先跳到第8级，然后一次迈2级台阶上去。所以。同理，要跳到第9级台阶，要么是先跳到第8级，然后再跳1级台阶上去；要么是先跳到第7级，然后一次迈2级台阶上去。所以。依次类推到最后，。至于，要么直接跳两级，要么一级一级跳，所以；而只有一种跳法。看到这里，是不是可以用递归解决，因为，代码如下 123456789class Solution { public: int numWays(int n) { if (n &lt;= 2) { return n; } return numWays(n - 1) + numWays(n - 2); }}; 有没有发现，这其实就是个斐波那契，所以用递归计算时间复杂度是 （具体时间复杂度计算可以看我另一篇文章）回过头来，你仔细观察这颗递归树，你会发现存在大量重复计算，比如和，这里被计算了两次。所以这个递归算法低效的原因，就是存在大量的重复计算！既然存在大量重复计算，那么我们可以先把计算好的答案存下来，等到下次需要的话，先去记录里查一下，有就直接取，没有再计算，就可以省去重新重复计算的耗时。一般使用一个数组或者一个哈希充当这个备忘录。解法如下（很可惜，超时了）： 12345678910111213141516171819202122class Solution { public: int numWays(int n) { unordered_map&lt;int, int&gt; tempMap; // n = 0 也算1种 if (n == 0) { return 1; } if (n &lt;= 2) { return n; } // 先判断有没计算过,即看看备忘录有没有 if (tempMap.find(n) != tempMap.end()) { // 备忘录有,即计算过,直接返回 return tempMap[n]; } else { // 备忘录没有,即没有计算过,执行递归计算,并且把结果保存到备忘录map中,对1000000007取余(这个是leetcode题目规定的) tempMap.insert(pair&lt;int, int&gt;(n, (numWays(n - 1) + numWays(n - 2)) % 1000000007)); return tempMap[n]; } }}; 那这种解法跟动态规划有啥关系呢？动态规划跟带备忘录的递归解法基本思想是一致的，都是减少重复计算，时间复杂度也都是差不多。但是有两点不一样： 带备忘录的递归，是从往方向延伸求解的，所以也称为自顶向下的解法 动态规划从较小问题的解，由交叠性质，逐步决策出较大问题的解，它是从往方向，往上推求解，所以称为自底向上的解法 动态规划有几个典型特征，最优子结构、状态转移方程、边界、重叠子问题。在青蛙跳阶问题中： 和称为的最优子结构 就称为状态转移方程 ，就是边界 比如和中，就是重叠子问题 代码如下： 123456789101112131415161718class Solution { public: int numWays(int n) { if (n == 0) { return 1; } if (n &lt;= 2) { return n; } int dp[n + 1]; dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt; n + 1; i++) { dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007; } return dp[n]; }}; 三、解题思路动态规划的核心思想就是拆分子问题，记住过往，减少重复计算。 并且动态规划一般都是自底向上的，基于青蛙跳阶问题，我总结了一下我做动态规划的思路。 穷举分析 确定边界 找出规律，确定最优子结构 写出状态转移方程 穷举分析 当台阶数是1的时候，有一种跳法， 当只有2级台阶时，有两种跳法，第一种是直接跳两级，第二种是先跳一级，然后再跳一级。即; 当台阶是3级时，想跳到第3级台阶，要么是先跳到第2级，然后再跳1级台阶上去，要么是先跳到第 1级，然后一次迈 2 级台阶上去。所以 当台阶是4级时，依次类推 确定边界通过穷举分析，我们发现，当台阶数是1的时候或者2的时候，可以明确知道青蛙跳法。，当台阶时，已经呈现出规律，因此就是青蛙跳阶的边界。 找规律，确定最优子结构时，已经呈现出规律 ，因此，和称为的最优子结构。什么是最优子结构？有这么一个解释 一道动态规划问题，其实就是一个递推问题。假设当前决策结果是，则最优子结构就是要让最优，最优子结构性质就是能让转移到n的状态是最优的，并且与后面的决策没有关系，即让后面的决策安心地使用前面的局部最优解的一种性质。 写出状态转移方程通过前面3步，穷举分析，确定边界，最优子结构，我们就可以得出状态转移方程：$$ f(n)=\\left{\\right.$$ 代码实现实现代码的时候，一般注意从底往上遍历，然后关注下边界情况，空间复杂度。动态规划有个大概框架 12345678dp[0][0][...] = 边界值 for (状态1 ：所有状态1的值) { for (状态2 ：所有状态2的值) { for (...) { //状态转移方程 dp[状态1][状态2][...] = 求最值 } }}","tags":["常见算法"],"categories":["算法交流"]},{"title":"堆排序","path":"/3265658309.html","content":"一、堆的概念1、堆是一个完全二叉树，它的所有元素按照完全二叉树的顺序存储方式存储在一个一维数组中。2、堆中某个节点的值总是不大于或不小于其父节点的值；堆总是一棵完全二叉树。3、堆分为两种：大顶堆、小顶堆 大顶堆：每一个父结点的值均大于等于其对应的子结点的值，而父结点的值就是最大的 小顶堆：每一个父结点的值均小于等于其对应的子结点的值，而父结点的值就是最小的 4、堆排序最后一个非叶子节点（父节点）的序号是n/2-1，n为数组的长度（具体分析见第四点）。 二、堆的实现有两种方法，一种是自己写堆进行排序，一种是直接对数组建堆。 1、手动实现堆假设我们排升序，且堆为小顶堆。首先，把数组的每个元素（HeapPush）插入到堆中；其次，小顶堆的堆顶是最小的数字，依次遍历堆顶的元素，将堆顶元素赋值到数组里，从下标0开始，赋值后删除堆顶元素，++数组下标；此时堆就会重新调整，最终堆顶依旧是最小的，再重复上述赋值堆顶到数组的操作，直到堆为空。具体实现可以参考堆的实现和堆排序和Topk问题。 2、数组建堆堆的调整无非就两种，一种是向下调整，一种是向上调整。向下调整：让调整的结点与其孩子节点进行比较向上调整：让调整的结点与其父亲结点进行比较简单区分就是，向下调整条件是孩子节点值比父节点小；而向上调整条件是父节点值比孩子节点小。以数组[9, 2, 7, 5, 6, 4, 3, 8, 9]为例 2-1、向下调整思路：选出左右孩子中小的那一个，跟父节点比较，如果父节点大，则父节点和子节点交换。记住一点，child = 2*parent + 1，这里child是左子树首先取左右child更小的那个跟parent节点比较，如果parent节点更大，就把child的值和parent的值互换，同时parent下移到child的位置，用公式child = 2*parent + 1更新child位置；然后换行，比较下一层的parent和child。 12345678910111213141516171819// 向下调整算法void adjust_down(int array[], int i, int n) &#123; int parent = i; // 父节点下标 int child = 2 * i + 1; // 子节点下标 while (child &lt; n) &#123; if (child + 1 &lt; n &amp;&amp; array[child] &gt; array[child + 1]) &#123; // 选出左右child小的那个，与parent比较 child++; &#125; if (array[child] &lt; array[parent]) &#123; // 如果child比parent小,交换parent和child,这样就保证parent比左右child都小 swap(array, parent, child); // 交换parent和child parent = child; // child下标赋给parent下标 &#125; else &#123; break; &#125; child = child * 2 + 1; // 换行,比较下一层的parent和child &#125;&#125; 2-2、建小顶堆在向下调整中，要保证左子树和右子树均是堆，否则不能；按照这个思路，那采用向下调整建堆时，应该从下往上走，保证左右子树都是堆。从最后一个非叶子节点开始，即n/2-1，调用一次向下调整；再找到前一个节点，调用一次向下调整，循环往复，直到对父节点向下调整（此时父节点的左右子树已是堆），堆就实现了。举例：1、对于数组[9, 2, 7, 5, 6, 4, 3, 8, 9]，n/2-1就是第3个节点，也就是5，取左右子树小的那个，即8，5小于8，不换，跳出循环；2、下一个节点是7，取左右子树小的那个，即3，7大于3，互换，parent到3的位置，没有子树了，跳出调整。 1234567// 创建小顶堆void BuildMinHeap(int array[], int size) &#123; for (int i = size / 2 - 1; i &gt;= 0; i--) &#123; // 倒数第二排开始,对每一个三角形成的堆,创建小顶堆 adjust_down(array, i, size); &#125;&#125; 2-3、向上调整思路：选出左右孩子中大的那一个，跟父节点比较，如果父节点小，则父节点和子节点交换。记住一点，child = 2*parent + 1，这里child是左子树首先取左右child更大的那个跟parent节点比较，如果parent节点更小，就把child的值和parent的值互换，同时parent下移到child的位置，用公式child = 2*parent + 1更新child位置；然后换行，比较下一层的parent和child。 12345678910111213141516171819// 向上调整算法void adjust_up(int array[], int i, int n) &#123; int parent = i; // 父节点下标 int child = 2 * i + 1; // 子节点下标 while (child &lt; n) &#123; if (child + 1 &lt; n &amp;&amp; array[child] &lt; array[child + 1]) &#123; // 选出左右child大的那个，与parent比较 child++; &#125; if (array[parent] &lt; array[child]) &#123; // 如果parent比child小,交换parent和child,这样就保证parent比左右child都大 swap(array, parent, child); // 交换parent和child parent = child; // child下标赋给parent下标 &#125; else &#123; break; &#125; child = child * 2 + 1; // 换行,比较下一层的parent和child &#125;&#125; 2-4、建大顶堆跟建小顶堆一样，在向上调整中，要保证左子树和右子树均是堆，否则不能；按照这个思路，那采用向上调整建堆时，应该从下往上走，保证左右子树都是堆。从最后一个非叶子节点开始，即n/2-1，调用一次向下调整；再找到前一个节点，调用一次向上调整，循环往复，直到对父节点向上调整（此时父节点的左右子树已是堆），堆就实现了。 1234567// 创建大顶堆void BuildMaxHeap(int array[], int size) &#123; for (int i = size / 2 - 1; i &gt;= 0; i--) &#123; // 倒数第二排开始,对每一个三角形成的堆,创建大顶堆 adjust_up(array, i, size); &#125;&#125; 三、堆排序有了上面的建堆，就可以直接进行堆排序了。对于降序，我们可以先创建小顶堆，此时顶点是最小值。从后面开始遍历数组，每次遍历就交换顶点和第i个数据，这样就可以把顶点的最小值存到尾部；然后在剩余的数字中再进行向下调整，重新建立小顶堆；再进行上面的互换操作。对于升序，也是类似的，先创建大顶堆，此时顶点是最大值。从后面开始遍历数组，每次遍历就交换顶点和第i个数据，这样就可以把顶点的最大值存到尾部；然后在剩余的数字中再进行向上调整，重新建立大顶堆；再进行上面的互换操作。 1234567891011121314151617181920212223// 降序void MaxHeapSort(int array[], int size) &#123; BuildMinHeap(array, size); // 创建小顶堆 display(array, size); for (int i = size - 1; i &gt; 0; i--) &#123; swap(array, 0, i); // 这里交换顶点和第i个数据,就是把顶点的最小值存到尾部, // 在剩余的数字中再进行向下调整,重新建立小顶堆 adjust_down(array, 0, i); &#125;&#125;// 升序void MinHeapSort(int array[], int size) &#123; BuildMaxHeap(array, size); // 创建大顶堆 display(array, size); for (int i = size - 1; i &gt; 0; i--) &#123; // 这里交换顶点和第i个数据,就是把顶点的最大值存到尾部, // 在剩余的数字中再进行向上调整,重新建立大顶堆 swap(array, 0, i); adjust_up(array, 0, i); &#125;&#125; 四、堆排序最后一个非叶子节点的序号堆排序是基于完全二叉树实现的，在将一个数组调整成一个堆的时候，关键之一的是确定最后一个非叶子节点的序号，这个序号为n/2-1，n为数组的长度。但是为什么呢？ 可以分两种情况考虑：1、堆的最后一个非叶子节点只有左孩子2、堆的最后一个非叶子节点有左右两个孩子完全二叉树的性质之一是：如果节点序号为 i，则它的左孩子序号为2i+1，右孩子序号为 2i+2。 对于情况1，左孩子(最后一个元素)的序号为 n-1，则 n-1=2i+1，推出 i=n/2-1；对于情况2，左孩子(倒数第二个元素)的序号为 n-2，则 n-2=2i+1，推出i=(n-1)/2-1；右孩子(最后一个元素)的序号为n-1，则n-1=2i+2，推出（这里跟左孩子推出的一样）i=(n-1)/2-1。 很显然，当完全二叉树最后一个节点是其父节点的左孩子时，树的节点数（数组元素数）为偶数；当完全二叉树最后一个节点是其父节点的右孩子时（满二叉树），树的节点数（数组元素数）为奇数。 根据一般编程语言的特性，整数除不尽时向下取整，则若n为奇数时(n-1)/2-1=n/2-1。 因此对于情况2，最后一个非叶子节点的序号也是n/2-1。 五、完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104void display(int array[], int size) &#123; for (int i = 0; i &lt; size; i++) &#123; printf(&quot;%d &quot;, array[i]); &#125; printf(&quot; &quot;);&#125;void swap(int array[], int x, int y) &#123; int temp = array[x]; array[x] = array[y]; array[y] = temp;&#125;// 向下调整算法void adjust_down(int array[], int i, int n) &#123; int parent = i; // 父节点下标 int child = 2 * i + 1; // 子节点下标 while (child &lt; n) &#123; if (child + 1 &lt; n &amp;&amp; array[child] &gt; array[child + 1]) &#123; // 选出左右child小的那个，与parent比较 child++; &#125; if (array[parent] &gt; array[child]) &#123; // 如果parent比child大,交换parent和child,这样就保证parent比左右child都小 swap(array, parent, child); // 交换parent和child parent = child; // child下标赋给parent下标 &#125; else &#123; break; &#125; child = child * 2 + 1; &#125;&#125;// 向上调整算法void adjust_up(int array[], int i, int n) &#123; int parent = i; // 父节点下标 int child = 2 * i + 1; // 子节点下标 while (child &lt; n) &#123; if (child + 1 &lt; n &amp;&amp; array[child] &lt; array[child + 1]) &#123; // 选出左右child大的那个，与parent比较 child++; &#125; if (array[parent] &lt; array[child]) &#123; // 如果parent比child小,交换parent和child,这样就保证parent比左右child都大 swap(array, parent, child); // 交换parent和child parent = child; // child下标赋给parent下标 &#125; else &#123; break; &#125; child = child * 2 + 1; // 换行,比较下一层的parent和child &#125;&#125;// 创建小顶堆void BuildMinHeap(int array[], int size) &#123; for (int i = size / 2 - 1; i &gt;= 0; i--) &#123; // 倒数第二排开始,对每一个三角形成的堆,创建小顶堆 adjust_down(array, i, size); &#125;&#125;// 创建大顶堆void BuildMaxHeap(int array[], int size) &#123; for (int i = size / 2 - 1; i &gt;= 0; i--) &#123; // 倒数第二排开始,对每一个三角形成的堆,创建大顶堆 adjust_up(array, i, size); &#125;&#125;// 降序void MaxHeapSort(int array[], int size) &#123; BuildMinHeap(array, size); // 创建小顶堆 display(array, size); for (int i = size - 1; i &gt; 0; i--) &#123; swap(array, 0, i); // 这里交换顶点和第i个数据,就是把顶点的最小值存到尾部, // 在剩余的数字中再进行向下调整,重新建立小顶堆 adjust_down(array, 0, i); &#125;&#125;// 升序void MinHeapSort(int array[], int size) &#123; BuildMaxHeap(array, size); // 创建大顶堆 display(array, size); for (int i = size - 1; i &gt; 0; i--) &#123; // 这里交换顶点和第i个数据,就是把顶点的最大值存到尾部, // 在剩余的数字中再进行向上调整,重新建立大顶堆 swap(array, 0, i); adjust_up(array, 0, i); &#125;&#125;int main() &#123; int array[] = &#123;9, 2, 7, 5, 6, 4, 3, 8, 9&#125;; int size = sizeof(array) / sizeof(int); // 打印数据 display(array, size); MinHeapSort(array, size); display(array, size); return 0;&#125;","tags":["常见算法"],"categories":["算法交流"]},{"title":"Python 处理错误的 json 文件","path":"/3741772592.html","content":"前言最近在做数据分析，拿到一组json格式文件，但是文件却不是规范的json格式，需要将文件过滤一波，恢复规范的json格式。这里做个记录。 问题json文件如下，其中&quot;planning_status&quot;的value是个list，同时这个list占了5行，每行末尾都有换行符。 12345678&#123; &quot;planning_status&quot;: [&quot;Now: 1390.04, Gap: 0.10, Delay: 0.20, Se: -0.3, Le: +0.06, Real ka al: 0.00036, 0.037, in_HDmap_mode&quot;], &quot;distance_to_ramp&quot;: 1291.777709961&#125; 解决12345678910111213141516171819202122232425import jsonfpath = &quot;test.json&quot;with open(fpath, &#x27;r+&#x27;, encoding=&#x27;utf-8&#x27;) as infile: lines = infile.readlines()\t# 逐行读取pi_string = &#x27;&#x27;for line in lines: pi_string += line.strip() # strip() 删除 string 字符串末尾的指定字符， # 若参数为空，默认为空白符，包括空格、换行符、回车符、制表符j = json.loads(pi_string)\t# 转为dict# 重新写入with open(&#x27;test.json&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as outfile: json.dump(j, outfile, ensure_ascii=False)def listToJson(lst): import json import numpy as np keys = [str(x) for x in np.arange(len(lst))] list_json = dict(zip(keys, lst)) str_json = json.dumps(list_json, indent=2, ensure_ascii=False) # json转为string return str_json","tags":["python"],"categories":["工具脚本"]},{"title":"数据结构之栈和队列","path":"/3423645076.html","content":"栈和队列简介 栈的特点是后入先出。根据这个特点可以临时保存一些数据，之后用到依次再弹出来，常用于 DFS 深度搜索 队列一般常用于 BFS 广度搜索，类似一层一层的搜索 Stack 栈 最小栈 设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 思路：用两个栈实现，一个最小栈始终保证最小值在顶部 12345678910111213141516171819202122232425262728293031323334353637class MinStack &#123; public: MinStack() &#123;&#125; void push(int val) &#123; stack_data.push_back(val); if (min_data.empty() || val &lt;= min_data.back()) &#123; min_data.push_back(val); &#125; &#125; void pop() &#123; if (stack_data.back() == min_data.back()) &#123; min_data.pop_back(); &#125; stack_data.pop_back(); &#125; int top() &#123; return stack_data.back(); &#125; int getMin() &#123; return min_data.back(); // return *min_element(stack_data.begin(), stack_data.end()); &#125; private: vector&lt;int&gt; min_data; vector&lt;int&gt; stack_data;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(val); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;getMin(); */ 逆波兰表达式求值 波兰表达式计算 -&gt; 输入: [“2”, “1”, “+”, “3”, “*“] -&gt; 输出: 9解释: ((2 + 1) * 3) &#x3D; 9 思路：通过栈保存原来的元素，遇到表达式弹出运算，再推入结果，重复这个过程 12345678910111213141516171819202122232425class Solution &#123; public: int evalRPN(const vector&lt;string&gt;&amp; tokens) &#123; stack&lt;int&gt; s; for (string i : tokens) &#123; if (i != &quot;+&quot; &amp;&amp; i != &quot;-&quot; &amp;&amp; i != &quot;*&quot; &amp;&amp; i != &quot;/&quot;) &#123; s.push(stoi(i)); continue; &#125; int tmp2 = s.top(); s.pop(); int tmp1 = s.top(); s.pop(); if (i == &quot;+&quot;) s.push(tmp1 + tmp2); else if (i == &quot;-&quot;) s.push(tmp1 - tmp2); else if (i == &quot;*&quot;) s.push(tmp1 * tmp2); else if (i == &quot;/&quot;) s.push(tmp1 / tmp2); &#125; return s.top(); &#125;&#125;; 字符串解码 给定一个经过编码的字符串，返回它解码后的字符串。 s &#x3D; “3[a]2[bc]”, 返回 “aaabcbc”. s &#x3D; “3[a2[c]]”, 返回 “accaccacc”. s &#x3D; “2[abc]3[cd]ef”, 返回 “abcabccdcdcdef”. 思路：通过栈辅助进行操作，这里建了两个栈 12345678910111213141516171819202122232425262728293031class Solution &#123; public: string decodeString(string s) &#123; string res = &quot;&quot;; stack&lt;int&gt; nums; stack&lt;string&gt; strs; int num = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; if (s[i] &gt;= &#x27;0&#x27; &amp;&amp; s[i] &lt;= &#x27;9&#x27;) &#123; num = num * 10 + s[i] - &#x27;0&#x27;; &#125; else if (s[i] == &#x27;[&#x27;) &#123; // 将‘[’前的数字压入nums栈内,字母字符串压入strs栈内 nums.push(num); num = 0; strs.push(res); res = &quot;&quot;; &#125; else if (s[i] == &#x27;]&#x27;) &#123; // 遇到‘]’时,操作与之相配的‘[’之间的字符,使用分配律 int times = nums.top(); nums.pop(); for (int j = 0; j &lt; times; ++j) strs.top() += res; res = strs.top(); strs.pop(); &#125; else &#123; res = res + s[i]; &#125; &#125; return res; &#125;&#125;; 二叉树的中序遍历 给定一个二叉树，返回它的中序遍历。 思路：通过stack 保存已经访问的元素，用于原路返回。由于中序遍历是左-&gt;根-&gt;右，所以要保证有左子树的情况下左子树在栈顶 12345678910111213141516171819class Solution &#123; public: std::vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; std::stack&lt;TreeNode*&gt; s; std::vector&lt;int&gt; res; while (root || !s.empty()) &#123; while (root) &#123; s.push(root); root = root-&gt;left;\t// 一直向左 &#125; // 弹出 root = s.top(); s.pop(); res.push_back(root-&gt;val); root = root-&gt;right; &#125; return res; &#125;&#125;; 克隆图 给你无向连通图中一个节点的引用，请你返回该图的深拷贝（克隆） 思路：由于节点数不会超过100个，所以可以提前创建一个大小为101的 Node * 类型的vector容器nodes，用于存放所有节点。然后通过辅助栈，从给定节点开始遍历原图。遍历的方法是：从当前节点开始，把它所有的邻居节点入栈。遍历的过程中，会遇到以下几种情况： 当前节点是第一次被访问。此时nodes中对应的节点的 val 必定还是0（默认构造函数），对nodes中的节点的 val 进行赋值，并把所有的邻居节点push到其neighbors字段中，同时把原图对应的节点入栈。 当前节点已经被访问。判断的依据是nodes数组中的节点 val 已经不是0，直接跳过即可。等遍历完毕后，nodes存储的就是一张原图的深拷贝，只需要返回初始节点对应的nodes中的节点即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*// Definition for a Node.class Node &#123;public: int val; vector&lt;Node*&gt; neighbors; Node() &#123; val = 0; neighbors = vector&lt;Node*&gt;(); &#125; Node(int _val) &#123; val = _val; neighbors = vector&lt;Node*&gt;(); &#125; Node(int _val, vector&lt;Node*&gt; _neighbors) &#123; val = _val; neighbors = _neighbors; &#125;&#125;;*/class Solution &#123; public: Node* cloneGraph(Node* node) &#123; if (!node) return nullptr; stack&lt;Node*&gt; stack; vector&lt;Node*&gt; nodes(101); for (int i = 0; i &lt; 101; ++i) &#123; nodes[i] = new Node(); &#125; stack.push(node); while (!stack.empty()) &#123; Node* cur = stack.top(); stack.pop(); int val = cur-&gt;val; if (nodes[val]-&gt;val == 0) &#123; nodes[val]-&gt;val = val; for (auto n : cur-&gt;neighbors) &#123; (nodes[val]-&gt;neighbors).push_back(nodes[n-&gt;val]); stack.push(n); &#125; &#125; &#125; return nodes[node-&gt;val]; &#125;&#125;; （未完待续）","tags":["数据结构"],"categories":["算法交流"]},{"title":"判断同一坐标系下物体方向","path":"/1360797208.html","content":"前言最近在写个小需求，需要判断障碍物在自车前后左右哪个方向，然后再进行下一步的逻辑处理。当然有很多种方法，这里就做个记录。 思路画了张图，假设A点为自车，需要判断B点在A点的哪个方向（注意我这里前向是x）。有以下公式：所以，为B点在A点前方，为B点在A点左方。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Vec2d { public: //! Constructor which takes x- and y-coordinates. constexpr Vec2d(const double x, const double y) noexcept : x_(x), y_(y) {} //! Constructor returning the zero vector. constexpr Vec2d() noexcept : Vec2d(0, 0) {} //! rotate the vector itself by angle. void SelfRotate(const double angle) { double tmp_x = x_; x_ = x_ * cos(angle) - y_ * sin(angle); y_ = tmp_x * sin(angle) + y_ * cos(angle); } //! Getter for x component double x() const { return x_; } //! Getter for y component double y() const { return y_; } //! Setter for x component void set_x(const double x) { x_ = x; } //! Setter for y component void set_y(const double y) { y_ = y; } static Vec2d CreateUnitVec2d(const double angle) { return Vec2d(cos(angle), sin(angle)); } double InnerProd(const Vec2d &amp;other) const { return x_ * other.x() + y_ * other.y(); } double CrossProd(const Vec2d &amp;other) const { return x_ * other.y() - y_ * other.x(); } protected: double x_ = 0.0; double y_ = 0.0;};int main() { double front_edge_to_center = 3.89; double back_edge_to_center = 1.043; vector&lt;double&gt; track_pos = {5974.055909431665, 219.0300190522155, 0}; vector&lt;double&gt; ego_pos = {5921.028659216853, 219.4455434876256, 0}; double ego_yaw = 3.139378753137839; Vec2d inner_u(track_pos[0] - ego_pos[0], track_pos[1] - ego_pos[1]); Vec2d inner_v = Vec2d::CreateUnitVec2d(ego_yaw); double inner_value = inner_u.InnerProd(inner_v); if(inner_value &gt; 0) { std::cout &lt;&lt; \"track is on the front\" &lt;&lt; std::endl; } else { std::cout &lt;&lt; \"track is on the back\" &lt;&lt; std::endl; } Vec2d cross_u(track_pos[0] - ego_pos[0], track_pos[1] - ego_pos[1]); Vec2d cross_v = Vec2d::CreateUnitVec2d(ego_yaw); double cross_value = cross_u.CrossProd(cross_v); if(cross_value &gt; 0) { std::cout &lt;&lt; \"track is on the right\" &lt;&lt; std::endl; } else { std::cout &lt;&lt; \"track is on the left\" &lt;&lt; std::endl; }}","tags":["数学"],"categories":["工具脚本"]},{"title":"正则表示 re.findall 用法","path":"/440403458.html","content":"前言re.findall作用是搜索字符串，以列表形式返回能匹配的字符。 形式1re.findall(pattern, string, flags=0) 该方法有3个参数，第一个就是你写的正则表达式，第二个匹配的目标字符串，第三个是一个匹配模式。 练习1234567891011121314151617181920212223#search是找一个结果的，findall是查询所有结果的。import rehtml=&#x27;&#x27;&#x27;&lt;div id=&quot;songs-list&quot;&gt; &lt;h2 class=&quot;title&quot;&gt;经典老歌&lt;/h2&gt; &lt;p class=&quot;introduction&quot;&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id =&quot;list&quot; class=&quot;list-group&quot;&gt; &lt;li data-view=&quot;2&quot;&gt;一路上有你&lt;/li&gt; &lt;li data-view=&quot;7&quot;&gt; &lt;a href=&quot;/2.mp3&quot; singer=&quot;任贤齐&quot;&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=&quot;4&quot; class=&quot;active&quot;&gt; &lt;a href=&quot;/3.mp3&quot; singer=&quot;齐秦&quot;&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=&quot;6&quot;&gt;&lt;a href=&quot;/4.mp3&quot; singer=&quot;beyond&quot;&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=&quot;5&quot;&gt;&lt;a href=&quot;/5.mp3&quot; singer=&quot;陈惠琳&quot;&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=&quot;5&quot;&gt; &lt;a href=&quot;/6.mp3&quot; singer=&quot;邓丽君&quot;&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 练习1：要求：匹配出li标签中既有歌手又有歌名的信息，包括超链接也匹配出来。分析：我们可以看出排除了歌曲”一路有你”，其余的歌曲，歌手，以及超链接都要匹配出来。 1234567results = re.findall(&#x27;&lt;li.*?href=&quot;(.*?)&quot;.*?singer=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&#x27;,html,re.S)print(results) #返回list，元素由tuple组成for result in results: print(result) #返回每个tuple元素# 输出[(’/2.mp3’, ‘任贤齐’, ‘沧海一声笑’), (’/3.mp3’, ‘齐秦’, ‘往事随风’), (’/4.mp3’, ‘beyond’, ‘光辉岁月’), (’/5.mp3’, ‘陈惠琳’, ‘记事本’), (’/6.mp3’, ‘邓丽君’, ‘但愿人长久’)] 练习2：要求：对上述html代码匹配出所有歌名。 123456# * 表多个 ？表示前面匹配有或者没有,就到前面results = re.findall(&#x27;&lt;li.*?&gt;\\s*?(&lt;a.*?&gt;)?(\\w+)(&lt;/a&gt;)?\\s*?&lt;/li&gt;&#x27;,html,re.S)print(results)# 输出[(’’, ‘一路上有你’, ‘’), (’’, ‘沧海一声笑’, ‘’), (’’, ‘往事随风’, ‘’), (’’, ‘光辉岁月’, ‘’), (’’, ‘记事本’, ‘’), (’’, ‘但愿人长久’, ‘’)] 练习3：要求：对于string类型数据，筛选出两个子串之间的内容 1234567891011s_data = &#x27;&#123;&quot;STGraph&quot;: &#123;&quot;Index&quot;: 10,&quot;planning&quot; : [&quot;Now: 1390.04, Gap: 0.10&quot;],&quot;mp_intention&quot; : &#123; &quot;maneuver_name&quot;: &quot;FOLLOW&quot;, &quot;scenario&quot;: 0, &quot;flag_to_stop&quot;: 0&#125;&#125;&#125;&#x27;# re.findall格式为re.findall(&#x27;sub_str_a, sub_str_b&#x27;, str_data, re.S),返回listresult_1 = re.findall(&#x27;.*?&quot;planning&quot; :(.*?),&quot;mp_intention&quot;&#x27;, s_data, re.S)# [&#x27; [&quot;Now: 1390.04, Gap: 0.10&quot;]&#x27;]result_2 = re.findall(&#x27;.*?&quot;planning&quot; :.*?,&quot;mp_intention&quot;&#x27;, s_data, re.S)# [&#x27;&#123;&quot;STGraph&quot;: &#123;&quot;Index&quot;: 10,&quot;planning&quot; : [&quot;Now: 1390.04, Gap: 0.10&quot;],&quot;mp_intention&quot;&#x27;]result_3 = re.findall(&#x27;(.*?)&quot;planning&quot; :.*?,&quot;mp_intention&quot;&#x27;, s_data, re.S)# [&#x27;&#123;&quot;STGraph&quot;: &#123;&quot;Index&quot;: 10,&#x27;]result_4 = re.findall(&#x27;(.*?)&quot;planning&quot; :(.*?),&quot;mp_intention&quot;&#x27;, s_data, re.S)# [(&#x27;&#123;&quot;STGraph&quot;: &#123;&quot;Index&quot;: 10,&#x27;, &#x27; [&quot;Now: 1390.04, Gap: 0.10&quot;]&#x27;)]","tags":["python","正则表达式"],"categories":["开发运维"]},{"title":"Python 实现每日自动推送 URL 到百度站长收录","path":"/3225872756.html","content":"前言闲来无事，看了下自己写的博客没有一篇文章被百度收录，无奈只好写了一个百度主动提交工具的小脚本，实现每日自动爬取当前博客文章并推送文章URL到百度站长收录，提高下曝光率。 解决其实百度站长后台也给出了示例：curl推送示例、post推送示例、php推送示例、ruby推送示例一大堆，下面就给大家用Python写一个几句代码就可以实现百度主动提交。 1234567891011121314151617181920212223242526272829303132333435363738394041# coding:utf-8import requestsimport re# 获取网站html数据def get_html(url): try: r = requests.get(url+&quot;/archives&quot;) r.encoding = &quot;utf-8&quot; html = r.text return html except Exception: passdef main(url): headers = &#123; &#x27;Accept&#x27;: &#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;, &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate, br&#x27;, &#x27;Accept-Language&#x27;: &#x27;zh-CN,zh;q=0.9,en;q=0.8&#x27;, &#x27;Cache-Control&#x27;: &#x27;max-age=0&#x27;, &#x27;Connection&#x27;: &#x27;keep-alive&#x27;, &#x27;Cookie&#x27;: &#x27;&#x27;, &#x27;Host&#x27;: &#x27;data.zz.baidu.com&#x27;, &#x27;Upgrade-Insecure-Requests&#x27;: &#x27;1&#x27;, &#x27;User-Agent&#x27;: &#x27;curl/7.12.1&#x27;, &#125; # 百度提交api seo_url = &#x27;http://data.zz.baidu.com/urls?site=121.196.169.103&amp;token=&#123;token&#125;&#x27; html = get_html(url) # 正则匹配,筛选出文章链接 result = re.findall(&#x27;&lt;li.*?href=(&quot;/archives/.*?&quot;)&gt;&#x27;, html, re.S) urls = &quot;&quot; for res in result: urls += url+res.split(&#x27;&quot;&#x27;)[1] + &#x27; &#x27; print(urls) response = requests.post(seo_url, data=urls.encode(), headers=headers) print(response.text)if __name__ == &#x27;__main__&#x27;: url = &quot;http://121.196.169.103&quot; # 网站链接 main(url)","tags":["python"],"categories":["工具脚本"]},{"title":"粘贴到 Vim 中的代码缩进混乱解决方法","path":"/3108661719.html","content":"前言我经常用Vim写代码，有时从其他地方复制粘贴到Vim下时，代码会出现缩进混乱，看起来很难受。 原因终端处理粘贴的文本时，会存入键盘缓存 (Keyboard Buffer)。Vim 处理时，会把这些内容作为用户键盘输入来处理。所以如果 Vim 开启了自动缩进，那么在遇到换行符时，就会默认把上一行的缩进插入到下一行的开头。 解决Vim 编辑模式中有一个 Paste 模式，在该模式下，可将文本保持原样粘贴到 Vim 中。在 Vim 中键入命令： 1234# 设置 粘贴模式:set paste# 取消 粘贴模式:set nopaste 在粘贴模式下进行粘贴，就不会遇到缩进混乱的问题了。","tags":["linux","vim"],"categories":["开发运维"]},{"title":"Tmux 入坑指南","path":"/15239708.html","content":"前言tmux是程序员们必备的一款神器，有了它，就可以轻松地在服务器上开启多个shell来进行工作。这些shell会很好地运行着，在下一次连接到服务器上的时候，可以接着上次的工作继续进行下去。 简介tmux 是一个优秀的终端复用器类自由软件，功能类似 GNU Screen，但使用 BSD 许可发布。用户可以通过 tmux 在一个终端内管理多个分离的会话，窗口及面板，对于同时使用多个命令行，或多个任务时非常方便。功能很多，总而言之，入坑就对了。 一个虚拟终端可以管理多个会话，窗口和面板 支持分屏，同时处理多个操作 窗口、面板可以在会话间自由移动，切换 丰富灵活的状态行展示 支持自定义快捷键，依照个人习惯配置令操作更高效 不受断网影响，避免丢失重要工作进度 结对编程，方便演示与协作 自带复制粘贴缓冲区管理 脚本化配置，可配置多种操作环境 层次结构tmux的主要元素分为三层： Session，一组窗口的集合。通常用来概括同一个任务。session可以有自己的名字便于任务之间的切换。 Window，单个可见窗口。Windows有自己的编号，也可以认为和ITerm2中的Tab类似。 Pane，窗格。被划分成小块的窗口，类似于Vim中 C-w +v 后的效果。 安装1sudo apt-get install tmux 使用 查询Session，tmux ls 创建Session，tmux new -s session-name 断开Session，tmux detach 重新连接Session，tmux a -t session-name 关闭Session，tmux kill-session -t session-name 默认快捷键 系统指令 Ctrl+b ? 显示快捷键帮助文档 Ctrl+b d 断开当前会话 Ctrl+b D 选择要断开的会话 Ctrl+b Ctrl+z 挂起当前会话 Ctrl+b r 强制重载当前会话 Ctrl+b s 显示会话列表用于选择并切换 Ctrl+b : 进入命令行模式，此时可直接输入ls等命令 Ctrl+b [ 进入复制模式，按q退出 Ctrl+b ] 粘贴复制模式中复制的文本 Ctrl+b ~ 列出提示信息缓存 窗口指令 Ctrl+b c 新建窗口 Ctrl+b &amp; 关闭当前窗口（关闭前需输入y or n确认） Ctrl+b 0~9 切换到指定窗口 Ctrl+b p 切换到上一窗口 Ctrl+b n 切换到下一窗口 Ctrl+b w 打开窗口列表，用于且切换窗口 Ctrl+b , 重命名当前窗口 Ctrl+b . 修改当前窗口编号（适用于窗口重新排序） Ctrl+b f 快速定位到窗口（输入关键字匹配窗口名称） 窗格指令 Ctrl+b “ 当前面板上下一分为二，下侧新建面板 Ctrl+b % 当前面板左右一分为二，右侧新建面板 Ctrl+b x 关闭当前面板（关闭前需输入y or n确认） Ctrl+b z 最大化当前面板，再重复一次按键后恢复正常（v1.8版本新增） Ctrl+b ! 将当前面板移动到新的窗口打开（原窗口中存在两个及以上面板有效） Ctrl+b ; 切换到最后一次使用的面板 Ctrl+b q 显示面板编号，在编号消失前输入对应的数字可切换到相应的面板 Ctrl+b { 向前置换当前面板 Ctrl+b } 向后置换当前面板 Ctrl+b Ctrl+o 顺时针旋转当前窗口中的所有面板 Ctrl+b 方向键 移动光标切换面板 Ctrl+b o 选择下一面板 Ctrl+b 空格键 在自带的面板布局中循环切换 Ctrl+b Alt+方向键 以5个单元格为单位调整当前面板边缘 Ctrl+b Ctrl+方向键 以1个单元格为单位调整当前面板边缘（Mac下被系统快捷键覆盖） Ctrl+b t 显示时钟 配置文件tmux 中的很多操作都是通过快捷键去实现的 ，每次基本都要先执行prefix（默认是Ctrl+b），这个前缀键对我是十分不友好的，所以我通过配置文件修改成Ctrl+a。通常配置文件路径为~/.tmux.conf，根目录没有就新建一个。以下是我的配置。 1234567891011121314151617181920212223# Send prefix，设置Ctrl+a为前缀键set-option -g prefix C-aunbind-key C-abind-key C-a send-prefix# Mouse mode，设置可以鼠标点击不同窗格set -g mouse on# Set easier window split keys，设置‘=’为向右新开窗格，‘-’为向下新开窗格bind-key = split-window -hbind-key - split-window -v# tmux插件，用于备份session，免得电脑重启需要重新打命令set -g @plugin &#x27;tmux-plugins/tpm&#x27;set -g @plugin &#x27;tmux-plugins/tmux-resurrect&#x27;set -g @plugin &#x27;tmux-plugins/tmux-continuum&#x27;set -g @continuum-save-interval &#x27;60&#x27;set -g @continuum-restore &#x27;on&#x27;set -g @resurrect-capture-pane-contents &#x27;on&#x27;run-shell ~/.tmux/plugins/tmux-resurrect/resurrect.tmuxrun-shell ~/.tmux/plugins/tmux-continuum/continuum.tmux 修改完配置需要source配置文件才能完成 1tmux source ~/.tmux.conf 自动备份到这里是不是跃跃欲试了，稍等，有些特殊bug我们需要注意。当机器需要重启或者意外断电等导致关机，这个时候tmux的session就全部丢失了。作为tmux的重度用户，有时候会有上百个session，有些session中保存了历史命令有可能已经记不清了，session的丢失无疑是个重大的损失。好在开源社区早已经有了解决方案，只需要简单地配置就可以实现session的会话的自动保存和加载。 原理整个解决方案由三个tmux插件组成。 tpm：tmux plugin manager 这个是用来管理tmux插件的。有了它之后，就可以很轻松地安装和写在tmux插件 tmux-resurrect 这个是主角，提供了保存tmux会话到磁盘，以及从磁盘上加载保存的会话的功能。但是只能在需要的时候手动操作 tmux-continuum 提供了定时保存，自动加载，以及开机设置自动启动tmux的功能。需要tmux-resurrect来完成具体的工作 安装配置123git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpmgit clone https://github.com/tmux-plugins/tmux-resurrect.git ~/.tmux/plugins/tmux-resurrectgit clone https://github.com/tmux-plugins/tmux-continuum.git ~/.tmux/plugins/tmux-continuum 然后，在~/.tmux.conf中配置： 12345678910set -g @plugin &#x27;tmux-plugins/tpm&#x27;set -g @plugin &#x27;tmux-plugins/tmux-resurrect&#x27;set -g @plugin &#x27;tmux-plugins/tmux-continuum&#x27;set -g @continuum-save-interval &#x27;60&#x27;set -g @continuum-restore &#x27;on&#x27;set -g @resurrect-capture-pane-contents &#x27;on&#x27;run-shell ~/.tmux/plugins/tmux-resurrect/resurrect.tmuxrun-shell ~/.tmux/plugins/tmux-continuum/continuum.tmux 最后使配置文件生效tmux source ~/.tmux.conf这样每隔60分钟就会自动备份一波，你也可以手动备份，快捷键是prefix + Ctrl+s，下次重启后想要恢复，先执行tmux进入，然后prefix + Ctrl+r即可恢复先来的窗口，美滋滋。另外，如果不小心手动备份一个错误的tmux，想要回滚，可以进入.tmux/resurrect，使用ln -s将last链接到指定的tmux_resurrect_xxx.txt文件即可 参考 tmux-plugins&#x2F;tmux-resurrect 题外话oh-my-zsh与tmux搭配更丝滑哦","tags":["linux"],"categories":["开发运维"]},{"title":"SLAM 之拟合直线","path":"/1673567539.html","content":"最小二乘法拟合直线上周面试了一家做机器人的公司，他们发我一道题目，顺便记录学习下。 问题给定一组2D平面上的离散点： 请求解出对应拟合直线 要求有几点：1、建立该问题的数学模型，并且基于C++予以实现，包括：类/接口定义，以及实现细节2、建议选择如下两种方法之一，或者酌情选择其他的方法： 基于ceres优化库，建立优化问题，并求解 基于Eigen工具库求解（提示：通过特征向量分解的方式） 3、生成测试数据集，并对比验证不同实现的拟合效果4、输出一份报告，包括：问题的定义，求解细节，以及验证结果等 分析其实就是直线拟合，这里就想到了最小二乘（视觉SLAM十四讲有写）。 最小二乘法，又称最小平方法。它通过最小化误差的平方和寻找数据的最佳函数匹配。主要作用是从一堆相关数据中求解数据的一般性规律。在图像处理方面多用于各种形状的拟合。 最小二乘拟合直线，主要体现为找到一条直线，使得所有已知的点到这条直线的欧式距离的和最小（或者理解为点到直线的误差平方和最小）。 那我是思考了两种方法，一种是直接求解最小二乘，一种是使用Ceres库优化迭代最小二乘。 解决数学模型的建立 目标 对于等精度测量所得的N组数据，。其中值被认为是准确的，所有误差只与有关。需要把这组观测数据拟合成一条直线，并求对应法向量。 约束 要求观测值的偏差的加权平方和为最小，即最小。 变量 对于一条直线，有两个待定参数，代表截距，代表斜率（代码里取）。 法一：直接求解采用直线斜截式，通过最小二乘拟合方程系数 根据最小二乘原理，误差平方和最小，得误差函数： 高数中极值定理可知，误差方程一阶导数等于处取得极值，因此分别对其关于和求导，解,值使得误差函数取最小值。 但是直线斜截式无法表示垂直x轴的直线，如：。 令，得 上面过程繁琐，只适用于直线的最小二乘解。下面将直线斜截式拓展导任意曲线，任意曲线方程 。可以看到直线斜截式即，时的曲线方程。将曲线方程，写成矩阵乘积的形式： 上面乘积形式，即,解出的 就是最小二乘解。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void LeastSquares(std::vector&lt;double&gt; &amp;data_x, std::vector&lt;double&gt; &amp;data_y, int data_n) { double A, B, C, D, E, F = 0.0; double x_square_sum, x_sum, y_sum, xy_multi_sum = 0.0; for (int i = 0; i &lt; data_n; i++) { x_square_sum += data_x[i] * data_x[i]; x_sum += data_x[i]; xy_multi_sum += data_x[i] * data_y[i]; y_sum += data_y[i]; } // 计算斜率k和截距b double k, b, temp = 0; if (temp = (data_n * x_square_sum - x_sum * x_sum)) { k = (data_n * xy_multi_sum - x_sum * y_sum) / temp; b = (x_square_sum * y_sum - x_sum * xy_multi_sum) / temp; } else { k = 1; b = 0; } // 计算x和y线性相关系数r double Xmean, Ymean; Xmean = x_sum / data_n; Ymean = y_sum / data_n; double tempSumXX = 0.0, tempSumYY = 0.0; for (int i = 0; i &lt; data_n; i++) { tempSumXX += (data_x[i] - Xmean) * (data_x[i] - Xmean); tempSumYY += (data_y[i] - Ymean) * (data_y[i] - Ymean); E += (data_x[i] - Xmean) * (data_y[i] - Ymean); } F = sqrt(tempSumXX) * sqrt(tempSumYY); double r; r = E / F; std::cout &lt;&lt; \"k: \" &lt;&lt; k &lt;&lt; \" \" &lt;&lt; \"b: \" &lt;&lt; b &lt;&lt; \" \" &lt;&lt; \"r: \" &lt;&lt; r &lt;&lt; std::endl; // AX + BY + C = 0 std::cout &lt;&lt; \"Direction Vector (B,-A): (\" &lt;&lt; -1 &lt;&lt; \",\" &lt;&lt; -k &lt;&lt; \") \"; std::cout &lt;&lt; \"Normal Vector (A,B): (\" &lt;&lt; k &lt;&lt; \",\" &lt;&lt; -1 &lt;&lt; \") \"; const char *title = \"curve fitting by LS\"; Plot(data_x, data_y, k, b, title);} 法二：Ceres优化首先是定义残差快 12345678910111213struct ExponentialResidual { ExponentialResidual(double x, double y) : x_(x), y_(y) {} template &lt;typename T&gt; bool operator()(const T *const k, const T *const b, T *residual) const { // r = y - f(x) residual[0] = y_ - (k[0] * x_ + b[0]); return true; } private: const double x_; const double y_;}; 然后构建最小二乘问题 123456for (int i = 0; i &lt; data_x.size(); ++i) { problem.AddResidualBlock( new ceres::AutoDiffCostFunction&lt;ExponentialResidual, 1, 1, 1&gt;( new ExponentialResidual(data_x[i], data_y[i])), NULL, &amp;k, &amp;b);} 最后优化求解 123456ceres::Solver::Options options;options.max_num_iterations = 20;options.linear_solver_type = ceres::DENSE_QR;options.minimizer_progress_to_stdout = true;ceres::Solver::Summary summary;ceres::Solve(options, &amp;problem, &amp;summary); 结果 代码仓库Least_Square_Fitting_Line 参考1、最小二乘法求解直线方程系数 2、ceres拟合直线","tags":["数学","slam"],"categories":["工具脚本"]},{"title":"ROS 使用 move_base 做4个点循环跑的导航","path":"/2024475831.html","content":"前言记录一下用move_base跑4个目标点的程序。 首先《ros by example 1》里有个用move_base跑4个目标点的程序，先去看了下源码，发现它仅仅是把目标点发送出去，然后等待move_base 60s，如果这段时间内成功完成导航任务，则继续发布下个目标点，否则退出。代码如下所示： 12345678910111213141516def move(self, goal): # Send the goal pose to the MoveBaseAction server self.move_base.send_goal(goal) # Allow 1 minute to get there finished_within_time = self.move_base.wait_for_result(rospy.Duration(60)) # If we don&#x27;t get there in time, abort the goal if not finished_within_time: self.move_base.cancel_goal() rospy.loginfo(&quot;Timed out achieving goal&quot;) else: # We made it! state = self.move_base.get_state() if state == GoalStatus.SUCCEEDED: rospy.loginfo(&quot;Goal succeeded!&quot;) 当时觉得好无语，哪有做控制是靠等待时间来判断的啊，通过当前位姿与目标点位姿的距离才能判断出导航任务是否完成啊。所以，只要把这段代码中添加一个距离的判断就可以实现基于move_base的循环导航了。即： 12if distance &lt; 1.0: move_base.send_goal(goal) 只要当前位姿与目标点位姿的距离小于1米了，我就重新发送一个目标点给move_base，这样就可以实现循环导航了（在实验时试过：在导航过程中重新发送目标点，机器人会重新规划处一条到新目标点的路径及轨迹）。那当前时刻的位姿怎么确定呢？有2种方式，一种是订阅定位节点发布的位姿话题；感觉这种有点low，就pass掉了，更优越的方法就是用Actionlib。 Actionlib为了寻找这种更优的方法，只有去看move_base的源码了！看了代码发现move_base其实是actionlib的服务端的实现，好吧，不知道actionlib是啥。后来又去看actionlib的概念。action也是一种类似于~的问答通讯机制，不一样的地方是action还带有一个反馈机制，可以不断反馈任务的实施进度，而且可以在任务实施过程中，中止运行。哇，带反馈，这不就是我要的更优越的方法么。之后通过下面2位大神的文章以及ROS官网中的教程简单学习了一下actionlib的使用。ROS探索总结（三十二）——actionROS知识（15）—-Actionlib的使用（一）actionlib&#x2F; Tutorials 如下图可以看出，action分为服务端和客户端，服务端会不断的向客服端发送反馈信息，而move_base为服务端，上述《ros by example 1 》中的例子为客服端。所以只需要在客户端中使用这个反馈就可以了。那么，怎么实现呢？ 问题1：是否发出了反馈消息我们先从第一个问题开始：通过这篇文章，知道了move_base确实是发布了反馈信息，而且反馈信息就是当前的位姿。ok，成功解决第一个问题。注意，这个反馈消息不是move_base发出来的，而是actionlib发出来的！ 1234567891011121314151617181920212223242526272829303132333435363738394041bool MoveBase::executeCycle( geometry_msgs::PoseStamped&amp; goal, std::vector&lt;geometry_msgs::PoseStamped&gt;&amp; global_plan) &#123; //发布速度topic geometry_msgs::Twist cmd_vel; // push the feedback out //发布一些反馈信息 move_base_msgs::MoveBaseFeedback feedback; feedback.base_position = current_position; as_-&gt;publishFeedback(feedback); //省略。。。&#125;void MoveBase::executeCb( const move_base_msgs::MoveBaseGoalConstPtr&amp; move_base_goal) &#123; // we have a goal so start the planner(通知planner线程进行路径规划) boost::unique_lock&lt;boost::mutex&gt; lock(planner_mutex_); planner_goal_ = goal; runPlanner_ = true; // 通知规划路径线程 planner_cond_.notify_one(); lock.unlock(); ros::NodeHandle n; while (n.ok()) &#123; // 被抢占了(可能是发出新的goal，也可能是取消了) if (as_-&gt;isPreemptRequested()) &#123; if (as_-&gt;isNewGoalAvailable()) &#123; // 发布新的goal，通知planner线程工作。 planner_cond_.notify_one(); &#125; else &#123; // if we&#x27;ve been preempted explicitly we need to shut things down //强制退出 return; &#125; &#125; //省略。。。 &#125;&#125; 与此同时，我也看到了在新的目标点到来时，新的任务抢占了之前的任务，move_base会将新的目标点发送到actionlib中并重新规划路径。 问题2：消息类型move_base的action通讯的消息类型在安装move_base时会自动安装，ROS中的move_base_msgs提供了这个消息的说明。简单说明一下，消息类型是由2个“—”分隔开的三种数据类型组成。第一条为目标点的消息类型；第二条为当此次动作执行完成时向客户端发送的消息类型，仅在动作结束时发送一次；第三条为反馈的消息类型，这个是在动作执行过程中一直发送的。 在这里可以看到，move_base的反馈消息类型为 geometry_msgs/PoseStamped ，消息的名字为 base_position。 123456789#goal definitiongeometry_msgs/PoseStamped target_pose---#result definition---#feedbackgeometry_msgs/PoseStamped base_position 这个反馈消息是发送在/move_base命名空间下的/feedback话题上，也就是/move_base/feedback。通过接收这个话题得到的消息如下所示： 12345678910111213141516171819202122232425262728293031323334---header: seq: 640 stamp: secs: 1547635103 nsecs: 592393429 frame_id: &#x27;&#x27;status: goal_id: stamp: secs: 1547635097 nsecs: 258239984 id: &quot;/nav_test-4-1547635097.258&quot; status: 1 text: &quot;This goal has been accepted by the simple action server&quot;feedback: base_position: header: seq: 0 stamp: secs: 1547635103 nsecs: 550548076 frame_id: &quot;map&quot; pose: position: x: 0.00729128714117 y: 0.0192558593724 z: 0.0 orientation: x: 0.0 y: 0.0 z: -0.0199257022983 w: 0.999801463486--- OK，第二个问题成功解决掉。 问题3：怎么接收反馈消息在学习actionlib时知道了actionlib的使用方式，即，一方为服务端，负责发送动作执行的状态与结果；一方为客户端，负责发送动作目标并监听动作状态。反馈消息是从服务端按照着自己定义的消息类型向客户端发出。所以，反馈消息的处理是在客服端内进行，通过回调函数的方式进行处理。ROS中有例子如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;actionlib/client/simple_action_client.h&gt;#include &lt;actionlib_tutorials/FibonacciAction.h&gt;#include &lt;ros/ros.h&gt;using namespace actionlib_tutorials;typedef actionlib::SimpleActionClient&lt;FibonacciAction&gt; Client;// Called once when the goal completesvoid doneCb(const actionlib::SimpleClientGoalState&amp; state, const FibonacciResultConstPtr&amp; result) &#123; ROS_INFO(&quot;Finished in state [%s]&quot;, state.toString().c_str()); ROS_INFO(&quot;Answer: %i&quot;, result-&gt;sequence.back()); ros::shutdown();&#125;// Called once when the goal becomes activevoid activeCb() &#123; ROS_INFO(&quot;Goal just went active&quot;); &#125;// Called every time feedback is received for the goalvoid feedbackCb(const FibonacciFeedbackConstPtr&amp; feedback) &#123; ROS_INFO(&quot;Got Feedback of length %lu&quot;, feedback-&gt;sequence.size());&#125;int main(int argc, char** argv) &#123; ros::init(argc, argv, &quot;test_fibonacci_callback&quot;); // Create the action client Client ac(&quot;fibonacci&quot;, true); ROS_INFO(&quot;Waiting for action server to start.&quot;); ac.waitForServer(); ROS_INFO(&quot;Action server started, sending goal.&quot;); // Send Goal FibonacciGoal goal; goal.order = 20; ac.sendGoal(goal, &amp;doneCb, &amp;activeCb, &amp;feedbackCb); ros::spin(); return 0;&#125; 可以看到，通过在发送目标点时将回调函数注册进去，从而在每次反馈消息到来时将自动调用回调函数，也就是上文中的feedbackCb()函数。在actionlib的源码中可以找到sendGoal()的声明，它为后面三个回调函数给了默认的初始值，一个指向空函数的函数指针。 1234567891011121314/** * \\brief Sends a goal to the ActionServer, and also registers callbacks * * If a previous goal is already active when this is called. We simply forget * about that goal and start tracking the new goal. No cancel requests are made. * \\param done_cb Callback that gets called on transitions to Done * \\param active_cb Callback that gets called on transitions to Active * \\param feedback_cb Callback that gets called whenever feedback for this goal * is received */void sendGoal(const Goal&amp; goal, SimpleDoneCallback done_cb = SimpleDoneCallback(), SimpleActiveCallback active_cb = SimpleActiveCallback(), SimpleFeedbackCallback feedback_cb = SimpleFeedbackCallback()); 知道了回调函数的使用方式就可以接受反馈消息了。不完整的几行代码如下：在下面的代码中，每次反馈消息的到来都会调用feedbackCb()，并将base_position赋值到全局变量current_point当中。 1234567891011121314151617181920212223242526272829303132333435363738394041typedef actionlib::SimpleActionClient&lt;move_base_msgs::MoveBaseAction&gt; Client;geometry_msgs::Point current_point;// Called once when the goal becomes activevoid activeCb() &#123; ROS_INFO(&quot;Goal Received&quot;); &#125;// Called every time feedback is received for the goalvoid feedbackCb(const move_base_msgs::MoveBaseFeedbackConstPtr&amp; feedback) &#123; //\tROS_INFO(&quot;Got base_position of Feedback&quot;); current_point.x = feedback-&gt;base_position.pose.position.x; current_point.y = feedback-&gt;base_position.pose.position.y; current_point.z = feedback-&gt;base_position.pose.position.z;&#125;int main(int argc, char** argv) &#123; ros::init(argc, argv, &quot;nav_move_base&quot;); ros::NodeHandle node; // Subscribe to the move_base action server Client ac(&quot;move_base&quot;, true); // Publisher to manually control the robot (e.g. to stop it, queue_size=5) cmdVelPub = node.advertise&lt;geometry_msgs::Twist&gt;(&quot;/cmd_vel&quot;, 5); move_base_msgs::MoveBaseGoal goal; // Use the map frame to define goal poses goal.target_pose.header.frame_id = &quot;map&quot;; // Set the time stamp to &quot;now&quot; goal.target_pose.header.stamp = ros::Time::now(); // Set the goal pose to the i-th waypoint goal.target_pose.pose = pose_list[count]; // Start the robot moving toward the goal ac.sendGoal(goal, Client::SimpleDoneCallback(), &amp;activeCb, &amp;feedbackCb); return 0;&#125; 可以看到，在sendGoal()函数中，第一个回调函数按照默认的声明给定了空值，并将在客户端中实现的后两个回调函数注册到actionlib中。 1ac.sendGoal(goal, Client::SimpleDoneCallback(), &amp;activeCb, &amp;feedbackCb); 这个方法使用了全局函数，但是假如我想使用类该怎么做呢？这就需要boost库中的bind了，用法如下： 12345actionlib::SimpleActionClient&lt;FibonacciAction&gt; ac;// Need boost::bind to pass in the &#x27;this&#x27; pointerac.sendGoal(goal, boost::bind(&amp;MyNode::doneCb, this, _1, _2), Client::SimpleActiveCallback(), Client::SimpleFeedbackCallback()); OK，至此，我们已经成功解决上述3个问题并且成功的接受到了作为反馈消息的当前位姿。有了当前位姿我们就可以做很多事情了，包括编写一个基于move_base的循环跑的小程序。 完整程序如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#!/usr/bin/env pythonimport rospyimport actionlibfrom actionlib_msgs.msg import *from geometry_msgs.msg import Pose, Point, Quaternion, Twistfrom move_base_msgs.msg import MoveBaseAction, MoveBaseGoalfrom tf.transformations import quaternion_from_eulerfrom visualization_msgs.msg import Markerfrom math import radians, piclass MoveBaseSquare(): def __init__(self): rospy.init_node(&#x27;nav_test&#x27;, anonymous=False) rospy.on_shutdown(self.shutdown) # How big is the square we want the robot to navigate? square_size = rospy.get_param(&quot;~square_size&quot;, 1.0) # meters # Create a list to hold the target quaternions (orientations) quaternions = list() # First define the corner orientations as Euler angles euler_angles = (pi/2, pi, 3*pi/2, 0) # Then convert the angles to quaternions for angle in euler_angles: q_angle = quaternion_from_euler(0, 0, angle, axes=&#x27;sxyz&#x27;) q = Quaternion(*q_angle) quaternions.append(q) # Create a list to hold the waypoint poses waypoints = list() # Append each of the four waypoints to the list. Each waypoint # is a pose consisting of a position and orientation in the map frame. waypoints.append(Pose(Point(square_size, 0.0, 0.0), quaternions[0])) waypoints.append( Pose(Point(square_size, square_size, 0.0), quaternions[1])) waypoints.append(Pose(Point(0.0, square_size, 0.0), quaternions[2])) waypoints.append(Pose(Point(0.0, 0.0, 0.0), quaternions[3])) # Initialize the visualization markers for RViz self.init_markers() # Set a visualization marker at each waypoint for waypoint in waypoints: p = Point() p = waypoint.position self.markers.points.append(p) # Publisher to manually control the robot (e.g. to stop it, queue_size=5) self.cmd_vel_pub = rospy.Publisher(&#x27;cmd_vel&#x27;, Twist, queue_size=5) # Subscribe to the move_base action server self.move_base = actionlib.SimpleActionClient( &quot;move_base&quot;, MoveBaseAction) rospy.loginfo(&quot;Waiting for move_base action server...&quot;) # Wait 60 seconds for the action server to become available self.move_base.wait_for_server(rospy.Duration(60)) rospy.loginfo(&quot;Connected to move base server&quot;) rospy.loginfo(&quot;Starting navigation test&quot;) # Initialize a counter to track waypoints i = 0 # Cycle through the four waypoints while i &lt; 4 and not rospy.is_shutdown(): # Update the marker display self.marker_pub.publish(self.markers) # Intialize the waypoint goal goal = MoveBaseGoal() # Use the map frame to define goal poses goal.target_pose.header.frame_id = &#x27;map&#x27; # Set the time stamp to &quot;now&quot; goal.target_pose.header.stamp = rospy.Time.now() # Set the goal pose to the i-th waypoint goal.target_pose.pose = waypoints[i] # Start the robot moving toward the goal self.move(goal) i += 1 def move(self, goal): # Send the goal pose to the MoveBaseAction server self.move_base.send_goal(goal) # Allow 1 minute to get there finished_within_time = self.move_base.wait_for_result( rospy.Duration(60)) # If we don&#x27;t get there in time, abort the goal if not finished_within_time: self.move_base.cancel_goal() rospy.loginfo(&quot;Timed out achieving goal&quot;) else: # We made it! state = self.move_base.get_state() if state == GoalStatus.SUCCEEDED: rospy.loginfo(&quot;Goal succeeded!&quot;) def init_markers(self): # Set up our waypoint markers marker_scale = 0.2 marker_lifetime = 0 # 0 is forever marker_ns = &#x27;waypoints&#x27; marker_id = 0 marker_color = &#123;&#x27;r&#x27;: 1.0, &#x27;g&#x27;: 0.7, &#x27;b&#x27;: 1.0, &#x27;a&#x27;: 1.0&#125; # Define a marker publisher. self.marker_pub = rospy.Publisher( &#x27;waypoint_markers&#x27;, Marker, queue_size=5) # Initialize the marker points list. self.markers = Marker() self.markers.ns = marker_ns self.markers.id = marker_id self.markers.type = Marker.CUBE_LIST self.markers.action = Marker.ADD self.markers.lifetime = rospy.Duration(marker_lifetime) self.markers.scale.x = marker_scale self.markers.scale.y = marker_scale self.markers.color.r = marker_color[&#x27;r&#x27;] self.markers.color.g = marker_color[&#x27;g&#x27;] self.markers.color.b = marker_color[&#x27;b&#x27;] self.markers.color.a = marker_color[&#x27;a&#x27;] self.markers.header.frame_id = &#x27;odom&#x27; self.markers.header.stamp = rospy.Time.now() self.markers.points = list() def shutdown(self): rospy.loginfo(&quot;Stopping the robot...&quot;) # Cancel any active goals self.move_base.cancel_goal() rospy.sleep(2) # Stop the robot self.cmd_vel_pub.publish(Twist()) rospy.sleep(1)if __name__ == &#x27;__main__&#x27;: try: MoveBaseSquare() except rospy.ROSInterruptException: rospy.loginfo(&quot;Navigation test finished.&quot;)","tags":["ros"],"categories":["机器人"]},{"title":"Apollo 之 Canbus 解析","path":"/817441275.html","content":"Canbus模块介绍我们先看下什么是Canbus： 控制器局域网 (Controller Area Network，简称CAN或者CAN bus) 是一种车用总线标准。被设计用于在不需要主机(Host)的情况下，允许网络上的节点相互通信。采用广播机制，并利用标识符来定义内容和消息的优先顺序，使得canbus的扩展性良好，同时不基于特殊类型(Host)的节点，增加了升级网络的便利性。这里的Canbus模块其实可以称为Chassis模块，主要的作用是反馈车当前的状态（航向，角度，速度等信息），并且发送控制命令到车线控底盘，可以说Canbus模块是车和自动驾驶软件之间的桥梁。由于这个模块和&quot;drivers/canbus&quot;的联系紧密，因此也一起在这里介绍。Canbus模块是车和自动驾驶软件之间的桥梁，通过canbus驱动(drivers/canbus)来实现将车身信息发送给Apollo上层软件，同时接收控制命令，发送给汽车线控底盘实现对汽车的控制。 那么canbus模块的输入是什么？输出是什么呢？ 可以看到canbus模块： 输入 - 1. ControlCommand（控制命令） 输出 - 1. Chassis（汽车底盘信息）, 2. ChassisDetail（汽车底盘信息详细信息） Canbus一方面接收Control模块发布的指令，然后将指令解析为CAN协议报文通过can总线传递给车上的各个控制单元；另一方面从can总线上获取数据并且将信息解析为底盘信息，然后把消息发布出去(反馈底盘信息)。 Canbus模块的目录结构如下： 接着我们来分析下Canbus模块的执行流程。 Canbus(主模块) Canbus模块的主流程在文件&quot;canbus_component.cc&quot;中，Canbus模块为定时触发，每10ms执行一次，发布chassis信息，而ControlCommand则是每次读取到之后触发回调&quot;OnControlCommand&quot;，发送&quot;control_command&quot;到线控底盘。 1234567bool CanbusComponent::Proc() &#123; PublishChassis(); if (FLAGS_enable_chassis_detail_pub) &#123; PublishChassisDetail(); &#125; return true;&#125; 由于不同型号的车辆的canbus命令不一样，在&quot;/vehicle&quot;中适配了不同型号车辆底盘协议的canbus消息格式，所有的车都继承自Vehicle_controller基类，通过对Vehicle_controller的抽象来发送和读取canbus信息。 车辆工厂模式(VehicleFactory)在vehicle中可以适配不同的车型，而每种车型都对应一个vehicle_controller，创建每种车辆的控制器(VehicleController)和消息管理(MessageManager)流程如下： VehicleFactory类通过创建不同的类型AbstractVehicleFactory，每个车型自己的Factory在创建出对应的VehicleController和MessageManager。用林肯来举例子就是： VehicleFactory创建LincolnVehicleFactory，之后通过CreateMessageManager和CreateVehicleController创建对应的控制器（LincolnController）和消息管理器（LincolnMessageManager）。上述代码流程用到了设计模式的工厂模式，通过车辆工厂创造不同的车辆类型。 车辆控制器(LincolnController)下面以林肯来介绍LincolnController，以及如何接收chassis信息，其它的车型可以以此类推。可以看上面的整体流程图lincoln_controller.cc部分，显然，controller分为三部分init-&gt;start-&gt;stop，init过程是获取MessageManager的protocolData，即发送的消息协议数据类型，然后通过CanSender发送这些消息。如以int为协议来代表的是整数，以char为协议代表的字符。那这个protocolData就是我们以这个类型为协议来替代车辆行驶的具体操作。例如在modules/canbus/vehicle/brake_60.h这个Brake60类的操作就是刹车。start之后启动一个看门狗，检查canbus消息格式是否正确，最后stop模块则是结束看门狗进程。 Canbus(驱动程序)上层的canbus就介绍完成了，而canbus的发送(CanSender)和接收(CanReceiver)，还有消息管理(MessageManager)都是在&quot;drivers/canbus&quot;中实现的。 消息管理器(MessageManager)MessageManager，顾名思义就是用于管理所有的msg，主要作用是解析和保存canbus数据。而具体的接收和发送则是在&quot;CanReceiver&quot;和&quot;CanSender&quot;中。使用前需要将所有用户自定义的ProtocolData初始化并将其分为send和receive类加入各自队列中，包含一个Parse接口，会逐一调用所有receive类ProtocolData对象的Parse接口，实现将接受到的CanFrame数据转化为自定义数据类型（例如0x6b的帧中数据为车辆加速度数据，将数据解析到自定义的ChassisDetail中的lateral_acceleration、longitudinal_acceleration、vertical_acceleration变量中），底层有一个unordered_map用于根据id搜索加入的ProtocolData对象，用于将send类对象提取出来供CanSender使用。拿接收消息举例子，也就是说CanReceiver收到消息后，会调用MessageManager中的Parse去解析消息，消息的解析协议在&quot;modules/canbus/vehicle/lincoln/protocol&quot;中，每个消息把自己对应的信息塞到&quot;chassis_detail&quot;中完成了消息的接收。 消息接收(CanReceiver)CanReceiver中的&quot;Start&quot;调用&quot;RecvThreadFunc&quot;实现消息的接收，这里会启动一个异步进程去完成接收。 1234567891011template &lt;typename SensorType&gt;::apollo::common::ErrorCode CanReceiver&lt;SensorType&gt;::Start() &#123; if (is_init_ == false) &#123; return ::apollo::common::ErrorCode::CANBUS_ERROR; &#125; is_running_.exchange(true); // 启动异步接收消息 async_result_ = cyber::Async(&amp;CanReceiver&lt;SensorType&gt;::RecvThreadFunc, this); return ::apollo::common::ErrorCode::OK;&#125; RecvThreadFunc通过&quot;can_client_&quot;接收消息，然后通过&quot;MessageManager&quot;去解析消息，在MessageManager中有讲到。 1234567891011121314151617181920212223242526272829303132template &lt;typename SensorType&gt;void CanReceiver&lt;SensorType&gt;::RecvThreadFunc() &#123; ... while (IsRunning()) &#123; std::vector&lt;CanFrame&gt; buf; int32_t frame_num = MAX_CAN_RECV_FRAME_LEN; // 1. can_client_接收canbus数据 if (can_client_-&gt;Receive(&amp;buf, &amp;frame_num) != ::apollo::common::ErrorCode::OK) &#123; cyber::USleep(default_period); continue; &#125; ... for (const auto &amp;frame : buf) &#123; uint8_t len = frame.len; uint32_t uid = frame.id; const uint8_t *data = frame.data; // 2. MessageManager解析canbus数据 pt_manager_-&gt;Parse(uid, data, len); if (enable_log_) &#123; ADEBUG &lt;&lt; &quot;recv_can_frame#&quot; &lt;&lt; frame.CanFrameString(); &#125; &#125; cyber::Yield(); &#125; AINFO &lt;&lt; &quot;Can client receiver thread stopped.&quot;;&#125; 消息发送(CanSender)消息发送对应的是在CanSender中的&quot;Start&quot;调用&quot;PowerSendThreadFunc&quot;，我们可以看具体实现: 12345678910111213template &lt;typename SensorType&gt;common::ErrorCode CanSender&lt;SensorType&gt;::Start() &#123; if (is_running_) &#123; AERROR &lt;&lt; &quot;Cansender has already started.&quot;; return common::ErrorCode::CANBUS_ERROR; &#125; is_running_ = true; // 启动线程发送消息 thread_.reset(new std::thread([this] &#123; PowerSendThreadFunc(); &#125;)); return common::ErrorCode::OK;&#125; PowerSendThreadFunc再通过&quot;can_client&quot;发送消息： 12345678std::vector&lt;CanFrame&gt; can_frames;CanFrame can_frame = message.CanFrame();can_frames.push_back(can_frame);// 通过can_client发送消息if (can_client_-&gt;SendSingleFrame(can_frames) != common::ErrorCode::OK) &#123; AERROR &lt;&lt; &quot;Send msg failed:&quot; &lt;&lt; can_frame.CanFrameString();&#125; canbus客户端(CanClient)CanClient是canbus客户端，同时也是canbus的驱动程序，针对不同的canbus卡，对发送和接收进行封装，并且提供给消息发送和接收控制器使用。拿&quot;EsdCanClient&quot;来举例子，&quot;Send&quot;函数发送can消息，调用的是第三方的硬件驱动canWrite，&quot;Receive&quot;函数接收can消息，调用的是第三方的硬件驱动canRead。其他的can卡可以参考上述的流程，至此整个canbus驱动就分析完成了。","tags":["apollo"],"categories":["自动驾驶"]},{"title":"Halo1.0 博客搭建","path":"/4287437300.html","content":"Halo1.0博客搭建简介Halo [ˈheɪloʊ]，意为光环。当然，你也可以当成拼音读(哈喽)。轻快，简洁，功能强大，使用 Java 开发的博客系统。 使用 Docker 部署 Halo本篇教程以 CentOS 7.9 为例，其他系统大同小异。 环境要求推荐的配置： CentOS 7.x 1G 以上内存 服务器配置更新软件包请确保服务器的软件包已经是最新的。 1sudo yum update -y 创建 Halo 用户推荐创建一个低权限的用户运行 halo： 创建一个名为 halo 的用户（名字可以随意） 1useradd -m halo 给予 sudo 权限 1usermod -aG wheel halo 为 halo 用户创建密码 1passwd halo 登录到 halo 用户 1su - halo 配置 Docker 运行环境安装Docker必要依赖1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 添加软件源信息1sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 更新 yum 缓存1sudo yum makecache fast 安装 Docker1sudo yum install docker-ce docker-ce-cli containerd.io 启动 Docker 后台服务1sudo systemctl start docker 允许当前用户直接运行 docker 命令需要将当前用户加入 docker 用户组。这样每次运行 docker 命令的时候，就不需要加 sudo。 1sudo usermod -aG docker halo(your_name) 注意：设置成功之后需要重新登录才会生效。 镜像加速12# 新建 daemon.json 文件sudo vim /etc/docker/daemon.json 将下面的配置复制进去即可： 12345&#123; &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot; , &quot;https://docker.mirrors.ustc.edu.cn&quot; , &quot;https://zxwb55s8.mirror.aliyuncs.com&quot;]&#125; 注意：修改完配置文件之后需要执行 service docker restart 才可生效。 安装 Halo自定义配置文件考虑到部分用户的需要，可能需要自定义比如端口等设置项，我们提供了公共的配置文件，并且该配置文件是完全独立于安装包的。当然，你也可以使用安装包内的默认配置文件，但是安装包内的配置文件是不可修改的。请注意：配置文件的路径为 ~/.halo/application.yaml。 12# 下载配置文件到 ~/.halo 目录curl -o ~/.halo/application.yaml --create-dirs https://dl.halo.run/config/application-template.yaml 修改配置文件完成上一步操作，我们就可以自己配置 Halo 的运行端口，以及数据库相关的配置了。 12# 使用 Vim 工具修改配置文件vim ~/.halo/application.yaml 打开之后我们可以看到： 123456789101112131415161718192021222324252627282930313233343536server: port: 8090 # Response data gzip. compression: enabled: falsespring: datasource: # H2 database configuration. driver-class-name: org.h2.Driver url: jdbc:h2:file:~/.halo/db/halo username: admin password: 123456 # MySQL database configuration.# driver-class-name: com.mysql.cj.jdbc.Driver# url: jdbc:mysql://127.0.0.1:3306/halodb?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true# username: root# password: 123456 # H2 database console configuration. h2: console: settings: web-allow-others: false path: /h2-console enabled: falsehalo: # Your admin client path is https://your-domain/&#123;admin-path&#125; admin-path: admin # memory or level cache: memory 如果需要自定义端口，修改 server 节点下的 port 即可。 默认使用的是 H2 Database 数据库，这是一种嵌入式的数据库，使用起来非常方便。需要注意的是，默认的用户名和密码为 admin 和 123456，这个是自定义的，最好将其修改，并妥善保存。 如果需要使用 MySQL 数据库，需要将 H2 Database 的所有相关配置都注释掉，并取消 MySQL 的相关配置。另外，MySQL 的默认数据库名为 halodb，请自行配置 MySQL 并创建数据库，以及修改配置文件中的用户名和密码。 h2 节点为 H2 Database 的控制台配置，默认是关闭的，如需使用请将 h2.console.settings.web-allow-others 和 h2.console.enabled 设置为 true。控制台地址即为 域名/h2-console。注意：非紧急情况，不建议开启该配置。 server.compression.enabled 为 Gzip 功能配置，如有需要请设置为 true，需要注意的是，如果你使用 Nginx 或者 Caddy 进行反向代理的话，默认是有开启 Gzip 的，所以这里可以保持默认。 halo.admin-path 为后台管理的根路径，默认为 admin，如果你害怕别人猜出来默认的 admin（就算猜出来，对方什么都做不了），请自行设置。仅支持一级，且前后不带 /。 halo.cache 为系统缓存形式的配置，可选 memory 和 level，默认为 memory，将数据缓存到内存，使用该方式的话，重启应用会导致缓存清空。如果选择 level，则会将数据缓存到磁盘，重启不会清空缓存。如不知道如何选择，建议默认。 拉取最新 Halo 镜像1sudo docker pull ruibaby/halo 创建容器并运行1docker run --rm -it -d --name halo -p 8090:8090 -v ~/.halo:/root/.halo ruibaby/halo –rm：停止之后自动删除容器。 –name：容器名。 -p：占用端口，前者为宿主机端口，后者为 Halo 的运行端口，可在 application.yaml 配置。 -v：目录映射，一般不要修改。 完成以上操作即可通过 ip:端口 访问了。不过在此之前，最好先完成后续操作，我们还需要让域名也可以访问到 Halo，请继续往下看。 更新 Halo 版本12345678# 停止容器sudo docker stop halo# 拉取最新的 Halo 镜像sudo docker pull ruibaby/halo# 创建容器docker run --rm -it -d --name halo -p 8090:8090 -v ~/.halo:/root/.halo ruibaby/halo 配置域名访问预备条件1、请确保域名已经成功解析到服务器 IP，可以通过ping域名看是否成功。 2、请检查服务器的 80 和 443 端口是否开放。 3、请开放宿主机端口，我上面的是8090。 使用 Caddy 进行反向代理Caddy 是一款使用 Go 语言开发的 Web 服务器。其配置更为简洁，并可以自动申请及配置 SSL 证书（推荐）。 也可以用Nginx反向代理，具体可以参考 安装 Caddy12# 安装 Caddy 软件包yum install caddy -y 配置 Caddy12# 下载 Halo 官方的 Caddy 配置模板curl -o /etc/caddy/conf.d/Caddyfile.conf --create-dirs https://dl.halo.run/config/Caddyfile 下载完成之后，我们还需要对其进行修改。 12# 使用 vim 编辑 Caddyfilevim /etc/caddy/conf.d/Caddyfile.conf 打开之后我们可以看到 1234567https://www.simple.com &#123; gzip tls xxxx@xxx.xx proxy / localhost:port &#123; transparent &#125;&#125; 请把 https://www.simple.com 改为自己的域名。 tls 后面的 xxxx@xxx.xx 改为自己的邮箱地址，这是用于自动申请 SSL 证书用的。需要注意的是，不需要你自己配置 SSL 证书，而且会自动帮你续签。 localhost:port 请将 port 修改为 Halo 的运行端口，默认为 8090。 比如我的 1234567felicx.xyz &#123; gzip tls xxx@xxx.com proxy / localhost:8090 &#123; transparent &#125;&#125; 修改完成之后启动 Caddy 服务即可。 1234567891011121314# 开启自启 Caddy 服务systemctl enable caddy# 启动 Caddyservice caddy start# 停止运行 Caddyservice caddy stop# 重启 Caddyservice caddy restart# 查看 Caddy 运行状态service caddy status 到这一步你就能通过域名访问了，这是我的博客。","tags":["halo"],"categories":["折腾系列"]},{"title":"Coursera 视频无法播放问题解决","path":"/2693822199.html","content":"前言碎碎念：本来这篇文章是挂 CSDN 的，老说我翻墙不给我审核通过，没办法只好迁来自己的博客了。 最近想看下 coursera 上的课程，却发现视频加载不出来，挂了 VPN 也不好用。 解决方法在浏览器上按 F12 调用 console 窗口查看发现 d3c33hcgiwev3.cloudfront.net 网站无法访问。只能想办法改 hosts 绕过去。 以下是 Windows 系统修改hosts，其他系统类似： 用管理员权限打开 hosts 文件(C:\\Windows\\System32\\drivers\\etc) 将下面内容复制到文件末尾并保存： 12345678910# coursera ip54.230.96.102 d3c33hcgiwev3.cloudfront.net54.230.96.174 d3c33hcgiwev3.cloudfront.net54.230.96.221 d3c33hcgiwev3.cloudfront.net54.230.96.57 d3c33hcgiwev3.cloudfront.net54.192.99.52 d3njjcbhbojbot.cloudfront.net54.192.99.85 d3njjcbhbojbot.cloudfront.net54.192.99.124 d3njjcbhbojbot.cloudfront.net54.192.99.42 d3njjcbhbojbot.cloudfront.net 刷新 DNS 缓存在 cmd 里面输入 ipconfig /flushdns 命令后按回车 更新：有朋友说 ip 失效了。正常，因为 coursera 是动态 ip，会经常变的。这里贴一个授之以渔的方法：用这个在线解析工具 在输入框里输入域名 d3c33hcgiwev3.cloudfront.net （如果打不开这个在线解析工具，可以百度找其他的在线解析工具）他就会返回一连串的 ip 地址 替换 hosts 文件里的 ip 即可。 PS：发现知乎有人（不为谁而读的研）盗用我文章，无所谓啦，这正好说明我这篇文章是对大家有帮助的，不然别人也不会抄。","tags":["course"],"categories":["工具脚本"]},{"title":"数据结构之链表","path":"/1091615714.html","content":"链表链表相关的核心点 NULL 异常处理 dummy node(哑巴节点) 快慢指针 插入一个节点到排序链表 从一个链表中移除一个节点 翻转链表 合并两个链表 找到链表的中间节点 哑巴节点哑节点（dummy node）是初始值为NULL的节点，创建在使用到链表的函数中，可以起到避免处理头节点为空的边界问题的作用，减少代码执行异常的可能性。也就是说，哑节点的使用可以对代码起到简化作用（省略当函数的入口参数为空时的判断）。 1234567891011121314151617181920212223242526272829303132// 普通结构体struct ListNode &#123; int val; struct ListNode *next;&#125;;// 定义函数ListNode *addNode( ListNode *node, int num)&#123;\t// 函数返回的是尾节点 struct ListNode *new = (struct ListNode*) malloc(sizeof(struct ListNode) * num); node-&gt;next = new; return new;&#125;// 问题是当node节点为空时，便会产生异常，node-&gt;next = new会报错，应该修改如下ListNode *addNode( ListNode *node, int num)&#123;\t// 函数返回的是尾节点 struct ListNode *new = (struct ListNode*) malloc( sizeof(struct ListNode) * num ); if( null == node )&#123; // 头节点为空的情况 return new; // 直接返回新建的节点（头节点的地址），相当于新建了一组链表 &#125; node-&gt;next = new; return new;&#125;// 定义哑节点如下struct ListNode *dummyNode= (struct ListNode*) malloc(sizeof(struct ListNode));dummyNode-&gt;val = NULL;dummyNode-&gt;next = NULL;// 函数addNode()重新定义如下ListNode *addNode( ListNode *dummyNode, int num) // 函数返回的是尾节点 struct ListNode *new = (struct ListNode*) malloc( sizeof(struct ListNode) * num ); /* 此处不再需要处理头节点为空的情况，因为dummyNode一定非空 */ dummyNode-&gt;next = new; return new;&#125; 快慢指针快慢指针就是定义两根指针，移动的速度一快一慢，以此来制造出自己想要的差值。这个差值可以让我们找到链表上相应的节点。比如，我们把一个链表看成一个跑道，假设a的速度是b的两倍，那么当a跑完全程后，b刚好跑一半，以此来达到找到中间节点的目的。 常见题型 删除排序链表中的重复元素 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */// 递归class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(head == NULL) &#123; return head; &#125; if(head-&gt;next)&#123; head-&gt;next = deleteDuplicates(head-&gt;next); if(head-&gt;val == head-&gt;next-&gt;val) &#123; head = head-&gt;next; // 删除head &#125; &#125; return head; &#125;&#125;;// 迭代class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; ListNode* current = head; while(current) &#123; while(current-&gt;next &amp;&amp; current-&gt;val == current-&gt;next-&gt;val) &#123; current-&gt;next = current-&gt;next-&gt;next; &#125; current = current-&gt;next; &#125; return head; &#125;&#125;; 删除排序链表中的重复元素 II 给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现的数字。 思路：链表头结点可能被删除，所以用dummy node辅助删除 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 递归class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(head == NULL) return head; if(head-&gt;next &amp;&amp; head-&gt;val == head-&gt;next-&gt;val) &#123; while(head-&gt;next &amp;&amp; head-&gt;val == head-&gt;next-&gt;val) &#123; head = head-&gt;next; &#125; return deleteDuplicates(head-&gt;next); &#125; else &#123; head-&gt;next = deleteDuplicates(head-&gt;next); &#125; return head; &#125;&#125;;// 迭代class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(head == NULL) &#123; return head; &#125; // 链表头结点可能被删除，所以用dummy node辅助删除 struct ListNode *dummyNode= (struct ListNode*) malloc(sizeof(struct ListNode)); dummyNode-&gt;next = head; head = dummyNode;\t// 之后不管head怎么移动，dummyNode-&gt;next就是head移动完的链表的头结点 int temp; while(head-&gt;next &amp;&amp; head-&gt;next-&gt;next) &#123; if(head-&gt;next-&gt;val == head-&gt;next-&gt;next-&gt;val) &#123; temp = head-&gt;next-&gt;val; while(head-&gt;next &amp;&amp; head-&gt;next-&gt;val == temp) &#123; head-&gt;next = head-&gt;next-&gt;next; &#125; &#125; else &#123; head = head-&gt;next; &#125; &#125; return dummyNode-&gt;next; &#125;&#125;; 注意点◉ A-&gt;B-&gt;C 删除 B，A-&gt;next &#x3D; C◉ 删除用一个dummy node节点辅助（允许头节点可变）◉ 访问 X-&gt;next 、X-&gt;value 一定要保证 X !&#x3D; NULL 反转链表 反转一个单链表。 思路：用一个prev节点保存向前指针，next保存向后的临时指针 12345678910111213141516171819202122232425262728293031323334// 递归，参考https://leetcode-cn.com/problems/reverse-linked-list/solution/zhu-bu-tu-jie-di-gui-die-dai-by-sucongcjs/class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (head == NULL || head-&gt;next == NULL) &#123; return head; &#125; ListNode* ret = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return ret; &#125;&#125;;// 迭代class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode *next = NULL; ListNode *prev = NULL; while(head) &#123; /** * 保存当前head-&gt;next节点，防止重新赋值后被覆盖 * 一轮之后状态：NULL &lt;- 1 2 -&gt; 3 -&gt; 4 * prev head */ next = head-&gt;next; head-&gt;next = prev; prev = head; // prev 移动 head = next; // head 移动 &#125; return prev; &#125;&#125;; 反转链表 II 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 思路：先遍历到 m 处，翻转，再拼接后续，注意指针处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 递归，参考https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/bu-bu-chai-jie-ru-he-di-gui-di-fan-zhuan-lian-biao/class Solution &#123;public: ListNode* successor = NULL; // 后驱节点 // 反转以 head 为起点的 n 个节点，返回新的头结点 ListNode* reverseN(ListNode* head, int n) &#123; if (n == 1) &#123; // 记录第 n + 1 个节点 successor = head-&gt;next; return head; &#125; // 以 head.next 为起点，需要反转前 n - 1 个节点 ListNode* last = reverseN(head-&gt;next, n - 1); head-&gt;next-&gt;next = head; // 让反转之后的 head 节点和后面的节点连起来 head-&gt;next = successor; return last; &#125; ListNode* reverseBetween(ListNode* head, int m, int n) &#123; // base case if (m == 1) &#123; return reverseN(head, n); &#125; // 前进到反转的起点触发 base case head-&gt;next = reverseBetween(head-&gt;next, m - 1, n - 1); return head; &#125;&#125;;// 迭代class Solution &#123; public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; // 思路：先遍历到m处，翻转，再拼接后续，注意指针处理 // 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4 if (head == NULL) &#123; return head; &#125; // 头部变化所以使用dummy node ListNode* dummyNode = (struct ListNode*)malloc(sizeof(struct ListNode)); dummyNode-&gt;next = head; head = dummyNode; // 最开始：0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL ListNode* pre = NULL; int i = 0; while (i &lt; m) &#123; pre = head; head = head-&gt;next; i++; &#125; // 遍历之后： 1(pre)-&gt;2(head)-&gt;3-&gt;4-&gt;5-&gt;NULL // i = 1 int j = i; ListNode* next = NULL; ListNode* mid = head; // 用于中间节点连接 while (head != NULL &amp;&amp; j &lt;= n) &#123; // 第一次循环： 1(pre) NULL&lt;-2 3(head)-&gt;4-&gt;5-&gt;NULL ListNode* temp = head-&gt;next; head-&gt;next = next; next = head; head = temp; j++; &#125; // 循环需要执行四次 // 循环结束：1(pre) NULL&lt;-2&lt;-3&lt;-4 5(head)-&gt;NULL pre-&gt;next = next; mid-&gt;next = head; return dummyNode-&gt;next; &#125;&#125;; 合并两个有序链表 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 思路：通过 dummy node 链表，连接各个元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 递归class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1 == nullptr) &#123; return l2; &#125; else if (l2 == nullptr) &#123; return l1; &#125; else if (l1-&gt;val &lt; l2-&gt;val) &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else &#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125; &#125;&#125;;// 迭代class Solution &#123; public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1 == NULL) &#123; return l2; &#125; else if (l2 == NULL) &#123; return l1; &#125; // 头部变化所以使用dummy node ListNode* dummyNode = (struct ListNode*)malloc(sizeof(struct ListNode)); ListNode* head = dummyNode; while (l1 != NULL &amp;&amp; l2 != NULL) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; head-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; head-&gt;next = l2; l2 = l2-&gt;next; &#125; head = head-&gt;next; &#125; while (l1 != NULL) &#123; head-&gt;next = l1; head = head-&gt;next; l1 = l1-&gt;next; &#125; while (l2 != NULL) &#123; head-&gt;next = l2; head = head-&gt;next; l2 = l2-&gt;next; &#125; return dummyNode-&gt;next; &#125;&#125;; 分隔链表 给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。 思路：将大于 x 的节点，放到另外一个链表，最后连接这两个链表 123456789101112131415161718192021222324252627282930// 迭代class Solution &#123; public: ListNode* partition(ListNode* head, int x) &#123; if (head == NULL) &#123; return head; &#125; ListNode* headDummy = (struct ListNode*)malloc(sizeof(struct ListNode)); headDummy-&gt;next = head; head = headDummy; ListNode* tailDummy = (struct ListNode*)malloc(sizeof(struct ListNode)); ListNode* tail = tailDummy; while (head-&gt;next) &#123; if (head-&gt;next-&gt;val &lt; x) &#123; head = head-&gt;next; &#125; else &#123; // 移除&lt;x节点 ListNode* temp = head-&gt;next; head-&gt;next = head-&gt;next-&gt;next; // 放到另外一个链表 tail-&gt;next = temp; tail = tail-&gt;next; &#125; &#125; // 拼接两个链表 tail-&gt;next = NULL; head-&gt;next = tailDummy-&gt;next; return headDummy-&gt;next; &#125;&#125;; 哑巴节点使用场景 当头节点不确定的时候，使用哑巴节点 排序链表 在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 思路：归并排序，找中点和合并操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 链表排序， 归并递归排序class Solution &#123; public: ListNode *sortList(ListNode *head) &#123; return (head == NULL) ? NULL : mergeSort(head); &#125; private: ListNode *findMid(ListNode *head) &#123; ListNode *slow = head; ListNode *fast = head; ListNode *previous = NULL; while (fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; previous = slow; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; // split the list into two parts previous-&gt;next = NULL; return slow; &#125; ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; if (l1 == NULL) return l2; if (l2 == NULL) return l1; if (l1-&gt;val &lt; l2-&gt;val) &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else &#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125; &#125; ListNode *mergeSort(ListNode *head) &#123; if (head-&gt;next == NULL) return head; ListNode *mid = findMid(head); ListNode *l1 = mergeSort(head); ListNode *l2 = mergeSort(mid); return mergeTwoLists(l1, l2); &#125;&#125;; 注意点 快慢指针 判断 fast 及 fast-&gt;next 是否为 NULL 值 递归 mergeSort 需要断开中间节点 递归返回条件为 head 为 NULL或者 head-&gt;next 为 NULL 重排链表 给定一个单链表 L：L→L→…→L__n→L 将其重新排列后变为： L→L__n→L→L__n→L→L__n→… 思路：1.快慢指针找到中点 2.拆成两个链表 3.遍历两个链表，后面的塞到前面的“缝隙里” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; public: void reorderList(ListNode *head) &#123; if (head == NULL || head-&gt;next == NULL) return; // 快慢指针分出两段 ListNode *slow = head; ListNode *fast = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; // 拆成两个链表 ListNode *needReverser = slow-&gt;next; slow-&gt;next = NULL; // 后端反转,反转用上面的反转链表I needReverser = reverseList(needReverser); // 插入前端缝隙 ListNode *cur = head; while (cur &amp;&amp; needReverser) &#123; ListNode *curSecond = needReverser; needReverser = needReverser-&gt;next; ListNode *nextCur = cur-&gt;next; curSecond-&gt;next = cur-&gt;next; cur-&gt;next = curSecond; cur = nextCur; &#125; &#125; ListNode *reverseList(ListNode *head) &#123; if (head == NULL || head-&gt;next == NULL) &#123; return head; &#125; ListNode *ret = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return ret; &#125; // 第二种反转 ListNode *reverse(ListNode *head) &#123; ListNode *next = NULL; ListNode *prev = NULL; while (head) &#123; next = head-&gt;next; head-&gt;next = prev; prev = head; // prev 移动 head = next; // head 移动 &#125; return prev; &#125;&#125;; 环形链表 给定一个链表，判断链表中是否有环。 思路：快慢指针，快慢指针相同则有环(因为fast快，slow慢，所以如果有环fast最后一定会追上slow)， 证明：如果有环每走一步快慢指针距离会减 1 1234567891011121314151617181920212223242526272829class Solution &#123; public: bool hasCycle(ListNode *head) &#123; if (!head || !head-&gt;next) &#123; return false; &#125; // 直接套用上面快慢指针写法 ListNode *slow = head; ListNode *fast = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123; if(!slow-&gt;next) &#123; return false; // 稍微加个判断，减少下用时 &#125; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if (fast == slow) &#123; return true; &#125; &#125; return false; &#125;&#125;;// 另一种表示方法是fast = head-&gt;next;slow = head;// 两种方式不同点在于，一般用 fast=head-&gt;next 较多,因为这样可以知道中点的上一个节点，可以用来删除等操作// fast 如果初始化为 head-&gt;next 则中点在 slow-&gt;next// fast 初始化为 head ,则中点在 slow 环形链表 II 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 思路：快慢指针，快慢相遇之后，慢指针回到头，快慢指针步调一致一起移动，相遇点即为入环点看下图：F为第一个节点-F到入环点0的距离；a为入环点0到相遇点h距离；b为相遇点h到入环点0距离；当fast和slow相遇时，fast走过的是slow的两倍，设slow走过为S，则S&#x3D;F+a，2S&#x3D;F+a+b+a，故F&#x3D;b；现在让slow返回第一个节点，fast处于第一次相遇的节点，此时slow从第一个节点出发，因为F&#x3D;b，所以fast和slow会在入环口第二次相遇，即为所求节点。 123456789101112131415161718192021222324252627282930class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if (!head || !head-&gt;next) &#123; return NULL; &#125; bool hasCycle = false; // 先判断是否有环 ListNode *slow = head; ListNode *fast = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if (fast == slow) &#123; hasCycle = true; break; &#125; &#125; // 有环则找入环开始的节点 if (hasCycle) &#123; slow = head; while (slow != fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return slow; &#125; return NULL; &#125;&#125;; 坑点 指针比较时直接比较对象，不要用值比较，链表中有可能存在重复值情况 第一次相交后，快指针需要从下一个节点开始和头指针一起匀速移动 回文链表 请判断一个链表是否为回文链表。 取中间分开链表，反转后面的链表，如果和前面的重合则为回文链表 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *reverse(ListNode *head) &#123; ListNode *next = NULL; ListNode *prev = NULL; while (head) &#123; next = head-&gt;next; head-&gt;next = prev; prev = head; // prev 移动 head = next; // head 移动 &#125; return prev; &#125; bool isPalindrome(ListNode* head) &#123; if (head == NULL) &#123; return true; &#125; ListNode *left = head; ListNode *right = head; while (right-&gt;next &amp;&amp; right-&gt;next-&gt;next) &#123; left = left-&gt;next; right = right-&gt;next-&gt;next; &#125; ListNode *middle = reverse(left); left-&gt;next = NULL; while (middle &amp;&amp; head) &#123; if(head-&gt;val != middle-&gt;val) &#123; return false; &#125; head = head-&gt;next; middle = middle-&gt;next; &#125; return true; &#125;&#125;; 复制带随机指针的链表 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。 要求返回这个链表的深拷贝。 思路：1、hash 表存储指针，2、复制节点跟在原节点后面，如A-&gt;B-&gt;C 变为 A-&gt;A’-&gt;B-&gt;B’-&gt;C-&gt;C’，3、设置节点random值4、将复制链表从原链表分离，如A-&gt;B-&gt;C和A’-&gt;B’-&gt;C’ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/*// Definition for a Node.class Node &#123;public: int val; Node* next; Node* random; Node(int _val) &#123; val = _val; next = NULL; random = NULL; &#125;&#125;;*/class Solution &#123;public: Node* copyRandomList(Node* head) &#123; if (!head) &#123; return head; &#125; // 复制节点 (遍历链表,在当前节点后插入副本节点) Node* cur = head; while (cur) &#123; Node* clone = new Node(cur-&gt;val, NULL, NULL); clone-&gt;next = cur-&gt;next; Node* temp = cur-&gt;next; cur-&gt;next = clone; cur = temp; &#125; // 对副本节点设置random指针 cur = head; // 因为复制了节点，cur-&gt;next不会为空 最终是cur为空 while (cur) &#123; if (cur-&gt;random != NULL) &#123; // 注意：原链表中cur-&gt;random可能为空 cur-&gt;next-&gt;random = cur-&gt;random-&gt;next; &#125; cur = cur-&gt;next-&gt;next; &#125; // 分离出原链表与副本链表 cur = head; Node* new_head = head-&gt;next; // 副本链表的头节点 Node* new_tail = new_head; // 副本链表的尾节点 while (cur) &#123; cur-&gt;next = cur-&gt;next-&gt;next; if (new_tail -&gt; next != NULL) &#123; new_tail-&gt;next = new_tail-&gt;next-&gt;next; &#125; cur = cur-&gt;next; // 注意：最后cur为空的情况 new_tail = new_tail-&gt;next; &#125; return new_head; &#125;&#125;; 是不是看不懂复制节点那一步，图解在这。 总结链表必须要掌握的一些点，通过下面练习题，基本大部分的链表类的题目都是手到擒来~ null&#x2F;nil 异常处理 dummy node 哑巴节点 快慢指针 插入一个节点到排序链表 从一个链表中移除一个节点 翻转链表 合并两个链表 找到链表的中间节点","tags":["数据结构"],"categories":["算法交流"]},{"title":"数据结构之二叉树","path":"/967469330.html","content":"二叉树遍历前序遍历：先访问根节点，再前序遍历左子树，再前序遍历右子树 中序遍历：先中序遍历左子树，再访问根节点，再中序遍历右子树 后序遍历：先后序遍历左子树，再后序遍历右子树，再访问根节点 注意点 以根访问顺序决定是什么遍历 左子树都是优先右子树 前序递归二叉树的前序遍历 12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123; public: vector&lt;int&gt; ve; vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; if(root) &#123; ve.push_back(root -&gt; val); preorderTraversal(root -&gt; left); preorderTraversal(root -&gt; right); &#125; return ve; &#125; &#125;; 前序非递归（迭代法）12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ve; if(root == NULL) return ve; vector&lt;TreeNode*&gt; stk; stk.push_back(root); while(!stk.empty())&#123; TreeNode* tmp = stk.back(); stk.pop_back(); ve.push_back(tmp -&gt; val); if(tmp -&gt; right)&#123; stk.push_back(tmp -&gt; right); &#125; if(tmp -&gt; left)&#123; stk.push_back(tmp -&gt; left); &#125; &#125; return ve; &#125;&#125;; 中序非递归（迭代法）二叉树的中序遍历 123456789101112131415161718192021222324/* 思路：每到一个节点 A，因为根的访问在中间，将 A 入vector。 * 然后遍历左子树，接着访问 A，最后遍历右子树。 * 在访问完 A 后，A 就可以出vector了。因为 A 和其左子树都已经访问完成。 * 和前序类似 */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;TreeNode*&gt; ve; vector&lt;int&gt; v; TreeNode* rt = root; while(rt || !ve.empty()) &#123; while(rt) &#123; ve.push_back(rt); rt=rt-&gt;left; &#125; rt=ve.back(); ve.pop_back(); v.push_back(rt-&gt;val); rt=rt-&gt;right; &#125; return v; &#125;&#125;; 后序非递归（迭代法）二叉树的后序遍历 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(root == NULL) return res; vector&lt;TreeNode*&gt; stk; stk.push_back(root); while(!stk.empty())&#123; TreeNode* tmp = stk.back(); stk.pop_back(); if(tmp!=nullptr)&#123; stk.push_back(tmp); stk.push_back(nullptr); if(tmp -&gt; right) stk.push_back(tmp -&gt; right); if(tmp -&gt; left) stk.push_back(tmp -&gt; left); &#125; else&#123; res.push_back(stk.back()-&gt;val); stk.pop_back(); &#125; &#125; return res; &#125;&#125;; 注意点 核心就是：根节点必须在右节点弹出之后，再弹出 DFS 深度搜索-从上到下二叉树的前序遍历 12345678910111213141516class Solution &#123;public: // 深度遍历，结果指针作为参数传入到函数内部 void dfs(TreeNode* root, vector&lt;int&gt;* result)&#123; if(root)&#123; result -&gt; push_back(root -&gt; val); dfs(root -&gt; left, result); dfs(root -&gt; right, result); &#125; &#125; vector&lt;int&gt; preorderTraversal(TreeNode* root)&#123; vector&lt;int&gt; res; dfs(root, &amp;res); return res; &#125;&#125;; 这实际上就是递归的实现 DFS 深度搜索-从下向上（分治法）二叉树的前序遍历 分治法模板 递归返回条件 分段处理 合并结果 123456789101112131415Type traversal(TreeNode* root) &#123; // NULL or leaf if(root == NULL) &#123; // do something and return &#125; // Divide Type left = traversal(root -&gt; Left) Type right = traversal(root -&gt; Right) // Conquer Type result = Merge from left and right return result&#125; 答案代码 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; divideAndConquer(TreeNode* root)&#123; vector&lt;int&gt; result; if(root != NULL)&#123; vector&lt;int&gt; r_left = divideAndConquer(root -&gt; left); vector&lt;int&gt; r_right = divideAndConquer(root -&gt; right); result.push_back(root -&gt; val); for(auto it : r_left)&#123; result.push_back(it); &#125; for(auto it : r_right)&#123; result.push_back(it); &#125; &#125; return result; &#125; vector&lt;int&gt; preorderTraversal(TreeNode* root)&#123; vector&lt;int&gt; res; res = divideAndConquer(root); return res; &#125;&#125;; 注意点： DFS 深度搜索（从上到下） 和分治法区别：前者一般将最终结果通过指针参数传入，后者一般递归返回结果最后合并 BFS 层次遍历二叉树的层次遍历 II 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 思路：在层级遍历的基础上，翻转一下结果即可 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; queue&lt;TreeNode*&gt; q; vector&lt;vector&lt;int&gt;&gt; result; if(!root)&#123; return result; &#125; q.push(root); while(!q.empty())&#123; vector&lt;int&gt; ve; int nums = q.size(); for(int i = 0; i &lt; nums; i++)&#123; TreeNode* tmp = q.front(); q.pop(); ve.push_back(tmp-&gt;val); if(tmp-&gt;left)&#123; q.push(tmp-&gt;left); &#125; if(tmp-&gt;right)&#123; q.push(tmp-&gt;right); &#125; &#125; result.insert(result.begin(), ve); &#125; return result; &#125;&#125;; 分治法应用先分别处理局部，再合并结果 适用场景 归并排序 快速排序 二叉树相关问题 归并排序 ​ 归并排序是典型分治思想的代表——首先把原问题分解为两个或多个子问题，然后求解子问题的解，最后使用子问题的解来构造出原问题的解。​ 对于归并排序，给定一个待排序的数组，首先把该数组划分为两个子数组，然后对子数组进行排序（递归调用归并排序），最后对两个有序的子数组进行合并，使合并之后的数组为有序状态。​ 让我们想想，把一个数组不断地划分为子数组，不断地划分……,不断地划分……., 最后停止了划分不下去了。 此时子数组的元素有一个，它们本身就是有序的。接下来，我们就需要执行合并过程，不断地一层层向上合并，…….., 直到原数组。通过这个过程就会发现， 归并排序的核心在于合并有序的子数组，而不是对子数组进行排序，因为最底层的子数组本身就是有序的，上一层子数组如果想要变成有序的，通过合并底层有序的子数组就可以得到， 最终我们使原数组变成了有序的，从而完成了排序操作。 归并排序是用分治思想，时间复杂度为O(NlogN)。分治模式在每一层递归上有三个步骤： 分解（Divide）：将n个元素分成个含n&#x2F;2个元素的子序列。 解决（Conquer）：用合并排序法对两个子序列递归的排序。 合并（Combine）：合并两个已排序的子序列已得到排序结果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstring&gt;#include &lt;iostream&gt;typedef bool (*CompareFunc)(int, int);// 下面函数实现合并功能，输入三个下标参数表示了两个子数组, :[nStart_, nMiddle)和[nMiddle, nEnd)void Merge(int array[], int nStart_, int nMiddle_, int nEnd_, CompareFunc comp) &#123; if (array == nullptr || nStart_ &gt;= nMiddle_ || nMiddle_ &gt;= nEnd_) return; // 建立一个临时数组存放中间数据 int _nIndex = 0; int* _pTempArray = new int[nEnd_ - nStart_]; // 对两个子数组进行合并 int _nStartChange = nStart_; int _nMiddleChange = nMiddle_; while (_nStartChange &lt; nMiddle_ &amp;&amp; _nMiddleChange &lt; nEnd_) &#123; // 此处的if中比较语句的安排可以保持稳定排序的特性。 if (comp(array[_nMiddleChange], array[_nStartChange])) &#123; _pTempArray[_nIndex] = array[_nMiddleChange]; ++_nMiddleChange; &#125; else &#123; _pTempArray[_nIndex] = array[_nStartChange]; ++_nStartChange; &#125; ++_nIndex; &#125; // 把不为空的子数组的元素追加到临时数 if (_nStartChange &lt; nMiddle_) &#123; memcpy(_pTempArray + _nIndex, array + _nStartChange, sizeof(int) * (nMiddle_ - _nStartChange)); &#125; else if (_nMiddleChange &lt; nEnd_) &#123; memcpy(_pTempArray + _nIndex, array + _nMiddleChange, sizeof(int) * (nEnd_ - _nMiddleChange)); &#125; else &#123; /* do noting */ &#125; // 数据交换 memcpy(array + nStart_, _pTempArray, sizeof(int) * (nEnd_ - nStart_)); delete[] _pTempArray; _pTempArray = nullptr;&#125;// 归并排序功能实现函数void MergeSort(int array[], int nStart_, int nEnd_, CompareFunc comp) &#123; // 数组指针为空，或者数组内的个数少于等于1个时，直接返回。 if (nullptr == array || (nEnd_ - nStart_) &lt;= 1) return; // 划分为两个子数组并递归调用自身进行排序 int _nMiddle = (nStart_ + nEnd_) / 2; MergeSort(array, nStart_, _nMiddle, comp); MergeSort(array, _nMiddle, nEnd_, comp); // 合并排序完成的子数组 Merge(array, nStart_, _nMiddle, nEnd_, comp);&#125;// 比较函数bool less(int lhs, int rhs) &#123; return lhs &lt; rhs; &#125;bool large(int lhs, int rhs) &#123; return lhs &gt; rhs; &#125;// 打印数组函数void PrintArray(int array[], int nLength_) &#123; if (nullptr == array || nLength_ &lt;= 0) return; for (int i = 0; i &lt; nLength_; ++i) &#123; std::cout &lt;&lt; array[i] &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl;&#125;/*************** main.c *********************/int main(int argc, char* argv[]) &#123; // 测试 int array[10] = &#123;1, -1, 1, 5, -5, -1, -1, 3, -4, -2&#125;; MergeSort(array, 0, 9, large); PrintArray(array, 10); return 0;&#125; 快速排序​ 快速排序作为20世纪十大算法之一，我们这些玩编程的好像没有理由不去学习它。快速排序是冒泡排序的升级版。 ​ 基本思想：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可以分别对这两部分记录继续进行排序，以达到整个序列有序的目的。可参考这位大佬 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;typedef bool (*CompareFunc)(int, int);// 比较函数bool less(int lhs, int rhs) &#123; return lhs &lt;= rhs; &#125; // 从小到大bool large(int lhs, int rhs) &#123; return lhs &gt;= rhs; &#125; // 从大到小void quickSort(int left, int right, int arr[], CompareFunc comp) &#123; // 递归边界条件 if (left &gt;= right) return; int i, j, base, temp; i = left, j = right; base = arr[left]; //取最左边的数为基准数 while (i &lt; j) &#123; while (comp(base, arr[j]) &amp;&amp; i &lt; j) j--; while (comp(arr[i], base) &amp;&amp; i &lt; j) i++; if (i &lt; j) &#123; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; //基准数归位 arr[left] = arr[i]; arr[i] = base; quickSort(left, i - 1, arr, comp); //递归左边 quickSort(i + 1, right, arr, comp); //递归右边&#125;// 打印数组函数void PrintArray(int array[], int nLength_) &#123; if (nullptr == array || nLength_ &lt;= 0) return; for (int i = 0; i &lt; nLength_; ++i) &#123; std::cout &lt;&lt; array[i] &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl;&#125;int main(int argc, char* argv[]) &#123; // 测试 int array[10] = &#123;1, -1, 1, 5, -5, -1, -1, 3, -4, -2&#125;; quickSort(0, 9, array, less); PrintArray(array, 10); quickSort(0, 9, array, large); PrintArray(array, 10); return 0;&#125; 注意点： 快排由于是原地交换所以没有合并过程 传入的索引是存在的索引（如：0、length-1 等），越界可能导致崩溃 常见题目示例二叉树的最大深度 给定一个二叉树，找出其最大深度。 思路：分治法 123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if(!root) return 0; if(!root -&gt; left &amp;&amp; !root -&gt; right) return 1; // divide：分左右子树分别计算 int left = maxDepth(root -&gt; left); int right = maxDepth(root -&gt; right); // conquer：合并左右子树结果 return left &gt; right ? left + 1 : right + 1; &#125;&#125;; 平衡二叉树 给定一个二叉树，判断它是否是高度平衡的二叉树。 思路：分治法，左边平衡 &amp;&amp; 右边平衡 &amp;&amp; 左右两边高度 &lt;&#x3D; 1， 因为需要返回是否平衡及高度，要么返回两个数据，要么合并两个数据， 所以用-1 表示不平衡，&gt;0 表示树高度（二义性：一个变量有两种含义）。 1234567891011121314151617181920class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; if(maxDepth(root) == -1) &#123; return false; &#125; return true; &#125; int maxDepth(TreeNode* root) &#123; if(!root) return 0; if(!root -&gt; left &amp;&amp; !root -&gt; right) return 1; int left = maxDepth(root -&gt; left); int right = maxDepth(root -&gt; right); // 为什么返回-1呢？因为高度不可能为负数 if(abs(left - right) &gt; 1 || left == -1 || right == -1) &#123; return -1; &#125; return left &gt; right ? left + 1 : right + 1; &#125;&#125;; 注意 一般工程中，结果通过两个变量来返回，不建议用一个变量表示两种含义 二叉树中的最大路径和 给定一个非空二叉树，返回其最大路径和。 思路：分治法，分为三种情况：左子树最大路径和最大，右子树最大路径和最大，左右子树最大加根节点最大，需要保存两个变量：一个保存子树最大路径和，一个保存左右加根节点和，然后比较这个两个变量选择最大值即可 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: struct ResultType &#123; int SinglePath; // 保存单边最大值 int MaxPath; // 保存最大值（单边或者两个单边+根的值） &#125;; ResultType helper(TreeNode* root) &#123; if(root == NULL) &#123; return &#123;0,-(1 &lt;&lt; 10)&#125;; &#125; // Divide ResultType left = helper(root -&gt; left); ResultType right = helper(root -&gt; right); // Conquer ResultType result; // 求单边最大值 if(left.SinglePath &gt; right.SinglePath) &#123; result.SinglePath = std::max(left.SinglePath + root -&gt; val, 0); &#125; else &#123; result.SinglePath = std::max(right.SinglePath + root -&gt; val, 0); &#125; // 求两边加根最大值 int tempMax = std::max(right.MaxPath, left.MaxPath); result.MaxPath = std::max(tempMax, left.SinglePath + right.SinglePath + root -&gt; val); return result; &#125; int maxPathSum(TreeNode* root) &#123; ResultType result = helper(root); return result.MaxPath; &#125;&#125;; 二叉树的最近公共祖先 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 思路：分治法，有左子树的公共祖先或者有右子树的公共祖先，就返回子树的祖先，否则返回根节点 1234567891011121314151617181920212223242526class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; // 相等 直接返回root节点即可 if(root == NULL || root == p || root == q) &#123; return root; &#125; // Divide TreeNode* left = lowestCommonAncestor(root -&gt; left, p, q); TreeNode* right = lowestCommonAncestor(root -&gt; right, p, q); // Conquer // 左右两边都不为空，则根节点为祖先 if(left != NULL &amp;&amp; right != NULL) &#123; return root; &#125; if(left != NULL) &#123; return left; &#125; if(right != NULL) &#123; return right; &#125; return NULL; &#125;&#125;; BFS 层次应用二叉树的层序遍历 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点） 思路：用一个队列记录一层的元素，然后扫描这一层元素添加下一层元素到队列（一个数进去出来一次，所以复杂度 O(logN)）。(和之前的二叉树的层次遍历 II类似) 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; queue&lt;TreeNode*&gt; q; vector&lt;vector&lt;int&gt;&gt; result; if(!root)&#123; return result; &#125; q.push(root); while(!q.empty())&#123; vector&lt;int&gt; ve; int nums = q.size(); for(int i = 0; i &lt; nums; i++)&#123; TreeNode* tmp = q.front(); q.pop(); ve.push_back(tmp-&gt;val); if(tmp-&gt;left)&#123; q.push(tmp-&gt;left); &#125; if(tmp-&gt;right)&#123; q.push(tmp-&gt;right); &#125; &#125; result.push_back(ve); &#125; return result; &#125;&#125;; 二叉树的锯齿形层次遍历 给定一个二叉树，返回其节点值的锯齿形层次遍历。Z 字形遍历 思路：在层次遍历的基础上加个下一层反向 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123; queue&lt;TreeNode*&gt; q; vector&lt;vector&lt;int&gt;&gt; result; if(!root)&#123; return result; &#125; q.push(root); bool reverse_flag = false; while(!q.empty())&#123; vector&lt;int&gt; ve; int nums = q.size(); for(int i = 0; i &lt; nums; i++)&#123; TreeNode* tmp = q.front(); q.pop(); ve.push_back(tmp-&gt;val); if(tmp-&gt;left)&#123; q.push(tmp-&gt;left); &#125; if(tmp-&gt;right)&#123; q.push(tmp-&gt;right); &#125; &#125; if(reverse_flag) &#123; std::reverse(ve.begin(), ve.end()); reverse_flag = false; &#125; else &#123; reverse_flag = true; &#125; result.push_back(ve); &#125; return result; &#125;&#125;; 二叉搜索树应用验证二叉搜索树 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 思路 1：递归 思路 2：中序遍历，检查结果列表是否已经有序 思路 3：分治法，判断左 MAX &lt; 根 &lt; 右 MIN 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// v1class Solution &#123;public: bool isBSTUtil(TreeNode* root, long min, long max) &#123; if(root == NULL) return true; if(root-&gt;val &lt;= min || root-&gt;val &gt;= max) return false; return isBSTUtil(root-&gt;left, min, root-&gt;val) &amp;&amp; isBSTUtil(root-&gt;right, root-&gt;val, max); &#125; bool isValidBST(TreeNode* root) &#123; long v_min = LONG_MIN, v_max = LONG_MAX; return isBSTUtil(root, v_min, v_max); &#125;&#125;;// v2class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; if(root == NULL) &#123; return true; &#125; vector&lt;int&gt; result; inOrder(root, &amp;result); // 按左、根、右排列进行比较，左大于根或者根大于右则肯定不是平衡二叉树 for(int i = 0; i &lt; result.size() - 1; i++) &#123; if(result[i] &gt;= result[i + 1]) &#123; return false; &#125; &#125; return true; &#125; // 分别将左节点和右节点放入result void inOrder(TreeNode* root, vector&lt;int&gt;* result) &#123; if(root == NULL) &#123; return; &#125; inOrder(root -&gt; left, result); result -&gt; push_back(root -&gt; val); inOrder(root -&gt; right, result); &#125;&#125;;// v3class Solution &#123;public: struct ResultType &#123; bool IsValid; // 记录左右两边最大最小值，和根节点进行比较 TreeNode* Max; TreeNode* Min; &#125;; bool isValidBST(TreeNode* root) &#123; ResultType result = helper(root); return result.IsValid; &#125; ResultType helper(TreeNode* root) &#123; ResultType result = &#123;&#125;; if(root == NULL) &#123; result.IsValid = true; return result; &#125; ResultType left = helper(root -&gt; left); ResultType right = helper(root -&gt; right); if(!left.IsValid || !right.IsValid) &#123; result.IsValid = false; return result; &#125; if(left.Max != NULL &amp;&amp; (left.Max -&gt; val) &gt;= (root -&gt; val)) &#123; result.IsValid = false; return result; &#125; if(right.Min != NULL &amp;&amp; right.Min -&gt; val &lt;= root -&gt; val) &#123; result.IsValid = false; return result; &#125; result.IsValid = true; // 如果左边还有更小的3，就用更小的节点，不用4 // 5 // / \\ // 1 4 // / \\ // 3 6 result.Min = root; if(left.Min != NULL) &#123; result.Min = left.Min; &#125; result.Max = root; if(right.Max != NULL) &#123; result.Max = right.Max; &#125; return result; &#125;&#125;; 二叉搜索树中的插入操作 给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 思路：找到最后一个叶子节点满足插入条件即可 123456789101112131415class Solution &#123;public: TreeNode* insertIntoBST(TreeNode* root, int val) &#123; if(root == NULL) &#123; return new TreeNode(val); &#125; if(root -&gt; val &gt; val) &#123; root -&gt; left = insertIntoBST(root -&gt; left, val); &#125; else &#123; root -&gt;right = insertIntoBST(root -&gt; right, val); &#125; return root; &#125;&#125;; 总结 掌握二叉树递归与非递归遍历 理解 DFS 前序遍历与分治法 理解 BFS 层次遍历","tags":["二叉树","数据结构"],"categories":["算法交流"]},{"title":"数据结构之入门篇","path":"/1699436293.html","content":"前言算法模板，最科学的刷题方式，最快速的刷题路径，一个月从入门到 offer，你值得拥有 🐶~ 算法模板顾名思义就是刷题的套路模板，掌握了刷题模板之后，刷题也变得好玩起来了~ 此项目是根据github大佬项目改写的C++版本（大佬的是Go版本），从0开始学习，通过各种刷题文章、专栏、视频等总结了一套自己的刷题模板。 这个模板主要是介绍了一些通用的刷题模板，以及一些常见问题，如到底要刷多少题，按什么顺序来刷题，如何提高刷题效率等。 数据结构与算法数据结构是一种数据的表现形式，如链表、二叉树、栈、队列等都是内存中一段数据表现的形式。 算法是一种通用的解决问题的模板或者思路，大部分数据结构都有一套通用的算法模板，所以掌握这些通用的算法模板即可解决各种算法问题。 后面会分专题讲解各种数据结构、基本的算法模板、和一些高级算法模板，每一个专题都有一些经典练习题，完成所有练习的题后，你对数据结构和算法会有新的收获和体会。 先介绍两个算法题，试试感觉~ 1、实现 strStr() 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从 0 开始)。如果不存在，则返回 -1。 思路：核心点遍历给定字符串字符，判断以当前字符开头字符串是否等于目标字符串 1234567891011121314151617181920212223class Solution &#123; public: int strStr(string haystack, string needle) &#123; if (needle.size() == 0) &#123; return 0; &#125; if (needle.size() &gt; haystack.size()) &#123; return -1; &#125; int i, j; for (i = 0; i &lt; haystack.size() - needle.size() + 1; i++) &#123; for (j = 0; j &lt; needle.size(); j++) &#123; if (haystack[i + j] != needle[j]) &#123; break; &#125; &#125; if (needle.size() == j) &#123; return i; &#125; &#125; return -1; &#125;&#125;; 需要注意点 循环时，i 不需要到 len-1 如果找到目标字符串，len(needle)&#x3D;&#x3D;j （下一步，试试KMP算法） 2、子集 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 思路：这是一个典型的应用回溯法的题目，简单来说就是穷尽所有可能性，算法模板如下 123456789result = []def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 通过不停的选择，撤销选择，来穷尽所有可能性，最后将满足条件的结果返回 答案代码 123456789101112131415161718192021222324vector&lt;vector&lt;int&gt;&gt; res;vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; // 记录走过的路径 vector&lt;int&gt; track; backtrack(nums, 0, track); return res;&#125;// 路径：记录在 track 中// 选择列表：nums 中不存在于 track 的那些元素// 结束条件：nums 中的元素全都在 track 中出现void backtrack(vector&lt;int&gt;&amp; nums, int start, vector&lt;int&gt;&amp; track) &#123; res.push_back(track); // 注意 i 从 start 开始递增 for (int i = start; i &lt; nums.size(); i++) &#123; // 做选择 track.push_back(nums[i]); // 回溯，进入下一层决策树 backtrack(nums, i + 1, track); // 撤销选择 track.pop_back(); &#125;&#125; 可以看见，对 res 的更新是一个前序遍历，也就是说，res 就是树上的所有节点： 说明：后面会深入讲解几个典型的回溯算法问题，如果当前不太了解可以暂时先跳过（可参考这个） 简单法： 1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); vector&lt;vector&lt;int&gt;&gt; obj; vector&lt;int&gt; outArray; for (int i:nums) &#123; int len = obj.size(); obj.push_back(&#123;i&#125;); for (int j = 0; j &lt; len ; j++) &#123; outArray = obj[j]; outArray.push_back(i); obj.push_back(outArray); &#125; &#125; obj.push_back(&#123;&#125;); return obj; &#125;&#125;; 面试注意点我们大多数时候，刷算法题可能都是为了准备面试，所以面试的时候需要注意一些点 快速定位到题目的知识点，找到知识点的通用模板，可能需要根据题目特殊情况做特殊处理。 先去朝一个解决问题的方向！先抛出可行解，而不是最优解！先解决，再优化！ 代码的风格要统一，熟悉各类语言的代码规范。 命名尽量简洁明了，尽量不用数字命名如：i1、node1、a1、b2 常见错误总结 访问下标时，不能访问越界 空值 null 问题 run time error","tags":["数据结构"],"categories":["算法交流"]},{"title":"ROS 之 TF 理解","path":"/768008996.html","content":"TF转换（参考）1、URDF、TF和odom的关系在机器人自主导航中，ROS会构建这几个很重要的坐标系，即frame。在urdf文件中定义base_link，它代表了机器人的主干，其它所有的frame都是相对于base_link定义并粘在一起的。它们一起相对于大地图map移动，让机器人移动就是向tf发布geometry_msgs::TransformStamped消息通知ros base_link相对于map的tf转换关系 。 2、概念理解 物理语义 理解 原点 base_link 为相对机器人的本体的坐标系 位于tf tree的最根部 原点一般为表示机器人中心 odom 一个对于机器人全局位姿的粗略估计 直接与base_link 相链接，数据一般来源于里程计(odometry) 原点为开始计算位姿那个时刻的机器人的位置 map 一个经过先验（或者SLAM）地图数据矫正过的，在地图中的位姿信息 与odom（或者odom_combined）相连,与odom同为全局坐标系 原点为地图原点（地图原点在地图相应的yaml文件中有规定） 3、关系 map --&gt; odom --&gt; base_link odom到base_link的坐标转换是从运动源计算出来广播的。map到base_link的坐标转换是被定位模块计算出来的. 但定位模块不发布map到base_link的转换. 相反它先接受从odom到base_link的转换, 再计算并广播map到odom的位置转换关系 fixed_frame：RViz中认定的大世界就是fixed_frame target_frame：Rviz中视觉跟踪的frame是 target_frame 4、坐标转换在lidar的launch启动文件中增加： 123&lt;node pkg=&quot;tf&quot; type=&quot;static_transform_publisher&quot; name=&quot;base_link_to_laser4&quot; args=&quot;0.0 0.0 0.2 0.0 3.1415926 0.0 /base_link /laser_frame 40&quot; /&gt;&lt;/launch&gt; 12345678args=&quot;0.0 0.0 0.2 0.0 3.1415926 0.0 /base_link /laser_frame 40&quot;// 参数意义，分别对应static_transform_publisher的// x y z yaw pitch roll frame_id child_frame_id period_in_ms// x y z 是 x y z 的坐标// yaw pitch roll 是 绕 z旋转弧度角，绕y旋转弧度角，绕x旋转弧度角// frame_id child_frame_id period_in_ms 父坐标系，子坐标系，发布间隔（ms）// 上述是指的 z方向增加0.2m，绕y旋转180°// 这些相对变换就是固定base-link，看其他坐标在base_link下的偏移 修改urdf文件的坐标 找到urdf的描述文件，如turtlebot_description&#x2F;urdf&#x2F;turtlebot_library.urdf.xacro，在文件中修改坐标 123456789101112131415161718192021&lt;joint name=&quot;laser&quot; type=&quot;fixed&quot;&gt; &lt;origin xyz=&quot;0.00 0.00 0.20&quot; rpy=&quot;0 3.1415926 0&quot; /&gt; &lt;parent link=&quot;base_link&quot; /&gt; &lt;child link=&quot;base_laser_link&quot; /&gt; &lt;/joint&gt; &lt;link name=&quot;base_laser_link&quot;&gt; &lt;visual&gt; &lt;geometry&gt; &lt;box size=&quot;0.00 0.05 0.06&quot; /&gt; &lt;/geometry&gt; &lt;material name=&quot;Green&quot; /&gt; &lt;/visual&gt; &lt;inertial&gt; &lt;mass value=&quot;0.000001&quot; /&gt; &lt;origin xyz=&quot;0 0 0&quot; /&gt; &lt;inertia ixx=&quot;0.0001&quot; ixy=&quot;0.0&quot; ixz=&quot;0.0&quot; iyy=&quot;0.0001&quot; iyz=&quot;0.0&quot; izz=&quot;0.0001&quot; /&gt; &lt;/inertial&gt; &lt;/link&gt;","tags":["ros"],"categories":["机器人"]},{"title":"ROS 之 topic 发布","path":"/2149880123.html","content":"Ros使用topic发布array：C++实现publish这里只需要数据data数据1234567891011121314151617181920212223242526272829303132333435363738394041#include &quot;ros/ros.h&quot;#include &quot;std_msgs/Float32MultiArray.h&quot;int main(int argc, char **argv)&#123; ros::init(argc, argv, &quot;Array_pub&quot;); ros::NodeHandle nh; ros::Publisher chatter_pub = nh.advertise&lt;std_msgs::Float32MultiArray&gt;(&quot;chatter&quot;, 1000); ros::Rate loop_rate(10); while (ros::ok()) &#123; std_msgs::Float32MultiArray msg; msg.data.push_back(1.0);//自己写的，可行 msg.data.push_back(2.0); msg.data.push_back(3.0); msg.data.push_back(4.0); chatter_pub.publish(msg); ros::spinOnce(); loop_rate.sleep(); &#125; return 0;&#125;// 订阅#include &quot;ros/ros.h&quot;#include &quot;std_msgs/Float32MultiArray.h&quot;void chatterCallback(const std_msgs::Float32MultiArray::ConstPtr&amp; msg)&#123; ROS_INFO(&quot;I heard: [%f],[%f],[%f],[%f]&quot;, msg-&gt;data.at(0),msg-&gt;data.at(1),msg-&gt;data.at(2),msg-&gt;data.at(3));&#125;int main(int argc, char **argv)&#123; ros::init(argc, argv, &quot;Array_sub&quot;); ros::NodeHandle nh; ros::Subscriber sub = nh.subscribe(&quot;chatter&quot;, 1000, chatterCallback); ros::spin(); return 0;&#125; python实现123456789101112131415161718192021222324#! /usr/bin/python# -*- coding: utf-8 -*-import rospyfrom std_msgs.msg import Float32MultiArraydef talker(): pub_p = rospy.Publisher(&#x27;lefttop_point&#x27;, Float32MultiArray, queue_size=1) rospy.init_node(&#x27;talker&#x27;, anonymous=True) rate = rospy.Rate(10) # 10hz while not rospy.is_shutdown(): array = [521,1314] left_top = Float32MultiArray(data=array) #也可以采用下面的形式赋值 #left_top = Float32MultiArray() #left_top.data = [521,1314] #left_top.label = &#x27;love&#x27; rospy.loginfo(left_top) pub_p.publish(left_top) rate.sleep()if __name__ == &#x27;__main__&#x27;: try: talker() except rospy.ROSInterruptException: pass ROS Publish&#x2F;Subscribe Arrays Example12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// Publish.cpp#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;ros/ros.h&quot;#include &quot;std_msgs/MultiArrayLayout.h&quot;#include &quot;std_msgs/MultiArrayDimension.h&quot;#include &quot;std_msgs/Int32MultiArray.h&quot;int main(int argc, char **argv)&#123; ros::init(argc, argv, &quot;arrayPublisher&quot;); ros::NodeHandle n; ros::Publisher pub = n.advertise&lt;std_msgs::Int32MultiArray&gt;(&quot;array&quot;, 100); while (ros::ok()) &#123; std_msgs::Int32MultiArray array; //Clear array array.data.clear(); //for loop, pushing data in the size of the array for (int i = 0; i &lt; 90; i++) &#123; //assign array a random number between 0 and 255. array.data.push_back(rand() % 255); &#125; //Publish array pub.publish(array); //Let the world know ROS_INFO(&quot;I published something!&quot;); //Do this. ros::spinOnce(); //Added a delay so not to spam sleep(2); &#125;&#125;// Subscribe.cpp#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &quot;ros/ros.h&quot;#include &quot;std_msgs/MultiArrayLayout.h&quot;#include &quot;std_msgs/MultiArrayDimension.h&quot;#include &quot;std_msgs/Int32MultiArray.h&quot;int Arr[90];void arrayCallback(const std_msgs::Int32MultiArray::ConstPtr&amp; array);int main(int argc, char **argv)&#123; ros::init(argc, argv, &quot;arraySubscriber&quot;); ros::NodeHandle n; ros::Subscriber sub3 = n.subscribe(&quot;array&quot;, 100, arrayCallback); ros::spinOnce(); for(j = 1; j &lt; 90; j++) &#123; printf(&quot;%d, &quot;, Arr[j]); &#125; printf(&quot; &quot;); return 0;&#125;void arrayCallback(const std_msgs::Int32MultiArray::ConstPtr&amp; array)&#123; int i = 0; // print all the remaining numbers for(std::vector&lt;int&gt;::const_iterator it = array-&gt;data.begin(); it != array-&gt;data.end(); ++it) &#123; Arr[i] = *it; i++; &#125; return;&#125; std_msgs、geometry_msgs这些直接搜ros wiki，都有用法的。 Ros使用topic发布LaserScan和PointCloud：消息类型：sensor_msgs&#x2F;LaserScan和 sensor_msgs&#x2F;PointCloud跟其他的消息一样，包括tf帧和与时间相关的信息。为了标准化发送这些信息，消息类型Header被用于所有此类消息的一个字段。 Header类型：Header包括是哪个字段。字段seq对应一个标识符，随着消息被发布，它会自动增加。字段stamp存储与数据相关联的时间信息。以激光扫描为例，stamp可能对应每次扫描开始的时间。字段frame_id存储与数据相关联的tf帧信息。以激光扫描为例，它将是激光数据所在帧。 sensor_msgs&#x2F;LaserScan Message：1234567891011121314# 这里有啥就填啥,就相当一个结构体X，然后(X.参数)即可# 测量的激光扫描角度，逆时针为正# 设备坐标帧的0度面向前（沿着X轴方向）#Header headerfloat32 angle_min # scan的开始角度 [弧度]float32 angle_max # scan的结束角度 [弧度]float32 angle_increment # 测量的角度间的距离 [弧度]float32 time_increment # 测量间的时间 [秒]float32 scan_time # 扫描间的时间 [秒]float32 range_min # 最小的测量距离 [米]float32 range_max # 最大的测量距离 [米]float32[] ranges # 测量的距离数据 [米] (注意: 值 &lt; range_min 或 &gt; range_max 应当被丢弃)float32[] intensities # 强度数据 [device-specific units] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;ros/ros.h&gt;#include &lt;sensor_msgs/LaserScan.h&gt;int main(int argc, char** argv)&#123; ros::init(argc, argv, &quot;laser_scan_publisher&quot;); ros::NodeHandle n; ros::Publisher scan_pub = n.advertise&lt;sensor_msgs::LaserScan&gt;(&quot;scan&quot;, 50); unsigned int num_readings = 100; double laser_frequency = 40; double ranges[num_readings]; double intensities[num_readings]; int count = 0; ros::Rate r(1.0); while(n.ok())&#123; //generate some fake data for our laser scan //设置消息的长度，便于填充一些虚拟数据。真正的应用程序将从他们的激光扫描仪中获取数据 for(unsigned int i = 0; i &lt; num_readings; ++i)&#123; ranges[i] = count; intensities[i] = 100 + count; &#125; ros::Time scan_time = ros::Time::now(); //populate the LaserScan message sensor_msgs::LaserScan scan; scan.header.stamp = scan_time; scan.header.frame_id = &quot;laser_frame&quot;; scan.angle_min = -1.57; scan.angle_max = 1.57; scan.angle_increment = 3.14 / num_readings; scan.time_increment = (1 / laser_frequency) / (num_readings); scan.range_min = 0.0; scan.range_max = 100.0; scan.ranges.resize(num_readings); //使用resize设定激光点的多少 scan.intensities.resize(num_readings); //用每秒增加1的值填充虚拟激光数据 for(unsigned int i = 0; i &lt; num_readings; ++i)&#123; scan.ranges[i] = ranges[i]; scan.intensities[i] = intensities[i]; &#125; scan_pub.publish(scan); ++count; r.sleep(); &#125;&#125; sensor_msgs&#x2F;PointCloud Message： 可参考这篇123456#This message holds a collection of 3d points, plus optional additional information about each point.#Each Point32 should be interpreted as a 3d point in the frame given in the headerHeader headergeometry_msgs/Point32[] points #Array of 3d pointsChannelFloat32[] channels #Each channel should have the same number of elements as points array, and the data in each channel should correspond 1:1 with each point 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;ros/ros.h&gt;#include &lt;sensor_msgs/PointCloud.h&gt;int main(int argc, char** argv)&#123; ros::init(argc, argv, &quot;point_cloud_publisher&quot;); ros::NodeHandle n; ros::Publisher cloud_pub = n.advertise&lt;sensor_msgs::PointCloud&gt;(&quot;cloud&quot;, 50); unsigned int num_points = 100; int count = 0; ros::Rate r(1.0); while(n.ok())&#123; sensor_msgs::PointCloud cloud; cloud.header.stamp = ros::Time::now(); cloud.header.frame_id = &quot;sensor_frame&quot;;//填充 PointCloud 消息的头：frame 和 timestamp． cloud.points.resize(num_points);//设置点云的数量． //增加信道 &quot;intensity&quot; 并设置其大小，使与点云数量相匹配． cloud.channels.resize(1); cloud.channels[0].name = &quot;intensities&quot;; cloud.channels[0].values.resize(num_points); //使用虚拟数据填充 PointCloud 消息．同时，使用虚拟数据填充 intensity 信道． for(unsigned int i = 0; i &lt; num_points; ++i)&#123; cloud.points[i].x = 1 + count; cloud.points[i].y = 2 + count; cloud.points[i].z = 3 + count; cloud.channels[0].values[i] = 100 + count; &#125; cloud_pub.publish(cloud); ++count; r.sleep(); &#125;&#125; ros订阅velodyne激光的点云数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import numpy as npimport rospyfrom sensor_msgs.msg import PointCloud2import sensor_msgs.point_cloud2 as pc2import scipy.miscimport osdef point_cloud_2_birdseye(points): x_points = points[:, 0] y_points = points[:, 1] z_points = points[:, 2] f_filt = np.logical_and((x_points &gt; -50), (x_points &lt; 50)) # logical_and（逻辑与） s_filt = np.logical_and((y_points &gt; -50), (y_points &lt; 50)) filter = np.logical_and(f_filt, s_filt) indices = np.argwhere(filter)\t# 筛选符合范围的points # 返回符合filter条件的位置索引，即第几个位置 x_points = x_points[indices] y_points = y_points[indices] z_points = z_points[indices] x_img = (-y_points*10).astype(np.int32)+500 # 转换数组的数据类型 # 点云数据通常是浮点数，而图像数据通常是整数，所以要float映射到int y_img = (-x_points *10).astype(np.int32)+500 pixel_values = np.clip(z_points,-2,2) # numpy.clip(a, a_min, a_max, out=None) # 将数组中的元素限制在-2和2之间，大于2的就使得它等于2，小于-2,的就使得它等于-2 pixel_values = ((pixel_values +2) / 4.0) * 255 im = np.zeros([1001, 1001], dtype=np.uint8) im[y_img, x_img] = pixel_values return imdef callback(lidar): lidar = pc2.read_points(lidar) # 函数 point_cloud2.read_points(data, field_names=(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;), skip_nans=True) # 这个函数返回值是一个generator（python中的生成器，属于Iterator迭代器的一种） points = np.array(list(lidar)) # 如果需要一次获得全部点，可以用list()转换为列表 im = point_cloud_2_birdseye(points) scipy.misc.imsave(&#x27;./lidar.png&#x27;, im)\t# 将数组保存成图像 os._exit(0) # python无错误退出程序def cloud_subscribe(): rospy.init_node(&#x27;cloud_subscribe_node&#x27;) rospy.Subscriber(&quot;/velodyne_points&quot;, PointCloud2, callback) rospy.spin()cloud_subscribe() Ros将回调函数写成类的形式：wiki 上介绍，在ROS中，想在回调函数中发布消息，有两个思路：1、把函数写成类的形式，把需要的一些变量在类中声明为全局变量。【推荐，模块化好】2、在函数中，把回调函数需要调用的变量声明为全局变量。也可以解决这个问题。【不好，不符合面向对象的风格】 下面的例子是在同一个节点中实现订阅一个消息，然后在该消息的回调函数中处理一下这些数据后再发布到另一个topic上。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;ros/ros.h&gt;class SubscribeAndPublish&#123; public: SubscribeAndPublish() &#123; //Topic you want to publish pub_ = n_.advertise&lt;PUBLISHED_MESSAGE_TYPE&gt;(&quot;/published_topic&quot;, 1); //PUBLISHED_MESSAGE_TYPE例如std_msgs::String //Topic you want to subscribe sub_ = n_.subscribe(&quot;/subscribed_topic&quot;, 1, &amp;SubscribeAndPublish::callback, this); //注意这里，和wiki上不一样。&amp;SubscribeAndPublish这个是类名 //之所以用this，是因为第四个参数是一个指向【回调函数所在对象】的指针，官方文档例子里把sub定义在了类外面，我们把sub定义在了类的构造函数里面，所以this就是在实例化对象的时候指向对象的指针。（关于this：当调用成员函数a.volume 时，编译系统就把对象a的起始地址赋给this指针；构造函数：建立对象时自动执行。结合两者，在本例中建立类对象时，自动生成指向本对象的指针。） &#125; //SUBSCRIBED_MESSAGE_TYPE例如std_msgs::String,记得&amp;要保留 void callback(const SUBSCRIBED_MESSAGE_TYPE&amp; input) &#123; PUBLISHED_MESSAGE_TYPE output; //.... do something with the input and generate the output... //output = ... pub_.publish(output); &#125; private: ros::NodeHandle n_; ros::Publisher pub_; ros::Subscriber sub_;&#125;;//End of class SubscribeAndPublishint main(int argc, char **argv)&#123; //Initiate ROS ros::init(argc, argv, &quot;subscribe_and_publish&quot;); //Create an object of class SubscribeAndPublish that will take care of everything SubscribeAndPublish SAPObject; ros::spin(); return 0;&#125;","tags":["ros"],"categories":["机器人"]},{"title":"ROS 之自定义 msg","path":"/921871846.html","content":"代码层级图123456789101112131415|- usbacn_ws |- build |- devel |- src |- CMakeLists.txt |- usbcan_test |- include |- .h* |- lib |- .so* |- msg |- test.msg |- main.cpp |- CmakeLists.txt |- package.xml 步骤1、新建功能包首先创建一个空的package单独存放msg类型（当然也可以在任意的package中自定义msg类型） 这里为便于说明，建立一个名为usbcan_test的包，用于对自定义msg类型的用法举例 12$ cd usbacn_ws/src$ catkin_create_pkg usbcan_test 2、新建msg文件在usbcan_test中创建msg文件夹，在msg文件夹其中新建一个名为test.msg消息类型文件 12345678$ cd usbcan_test$ mkdir msg$ gedit test.msg# 内容如下：std_msgs/Header headerint16 idint16 lenint32[8] data 3、修改package.xml需要message_generation生成C++或Python能使用的代码，即将将.msg文件编译生成.h文件，需要message_runtime提供运行时的支持，所以package.xml中添加以下两句(一般生成的文件中都有了，去注释就行) 1234&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;run_depend&gt;message_runtime&lt;/run_depend&gt;# 或者这一句&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 如果还要ros支持，同样去注释 12&lt;build_depend&gt;roscpp&lt;/build_depend&gt;&lt;exec_depend&gt;roscpp&lt;/exec_depend&gt; 4、修改CMakeLists.txt这个CMakeLists.txt是功能包下的，有几点注意：(1) 首先调用find_package查找依赖的包，必备的有roscpp 、rospy 、message_generation，其他根据具体类型添加，比如上面的msg文件中用到了std_msgs/Header header类型，那么必须查找std_msgs 123456find_package(catkin REQUIRED COMPONENTS roscpp rospy std_msgs message_generation) (2) 然后是add_message_files，指定msg文件 1234add_message_files( FILES test.msg) (3) 然后是generate_messages，指定生成消息文件时的依赖项，比如上面嵌套了其他消息类型std_msgs，那么必须注明 12345# generate_messages必须在catkin_package前面generate_messages( DEPENDENCIES std_msgs) (4) 然后是catkin_package设置运行依赖 123456catkin_package(# INCLUDE_DIRS include LIBRARIES usbcan_test CATKIN_DEPENDS roscpp message_runtime DEPENDS system_lib) 到这里新的msg类型usbcan_test/test就可以使用了，下面编译这个包，然后利用rosmsg show指令查看 12345678910$ cd catkin_ws$ catkin_make$ rosmsg show usbcan_test/teststd_msgs/Header header uint32 seq time stamp string frame_idint16 idint16 lenint32[8] data 5、调用自定义msg类型如果是在usbcan_test包内的节点中调用usbcan_test/test类型，只需要在.cpp文件中如下调用即可 1234#include &quot;usbcan_test/test.h&quot;usbcan_test::test msg;// (usbcan_test文件夹)::(test.msg) (随便一个名称) 然后修改CMakeLists.txt 123456789101112# add_executable($&#123;PROJECT_NAME&#125;_node src/usbcan_test_node.cpp)add_executable(cantest /home/fu/usbcan_ws/src/usbcan_test/main.cpp)# add_dependencies($&#123;PROJECT_NAME&#125; $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)# 这个PROJECT_NAME就是你到时rosrun的节点名add_dependencies(cantest $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)# 动态库依赖(如果需要的话)target_link_libraries(cantest $&#123;catkin_LIBRARIES&#125; /usr/lib/libECanVci.so /usr/lib/libusb.so /usr/lib/libusb-1.0.so) 因为还用到include文件夹里的头文件，所以CMakeLists.txt要去注释 1234include_directories( include $&#123;catkin_INCLUDE_DIRS&#125;) 6、其他包调用自定义msg类型如果是在其他包调用usbcan_test/test类型则需要修改package.xml和CMakeLists.txt，比如同样在工作空间usbacn_ws内有一个名为test的包，我们可以在这个包内写一个节点，使用我们刚才自定义的消息类型usbcan_test/test，如下： (1) 修改package.xml 养成好习惯，维护软件包清单的更新，以便于别人使用你的软件前安装各种依赖项，当然这个文件不影响程序编译 12345&lt;build_depend&gt;roscpp&lt;/build_depend&gt;&lt;run_depend&gt;roscpp&lt;/run_depend&gt;&lt;build_depend&gt;usbcan_test&lt;/build_depend&gt;&lt;run_depend&gt;usbcan_test&lt;/run_depend&gt; (2) 修改CMakeLists.txt调用自定义消息类型主要修改两个地方，以下是重点： 一是find_package中需要声明查找包含该消息类型的包； 二是add_dependencies要注明该消息的依赖，其他地方和普通节点一样 12345678find_package(catkin REQUIRED COMPONENTS roscpp rospy message_generation usbcan_test)add_dependencies(test1 usbcan_test_gencpp)#调用同一工作空间的自定义消息类型时注明依赖关系，防止发生头文件找不到的报错 完整工程参考","tags":["ros"],"categories":["机器人"]},{"title":"ROS 之工作空间","path":"/1309878189.html","content":"ROS创建功能包12$ cd %TOP_DIR_YOUR_CATKIN_WS%/src$ catkin_create_pkg robot_setup_tf roscpp tf geometry_msgs TF变换(参考)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// tf_broadcaster.cpp#include &lt;ros/ros.h&gt;#include &lt;tf/transform_broadcaster.h&gt;int main(int argc, char** argv)&#123; ros::init(argc, argv, &quot;robot_tf_publisher&quot;); ros::NodeHandle n; ros::Rate r(100); tf::TransformBroadcaster broadcaster; //创建一个tf::TransformBroadcaster类的实例，用来广播 base_link → base_laser的变换关系 while(n.ok())&#123; broadcaster.sendTransform( tf::StampedTransform( tf::Transform(tf::Quaternion(0, 0, 0, 1), tf::Vector3(0.1, 0.0, 0.2)), ros::Time::now(),&quot;base_link&quot;, &quot;base_laser&quot;));//Quaternion四元数来存储旋转变换的参数,第二个参数是坐标的位移变换,第三个参数是时间戳,第四个参数是母节点存储的参考系，即base_link，最后一个参数是子节点存储的参考系，即base_laser r.sleep(); &#125;&#125;// tf_listener.cpp#include &lt;ros/ros.h&gt;#include &lt;geometry_msgs/PointStamped.h&gt;#include &lt;tf/transform_listener.h&gt;//一个TransformListener对象自动订阅了ROS变换消息话题和管理所有的进入的转换数据void transformPoint(const tf::TransformListener&amp; listener)&#123; //创建一个函数，给定TransformListener，在“base_laser”坐标系中取一个点，并将其转换为“base_link”坐标系 geometry_msgs::PointStamped laser_point;//创建一个点作为geometry_msgs::PointStamped,这里“Stamped”只是意味着它包含一个头，允许我们将时间戳和frame_id与消息相关联 laser_point.header.frame_id = &quot;base_laser&quot;;//因为我们在“base_laser”坐标系中创建一个点 //we&#x27;ll just use the most recent transform available for our simple example laser_point.header.stamp = ros::Time(); //just an arbitrary point in space laser_point.point.x = 1.0; laser_point.point.y = 0.2; laser_point.point.z = 0.0; try&#123; geometry_msgs::PointStamped base_point; listener.transformPoint(&quot;base_link&quot;, laser_point, base_point);//参数为我们想要将点转换为的坐标系的名称,我们正在转换的点,存储变换点 //TransformListener对象d transformPoint()函数就是用来变换的 ROS_INFO(&quot;base_laser: (%.2f, %.2f. %.2f) -----&gt; base_link: (%.2f, %.2f, %.2f) at time %.2f&quot;, laser_point.point.x, laser_point.point.y, laser_point.point.z, base_point.point.x, base_point.point.y, base_point.point.z, base_point.header.stamp.toSec()); &#125; catch(tf::TransformException&amp; ex)&#123; ROS_ERROR(&quot;Received an exception trying to transform a point from \\&quot;base_laser\\&quot; to \\&quot;base_link\\&quot;: %s&quot;, ex.what()); &#125;//打印错误&#125;int main(int argc, char** argv)&#123; ros::init(argc, argv, &quot;robot_tf_listener&quot;); ros::NodeHandle n; tf::TransformListener listener(ros::Duration(10)); //we&#x27;ll transform a point once every second ros::Timer timer = n.createTimer(ros::Duration(1.0), boost::bind(&amp;transformPoint, boost::ref(listener))); ros::spin();&#125; rviz(参考)joint_state_publisher包1sudo apt-get install ros-kinetic-joint-state-publisher 在launch文件里加入下面这句，用来描述机器人各个关节状态的主题 1&lt;node name=&quot;joint_state_publisher&quot; pkg=&quot;learning_urdf&quot; type=&quot;joint_state_publisher&quot; /&gt; robot_state_publisher包1sudo apt-get install ros-kinetic-robot-state-publisher 在launch文件里加入下面这句，用来加载robot状态发布节点 1&lt;node name=&quot;robot_state_publisher&quot; pkg=&quot;robot_state_publisher&quot; type=&quot;state_publisher&quot; /&gt; “robot_state_publisher”就是一个tf广播器， 它是一个C++的程序，订阅了”joint_states”主题，计算各个坐标系之间的变换关系，并将之广播出去 主题的发布者只有joint_state_publisher，订阅者是robot_state_publisher。 保存地图1rosrun map_server map_saver -f map(地图名称)","tags":["ros"],"categories":["机器人"]},{"title":"ROS 之坐标系理解","path":"/3018098590.html","content":"### 地理坐标系 北东地。北为X轴、东为Y轴、地为Z轴。 地面坐标系（earth-surface inertial reference frame）①在地面上选一点Og②使xg轴在水平面内并指向某一方向③zg轴垂直于地面并指向地心④yg轴在水平面内垂直于xg轴，其指向按右手定则确定 机体坐标系(Aircraft-body coordinate frame)①原点O取在飞机质心处，坐标系与飞机固连②x轴在飞机对称平面内并平行于飞机的设计轴线指向机头③y轴垂直于飞机对称平面指向机身右方④z轴在飞机对称平面内，与x轴垂直并指向机身下方 姿态角（Euler角）：机体坐标系与地面坐标系的关系是三个Euler角：yaw，pitch，roll，反应了飞机相对地面的姿态。我的理解是，roll角是Zb在ZOY平面与Z轴的夹角。pitch角是Zb在ZOX平面与Z轴的夹角。yaw角是Xb在XOY平面与X轴的夹角。 roll（横滚角）ϕ：飞机对称平面与通过飞机机体纵轴的铅垂平面间的夹角，右滚为正；pitch（俯仰角）θ：机体轴与地平面（水平面 ）之间的夹角，飞机抬头为正；yaw（偏航角）ψ：机体轴在水平面上的投影与地轴之间的夹角，以机头右偏为正。 旋转矩阵：地理坐标系到机体坐标系的转换矩阵。旋转矩阵为正交阵，逆即转置。 传感器：都是基于机体坐标系的。加速度计测三轴的加速度，磁力计测三轴的磁感应强度，陀螺仪测三轴的角速度。注意角速度的定义，方向是沿着三轴的。得到姿态角主要靠陀螺仪测得的角速度积分，但存在漂移误差，因此要用加速度计和磁力计随时校正。 很重要的：在地理坐标系下，重力加速度坐标始终为（0,0,1g），磁场坐标为（M,0,D）。在地球表面，磁场始终是沿着磁感应线指北的，某点的磁场强度为磁感应线在该点的切线，它在北方有个分量，在垂直方向有个分量，在Y轴是没有分量的，即（M,0，D）。这里还有一点，地理的北极和磁场的北极是不重合的，有一定的夹角，即磁偏角。根据经纬度是可以查到这个夹角的大小的。我们定义的地理坐标系的北当然是地理的北。但用磁力计求得实际是Xb与地磁的北的夹角，我们最后会加上磁偏角，这样就是Xb与地理北的夹角了，就是真正的航向角啦。 惯性坐标系地心惯性坐标系（earth-centered inertial frame, ECI）","tags":["ros"],"categories":["机器人"]},{"title":"about","path":"/about/index.html","content":"Hey there! I'm YOLO. 👨🏻‍💻 &nbsp;About Me 🤔 Exploring new technologies and developing software solutions. 🎓 Studying Electronic Information Engineering at University of Shantou. 💼 Working as a Test Engineer at Automotive OEMs. 🌱 Learning more about Autopilot System and Artificial Intelligence. ✍️ Pursuing Graphic Design and Blog Writing as hobbies and side hustles. 🛠 &nbsp;Tech Stack 💻 &nbsp; 🌐 &nbsp; 🛢 &nbsp; ⚙️ &nbsp; 🔧 &nbsp; 🖥 &nbsp;"},{"title":"哔哔","path":"/bb/index.html","content":""},{"path":"/css/custom.css","content":"/* 隐藏文章内容页面的文章修改时间 */ :root { --post-update-datetime: none; }"},{"title":"友链","path":"/friends/index.html","content":"如何互关友链 互关原则 先友后链：与 felicx 有至少半年的有效互动，例如 issue 或者评论留言。 安全合规：合法网站，非纯搬运，非盈利，无木马植入的站点。 有效网站：网站内发布至少五篇原创文章，内容题材不限。 其他原则：若您的网站长期不更新、存在广告等情况，可能会暂时下架。 互关方法 我已满足全部条件，快告诉我如何交换友链！第一步：新建 Issue新建 GitHub Issue 按照模板格式填写并提交。为了提高图片加载速度，建议优化头像：打开 压缩图 上传自己的头像，将图片尺寸调整到 144px 后下载。将压缩后的图片上传到 去不图床 或者其它稳定的图床并使用此图片链接作为头像。第二步：添加友链并等待管理员审核请添加本站到您的友链中：1234title: YOLOのBLOGurl: https://blog.felicx.eu.orgavatar: https://blog.felicx.eu.org/assets/icon/20240713_rtEVzmVj.webpdescription: You Only Live Once!待管理员审核通过，添加了 active 标签后，回来刷新即可生效。如果您需要更新自己的友链，请直接修改 issue 内容，大约 3 分钟内生效，无需等待博客重新部署。"},{"title":"links","path":"/links/index.html","content":".links-content{margin-top:1rem}.link-navigation::after{content:\" \";display:block;clear:both}.card{width:130px;font-size:1rem;padding:0;border-radius:4px;transition-duration:.15s;margin-bottom:1rem;display:block;float:left;box-shadow:0 2px 6px 0 rgba(0,0,0,.12);background:#f5f5f5}.card{margin-left:16px}@media(max-width:567px){.card{margin-left:16px;width:calc((100% - 16px)/2)}.card:nth-child(2n+1){margin-left:0}.card:not(:nth-child(2n+1)){margin-left:16px}}@media(min-width:567px){.card{margin-left:16px;width:calc((100% - 32px)/3)}.card:nth-child(3n+1){margin-left:0}.card:not(:nth-child(3n+1)){margin-left:16px}}@media(min-width:768px){.card{margin-left:16px;width:calc((100% - 48px)/4)}.card:nth-child(4n+1){margin-left:0}.card:not(:nth-child(4n+1)){margin-left:16px}}@media(min-width:1200px){.card{margin-left:16px;width:calc((100% - 64px)/5)}.card:nth-child(5n+1){margin-left:0}.card:not(:nth-child(5n+1)){margin-left:16px}}.card:hover{transform:scale(1.1);box-shadow:0 2px 6px 0 rgba(0,0,0,.12),0 0 6px 0 rgba(0,0,0,.04)}.card .thumb{width:100%;height:0;padding-bottom:100%;background-size:100% 100%!important}.posts-expand .post-body img{margin:0;padding:0;border:0}.card .card-header{display:block;text-align:center;padding:1rem .25rem;font-weight:500;color:#333;white-space:normal}.card .card-header a{font-style:normal;color:#5073b8;font-weight:700;text-decoration:none;border:0}.card .card-header a:hover{color:#5073b8;text-decoration:none;border:0} 留言添加友链 名称：YOLOのBLOG 地址：https://blog.felicx.eu.org 描述：You Only Live Once! 图标：https://FelicxFoster.github.io/picx-images-hosting/Icon/head_icon.1jj4q1n854f4.webp"},{"title":"FriendCircle","path":"/friends/rss/index.html","content":""}]
[{"title":"2023年度总结","url":"/3216805600.html","content":"\n  48c57c7f2155863d1867bc0a82ac3f8a0b12c7da81c0ae704e5f26b92a75ac218a295d1772c261f740a2e3091d5c35601ef08dc111850650a9baf548ee558a7188a29b9fb89db5baec04dcb0cfe0f2bed99f53868dfe52381066bb27dd6fe92f4a22de3b715dd45c77af46666a36086e640d02a356373bae76e53bf872e5e0e2745cf8c506e4e4b9f544dced3b400b481f5e6961e7b2f4143dad9a6f812e287dc883c00b2fbcb5f610d6eef6269767c8ca3d87aa6ee05a6b28d37d49c5bf52aa0fe70231fbfe42bfe5e42821afdd332836aec5c89871f5747a32962959c884b790b0e9c4e5416fa8b7b7d8335d8b31a08c55c6beb6076c219c38b9848a472d948aca3527ed3b3e26deec63744a386bd33489f11bebb400baeb7b563f2cc212ec94f00773a56db25ad950d92081079de0896ef293186e348b8f67ef1230522e29630782defe3fe8d9b0d62f43efd0a49e403e9bdf7c5d8f91473e39378053bb2b106c34c70a6cb3948c04dd7a2b16b26f097145cfdd4bccb3e4ac5d7352ccd4444d022bf9777f37563da0170c3ade9b5c7e37d623f122605e61a720100c348f9f20b1efdc921c99edf77f792170dbfcd25a43a3e1230e82f86559710b295a6b2ec251e633ab0bc4142a083d815661170f015806918c91a708cb97fb4cf9107dd5d478cefad4b05638754f1822b002ceaa86dadd246b256d44e87a1e880358c00f540ad657edc246e0666a4f54ef4b29b609d8a004b7601473ba2016b909f2a3c4a5ddf64ce5e305b8f2804b4c84e967599f9f1df43b33a5cb77b65a2d7d6e1e0872693a2e4b9660915f07def627f2e2df43fb62655650ccfc940519e5a3ad1d06d6074bf5022457820a49d4b3ba701fa57430e57e161599bb29d6fa886cd308bae3e5117d585a14ccfcfe2f9ce9911b17ed418700c7c1bed4e3197c3bc62e08052101a74343d288ec7d9ea2569cbc4389d1abb2366b759ea3e7baafc90de5bac96c1523e119c31d43d819d63861a3cc4efac7acfd03fa6b1e02ec4f8e7612a96e049d903a427e0567b7840f906bd3772991dc82a6942de2fc86f26966467ed961550807a49827d9b5c8d510c4697dce8c4e71e44fc80c51bd355300bda7307bb5b6e76d2c75e90ebca4e880d0bec38ccf2c8f58d1ec11afa9a0bc6bd28b5bc5f530c25f225961cafb44b1ac7b69a0d15d464fb37815f320ff7d8b26ed602782540e7f2fdd22fea216cb62186d13a455554a2e29acabb469a0c55842f61c8e1c787b65d2df8e459457a1371f33f5b9e9c2090fa707f0eb1926d822d4dde55fc0f060c77a73e731cb60e3754abf1a26079befcfbecb96bef610379fd4e5795c214853781e4a59bb9d98dc45ab7a1fcd37088ca0aa770d3d4db521279e6fc8a832d80dc6a2097a0a7f65c6631b3970761ab8c7615e0fa0e6f7a3fb1feb03ecb6cc20de8c5be9f695e975c2777503da0340b56e5c738986ddd8191ea813e2960a0e12ae377350537a624440a0a968b89ea3d16ad72bbd32ef7e0a4ff7089dfa41d689431faf5f581a3a2640ac0706d42e2aacf15308d16b9a52729ec10560a2f3b9aba88f6ecc8319b182040ee9316f610f385643f86604176e979c20be767a9e88e3aae95e6b7406c6fc497acdcc4e9b745d6103d781c07051679579f47785857fb2d060c885efbe555915120c8bd0e44f4302224539b7137e42d376f676790e781374f920d0b9d0a08ca67120714258c998fe7d7df3c139452c4153c06ccc1a7fe3cb2ac3c4abb1de4f08ca8416918669723bf97b857762329b4aa3672aba6cebb8c3c4c56cb70327b3064d0abc7794b74176eb627948bce7207cc341eb1f8b4e55e6e4ae68a502982643435aff8f4cfcb67f756ffa5c42f6f018a999f9717eae66684b6ab6502aeb0e2c7b8af27aea396565adac192959184bbd33d52430db7a0ed0585c8f47bf0e66fbd211b3cfe68d10910685966898a02ad626fad263cf0b0c580499b2b657cc10eb2c02e84757004928d50c17fcfd798a3dd06e523fe2aa912c40d4c8acb4bea31f186651306d6091f07c7d06961cc3317d80e9eedb3cb4f77b2eac5ee938e8a885bd5b2a2f9422fb2461d34cd21a7a820b324538c0e1cbf96706bb6e1ed18765f73c4dec683aa542aa596ef131fc9c0abd61f1ea350164acc9a19a52ff18bf81da5e27daaf4512cbe6f7a5555fc3ca0037b5dd820fcc4b1fa52ca3bbc25c490e5e69a2e02d1ff60dc9e45778736107ddd5957775438090e2a053e0299803be6911cc55a103878cdb7385c7dcff83b32a81dbadcb7242afdfecbc112001276a5eba573c814cd7c3689520ecf983e4204a3cebae7db37d7acfa6ed14917966b67ebd377e76722dfe2ee322c604aa4ae5c50c1995774601e51562bb662a70977306f15921bafea1857bbbd315a612227a8624131894b14b4cf315f677eb746fd64d3001e09f3279b34330a606cbd65c1d4dc8c81c90e3f1b395fc6423c042ae5da5cca27bca97f0fe723c9c3a595df9eb3d23aa1c412bbf1a65e4fd4654c0ff15c7ff36a8a11770f098e156774cff9095f0ee241e7a3ed9f1d87ad8f27d0262d397af938a97bf834bb750049474e3534fd8bd74e1ef8be2d349826c2d99d8010c10ebabbb8d4c446e53eebb2fe4aa79888d996475750e9760c086791b476ceb540b6f844dd7afe4ae53bc541b732bb2ade642710a8e0d16901256a5d40525e4deee5671d1764abf5b96bec0cf49b5c561a10b605ad36d5fd7b74d8fe0f93c1d22bcc99a00d98dadfd405e9cf8f34b17397d4ebec01b052616151fdd5768e1cdf6cbc78c09c948aae066f0f54984c3a8d92efd496eabd8230f50637d151af1ed730380e71aded07c4aafa92ffcd19118b4a1854791f9653616bc48524317ce4c7fd665733c3fffb44bd3b1231063444bf2731b28df66d0884de7633ad25624c419b3bf5c93a1ba2d84998cf11c7147255faa6e709dbdd092a99066040bcc1efb24267c3e94d4e5336bf748c99ea38276753c6a3ae1e56305249e84dc0de0bfb872b8d7911d25783f5571888fe4f45454be593f22867e2360905988e08c255e20c17ba882097a3fdc07ef8acdd3ff7c304fa653a576f8f122e04faa59926a909bcb882970a498903f9f5d6aaaa4c4db16f3945a1cb8550a23d22e2750ba0d5ac99d8482fff637688f8b87450903ec1cc8d6bb740826b2fdc482bb0f71be727421b616c172e8f71e6e676b2f106ffcefd5309a6f2a3b44e7c8dd5a836db014a382227436bc3ac7963eb0da9399f142a734f19d8fddc9b9f5296655561265412e0ec75dcd8abb53d8b2147197a3ce67dd6edaf4bf545e793f3843be7fdfd00c3268a216273e45c27e1f37e6d3a8040f41ea32afbe5e2423ff343acf6b0cffefa6772a3350cf49739ccaf08d01f375524de6ef8ee636e289fad2361a63bea9c9c9703073efde52d704d2a0702d59a0c4df8a4e370ae27d9a35d84d58d8965283bed4562572b765dc20c938d3a5b4ba6250f0ad909f750c53ccc5096db581da6039135b356ae621fd07663c8de0fdfe9dad31a0d672448e5e7525a4438310d59fcb3716e747189a2fe9c19cacdda6a448d721b19ab02235143560acca18aad205f07a3aa7ad2ea1cf3a89053c7a612375eedf37a07ae44edce3489da5fea033bcea759b07a59c94bd3e9ed2e09172a2ac521be39bf6b8c74b62f15decae5f23584890d5a8fbb07cd6b9db0d680581c47f9b624444fb19c67f7ef52b93c21f370922d4b4aead1663392f2e5e5e2c95db5e5e4a2032c3f9a76df0233f38b1ae84345c55170a64ea2de4560c4825deccae53324da5e600b8596543863085f0a33668520f3079a08baf7268d79b6bf05f86152fe8be189745f405c5f85cda55400322d7726e837e2461c74a856e90d82815802c542b99afb76a00750dda470994283302dd7efa0f6bcbb5bdbde94387cd135ea582fbeac02055bbcda15e6d522f7b3a0cc37a96bd5240ff8d31a8aeef17b2577978bfb4fd05e4e3db181011a2e4660b1c464ff0c6a4e00d437626520b6cf276710f0e35962fbf942735a1574df2dc8b8f4cf5843417a2752602611dc99fe0fc16bb3730e0b05de6c2971face7b762fbf48e691eaa45fa7e2d872318c34dd6a1665466c81fd8172e7106e153f1bd6416c0574c2075ef7eb3da13f99a870500300f701078feb5e5454263b6d8aaa19861e4876a204b4b95ea9ac0ab3a4cd0407402bbbcef95d146c7b7bb4ddeb6ad9bc3afb748566ca1fb6451d52c562f73aecfd876aceb14697118ee94536f7e3483350fba006e4a807b662a3d7c568d1b6a12ee2a5e1424c7d9df98aedf2398a40b626624fefbe2e764d4cbc3ba14aa96efe687d9ac7d9183b942070edf3cc85fe8e125f86b8c62fd272ba734f787221fb6c925920f0a30027a4e6d437ca8707778a357061f16d8a38e95b79a87ba94d494e6a94cd2ad2bb6e7ef35c0d64c9e234e84f134957b8a2bb2a44ddd7f26aca4f8c35602fe366def6a6663844edb1e60fea993dca057f79bdddd04843b5ffdd89ed625fbf59bc8cfa4460a9b28ab3da9a3f4975286b0a32e33a1dd0ba19bd8b358ad06b8b80907e4e494873348480a1ae46003ec13e9de548a4603ca0795f08bbe5f523e2bbbf8e6d41dd574da55bf7c1e2cc46f371523632ff7ab6f9824853685315e63c17faf7ba77194332414e857d3297b5a4579efcd9ba67d5977d36a7ceb04cb3cc86adde00edb4ea67bcfa21d9fe605879ec355681de1b7a608574b1458a60806e22538f83c7f66180868652d748363bcf10c615d916e6987212d4226b3b7d4c5dfa3f81284bbe49a77a5a7ef68cb21c61bc9f506a402f2df8d6d58428f291db248f385ea60326fe3bf3cbf02ab4ea14661a0a51198823a097bd9e2f88d28e623981df4ac78501c3dbce24f8a4cf261f6b230962698aae3ff7f2544e2c1b986e37330528ba6547cc7d2101b18ac797a17f1a7205b17b0db69bd728633454f4eb6d05bf7e782ae260ab338cca3c2e9d9fd38ae3b14db2ba01821c268fdee81deb306a50a2ca4539a9a32dfa0aacce87d4935ffce9b6df042f7f152f26e976894bcd801cbcf00cb9f0e50c28b96ba051fd184bd421f04a646360781b6583b99e5fd66bf09f898752436e23867b13ef8c68a165cd25a83be7899e9f87cd2cdd6e5b262dc73b1d6e449cac7def777acd10c15d225a4d7bd5bfc07e518e034f3915155f48faa75a9cc61d7d0ac9c00f5185491419709cc225ee2f49b3d9385b65b90077f822fa6f0f066d1c2766f913c5780a892c4b02f22a79d420c14a03942be8501cfe3b3db8a8f1d5a1c8a26659737227c7bca91a0655dca02deb7d71eef54b97e1322e08b6bd4ebc52e6d835eea78efb716f367ca04fec56e096463b0374dfb9f7a035696fadb62467a887c261ad7d0601a0cc9a9707599fcaf84bb1ebd396d2a87e9cef2bd04353f30a7ae87af4cfd1ac98ce49f9947f540aa23b46c5d564f6eb903192fa8734825e4327c975ddadfabc80d835dae9f9d6d17890e9745d0fdb6fe96e2872bb646b6f1e0246d8863cef646b52d687800c261c015b533944f4e9534a747ae6f37fbf521c69330e7971ffdd635177cfb88806730ca54886f1239cde7cfcf9e1c6cf136b0a04e53ce6bb9fea3c4ef658f3805de241c4643879e1de2f8f03b68a7a335ff8fc78f25dee1df51d91a71c180802684dc858e6fa9896f7ab7b7dbad19098947aa8746b44d7f2873e5f06f5d90201770f69e0b24d03f1c5de2f30aacba71e047e3720ef84a15e4252f96f3271b5d126cdf568db239e180c35a920618b09fe972b9e4c4b17bca4f6fce0dab96204deddfa0a5a97ac218b5c987d4b5698e3aabaa9dda72da689e1fd6120808bddcc98ebb0fb525e70f975564d6ab06b5e084bd68dbecea0e3b7d4d114796e0c77bcf7fb946c44da2ea18d0da9800b74070ff621b2a3d3e573cc0d386f20ad076f52b2d2f78245f7030fb3d8aa6678f71d7318c61efbb960b70e85f827a18058845f6f919e48bd4dea9dd4683852cccbd0b66cedb1a1aaddc61d069243702348efd709deae3c21801b1f12dc34cafd0fd2a11a30f294ac83a06364090a93e20ada689fcd1e228bf209651a1e4da6ad5fdc585836870c73097eecb9ebb84fe901ebbb12020140dd01df1b7ba822b2ae443167f6deefcf7fa199d00da265b4488ce230d8ae4c45ea80181c5eba8504b72188ef632be73c85b9699853f5a4294e02ce6585512b09d754dda859fd49d098e3c8d13232eb3da0622540dde83aa6e5e63a01b366776c86e5977edcddd04bce2c281066ebfc56ca2e067b0d215c85a169a88f750e592ca891ecd0509cc09c09874494b6cf2bf5427467ecb154989a244bc4748ed7a55be132b8b2f103cc8f88afaaa01cc1aab8d265c90e50a58c92c8072480ee6b173a7d93280dc1f45175e6534984bbc5a464d19950945d7f8a6c4ac6e9f8a7fa07b02cf3b3830320c1f03876472e4403e915c8ad3a16cdf0c0e2b45b93a2fe1c3c0882bea5150c908cf484311cc52df7d353968c4e9d7e009198dd023a69da77c17b62eeaa4dadffc3202b1eb08d863dbe56be63c03bf2454c189e3a7d8f39ba316a41f889d22c7138fd26c48df383ea350d38f70ebf98ce2d34130ff1e2a4747265209bef49e67fa70ef826db64aabc9be622342ea100859035b38882a1c420cbdb7fd48f6a8158b57dd0a8a856c19ddbee72195ca8d62771408a724317d34c59b58c04fbb42da38dfb7922f3a0ed3db2da67e501c5020079cc3a5b3596248bc010349ec4b05833425e24bdcf5f0a37716c0300761175701559eea83e900c9283f89bca99d804acfef61da94a1a36773b04eaac1d0c2e8b292c704fb066ed19643ca5e91191c6a318b6c342e847a8e3cdff117d8dbfc6eb4662a008c526b1562be5cd983e90e7285754795879a21b2b26df2baef7adfce3ba4abd45dfa16b18f61d298e9ba74f3343b750ca78cc087886920c90513fa2612722f37fb77faf2a322844893d3daae229bc90fb03dd99b817f87f5469617550a15889f22c2805110cd2d6aada09d21dda952df7025f0ac23999c0b6801fd7ff79998569949f44050327072750f6b9eca15740e8b1d2ae3b084a1754c3f13dfd428ac5852e151dcf086cf948415dc88789987f41ae324d970f31c6864aca2063ffa29fc3111fbdc3dffb025651116edb21ef8e22af469db93b42584a8e71e5fdacfe9ad57cf6259dee4960d3006f1d1f70254934096cbfae94e3a0411f8a3adde3baac8d305d2d692de4a22dc57f3d0ec05486cbcb6769bad8e5acc82cefc0a2051943fadc3013dc609c49eeb9c7300be3837c3addc832c09284522b5a692fea0e92c11b2abab04cc0b9935177bfbcba44ac03192f7457859d6f5164a4380138fa3cdbab4c72cd10e8bf9e3b276e4d538de51643f24d2bd0bec2438fe2d0a575de695edeff5832198a15d31b32420a92542963105dc2c2366d57546e257bf9d2ed7ee47aab15f0e8c627f133bd33bf2081c6ba9026b67edc814d4adc2bc1fb6056a1fbc1407b3654ac568dbf274cdf5ade98041ef5f2a0a8680c8a14f7b482785e10a6d8c2ca3ac4caa8675023eb0a17450cb608e2974cddf920ea1823b077f9b9653af0f0826a8db7759ba6c465d86852a41aa4673a099ccd7196091f2cdfd42c7c8772460a75f1aee7e530f1cfd8faf8755c2d995631e883376c4f74c5da2e33fea2619b63f8aebc509fd114a762c551ccb6e80acab7c485f6f1efd99f177fbff22799e59d31ef989bd18d40df87c7c377cb5d2157d6f2355da82c4c00a7b72d02bed52e4e1b8eca6d73a985aa9d738b9c43d2e32be290505c82b66187fae4e98f4116615117340a0051211cabde0256fe81d11c6e481b90a368b12bfa9da7908e1f615ceb061d2b8058bb7899b8d139a27d2fa6b5172e66db31ae99b51af942bad379a1830cbde534750639956f7d62798b89903d49f776f1126224b0c30232ae106ec74ffa40c57cea68d1892f82af353231ee7aeda1f82b83fb600efae5dfcda2baca195286ce4e4c3e74f910e9cfb0778e65db832f568dba7a0330a848bd5c742c50eb9541c4bf41f968db0e1cf879b350973684d5c8332c600915d9d4a961237f62d323dbea272220876388b1029cb6838b9c80f949b79ab8d8caa3783f3323de6630c27628b9cf3519f0b03e17351ee671d8b2d2d48cd653115d26a14f9689b0653fda1acc0fd386787300d2e0e83b3312da10db88a3c33716ebc1fb519f724a7b1f213ce8091921b31fe82c25fd68a55f4622e5d79d5c6806891980f57e123a1a75dc9728730696ecfc8fdbf2c289f2f0dd64dd8ef2d8be5f1a824fd1563b1927cb26b948c8a8cfea497904426d0204d30dbfeb421161086f2fd98a26a32306e9c32635226220ecfcb5abb431c31a79fab25f84299ac3bc429760913abc7a7387f27a935df34758d5ce101be334e4c180aa3f5999837c61d1c8dc5ab06138cf811ea86a2dcbfd696ae0dc8d0fd8d6f9a49c325cc28d6148b44e67365c6de5d42f315fc383cc4312f08208a2a54e1eab7dd976523fabd93e96c99cd1dbd0631291da2c8e0b528209f98b8226dcfcc37cdebba2f5679f934d623099edb221c3974119b4b5cedd8edbc6091738b9d728bfdb6e98b082408f74f60924f89741577626e3b5fa0abff83ffebe79223272d19bb178f10258d78dfae822e12e8d128931dac3e58c41389cb0c4a2bac220f1cce529320a8c292b110296cd0f9fc0cfe946aff71020bcf2d2b3a578ba7755d9f1238ca8959c4af124a12f9d14e5c88d8142c6e39cdb59b732defc6f414ad5b0402ef3fca10e353ab220bd7e661d5a3ccea73389f65ca8e95e4607e2ee41261b46b1e02718b2624ab12f7eda1a0d149cd890a27a418b4dd229cae7571982d3dc1ee3b5081b22588ea1f205db4d3885e487af7da7f838ea21fc05bec1589197328856ee535098cd3f2e0b033aab26e938d53e323760592eafa1ec6e0c198a435b5ca538998eec594c3178dd5df634fa1ab583e83dc063a8f94342c4548c6198bfa7b7a7310594c2b966675f1ea4175a1aaeb24602942aff2b8f9f41fe965461da455318243da019009e80984daf2d2f2686fc9de6a99d0eef3b2d67c36c556d90ae15cf30bc5d5598925d00fd16374cbf87daf59de34849fa2122b54067b33eb78b2a7c14ccf2c10249cfaeba93b06b1d0bcea247f9cd8f4bfe944e92a985eca104ea7025b6eaef53f400ebaaccdadd02f6c88feddbbd7ac6f8afa5b6919a267d735c6f47dfa7fb1faf6d7efb442bc1f7c0dc22b45f72a686e5961da300afa458a463f2ea133e7efea0595c26554d36c8048992b9d8bf724378e29c124e56d796226f8a70eedf0328b962eca602f231af527566b6cc7b080d2eb6ce9f590690f2ff91060692560645a4b1c239487e07fe7e46f7d3ba1c67b4cb8738829fd497a67b669ca15ed91481182004b713f75ae79160b72f1ad19646d5ccbbb0b068251de561512e1047331c9b1df40e428a2de9743a61b4489b41379ed14883a4f1939f833e25fa601aceada3abe3ee465e9e551baf89e89c846906b1b3585b5445f8ed148c0db20379203f12d08a728a4fa2c74d5a9f3607599855261d98b55b11651651c2a8d5883793279632366a9afbe8fe45d9197cb4271b227fb452fddc7f84f55bf7eb97a9cc13a40d9e4a271a0c2a4f8de0d413e7c165f75554abcb64c438eb7146323db401011d72c6ba57c6feba201a6436eb38873ec2bb4acd4c26439720d653d9c3c16a671227d10ab6f941087d55b597365f9a6e97ecb8256010639744b6a531f766d86e7d2b627cf5de5b4bf22afd2c8e822ac7c31816eb22b8514f97c594b65508204357160f9ab9f0b60d9ca484164c72c1dae2c4a88f2ceb5d163c41c7241d8766f9d85585471a19a1b7a04b7f827c08513cda1aee38c38184cabafa40a9d0a2e3316c03e60e0151c980ae0305adbdf21e2f0e3df2fcb38b41ae077ef5da98ac11f4e0d613f4c9659e93d9b10e786d8235c6c0c72a77adf3c1384abbc772d86afdb4ff7ead6f37719603eed88e1111f974cddd17616650068f1d6e1a210b2ff0ea7127d527abe693f708cd3039c23b655bade463cdb22796061ea554ab34aa8660ad36b97a7f5b7ed2f81fbd2ae03bee6ecf278b8c2c1022be11fadb62ca8fa7fdbed549db4fd8b55f8495f7c78f9f52114dc8325918802e87f4070cd69322068f3a081c69d4a0bdd4a55779f04564b9665f160a45f0e6ee1bf37c91f31ff2f18fa6c2a1f060d6ab170ec337bf3998a0ada42dbee70580a8010839bcd349498b5718b171dc33add57e51e56cbd037bbb2ce7a2b7090934eefd1396cd9d0bc0fd71abdf1c3e88e4b4ab05e8377ab3c2545e0570d255fc01d13474b3f6f7a34d9584a5f4d4b2414fea898f8b1f4f39bf903b777d96f10aa8ef0a298c7911fcaf336f77016e0a57d858cf84edda0a709f959065207e49544972d220ee98ce95cd5eb399ffcd86e65731a31b2c6dd9f9b71776125fa8020da9367f3dcbd02f1f25da07aedd182c7bd7d0e1e066e443149b9ab897f77c6b67d851d07368caba52d1c592797a6c52da2fe6a413cf977a2c202ee35e0f1edb77965b6812530eb9a2ce6f23adee149531ec393f5fffbef605e9e1d8e196fad0145b4359004357671ca3bc9fc20b4f9bc503ba03f6eda771107e4a187f0189dbdfc9ea1d7b466c32a7d0b5b441271bbca98ba13547b0e453cb91670be2ef87bc78c3ceb51353f0025471d687bfa25daabbe889767fa5d02986575990170a20ec35f996494036e63ea9b6752933efc6cd6757771ce86736f86965bac3af8cb298b997672c11e9280965b3744ce50fb6fee49e685e081dfb49869c253ce69190f3bf1e26028215398f1a7349ff1da3970e2911fcd2259111e68db6c720dd4e93cf6bb72662d79930a750c1adb2fdcb8ea080c875dfb2bc33f7b14ca99e5c88db91dfd973d3eb8cc9a863259b7209e64dd91610d79c691cfed9520e3a915858c7f9aa09a8885db65fd6c8a91af8d6331f168f5ff670a90ac94f3dbc5e5e49a1c09931dc93b95c24dcbadfcaaf8058e3b52a70a6f5cf274cefc2ad4199678cbe8a23d1c0c0bd3fb773410210b4c8f7779f4729f496db2aba5a87fe0d66615dbe7be4ebe21cacecaa86cc934bba3c5242ab0ba24a32a4deeba02d95124e2a157c5abf36e70b2b4fad2d9c9c8814934b2b833ecd990803df069dc0ba51a6a6df7ed3e2192b825feb4c80905305a17230f549aaaae177b17cabf1dbbdff2d693c2276393d38eb62b6d7762949d79bdb78d3be03bef6c536cea4c5ee9ea292145ad80dcfc8811d16528d9631b15d4660b0cda952e1d7bc554233c9b345321bc37effacd40f10f75704cc07c2a865c80df49a6838a58e7fc551234af75e5c47d2883b3f591b90dbf1c479e2e4c57e6e974c6d41fe84549d3c9c7eb6182f9df6adb72c1af516c6b4a2a9ab1019ff1e0f342e3e3e1ee82173fff397f14f6501183eba825d3d6c58d3973704f6cea724f9415d9c818bc8ce4e5b7d7e5c244df516e67ab46302aeb99ed590ffc040cc93101269a902339600d22f78516e63c32580a2606926df166ef839357c78f1f1f92be371f935b0352979a1dec0748dd8efd3d74afea4f90f7b3836c9d37a7f2781b40cb2ca13be814e8ed3a21608390c3d5bcbb0ae4eef3bb14b9068273acfd263e18f9ebd25f28d64180dfdef5d49bfb57d6a2ffe3ed2d64ad186609196d3ec47b642adf0e4d4cbfba4f47fd2131fd8a2119434dd9f46db0f92c23ae996b70f6ae830bdb05419c7cb9c0c25487df068ef09d67260727d65cf7357c0fe1abcbcd00ea1957cb3def937457fdb5d9951607ec420f39a38e66b33a93f22aa59ce10d4e626ac5868b9cebc9e61b77a2638fc9d1d96fb0f442dfe0ee558d8e9ee0862e03cf84165377b34178c8c4da7be2a46ad22c510c6a79df4f8a81a39692211b2452879f02c6c7afff0425157fe355811101f1225989965b36ac3ac99c30b47d7f2e9285c119032989dc71b9a8984ffc171dc842d223aa6afefcb80d97f871c6c1e82d1e23b4c555cc185d1fe11bdf48f124d5b0f7a1f3689226d66ed0f7adc10ca5ea972ad6044b1a826d55b8a6785b6089fe32e3f1407c12ddfedcc20d361ff6d5f2a7fdea26e2d3ac89d93a847601b38a7b36a1defb77dd5f4759ad95e622c7093742a810b062091029905be6106c72462764712a7c7d59b5ce822bd76c51701973261ce463a8306f8c51189b13fe09c960f3579663c5d7750122814dd4b1a4b0ddb3968c3aaaa7976e5b8e6cd6ef856fa3f24a9dcfb6f64dcd004110217acc8b95675d4196dd48528a55b38ac0637d782e9f36be5311f3645d6698631dd3d8152157781cd1f6712933ebc159dfea981a76e1fbfb93eda563aee97254a2579355906c862a7895e3df5cc7acdd75fcd4fdcf422f594c216ed26be7a755f1fb07c8a8475c30a9c4c8e4093071d67daa44a5925bbe670a453eaa23ab9a837286e3f97a7e9e1f8cfbc81f9608a5d218310d70cc858c7c231e2597ac603f0e5bddf6e3f55e2bb9b2ef9052b87056051806ff909555ac4bb4037e056b307d20ac5537f791df8afc4d95a76e7ef197f08e4de7d91c6e3324c37a34efc48a8e61d9455d929f4257bc89b802103291a869a0e8644cb752a2cd22dc2127b563f371a69cea3fbb7131288001d5fbd61664badc2dc987d917951dc8622e11b44f7730efc77ec6f086f4d31f4303d49bb10c717661063454b74f25c44478d443980784193d4ad21fa1eaba1cb71865c8bb7623ae98e85bd77fc73b65905938862d3548a93c44a06e2249877c74b090e3b8097bcfa7fd542bfdfdd9e0a90652608f8e7b7b6ab7e1604f3688244b65fee855971ceab72bee3a5a11738bfe590b86d73094464e52052fe3c81f5fb6a5440ee68c07085458d6c52923aa251687651001f8d8b45ad4347b65aa8751ec9612a11d86823b6261163b36302ac13cabca05ac62431605d517bdd0fc2d0242777c46686ca12b059afa3aab8aed2754aef292c0bc204f9273b73d1a48d74b4d40e15f626c59cd602bedba4d2998e6c6b9adb5a576d56a2602e929d6d23c7bf43f965164e248c14665981269628b62d44f90cf1c36bfbe0e45b7df6bdb4f5b32427cf1a4068d95f0a87c918e3d166868f0a77aad58ca874071b1329cab97bbf4d567e2cc217559032ebac53a9db6fb761e97513b77db9652c3d82fa3eda12ed0845beb85d2e0339fdde879a772bb032f988dccee0b63035561e0f4e0b2138133abff7440030996e22b924e0f6d204bf6d33acc38e543c4e9198638515221db38e271fe93bcdfbdb171daaf87930c005688ed474af27e8166789d07461402f03d73f49997d7a07a2a0872b4fc549091d58ba353efa2ecd4d3ac0c9cdab96340ed256b19ea363098f53ccb929e7caf0104f47f7743a3924e2c419eb3bb985a1f5d8b64b63ab0f10856dc324cfb3bcb497fc7f9964e23ca20ba4278eba6f14e5ee514beb54d3b581d5b031259495c7fd5957b6648d13cf9e4f9014652de412fca1a9687cfa95ffc3681446611ed2f337d1f22cebbf52fc75f4d4b165a1b4d29257152e6b8773323a82ba7760666ccf650c83ac4f7da4a7e09f6cb5417b8b687144e639889a98ab97c3b569fc8897ea2629becc9eb4f05095e1b8c05e3b6213263102b877d4c1edfca908de165bcab440a78290120cd58be68cd92651652f7e1f40768e32efe55a99665bc6e11622bbc760f42d13adfef775e1ffaee0f7aa39e3274dfb4ec29f62846da1d016b9bf9c70979f4143cdeeff6937659d8c4eb4e5d95193327ded4616c6a19d981155c85d5e2d365b9636d6a5e87bceb0723a34d85e6a8f462449cc670141f4c29af0c11da9db11ab7bd08e5bae45fa6287fc1f34c356c02c78041faefdba626f0cf696c0cae89d472780998b7e525c765322708249be43f131eb248d213cb57eb28d5f57155a57de79689289fc9dee98a831a050dd7ed2ff8ea558b5fa613e6727966a5626e5a730a98ec85ee6d8feea94ef0a65f670a25b2529d4a7c3cde4444b5e0aa289dcc47b021b3edeb49e5414b798cb4a9dba5972d71501a91509d6d2de597665e6d01c7c9123ea21b6c0c34e0af1b085d58642310c54150875ef3cf8fedb3598a800ba5f37bc7fb60fa0afa97299bf02244127171d9f7be84a8818a6895ddd649718e5f90208d426f4f5c8937fd4ac3708b64152a32d16cb21a8cb027d4fd51761fb8fbde674af54b91d4b3e215ad072cb1200ee6d786a45dc532804b6adb26ec63cc42d1531f23ff83779b9f165b438796fbc332cbedfc5effaf8b52fae24993026f41781d1deecc8b3a40d42871fa4738a4efc221979b86ecd15d367bcb2c764fb34ab47fb9eb698ea633e307f886488b17b4ebc64399e2452163e96a003c8d8ad4c8835b1bfa9040353a43d3555a420b76e00e108f45e23f64974dc3a8aa61058b093677d45561411957cb5c9e43deb0926dbe01b4f089825c6622c63f0a26923b20061c42064c714ffa520ea68f15109db1baf56c44f3062ba670c932562cdb554bc9078a640a2af6dda1652f5c3b59a600a063595ac94affcfc67af5d4492b4e4fdba43419c247af1cd77685ec4b06e16b7cd29bb478e9e149ea0fd20824f0fd4ba28a40394f6598f99a59e00644f1cf324851a33d70c41c96e132d846c9b135850bdcc3681f076d4e191c30de0757976841709dd976fd743a14bb4e4c9a4cd93c40466ac4c92b548e27d39281d5a330a3bc914a061a39c6650fd02ab35fd346860a100831624680206ca24df2bb573eed98c833bd80cf70cc00820ea820c483ea4804d4a523d5269154e28a7f64ed9a2ebc4c29f04fe54c7ed1844658ba5afeda7c685e4b90bb84bbac046b5b3aeaadf0a7564fbade45d4d9bea1a3d0f0f8b8e9a2d262b8ed13dd8bf24888b2db80aa407b7ac844b798c19c07a3b0003c130991bf4303dd0120f7f3c0c57da4930e91c7dae10aa4f940851768179200892c80979778d1e269a425d5bf9622c1a71e9e3b0502b730d94b87e9a1eaec8352337b4babd4ab9d14913876dfda3215da41d85e7373c763d1cf2dfd8736c63cbd202a8d1cfeb33d298f10ead9dc69b0c3756992c053ce4dce2e8f1e4053eb1b171179b307d19b9bdd56d6fc5f9280c075e70de9ee3d9b4358f71c3bd61d144da4b1aa699772c58d2bb34ffaba224a14fce58d9672c0ec576ba55d85812e2c76dbdf028e941fe7f4a958eaa62952f4f50946cce62c0ab007e00bf03abcaf58ec3c9d8c2fea15d2e5354a6060475c8e0cc017062ba6bf7677725a10670e2fee908e6659e1b0ca91ce34b8acf0e0ae6dbb6cbc33654c13a65862495b65ee44867282dd84ab9a9b552f2c44e13263c01496fa93e5cce58f8c9e3d3e59fa6246d046eeb435b3abb638eaf4bdbcba994c81e5818da58030eac655d7caea8b5661b696d94da46b0a33948f324c5287f0532c049ffeb00fb12530af33770943a013302516a1088952b18a47701ffc0728e66116688658ae6fdccb2fb73bd616dc2db57b65f8ef552daa86f6da619177e34fe9b43ff549296cba2320c65c6bbf52749aa4a8221bcab72fbc84409f34c157f022eeeb7f2701b8ff8955e2684d29c2fcc99a3ca6a4f489b538d5b3f112475117f2d43a236f77461dbfc87154f8025520615aff5138a1c5493df2a8e1ac5e593f24ab6cd8ecd875c7f4f7c28a63ff7748169064f1c5b5f4176e57f559b5303e67025d5fe47f84d4758e126126b2db3f702730a58dc6e41339d9d137cd7c3cc120c3dc1384cb47e1c7b5f305c2809834c571b39448b60aaaee045cbe4343dd630b2002663e7bbed88b25d319f8d37034a9490a1ac8b7c3f81756973b9dd04539c5e18220588bc4686105d8ea9308f8c6b25eafba9dde2ac8212be716e4a13a75e73a3a36a04474821091b39bb968eca4686f7928ef4ff9b6634f0d12eea0254d122ed31126f7f78d264170b7621014b4d47565235a300ba368ceda4a3627b7a62dfc14d29557b9ea1f87210eb5aeeb738442ed631afe1e35882d4b50b7c4d6a81b376faa35e8509042fa4462e1ff910b434c559161d847b0b554ad918c65198e93be05b1f12106d16db511415bc60dedad70ca1b75b1168469a58866149f408695f82d21f16ba7732e0b4b6c78937663e6ff15f3d16932b79f7321cad37363a6f36c82dd95c6a0143cd5d3c8a2e0d3cac23fe0ce33989dc36ae0785969bd2d95e1b85c909e40d7a7460c4bf34b4f6afe5f8b20ab0dfef7001ab48aa82bc0619d1acb70fd833caf4e919ca80de69890ed08e2f95b997b633c1b1f730e31eb0e3db8fada0e4f2ad9f20b03910fe6c7487ac1a145658240cccd8d0656f7a764a200d6e942df905914c443fe68d9e79df7085849ba532b2bbcbd598cebf0601b4b3a424201b1fad232dc23200dcc863b888ba3efcb493d28fb3e775192fffdfa75e3c92b578a836fc35e2eebb0b1cb6b87f491ca254e68c524842ef804a2b7e7a77585b279b79e921f80e98e038b0ac0f5a8274379910807db47ecad4462c0815a8852116090f224c8d2255d2ee8137e7e2165a6218f8504f34f2c02ceb65fffd463b8b82733c0372b55b4fbda8c522d7372df21dac2e4e7394a86b2e549ff6ba3eed7fba7f4b7005a54f29b60c36b6bfb72fddc081247a8b2ee8cb411119887a006eddbd6c26b353f44c1f224c534cc231d58a612ffbc3475156a810e9ce862dbe0ad706e0d7924db4d8b60ea740ae815a8addbe2f6f13f3d0686a6e20bdbdee4979c1178f8376753fc2f5f6694f3697bd3fbe5f05bf473ef32263d3198cec5403295b1c44a38e14b09db7aacc182296f31cca06224916c4de017b90aff5be763de64f6b84c8f53720df405c3621c71e8830a563c74b7790063ea8b9e3688b18a451caced32a38d1a28f6b818bb62d6d3e361c22037675b096115ccc0f5a7262922e1f5c1e5e0ef849585554655a967cfff46b97aa4e2d2a2daff9d15a95c342b1bc7f31eb2a972d3767e359c6c4e61526bd33990cf2eab9380c2a03460f8e1d9f1ea6e3ebabf10acc3e96a675c6150bf92b873379b8f99227e364b548f60798f4c8e51e6d4e5c5dd93dfce9d0959ac2e75496c3f00e22b25acde660eacc788fec20c5489140ebf0c47e91992b66b13302799538e2d72229b5f0fb4cce30966ec4f6f776c93c3a4cae713c481129d533d297195f603a6bbd39eaf04fdb74a746d0571beb2424e2c127938ec1969ebd9c8a8e17b1b597add8a0aa5833e18d4307c4d9a0205918eaaf44e071ed0439d9e49fe8cad89d8b7f5ea3ad320d58dc7616c04675e7c9dd489a1b4ef1d71ea6e373c2655ffd3543720318265e305ac519c9934e13ecd1d18461181efa6d6ff980e1079314533ea4b73fcf5a4d21832f455d2452c0d704a818bd5975cc1d7fc0fa34e66f0f14e89253ba24838724a88f77d1bdc7b5c6b57707e84d8bdc3e16ca6703dd8005ff9f57dab143642683d4580094b38af16ec9e4d7b39037ae142a990b5fa8bc7154586a158722be9be94fd5b6483eb31850dc4ac66279574182e9070a510b7a6af51fbd41458608bbfb0bfabe8bb365cc21ad4eda64dfb011516c73d440690747c0eae1af828d21533e1f24208a18e128aafa80c6b22eb6d3300d12b4f83ff657aa70e8d9dcfb8d72a264eb4c8e08de7001140cab0b43ab219b68679ed2ce14f81bb088e384c1de71f2afc632094c2d11dcf4408a328b6a632132fbbdb29fa3a0bd3f624523ee776129a8fb7edb78ab7f0ae0774c75795fb01c29567dce023939d348308d35f686cc22e62a7109b571c751aef6f835ea7c7e04d75ef7ccc29661136017bb752a9ccb32823e5aece93e55909e5e8102c6316ef51e1a8622fc3905a71e99afa97246099afb5f225fd834b29a6b46393f1fe2f9c82430faa63a5df128bf615439770bb12523c29fea37fe8464f9113d5455d74b6726f611c86306eece356bdd1be81dc17bf64f60ed3a0cab13a77635367cd0e66a42402ca301c103a3615989fed1dbd4f22bc9c67281afa221bb329962319210e79bd61436eabdc6268e645f9488c69fb4685f36f8fa4325a16e7c6b82b124df0a03a2ad4f1911f567c68b9cc53f90a3ac2221e623c0cf2181120d8683596c14c035cfc903e530ef7aee976afc3e3ed861cd813daa28a0fb4cdb23e09c24ff0e3d3f3f5a6ba117f9bf42203c98b82a8b3bcda4a31c5bf1f885910787d154b477749ac5036224e8ad847e055cedabef1e60bbef5f4723916f8eac5927d1ff01f7725f99203aa75e699a0c60a4ebdc5c6147aa3bdf7672ca1fbe3f02f04b24bb398773cdcefb448f01b3160e0fb8086535cea3782adbcae2782bfed2d74c81fd1f7504e9141a5b96ba2257a1f67016fde4675cf532f380561a235446dc05e4c99dda2bafd1600cd535aff08122baed05df31d492dde3400b63a3c3f86901b0ec6bf28ac86ab853719271a1b4cc293426995552bfff2f5a91812eb69b491759905972d96af78c2fc661f8507a0047ede0f1a4ff5bc36f678e1d350983785dd0ce16b36dcbcbf33c8ac880bad8bd7280a88c543601dfe5bd6b8b90759e0b6e9562d065237aebf55f51e728888d780bf5ba6cc4953e7ffd081c17748aa9d49a6c019ead75793aae51b704d0a5c6c8770d9618b9e15efedab632512214416edc32c12d4ee1c62cc571c595a6541c4f2256843945a406226030f62276e6a112c3d20c86c84f0cad357c319712dc98810a4728f4cf22b5911bafd8c0668af5dcca0eaa7dc10b4fe5da1ad16b307021d1b593b7921bfb10c022fb5f653c826450ac94c6e996f960def016271cf7e7ebab6cf4df00b5ba6690f721cad91135175a4b5520c419e9af1ec67164f0aa931837abd9aea678decd07d55502a9c0b5adb6552c2c3d5812cdb0783a26ada0366f5d46b448959b4955d3bb52c764dd185a9c836a6b3434bcf129f5f96a38dae5135ad38fe727a63ee91d6397451434f58594a19694953e0589e740060b533343c6781479858b8cbbd84e84d92f856607dc9aba8b85c394d26426f7f2caa11916ad6d0e4a06194248883233b90223eee5e39d6bd4d357ec5dec5217f2095bd0d0e15f795d5e0271b9774f84804da742aae14b25b511bb4cc07327684c7cbc52e1c977494ee4878a90d96f38c233d647f9d0df28754ed560b7822777b378bf18b133472031b5e75879e5b641baa85ff0f80f4850dbef4cedb567c1bfb160349c51ba24fe7ebb08f37bed1a5cb703a79dfa9de5d110f73f74303c67925ff8e31fa2f77362437e42de8d011aa769d5ea314f47af793a84d2d195158ddae29f4c0c10b0ed940f1ddc324e1c7e371c0340f0b85a731a63522a75653d790f9b6bfb45c97ddc79560f1ebe03fbb861a31e4017ae9b3bd90756b4e5d2e55ae74701072c4e3addc0df63f76f54f6658220ce414b35b0b3d69d4f9232c3b93b91cd973889aaa2aec64a0d5fc82fda27006811160e6a1914640cf79e4f66456af3f3db6f3bd98f095da835c86abb155f4671d2102e8b39788a30c55d8938378a2470d551998b7c949647192630eef1ff96016bf50758d23b128cbdc49b027c7dba871351f255f65d5a9db1009a20b9a9610a361f758f0bab39fad49455a59e75f769323b688a946adad3585295fee999c4d27972e8ae0a193c041434632bf6a46fdf04de6b90a1726ab8f97a9a9be44d7e237cf3852ec4685682a03c218c513fdac4d36bcd3689246fc7cb412943ee2b973a38d051d6beef3e4478b21eb85f03edaf2105ea851ab2e48b4fe919aad3f8eecc10b5d82275a76fee7dbe54bb56238bd02c8da359f9f7598558ace3dd8d5e02dbfe40cad74a86b980b7b1f5717042f7430b30054c651099c518036bf22f57ff485793e7c8513d9737fa4c9b79a03ae72d19301248e11cf0cc16c80b86a106d1a170c7ed82cf19e6743a6a73841699317614f1ebec412df02e0cc30bc1859575c2e390f9a0944f809b8e9b97a80804b982c6df60229b62bebfcbcb51b17976a09dd73e8b2b0e724ab9ee7bf230c97905b076baa81946e9caed548eb2ebd5ec48bd2920f234f83c7dfa30df2f27c83a556fc92af7a637c1b7fea5ffa2dfa310805c7189f58a93dc5c55edcdcd9e88c113975ed6bdb88171da2a6939ad3a6bab8649f14fb4bd8b18be3de64dd08d3101e64351a0460ec20a247c563fba04288e4f9c38e4526d5b19d38accfbd1fa98b45be56ebf109936145450a8d98c6d5260026adf39214c1dd5f7335c61f60b83e2e572db0a7b53727af93d6d2c2235275cdb367809cfb71a4d5c14d171988a876794bd152934da74c17aab911e06be92691461b202ac89566a66e53899a487f802adea4677a93e9aa4fef59392b8ecf2624b0c811b3d973ddf02f4ce230a13a9739ab8d17cb2ca7410efa8a40cd5279458543cb83b9c1964e40d56b2a48cdcb9cb50e6f0d7d1b99c3aa86d7c8aecdfe56e6c628f0981a7865b8c158e35445d1d7119ab86d8376d01744913fc94c512d0695c23636b4e1d7e75ddc92acbe620e29f1908020d215e0a8ddf86329a298ef27f217fa2ddc9b709393cffcb7fd9e6849f08ce9d607d85954286f87a8eda349fce37f68113a8af06eea0cb1c4023e96f2d5534730538c1948ba928076ccf962b9d55b83d9e7fa7f60f9133f2e12c2b017c4c704dd9d0300a624c7f4fa5049f3714b0bf38c17a723062fc8131bcfe76b5f8e0e6ec71a6c1994e5abb2d61f379cf943e4c1de2de1d5e4e2efcc144d3006da240ec95e9fd7893f1929b4225390d4a9d149bacf461ad294db0acf5a7227b1e353bf5c6c0ad9bfa9d44fcf3383769b9c926a14b88174a61eea2501188384a7681f2ef16756b4f548f966159c71b959e9ba138dec60dbc80b6be7f55d5540545ea927bde36624df354079a5c12122877040b4214d61b81497600ebbd47ec0660aa06dcbe70786fb8330ceb33880e48a1e0bdd9e2b3293320a45bd3e3ec1d502df34fb4ecf3f9503b564feaca522e2383bd4e61f4e2485c11f9139cdaca8eec406cc32225ca9dce1fe1e92019ce3bda4ac66c260db84f65db36aed27444e58fd5e7c035fa0601296a65863c76176ad5751dea5636e6f4406d52e4b0ce63e18a5db2582889fa5b3cb89374b737f3fbf04aea4c222ec5fd0803e13cc85de2d7a3da7f76c22df2d05c95311f2e9f6d3c2eac559651c966676aa6b21efa9f9bf6b58b649d508c5bdcc3951707b0ecdf463a564514d66ec2e4297e735b832ce43b95e8e61c85830eee56378c7e540bfcce9c95a4c3bf4df0dfe2596b092818c1030631a2de0ec655e3cca099b2ce104db90bb0a7f27d4d5c43228652c62d043b02c03dafca7655acb3e750fa90fe2f78df8f4b4b378cfdbde7a1cf140b237df59cd209a5116978921fbc248cda36ab8ab79e1cbd0ca5951cd3f45943834facdb8dec6bcd2479f816d99e4d23f4516b90271fcc8cf1730014bafcb2000e1048ee0241939ab58d5600f9f6e5205c901f19ef1a38286851d47e3ce0a1b90fdc8ce12f2f1cff8a05f79ee1f1f9ca48789d20edeeecf4d639f604d82b42ef142470f530ade139b4b87c15a366c1dfa9d2e9f8de5f49ceaee964a5c8a6df4e9632a7b6b91be652a4f272130c307ec95bf77f90e53d806189c37083031381b8b9b30cb231b2f90f6e390fbeb08eacd18d49046662f1f30baab81cfbba631ed286370daae6f968b56631ff4b9c2608432f98c8a9367be50cb100c2692259353afc27747c25fbcdaf9a8fc92ad8154e2a68db5de873ffb9779c20c2be0780858e72f5b6b4f4d079f4cbdf2dee24ac1f61f7950eb51fc5a0cdb6fde674d54801d3620a3a78cd2a0e8d332c8c6e94b6f09e5a6eecdb9bfe1b49ed55abd57499430cf05e9d3691c63f12114e948cd05a95589288902c752bb0d701ff9429dd44b3e7409bbe00b964477241c1b3528a089ff3385121ace7433bcc2c3964d991b83d6ff7f70a0ab679d2f9d4210e0c61cad1a3d8edd8b4332c5111e2a0842f1e6b24643308fdf6f69972f191a33d66acc6127da0c088acae3d32a8661cd2783e1eabbee966e52b2399aa2af1ce8f46afa66ebcf3383cdea69d26cd0af62a7a614ce0ca2547871fcce9752ee47360e6d04a93d570d91a03a6b9b8c284ada221a1d85d7410257884b91259e15fcab5c2f421113dc21e6327087906b4ae0ea76bfa79ff3d13611a2e6be241e75cb3c213ffdbce332c6e3bdc94076df18bb6f4e961852eb6d2dba7eae00afeb83c86a185c71d773cb97f68bc0871c88511d7229bea923503767e955d92d76dba489e899e164f271c251984c5acf786507f61285e61a23af67f303a190b65db1fb7f7d30d74868fe9fab81266c09f0ad90e1a15d40fe02152ab156c184a69c51a77ae2449c327f33501f7daf7da312ef3aab0ee8f02a551a7532e2ee5053eac3d27081e0eabf2f86d10e21652b4addba95bfa3386dfc6db982497f05881d5fa6a465fa3020b146fbca3f9bab32f02b79f4f8f18f1f7fb23481db0931d572ea4c6877b0ffdb48a7fa844ab29b7480874eb4993ecef3b2d47efcc0e5098b44a9c2a18e4ac0d884b1dbf7a28f9a5b9054aa3f4c6cff4fd770361bf792518b9a1c9fa54d5f1c19e1ee43ef9b3721bef90ba588fd67922f82adc76894f2916e759117e1d1222b579d97d92d7e3c39b05f8c92ad0808416fa584a9978f984a8c639afa94897fc92669a886eaac7b26b70fe472665e6fb8af70fbdc9d721375402d92aa48165fe736ccb37c2b2893619a2a305ef731116855c1217110d66c93d7e66717a9ba81b30649b441c93b45c9e5fc7826482e31161aa7988688dca334b46d53db6319d0a5c8dceffd1e68b3b459c5004eb1502cb4f27ceb579de704655fee99ac2a8ecab133e45a5512d888d2265453be4eed762c2b5aeaecf379999b41e1f44b690e856a4afeab14984ed1dcd6ca821237c2aa2e7e206db61e7d7f7b9780355ed9a2b1bbec1fe04b59267d4de98e999f4e93f182b73dd683ee91124d25ab69c97a5508c637707d7a949534433f690c18afff2e5fc4e2e5c322c80fcc148782d422385ddc76b96b3dcde3a730b97a7f4d68591e28496d32bbc45b974c98b0725bcaf1bcaf80b68d71f1b412313151feb1ad426735f0aeff36cfad8f26b10b45ae05b35e4b86409cc1476ae2d9d5600e7549078828cfcf84109d141429a7bff267d468d3310e84c210f12e734245333d906598d4cca841e1a408fa22e93b4b69d04d743eac27dac83d3d6a1ed6b38550206e1bbe429c4883e3bfc730a87e3e7e6f5207b4c64f2c6ec2932c1fc4e33a37df7caa1f8a9e2759851cb63490f773dd14917561ece4b5dc20ac05b9358da3a27fd97b4309093c323d0f0b498fd1cc3b03268bff400b6bd50482bd49346f722d86749d891cc3bc0f37a4e928a3e4fcf5cee1fd5940767eaa2d59d4f5c7111769a166e84b4d3db72071b65a19aded5974b69855901fb2ddc11870158c32df28a91db2610b92b1135b8e41395ab71dfad7ada6ea0bd9ff88b62a78534a04f73bed4d5f05c0bada6fb9a76d1a6cf8637f6a73ac6ee76cdfddd648b94fd610e1bb5310218a607e3012932b7ff233956dfb672f00217ee2f0c8f384ce5f9c15415f18714fa4867e38df28175d04a6e61f05cb837cb133bda1ee9699290e1981fd06ce5f5a4548157cfa7a8cc63e89fb138f735fd16fb77893a2f15fa90f873974ff716eb6fc058894e51a9e9770b9ad49239f8f308d032c7e8ce2002ce4212a6365d4d4c469c586e01bf0dd0e3dfcb9b828dc1ad15b67d66561d71ad020b36c6f7ade8fe6c15b40636eb353660f4f3b3418d9045153d653cb2f581dd1624829fbde45fd660098a41e5473e5611f4c47bccd90889d679b24be6607bce3c2d7ed573e7e83939e51b898080735ffba8d51bfa56a1ad33f9754bd1b292288023598353f71c95650110220ce31446948355888274644f339017059e1da4539872c7b953b1d105604890e2b6f38b6dd08926bc3211f48f5cbcba70822863dcc5aa93f86a57ccbbe7f67171f8bcca58615713891822e779a9b54c268c4a531719b4cc1b8e5e115480472a441bb7c3d5ce9bfc4989ecc734323bb8fd64c3e56e7e7142778177e74fa33259094062c7ff40010a4ddb1b66ede5d695be2c5d56fe5b0e4b99ce69bc4e431dc7407a1c904afede67b0ac21415c2b2793b64a4639ba9a46292d7f033292b401fdb47f91b29e026731d71cb1bf45d3987228d1c25ecd38dcda94ffaa8b1364a99dc7d553f1c669899999fb19fcab5409b60421fec27bcd55093b7534907df8e6f7564f0cdefa7cbf7f3bddf1d030a1d71de8e4250c3d296e3925f8dc4426db68c15373c92b7464f8628e1094f6adf781f8e9acc07565eb6f27182b9c1afe14a605fe0fdd01728e873b46d1d6d110f2c3c347193f2ca958e07e3d2f1bf1bf82c846134f73ec44e2ec868488af4521ada2f557cf3c0451c6ceec0bf9a675380fbfd3bc8b484a1a8e285824b5faf643ab145bb5dc182717c5214e6e499064501c44e0061fe14c4a5c3c96c41ed59b642261293fc49c63d319d1b40c5268c3f099f7fc5ef7f55d5aff289cda376494ebe72434498ebd3718c2defdd0aaa3eeeb747f98f191b0d16b8e15d4611804856254c70a62bcbc31abe038a321e9d43afe93a29f9d7eeb39b55d3bb53ff849fdd0f190d68bde460ff603515f1aaa39469d77406bcab8570a443df127f621973dae6b370fc50abed95a8242524f39b6f322b8cedd7290eebc32fc23a81f53d404906eed04b1a439cbc33ad0b9d48c1981f6fd274b6749ace6ac6870945a86f70adb8d390f7c46ffc3da7fc2eabdaafb264b70e4ef7164e66e1583854cdc2d1f441030dd7ab1ce1c867a7b47503dc241eb61f3053f4c8527852df916bf262da47122b18d29b2472434cba43ed3c2229ecf2aca4df4633b6c4c8fd33def9431ec98e6665e87f4eb3b36f21e2b1d088b5a6dd460be7f1ca8fa16f519644b88bd0280ca2cf77f9408294e57f6c91e3a3fe0c99017cbac8a00610a5214053850cbf328ed6d625357e911a0d23a9d5201f758b4c7218e976829d50141c378fe0beb7d346e8da05aa69a0d4f84325c1bfa05e3c849350864221acd860efd1031a70a345ca8bd5b2d85bed2396ae9b469d450412264de68c0c7bc911a789cf8998adb1e8927ff91189256576ebd68737a2edaa4776b477a57234f2193d3b0cf62a923548fe7fae450da8cfe45f19c740428110a9ba8786769477dd7cfed5c94400b110044d2b167483d2390e0835aca46f3f4e1f43faf12e0b6c92a4d418619eaff6e3ddfc21e25e38d4f28d138b7af132ec03f725995bcfd5bb9cb0a859cc7623c2f03a3d53ecc12da974979cbf1ba6ec5ce99bd64e8d2d14a58509116b7fdf8a883444050435e8c690e837f00502acca0ebb11dbacd1bbe2c9de1ca745d79f1499aac4ecd7a8fb012573425a171b823b8cc8240fce344d34e3035a65e49e7dcdda3b006402334b5db9e31be555164675dfb97684d5d815e93eefdacafbc8d4aad88e6f97368176eb87b6438595be14f4248e07e6dce66e55e92754d1bc628c6e56f7d65af761b3177f09e858167bf111adaf1193ef30bc7e43b3589252053690e2170ba3c26f1bbbc6ec7ddc8276de88e2396996ec030a1ecc3744b6efc31f807ba1fd3c4710d3fe896de13f9d3e00060562cfa53ffb082702ea2f763d0e26427dd9ee9d4f88e61f1cafd466459769a4c43261b0961e0a804e41131af56ee599f75d9e41616150aafc5202ba4771cde08f7e312af12ae2e320a59d7a3d6a782f3da62987002c1e9852f37c209cb1f0e29085bfb9f106fd8f29cad33771635defc53f8f41d70d9ac0ba4274d6525c9052ccea4566e9e32fff6ef1c0bc30e449a7b630f7ec4dddfda0dd135a73d4fe8f9ed1cc48324a13f27f5d2d8561721bb7c18e81684eb5e3befcfd22a2d09857dea2aecec540d2adeb1bf92224a0d1b262e297509840930ac754e84afa7ffc51685b7e6f3ba4f88d3922a15a9bf9563d2f17a1744ec12cb4e85566137456a99368950463f9797ac576f444ce0eacdf8bbbfd3abb85e35d2537b98ee65c2e741969a8d261c1594c1ec2cafcd04330035587491c4bf857863badd35a93bfc80180b3afd6d92de0d1e4f3bed73f1e192d5a3e901b36776ff88fa4ecc6cfebbe5f6d7beb06062a8c232844c55aa030b0cf515d0d5c743e90f5f5215b90da7569dc2f20065e8ba50ad16f3f0530c7b6110072cdf04ca0dd6ff6f5318142c242b82023161c9beead88a4755b02d2c942a36f4f98dabdcabfa94fd0004be4ffa4029e19d916416d633130b1d2eb81111baa3fdce598b4af82ad4f24874ebd442ac149f8579649f2ab4b8816227a090acb12e1085e7307a6b158a33e29b9f21e1539209d04bea8aafe547f7bf8b6b40569f3c1df224fde3cda50935f7fd6a0c359b30d0171e39352f86554bd8ccbfa5e78020410f0d5575dd0bc8977382f15f571ee06b0fd3331c5a56bb018f5ac08cd32ad11ce8f6d3974088ce36779100be3dbe2244544caf5e48d522ef78e5cf2409e62d3c77a274fe7241932cca0839385a036fc2ab316b8f1d506e7b8e31dbeb275fc7c5050bc9be9d9e2c3090f51363d78db26a6bfd8e96ad4866d3dc441402c7d71b6577ba086c7e9dee4969e1f852558476de08977454ed05e4daf8e46929dabad44679934f9383744921d7146a501e2cc2c316d7307f5ba731efda53a643c421b7c23c8a51125b67364c6e5bbeb9eb88e42d7ab54d873c47383113995c67d79e4e29d1a0f59242c8612d4c7eb7fbf05fafdb02d6b4a5b619fd109bf27a383ea62d7b3f8e78e6aad38030fa293cd4aeb2e75bf21f441d6ea3d57eb08824628ea89ccb8cc86a0e86876a7d302e179e0b7f6d7526670d78bb771d5c3163bb49ae67ffdadcc630326e8cad4ad14ed2f72e0d2e52d0f2420488ec3f495631037786ce0e08354a17e36b3f3132502df91e85fd9f09b93194cb4d74aa6ed313db1fd2c8d552b34007d0012e1114dd2bd3ea31cc84e8222559a19135e7f8ec8ba83da9c85dd1c514f504dd04199e60ab6a040846c7911e5bdc8eead3d556577cbbc7f22c6f6d25a173044f62833141fe089dd200ba1f1d55e13b84318a8e4be3087382d460f41e731effe529e35d78df4dc382a3395c19675964b30932cf717d0397e6d633f1869c389bbf190924a98afcccbeebac3c2b2df80ec4ce1b460f6be192fee6d44668dffa7faaf19445e2a25824d1ba5d117262179d78b1bdee77c8acfa46298100af8d509e18ab3eaeba83adfc32133948e905325b15285dd3214e750113e91a82d26d7a68055aeb37059f5f5b8ab03f17d0184356574a622289167c987ee7f57323cd589b9e147e14503bf9502a5bc58a4c3e6ed38f72ab182d0a10a77de1e0bbd3d5e946238e84ec922abed2a6d0ad56f2b8f5d268ed4bfd130b152bf653a6fa6420597036f28e306537fb0d7532be2f1a44fc638b5d4ce773d43dcc58b05bca69877f89af2a89d2fa1087548b5bc49ed23f9b90707124f96e45e636dc746889b1005e53273698a4186c943a456f49d039698881d3edcb87437bd2b54d4217fad3e07d2803e041481a95e6f38cb02c6d330d41cef3a181d93faf5c2b28835f1b337b98be1456baf23c40740f5843929d45a9698a73a5a39764a07bc78e26385ca7a14945125a69eeb56064bffb00d0b918c8464b05e9e54dca9d3a5b3c8ff40cc6c064e5b142aae275bb855c3f86f9e04f2e33702a95da439764f6b3a4055cd842cf58fa2af08fe3029faac4048ad38e73d374e0f0d0c37f9a209bfa14191b22043fbea214e813553a82a1c446b224c3e05b3e1b4c3bad4f3dd85e830dec73abaa3a24ec21eb6d9aaf0706332e1d26a3edf96a0f53f370d3b32889198764cef29b92fd0ee3686c1ea66da6b99504f6ae37bb182cc7c935733875b731557efa8c953f94f4ac33a9cb57549de5967095968ea258585bb9df4abddddc0dac8c066f13bb7ca5ca12378e00b1bae041f6270911ea1ddfc1389639a0f5ebfdaa54d675fce4be504e920cd8dcec408e524c05275be24360fba9ef64eccf3d846e8e4c8a34dfddb1f96879d0d4f88105ab7cfff14f28e165ee900b7e19139a23718b78bc3c08f2998eb365f000e37b3804e7fd12af77655045f0aa5baf424b531f948825257955b12815b1e54664000f0bd0fdba5767b07b580e416726e6638d0bd98def6413fb32a9d01ce6ffcd6bbf29ab9a2fd16e580d07bc1aaa20adbb2ae7463c3ddd5f7d1f00e764cd3d0fbb8bf59baf009c3a96be9196d308829edb7bd99fa74ea581b48b7e51e21dfdb0899e51d9ef677959600d7e2643d6259bc0dbb6abb865ffff546dbde606cff6dcb547413a112db90b389da368e5b4794409f52a76d1dc6bf0a716f6e1803cd9534c5b12754655c869d08a525b8dc3d1291576999951c5087c823055a86648989dda259f5b023e10991c390ec6facdfe69945217a5baa6ac0556ffe43e569996a6c09d90e9b3fc1b24a86ee234211600b4f9c59eb252fbf0f9748309dfac5181a217fa8a26a7f037a11d3fd344012e3d7a03ef5fef04012de3a28fc06cdc9198db6a9995795597d6c74ff8b67b1240663c21458bdca21d3bbed3f42e621493949e64e0a273b71e9129661d041545350490958dd7b851b876602858a6021a2d1b8c09fbb502d3461f9824a7bd7e917b088d79591545b8ea3aa406ca34dff2d7189d0e427855e2c1591cb6f0d7ca38546ccde4c462a4d84c723c225282499d5ea75d6a2f620504f9c6958ecfae7e47c1e512b1fa63448077906a06e0b63d3798157d07d34504d0678b3705e9bea0ae79a3644b1390e20407d0134806ef4103c71fecc58121d3b04dc207d2877971d0958aec9f32ada975b6802a84d0692f93e74e937b5c8d2496f60ea992f963a6ea3ee0a1c2fc946bfc817c5976d5c718127812c5ce1f1d0225bd112f1756ce7c2b0440b2d204dc86394d0ec7518058de721f0de394c51cbc3ef4857997227927eafff17e9cfad4b9bc9967f65272ea4eba0706eb0a2b39d90f77877ec97bc7ce94cd90342ea96d2e748f7f9207533e3763c39588b33258542ebda27c905ba356015bff70ebfe5986953913c4d424efa9f0e6ab46157228b30ee9fd7dd50bec87c73ddc46acccf06ce33a583a729e1fd7e9f11f323fd215db55c5fbb1beae72ce18c2fa947aeb140aebfed81aa062d8e2690974ed85dfa8b0e04dc147f071224cb6c04bca3c85afa482407bb4d924ffe9a4b95007ea78f9590a53880b38e0db972f981bb1992121a42c6cc69a3630b0670179a9a8b1572ab00a85e529af3baab0e49618f266e821d981503f6ca1a1e8b423959a33596236a7aad3b91b82c0f2c5ebf3f00020efe89308b3a2b6383e64ef4576bfaec264a949668b7af86ba3a644decf0be7dd5796e34e2675cc60ec864126c0f0582d3c8f0abea4bac36b8792d8d83c1e2ba4371d4bb62a59c6d50e81538f2ec3c6465d2b961a286ca228c6d6a467db52b22b4ba1d9979cf4daebf8a92c2a5519b6f299d53e9bb2231f81b5c92abcf7c42a897c412d932819072f8ba77c3b2c8d8585c76710fec32e8497245ed7889dcf7c10478e8577fa510169ba2194e4e79c4fa41597992a13efc1eaad45544e7f8510fee6fb5e845cc8da79c441d338a702289ab8e5bf1a0de451a1a9f12024902e2ac47bc64050f54bf88f6010ccf9ba3338bb45db2c66192f9dc2d8f2425a7dff594939ae4b529bc0fdc7b06941d48d05dd202f9ff7a9bc80807fed3c91f3bd7422d00011a8bce501126e064e8f6f60d8e43dc79f24bce40cba0964d6da8667e77a54226599139308c7cb5a5e7681d403fc307e4fc58bba13513d1f31bbdc51e4fa694a58d59b094ef6d42824538ac1a8a5b3b6be94254c6b49fc7f135682bf4ca28cb464f589ac610ee77da1acde31485fc20c32236fd67ff8930d2664cfa9da5e4c776ffb457c6c7e409f9f82b1fe353aa58d3cbc3293f9c8b10aaee5f16b79c59c87dff59d10512438b02f4b42619a8856cfc50af52efc93771d8ee78252df721079a41572a5ac51f35c196c17431aea7e09d866a77769a8ad9af019a394f3a481d87d1a065029bd0699a3ac1a356449c5ff188ca91219cea771d402176a7f1f7ccff4d852f140d32049dec7cfa533116d04eebe7a748cc016177e2de6093dbf3e13b47983b3b81e22a354288b7d59959be73e4bcc3febb69b3321d63a150bd78e7193962ec09026345485be1387f9d0f9d4c31320f39b676b05bee7e67d380047e4475a3ef4870381ce35ef6dc5db4cc41d297bc413a2c86469927dfc37f36d95b7abbdaebf3c3eba119c4a846b6cbe382a7075e471c0f8c3548c5f177eb2bd8f4e04ff2b5ed099988ba49dfe87c97403f3f33d00c1d6233972e92a1779849d59fe76ae86292e43706459c104bd5c08e38d2455af2f350af4704ffdfbf4904b8fa617379bca839487291dd6d9b6983566ff04d21360be7c7ff452aac9182b2d7f7ee36d972abaf92484c34a203b9f86164dd0d6bfbcb6d44e8b7eae0e8d22d916d4f83f878cf07d98084d7bd75879c6ffe3bb9d118259a6c9a14cd9942d8f919321a546112c4cc189f509c7e0c497d7c77771a470f1f12e470c6ee6833d3d835358dbef4fc72e80a988ac51c6c716622da7122e845aa25414a1cb25adfe24cf2d6fbb09dcdcf151e5e495023b3fcee2d31d1ce6943722ffcdab75b5a0356e1a1677897e1a6c172f3a2ddb1fc35cc73e2989a9cef8800bed78aa2f003cbda94527d15eb18be259e1e4e899f2a9d02aba3d6ac69b59da7741a364401b2dd87a12d76bcecb445f2d6bafb27984869425cf589277c0209fafe01d85a6675e58db8c25fbba5bcda89944f85b88926fe7d469bbbc2c08cb110ca6dc45dea107e75b1cca77cffc8b1ffbb6a1e21e4eeb25dbfd069118b3e58d17e893c7a51938c4003cef4b6b364dba1772b53d9145ec8a9b3964b24a9ce2bbee51c8aba203a2b60e3b136c7c8eb1950138bbe8d995d4f5952f5cf798ddc0f2f88060dcd2b67ff391fa5eef4a132efb21ace9969a3d9ff3e547872cbefd8435154859bada7d85639083dd3cd1066b156f707236c71079f406427e802bbce6b9234c20bf0837faef379feea4eb25bee3fb33bcfd9e5a5267dea6ecb8dc1ce00b596d92155dd41740295a370fc54012fa1f57657a819794c77fb213ef605c5d68345eb00de5f00955a8e15fd8d45624b5c96a33988f2efaad4bd4163b86fc7d45fdc054712b7d6f4e50504e4f6c4d03e8d38b7008aff8a319bce0c40015ee776aa9c498b85bc3dbb7146cd1c8aa047fa9f9458ddf11918f3e77cb6253c50a04378dbe046ffc9c4665aad3aa8b013a4652d560001f4fff732f569b3334ba3adcb2d64ed800d20aac86fed668c2c6bdd029bff347f27ecfc4788ea4a08698c26b72b7d083c5b714814c4e13c6f5ddc61dcf0efb8de52b1dd523d77c0c94fb1596470b43399bf6fb578f5c2dcfe40f2eef4ab0ae31e0d0816c87ac66b6387bdffa3de17c2ceb5a077a58df91952090c5cfb39d9c51f991c4f7cbce32cda0d95f493a950861b06659f1490ca788d3613c99bd1b2139355e7b1aef3f0e0d98a6f76c8b1833d84eee0e402b72d306f5ae2f8319991b8a9315140860e6aaffe63c61fe23118fd6e8bf2466f7661c0ca6a88c22aee7ce581badd2d63583025eefd2226f96e6ebec901da4a6ddd0ae6a70e3fdab42102cdd4457527d0069fdd8d756bc6fb125a3c0a811e0ea7bea08dc8e1953b04e7e2f2b6d545e720b207fd9ea22f57b14078e2ad88cb09c9740014a84a328675529f1b6edd14879080264c1f1cca8c7db922aa51e6189bedf1d1b8dc083b30b6aba674bb7aaf84df94ef121cb1f277628b6a67b4089934e46dd85eb5520e\n  \n    \n      \n      \n        Hey, password is required here.\n      \n    \n  \n\n","categories":["随笔"],"tags":["年度总结"]},{"title":"CAN 之 BLF 文件解析","url":"/1584988185.html","content":"前言blf 数据是 CAN 数据录制的一种格式，以二进制格式存储数据，需要用 CANoe 等工具进行解析才能查看数据，下面介绍使用 Python 解析 blf 数据。\n工具包安装pip install cantools python-can\n\n解析blf文件一般情况下，解析 blf 需要 dbc 文件，当然其实不用 dbc 也可以，只不过解析比较麻烦，推荐还是配合 dbc 解析，这个也是我们最常用的办法。所以要用 dbc，需要先加载 dbc 文件，这里需要cantools。\nimport cantoolsimport candbc_file = r&quot;xxx.dbc&quot;dbc = cantools.db.load_file(dbc_file)\n加载完 dbc 文件，就可以解析 blf 文件了。\nf = r&quot;xxx.blf&quot;log_data = can.BLFReader(f)for msg in log_data:  print(msg)\n打印结果是这样的\nTimestamp: 1673917200.026000    ID: 0301    S Rx    DL:  8    1d b0 41 54 07 02 00 00    Channel: 0Timestamp: 1673917200.026000    ID: 070b    S Rx    DL:  8    00 c8 0c b6 24 b8 24 b8    Channel: 0Timestamp: 1673917200.028000    ID: 0322    S Rx    DL:  8    00 00 00 00 00 00 03 00    Channel: 0Timestamp: 1673917200.126000    ID: 030d    S Rx    DL:  8    00 14 00 00 00 00 00 00    Channel: 0\n上面 msg 输出的格式为“时间戳、can_id、属性（比如是否是 canfd 帧、是否是错误帧、是 rx 还是 tx 帧等等）、长度（也就是 dlc）、以 16 进制格式输出的 raw data、can channel”。\n由于 msg 本身就是一个 can.message 类，因此我们也可以手动取到它的各种属性\n可以发现，时间戳解析出来了，其它的数据都是 16 进制，没法直接看。当然我们如果熟悉 blf 格式，可以自己把数据还原出来，但是既然已经用第三方库，我们当然就不用自己解析了，而且仔细观察一下即可发现，之前的加载 dbc 并没有用上，所以这时一个重要的函数登场了，那就是dbc.decode_message(id, data)，具体代码如下\ndecoded = &#123;&#125;for msg in logdata:  try:    dec = dbc.decode_message(msg.arbitration_id, msg.data)    if dec:      for key, data in dec.items():        if key not in decoded:          decoded[key] = []          decoded[key].append([msg.timestamp, data])  except:    pass\n因为我要把 blf 数据解析出来转成 mf4 了，所以构建了一个 decoded 字典，每个 key 里记一个信号，熟悉 mf4 的应该知道，mf4 里每个信号主要包含两部分，一个是时间戳，一个是数据，有了这两个，我们就可以创建 mf4 文件了，最后放上创建 mf4 的代码。\nfrom asammdf import MDF,Signalsigs = []for k,v in decoded.items():  timestamps = [i[0] for i in v]  data = [i[1] for i in v]  s = Signal(data, timestamps, name=k)  sigs.append(s)mdf = MDF()mdf.append(sigs)mdf.save(&quot;xx.mf4&quot;, overwrite=True)\n这样就实现了 blf 文件的解析与转换，当然，转换的格式很自由，只要熟悉相应的格式，比如 csv，hdf5，xlsx，json，pickle 都可以，因为我们已经拿到原始数据了，保存成什么格式就很简单了。\n","categories":["自动驾驶"],"tags":["python","can"]},{"title":"2024年一波三折的Q2","url":"/1057849259.html","content":"距离上一次写博客已经过去了4个月。不是我不想写，实在是有心无力。Q2这段时间经历了太多事情，整个人都不在状态，这里也做个总结，顺便聊一下一些人生感悟。\n3月份主要是在准备面试和面试的过程中，最近行情不太好，投了几家都没面邀，后面就只面了一家，搞自动驾驶的，一共三面，面试过程倒挺轻松的，问的问题也比较符合我现在做的，就是到了谈薪阶段，给不了想要的薪资，最后也是不了了之。\n4月份一直在忙工作上的活，也没时间搞博客。\n5月劳动节放假期间去配了副眼镜，结果度数配高了，戴了几天眼睛都很不舒服，赶紧请了半天假去医院检查了下眼睛，确认眼睛有点发炎，然后度数确实是过高了，只好戴回旧眼镜，想着后面有时间再去重新配一副。然而，痛苦的事情来了。检查完眼睛的下午去参加了公司的团建，席中喝了些白酒，回来后右后槽牙开始隐隐作痛，本身这颗牙之前做过根管治疗。到了半夜，疼的受不了了，抓紧吃了颗布洛芬，模模糊糊睡了过去。到了早上，去牙科诊所看了下，先给我开了点止疼药，说是后面可能需要拔掉。吃了几天的止疼药后，牙齿没有自发疼了，但是有咬合疼。约了个中山大学附属口腔，想着主任能不能有办法只做根管，不用拔牙。但是事与愿违，医生建议还是拔掉，因为做了根管可能保不了半年又会复发，没必要浪费钱。整个人有点恍惚，又约了穗华口腔，想着能不能拯救一下。到了医院，拍了片医生还是建议拔掉，粗略跟医生算了下二次根管的费用和后续种植牙的费用，毅然选择了拔牙。整个过程很快，拔牙后的一周都在喝粥修养。\n到了6月，最痛苦的来了。1号晚上饭还没吃完，突然肚子上腹部疼，到了晚上12点，痛感很明显，自发性绞痛，赶紧吃了粒洛索洛芬钠片，还是没法好受，而且开始怕寒，期间肚子很胀，又拉又吐。到了凌晨3点，痛感更加明显了，钻心痛，汗水直流，实在顶不住了，开始裹着外套出门，本想着去附近医院挂个急诊，结果没开门，赶紧打车去南方医科大学附属医院挂急诊。到了那里，整个人都不好受了，医生也看不出啥，诊断是急性肠胃炎，然后打针挂水，挂到了早上，肚子还是很疼，但是医生看不出来，只好先回来了。到了下午，右下腹开始按压疼，走路都很疼，顶不住了，去附近医院，又是B超又是拍CT，确诊为急性阑尾炎，心里想着先保守治疗吧，所以开始吊针，晚上回来后还是没有效果，晚上还被疼醒了。第二天起来后，肚脐周围都开始按压疼，早上忍着痛去公司上班，实在顶不住了，又去医院挂了一次水，完全没有效果，立马挂了中山大学附属第三医院的胃肠外科，到了医院后，给医生看了确诊急性阑尾炎，立马给我挂了个急诊，让我办理住院。早上六点开始做手术，麻醉很快，九点钟我醒来的时候已经做完手术了，然后整个人迷迷糊糊的被推回了病床，就是一整天都在挂水，下午我就开始下床走动，肚子被开了三个孔，有时候伤口有点疼，还带了个引流管，走路很麻烦。一共住了4天半院，最后一天早上拔了引流管后，下午就出院了。回来后整个人还是很虚，只能喝粥。\n到了今天好了一点，趁还有精力写了下博客，记录下Q2这一波三折的人生经历。从眼睛到牙齿再到阑尾，Q2真是够精彩的。经历了这么多事情，也有了一些自己的感悟。\n✅ 身体是自己的，只有搞好身体，才有赚钱的本钱。✅ 好的心态很重要，心态好对病情恢复很有帮助。✅ 身边有人陪还是挺重要的，一个人孤身看病住院其实挺难熬的。✅ 医保是个好东西，能省很多钱，还有保险也要买。\n","categories":["随笔"],"tags":["年度总结"]},{"title":"Apollo 之 Canbus 解析","url":"/817441275.html","content":"Canbus模块介绍我们先看下什么是Canbus： 控制器局域网 (Controller Area Network，简称CAN或者CAN bus) 是一种车用总线标准。被设计用于在不需要主机(Host)的情况下，允许网络上的节点相互通信。采用广播机制，并利用标识符来定义内容和消息的优先顺序，使得canbus的扩展性良好，同时不基于特殊类型(Host)的节点，增加了升级网络的便利性。这里的Canbus模块其实可以称为Chassis模块，主要的作用是反馈车当前的状态（航向，角度，速度等信息），并且发送控制命令到车线控底盘，可以说Canbus模块是车和自动驾驶软件之间的桥梁。由于这个模块和&quot;drivers/canbus&quot;的联系紧密，因此也一起在这里介绍。Canbus模块是车和自动驾驶软件之间的桥梁，通过canbus驱动(drivers/canbus)来实现将车身信息发送给Apollo上层软件，同时接收控制命令，发送给汽车线控底盘实现对汽车的控制。\n那么canbus模块的输入是什么？输出是什么呢？\n\n可以看到canbus模块：\n\n输入 - 1. ControlCommand（控制命令）\n输出 - 1. Chassis（汽车底盘信息）, 2. ChassisDetail（汽车底盘信息详细信息）\n\nCanbus一方面接收Control模块发布的指令，然后将指令解析为CAN协议报文通过can总线传递给车上的各个控制单元；另一方面从can总线上获取数据并且将信息解析为底盘信息，然后把消息发布出去(反馈底盘信息)。\nCanbus模块的目录结构如下：\n\n接着我们来分析下Canbus模块的执行流程。\nCanbus(主模块)\nCanbus模块的主流程在文件&quot;canbus_component.cc&quot;中，Canbus模块为定时触发，每10ms执行一次，发布chassis信息，而ControlCommand则是每次读取到之后触发回调&quot;OnControlCommand&quot;，发送&quot;control_command&quot;到线控底盘。\nbool CanbusComponent::Proc() &#123;  PublishChassis();  if (FLAGS_enable_chassis_detail_pub) &#123;    PublishChassisDetail();  &#125;  return true;&#125;\n由于不同型号的车辆的canbus命令不一样，在&quot;/vehicle&quot;中适配了不同型号车辆底盘协议的canbus消息格式，所有的车都继承自Vehicle_controller基类，通过对Vehicle_controller的抽象来发送和读取canbus信息。\n车辆工厂模式(VehicleFactory)在vehicle中可以适配不同的车型，而每种车型都对应一个vehicle_controller，创建每种车辆的控制器(VehicleController)和消息管理(MessageManager)流程如下：\nVehicleFactory类通过创建不同的类型AbstractVehicleFactory，每个车型自己的Factory在创建出对应的VehicleController和MessageManager。用林肯来举例子就是： VehicleFactory创建LincolnVehicleFactory，之后通过CreateMessageManager和CreateVehicleController创建对应的控制器（LincolnController）和消息管理器（LincolnMessageManager）。上述代码流程用到了设计模式的工厂模式，通过车辆工厂创造不同的车辆类型。\n车辆控制器(LincolnController)下面以林肯来介绍LincolnController，以及如何接收chassis信息，其它的车型可以以此类推。可以看上面的整体流程图lincoln_controller.cc部分，显然，controller分为三部分init-&gt;start-&gt;stop，init过程是获取MessageManager的protocolData，即发送的消息协议数据类型，然后通过CanSender发送这些消息。如以int为协议来代表的是整数，以char为协议代表的字符。那这个protocolData就是我们以这个类型为协议来替代车辆行驶的具体操作。例如在modules/canbus/vehicle/brake_60.h这个Brake60类的操作就是刹车。start之后启动一个看门狗，检查canbus消息格式是否正确，最后stop模块则是结束看门狗进程。\nCanbus(驱动程序)上层的canbus就介绍完成了，而canbus的发送(CanSender)和接收(CanReceiver)，还有消息管理(MessageManager)都是在&quot;drivers/canbus&quot;中实现的。\n消息管理器(MessageManager)MessageManager，顾名思义就是用于管理所有的msg，主要作用是解析和保存canbus数据。而具体的接收和发送则是在&quot;CanReceiver&quot;和&quot;CanSender&quot;中。使用前需要将所有用户自定义的ProtocolData初始化并将其分为send和receive类加入各自队列中，包含一个Parse接口，会逐一调用所有receive类ProtocolData对象的Parse接口，实现将接受到的CanFrame数据转化为自定义数据类型（例如0x6b的帧中数据为车辆加速度数据，将数据解析到自定义的ChassisDetail中的lateral_acceleration、longitudinal_acceleration、vertical_acceleration变量中），底层有一个unordered_map用于根据id搜索加入的ProtocolData对象，用于将send类对象提取出来供CanSender使用。拿接收消息举例子，也就是说CanReceiver收到消息后，会调用MessageManager中的Parse去解析消息，消息的解析协议在&quot;modules/canbus/vehicle/lincoln/protocol&quot;中，每个消息把自己对应的信息塞到&quot;chassis_detail&quot;中完成了消息的接收。\n消息接收(CanReceiver)CanReceiver中的&quot;Start&quot;调用&quot;RecvThreadFunc&quot;实现消息的接收，这里会启动一个异步进程去完成接收。\ntemplate &lt;typename SensorType&gt;::apollo::common::ErrorCode CanReceiver&lt;SensorType&gt;::Start() &#123;  if (is_init_ == false) &#123;    return ::apollo::common::ErrorCode::CANBUS_ERROR;  &#125;  is_running_.exchange(true);  // 启动异步接收消息  async_result_ = cyber::Async(&amp;CanReceiver&lt;SensorType&gt;::RecvThreadFunc, this);  return ::apollo::common::ErrorCode::OK;&#125;\nRecvThreadFunc通过&quot;can_client_&quot;接收消息，然后通过&quot;MessageManager&quot;去解析消息，在MessageManager中有讲到。\ntemplate &lt;typename SensorType&gt;void CanReceiver&lt;SensorType&gt;::RecvThreadFunc() &#123;  ...  while (IsRunning()) &#123;    std::vector&lt;CanFrame&gt; buf;    int32_t frame_num = MAX_CAN_RECV_FRAME_LEN;    // 1. can_client_接收canbus数据    if (can_client_-&gt;Receive(&amp;buf, &amp;frame_num) !=        ::apollo::common::ErrorCode::OK) &#123;      cyber::USleep(default_period);      continue;    &#125;    ...    for (const auto &amp;frame : buf) &#123;      uint8_t len = frame.len;      uint32_t uid = frame.id;      const uint8_t *data = frame.data;      // 2. MessageManager解析canbus数据      pt_manager_-&gt;Parse(uid, data, len);      if (enable_log_) &#123;        ADEBUG &lt;&lt; &quot;recv_can_frame#&quot; &lt;&lt; frame.CanFrameString();      &#125;    &#125;    cyber::Yield();  &#125;  AINFO &lt;&lt; &quot;Can client receiver thread stopped.&quot;;&#125;\n\n\n\n消息发送(CanSender)消息发送对应的是在CanSender中的&quot;Start&quot;调用&quot;PowerSendThreadFunc&quot;，我们可以看具体实现:\ntemplate &lt;typename SensorType&gt;common::ErrorCode CanSender&lt;SensorType&gt;::Start() &#123;  if (is_running_) &#123;    AERROR &lt;&lt; &quot;Cansender has already started.&quot;;    return common::ErrorCode::CANBUS_ERROR;  &#125;  is_running_ = true;  // 启动线程发送消息  thread_.reset(new std::thread([this] &#123; PowerSendThreadFunc(); &#125;));  return common::ErrorCode::OK;&#125;\nPowerSendThreadFunc再通过&quot;can_client&quot;发送消息：\nstd::vector&lt;CanFrame&gt; can_frames;CanFrame can_frame = message.CanFrame();can_frames.push_back(can_frame);// 通过can_client发送消息if (can_client_-&gt;SendSingleFrame(can_frames) != common::ErrorCode::OK) &#123;    AERROR &lt;&lt; &quot;Send msg failed:&quot; &lt;&lt; can_frame.CanFrameString();&#125;\n\n\n\n\ncanbus客户端(CanClient)CanClient是canbus客户端，同时也是canbus的驱动程序，针对不同的canbus卡，对发送和接收进行封装，并且提供给消息发送和接收控制器使用。拿&quot;EsdCanClient&quot;来举例子，&quot;Send&quot;函数发送can消息，调用的是第三方的硬件驱动canWrite，&quot;Receive&quot;函数接收can消息，调用的是第三方的硬件驱动canRead。其他的can卡可以参考上述的流程，至此整个canbus驱动就分析完成了。\n","categories":["自动驾驶"],"tags":["apollo"]},{"title":"CAN 之报文录制格式","url":"/2276434991.html","content":"前言搞自驾，免不了要跟 CAN 数据打交道，那常见的 CAN 报文录制格式有哪些呢？\nCSVCSV（Comma-Separated Values）以纯文本形式存储表格数据（数字和文本）。\n多用于测试数据，全文本文件，可以用 notepad++，Excel 等软件直接打开。\nASC&#x2F;BLFASC（ASCII）格式为可读的文本文件，该格式文件可以与外部程序进行数据交互，可读性强。支持所有总线信息&#x2F;协议、系统变量、环境变量、内部事件、标记和注释的报文。\nBLF（Binary Logging Format）格式是基于报文的读写格式，是一种二进制日志格式。以二进制格式存储数据，在文件大小和读&#x2F;写性能方面非常高效。支持所有总线信息&#x2F;协议、系统变量、环境变量、内部事件、标记和注释的报文。\n这两种文件主要用于 CANoe&#x2F;CANalyzer 等相关 Vector 软件，用于记录测试数据（ASC 可以用文本直接打开，BLF 需要用 CANoe 进行解析）。\nMDF&#x2F;MF4&#x2F;datMF4（Measurement Data Format version4）格式用于汽车行业以二进制文件格式存储测量数据。CAN、LIN 和 FlexRay 总线信息以 ASAM 标准存储，其他总线系统和协议以Vector-specific 标准存储。支持所有总线信息&#x2F;协议和环境变量。\nMDF（Measurement Data Format）格式分为基于报文的和基于信号的，基于报文的格式只记录报文信息，基于信号的格式只记录信号信息。支持环境变量、统计信息、CAN 信号、LIN 信号、FlexRay 信号、GPS 信号、J1939 信号和 J1587&#x2F;J1708 信号，但是不支持MOST 信号。\n这几种文件主要用于标定工具（如 CANape&#x2F;INCA 等）测试数据的记录。这些数据可以包含不同类型的数据，故在标定领域应用较多。\nA2L&amp;HEX&#x2F;S19A2L 文件是基于 ASAP2 标准，采用 ASAP2 指定的一套类 XML 语言的描述性语言（采用开标签和关标签来描述信息）书写，描述 ECU 的通信等相关的参数，以及标定，观测变量的地址以及物理值计算公式等等的文本格式文件。HEX&#x2F;S19 文件则是对应的地址的参数和数据文件。\n这几种数据也多用于标定领域，从事标定工作的小伙伴肯定不陌生。\n打个不太恰当的比方，如果把车载 ECU 比作一个人，那么 A2L 就是他的骨架，HEX&#x2F;S19 文件就是他的血肉，两者缺一不可。另外需要注意的是每一版软件的 A2L 和 HEX 里的地址是一一对应的，如果错用了HEX 文件就有可能出现数据紊乱的情况，需要特别注意。\n","categories":["自动驾驶"],"tags":["can"]},{"title":"CAN 之 DBC 文件解析（简单版）","url":"/768939725.html","content":"什么是 DBC 文件DBC 是Database Can的缩写，其代表的是CAN的数据库文件。简单地说，通过 CAN 总线通信的数据类型可以用 DBC 文件来读取和理解。一般通过 Vector CANdb++ 进行编辑和查看。\nDBC 文件内容当我们打开一份 DBC 文件时，左侧树形目录对应\n\nNetworks：从网络的视角来观察总线上存在的节点、报文和信号\nECUs：每个 ECU 的 Network Node 和 Environment Variables\nEnvironment Variables：在使用 CANoe 仿真节点时会用到\nNetwork nodes：从单个节点的视角来观察与节点相关的总线报文及信号\nTx Messages：节点发送报文\nRx Messages：节点接收报文\nMapped Tx Signals：节点发送信号\nMapped Rx Signals：节点接收信号\n\n\n\n\nMessages：CAN 总线上传输信息的最小单位\nSignals：Message 里最小的元素单位\n\n值得一提的是，Messages 与 Signals 下包含的报文信号比 Network nodes 下的收发报文信号要多，并且有可能会包含实际没用到的报文信号，因为所有创建的报文信号都会在 Messages 与 Signals 下显示，但只有映射到节点的报文信号才会在 Network nodes 下显示。\n\n因此我们主要看 Network nodes 下里的网络节点，网络节点分为多个类，如下图，分为 SDE、sensor2、sensor3 三个类节点。\n\n当点开节点时，会看到类节点下的 TX 与 RX 下的多个 messages。\n\nID：CAN message id，一般以16进制显示\nName： CAN message name\nID-Format：CAN 报文的类型（CAN Standard&#x2F;CAN FD Standard）\nDLC：数据长度代码，CAN 报文中数据的长度\n\n\n每个 message 又包含了多个 signals。\n\nName：信号的名称\nMultiplexing：多路复用\nStartbit：信号的起始位\nByte Order：信号的位计数，分为 Motorols（大端字节序）和 Intel（小端字节序）\nValue Type：数据类型\nFactor：信号的转换系数\nOffset：信号的转换偏移\nMinimum &amp; Maximum：最小和最大的信号值\nUnit：信号中存在的物理数据的单位\nComment：信号说明\n\n\n其中 factor 因数 与 offse 偏移量 定义了 physical 物理值（如vehicle speed，engine speed,water temperature）与 raw 原始值（总线上传输的值）的线性转换规则。\nphysical_value = raw_value * factor + offsetraw_value = ( pysical_value - offset ) / factor\n\nDBC 文件解析这里使用 Python。首先安装 cantools 这个库文件，可以直接解析 dbc 文件。\npip3 install cantools\n\n使用时，直接 import cantools 即可。\nimport cantoolsdbc_file = &quot;******&quot;dbc_info = cantools.db.load_file(dbc_file)    #创建一个dbc数据库对象\n\n直接使用时，下述附代码，可直接复制使用。\nimport cantoolsclass DbcInfo:    &quot;&quot;&quot;    用于读取dbc文件，返回dbc信息    &quot;&quot;&quot;    def __init__(self, input_file):        &quot;&quot;&quot;        init        &quot;&quot;&quot;        self.dbc_file = input_file        self.dbc_info = cantools.db.load_file(self.dbc_file)    def get_message(self, frame_id):        &quot;&quot;&quot;        return message，特别强调，frame_id输入10进制即可，同时必须是int型数据，不能是字符串        &quot;&quot;&quot;        return self.dbc_info.get_message_by_frame_id(frame_id)   #直接返回message的所有信息    def get_message_name(self, frame_id):        &quot;&quot;&quot;        return message name        &quot;&quot;&quot;        return self.dbc_info.get_message_by_frame_id(frame_id).name    def get_message_name_by_message_id(self, frame_name):        &quot;&quot;&quot;        return message id by message name        &quot;&quot;&quot;        return self.dbc_info.get_message_by_name(frame_name).frame_id    def get_signals_list(self, frame_id):        &quot;&quot;&quot;        return signals list        &quot;&quot;&quot;        return self.dbc_info.get_message_by_frame_id(frame_id).signal_tree    #这里返回的是message中signal的list，包含一个message中所有的signal    def get_signal(self, frame_id, signal_name):        &quot;&quot;&quot;        return signal, 输入message id和signal name        &quot;&quot;&quot;        return self.dbc_info.get_message_by_frame_id(frame_id).get_signal_by_name(signal_name)    def get_signal_config_maximum(self, frame_id, signal_name):        &quot;&quot;&quot;        return signal maximum        &quot;&quot;&quot;        return self.dbc_info.get_message_by_frame_id(frame_id).get_signal_by_name(signal_name).maximum    def get_signal_config_minimum(self, frame_id, signal_name):        &quot;&quot;&quot;        return signal minimum        &quot;&quot;&quot;        return self.dbc_info.get_message_by_frame_id(frame_id).get_signal_by_name(signal_name).minimum    def get_signal_config_scale(self, frame_id, signal_name):        &quot;&quot;&quot;        return signal scale，这里指的是signal定义中其取值范围的间隔，        比如从1到10，每个2取一个值，scale就是2        &quot;&quot;&quot;        return self.dbc_info.get_message_by_frame_id(frame_id).get_signal_by_name(signal_name).scale    def get_signal_config_comment(self, frame_id, signal_name):        &quot;&quot;&quot;        return signal comment，signal说明        &quot;&quot;&quot;        return self.dbc_info.get_message_by_frame_id(frame_id).get_signal_by_name(signal_name).comment    def signal_config_value_description_to_num(self, frame_id, signal_name, value_str):        &quot;&quot;&quot;        return signal value description        这里需要特别说明下，有些signal取值不是正常的数值，而是文字描述，        这个在定义中是个表，比如1：open, 2:close, 4:ignore，        本函数的意思是当你取到这个字符串，比如close时，能够返回这个字符串在对应中的数字2，        这在解析和保存以及后续发送中是很有用的。        &quot;&quot;&quot;        return self.dbc_info.get_message_by_frame_id(frame_id).get_signal_by_name(signal_name).\\            choice_string_to_number(value_str)if __name__ == &#x27;__main__&#x27;:    dbc_info = DbcInfo(&#x27;D:test.dbc&#x27;)    #test，根据自己需求使用上述函数即可    #frame_id输入10进制即可，同时必须是int型数据，不能是字符串    print(dbc_info.get_message_name(520))\n\n如果想进行 can 报文修改，需要注意的是，直接给的数据不一定符合要求，需要保证修改数值在 signal 的最大最小范围内，同时保证该值符合定义中的取值间隔，可采用下述函数进行 check，保证输入数值符合要求。\ndef check_value_meet_norms(self, frame_id, signal_name, value):    &quot;&quot;&quot;    check value meet norms and return closest value based on scale factor    检查输入是否符合规范，同时输出符合规范的最接近输入value值的value    如果你要用脚本修改can报文，但是修改的值如果不符合要求，给入会报错，    该函数保证修改值符合规范且接近用户期望值    &quot;&quot;&quot;    max_value = self.get_signal_config_maximum(frame_id, signal_name)    min_value = self.get_signal_config_minimum(frame_id, signal_name)    scale_value = self.get_signal_config_scale(frame_id, signal_name)    if value &gt; max_value:        if isinstance(scale_value, int):            return int(max_value)        return max_value    elif value &lt; min_value:        if isinstance(scale_value, int):            return int(max_value)        return min_value    else:        num = round(value / scale_value)        if isinstance(scale_value, int):            return int(num * scale_value)        return num * scale_value\n\n参考\ncantools 官方包\n\n","categories":["自动驾驶"],"tags":["python","can"]},{"title":"CAN 之 DBC 文件解析（详细版）","url":"/4096777957.html","content":"前言之前写了一篇简单版的 DBC 文件解析，下面详细介绍下 DBC 文件里的各个字段。\n总体概览DBC文件是以 Tag（标签）来标识每一个元素。\n\n如上图所示，一般 dbc 文件中包含了如下的 8 种信息：\n\n版本与新符号\n波特率定义\n网络节点的定义\n报文帧的定义\n信号的定义\n注解部分\n特征部分\n数值表部分\n\n详细解释版本的定义VERSION 信息可为空，也可以由用户自定义；NS_ 表示 New Symbol，在外面创建 dbc 文件时已经自动生成，所以无需过多留意，默认即可；\n波特率的定义格式为 BS_: [baudrate:BTR1,BTR2]\n其中 BS_ 为关键字，用于定义 CAN 网络的波特率；[] 内容表示为可选部分，可以省略；但关键字 BS_: 必须存在，省略则会出错。《DBC File Format Document》规范中明确提醒，必须保留 BS_: 标签。\n网络节点的定义格式为 BU_: Nodename1 Nodename2 Nodename3 ……\nBU_ 为关键字，表示网络节点；Nodename1、Nodename2 为网络节点名字，由用户自己定义。注意需要保证节点命名的唯一性。\n报文帧的定义格式为 BO_ MessageId MessageName: MessageSize Transmitter\n\nBO_ 为关键字，表示报文；\nMessageId 为报文 ID，是以 10 进制数表示的；\nMessageName 为报文的名字，命名规则和 C 语言变量相同；\nMessageSize 为报文数据域字节数，即数据长度，为无符号整型数据，CAN 2.0 为最大 8 字节，CAN FD  最大 64 字节；\nTransmitter 为该报文的网络节点；如果该报文没有指定发送节点，则该值需设置为 “Vector__XXX”。\n\n用 BO_ 996 HUD_1_B: 8 HUD 来举例，这个报文是由 HUD 这个节点发出的，数据域长度为 8 字节，ID 为 996（0x3E4），名字命名为 HUD_1_B。\n信号的定义格式为 SG_ SignalName (SigTypeDefinition) : StartBit|SignalSize@ByteOrder ValueType (Factor,Offset) [Min|Max] Unit Receiver\n\nSG_ 为关键字，表示信号；\nSignalName 为该信号的名字；\nSigTypeDefinition 是多路选择信号的定义，可选项，有 3 种格式；\n空，表示普通信号；\nM，表示多路选择器信号；\nm50，表示被多路选择器选择的信号，50 表示当 M 定义的信号的值等于 50 的时候，该报文使用此通路；\n\n\nStartBit|SignalSize 表示该信号起始位、信号长度；\nByteOrder 表示信号的字节顺序：0 代表 Motorola 格式，1 代表 Inter 格式；\nValueType 表示该信号的数值类型：+ 表示无符号数，- 表示有符号数；\nFactor,Offset 分别表示因子和偏移量，这两个值用于信号的原始值与物理值之间的转换；\n物理值 &#x3D; 原始值 * 因子 + 偏移量；\n\n\nMin|Max 表示该信号的最小值和最大值，即指定了该信号值的范围；这两个值为 double 类型；\nUnit 表示该信号的物理单位，为字符串类型；\nReceiver 表示该信号的接收节点，若该信号没有指定的接收节点，则必须设置为 “Vector__XXX”。\n\n如示下面的例中：第一个信号 SG_ S_Check : 45|10@0+ (0.00625,0) [0|160] &quot;M&quot; EL3160_60,ESC表示定义了一个命名为 S_Check 的普通信号，其起始位是第 45 位，信号长度 10 bit；信号是 Motorola 格式，数值类型为无符号类型数；因子为 0.00625，偏移量为 0；信号取值范围为 0 到 160；信号物理单位为字符串 “M”，该信号接收节点为 EL3160_60 和 ESC 这两个节点。\n第二个信号 SG_ Send_Mux M : 7|8@0+ (1,0) [0|0] &quot;&quot; EL3160_60,ESC表示定义了一个命名为 Send_Mux 的多路选择器信号，其起始位是第 7 位，信号长度 8 bit；信号是 Motorola 格式，数值类型为无符号类型数；因子为1，偏移量为 0；信号取值范围为 0 到 0；信号物理单位为字符串 “”；该信号接收节点为 EL3160_60 和 ESC 这两个节点。该信号做选择通道使用。\n第三个信号 SG_ S_Level_A_Voltage m50 : 15|16@0+ (0.00625,0) [0|160] &quot;V&quot; EL3160_60,ESC表示定义了一个命名为 S_Level_A_Voltage 的被选择信号，其起始位是第 15 位，信号长度 16 bit；信号是 Motorola 格式，数值类型为无符号类型数；因子为 0.00625，偏移量为 0；信号取值范围为 0 到 160；信号物理单位为字符串 “V”；该信号接收节点为 EL3160_60 和 ESC 这两个节点。Send_Mux 作为选择通路使用，这个例子中，当 Send_Mux 等于 50、51、52、54 时，代表后面的选择的通路。\n注解部分格式为 CM_ Object MessageId/NodeName &quot;Comment&quot;\n\nCM_ 为关键字，表示注解信息；\nObject 表示进行注解的对象类型，可以是节点 BU_、报文 BO_、消息 SG_；\nMessageId/NodeName 表示进行注解的对象，若前面的对象类型是信号或者报文，则这里的值应为报文的 ID（10 进制数表示）；若前面的对象类型为节点，则这里的值应为节点的名字；\nComment 表示进行注解的文本信息；\n\n如示例中的 CM_ SG_ 996 HUD_HeightLv &quot;Control hud height level&quot;;表示对 ID 为 996（0x3E4）这条报文下的名为 “HUD_HeightLv” 的信号进行注解说明，说明的内容为 “Control hud height level”。\n注意注释以 “” 包围，注释内部不允许再出现双引号。\n特征定义部分和特征相关的 Tag 一共有三条：\n\nBA_DEF_  特征名称类型定义。格式为 BA_DEF_ Object AttributeName ValueType Min Max;   - BA_DEF 标签\n\nObject 特征类型，可以是 BU_（节点特征定义）、BO_（报文特征定义）、SG_（信号特征定义）、空格（项目特征定义）；\n\nAttributeName 特征名称（C 语言变量格式）\n\nValueType 特征值类型（只能是十进制、十六进制、浮点数、枚举、字符 5 种类型）\n\nMin Max 数值类型这里出现范围，枚举类型这里是枚举值，字符类型，这里是空。\n\nBA_DEF_DEF_ 特征默认值定义。格式为 BA_DEF_DEF_ AttributeName DefaultValue;\n\nBA_DEF_DEF_ 标签\nAttributeName 特征名称（C 语言变量格式）\nDefaultValue 该特征的默认设置值\n\n\nBA_ 特征项目设置值定义，格式为 BA_ AttributeName projectValue;\n\nBA_ 标签\nAttributeName 特征名称（C 语言变量格式）\nprojectValue 该特征的设置值\n\n\n\n举例：BA_DEF_ BO_ &quot;GenMsgCycleTime&quot; INT 0 65535; BA_DEF_DEF_ &quot;GenMsgCycleTime&quot; 2200; BA_ &quot;GenMsgCycleTime&quot; BO_ 400 100;\n表示对定义了一个针对消息类型的特征，特征名为 “GenMsgCycleTime”，特征值是整型数据，取值范围在 0 到 65535 之间；默认值为 2200；项目设置值 “CAN ID &#x3D;&#x3D; 400” 的消息，其特征值设置为 100；\n数值表部分格式为 VAL_ MessageId SignalName N &quot;DefineN&quot; …… 0 &quot;Define0&quot;\n\nVAL_ 为关键字，表示数值表定义\nMessageId 表示该信号所属的报文 ID（10 进制数表示）\nSignalName 表示信号名\nN “DefineN” …… 0 “Define0” 表示定义的数值表内容，即该信号的有效值分别用什么符号表示\n\n如示例中的 VAL_ 996 HUD_OffSt 1 &quot;Active&quot; 0 &quot;Not Active&quot;;\n表示对 ID 为 996（0x3E4）的这条报文下的，一个命名为 “HUD_OffSt” 的信号，进行其数值表的定义；用 “Active” 取代 1；用 “Not Active” 取代 0。只有自然数类型的信号才可以使用数值表表示。\n","categories":["自动驾驶"],"tags":["can"]},{"title":"Cloudflare 解析 ORG 域名","url":"/1263441363.html","content":"前言我们有了自己的域名，那么怎么让域名与我们的 ip 产生联系呢。 这个时候我们就可以使用 CDN 服务商来进行 DNS 解析。\n但是，我之前申请的是 .org 这种顶级域名，这类域名在国内没有获得国家工信部备案审批，不能在国内备案。对这类不能在国内备案的域名，是不能用阿里云腾讯云这些国内注册服务商进行 DNS 解析的。\n怎么搞，这时就得用上  Cloudflare 这样的 CDN 服务商来进行 DNS 解析了。\n注册账号进入官网，右上角默认的是 English(US)，可以点击 English(US) 切换到简体中文，然后注册一个账号。\n\n添加站点登录到 Cloudflare 账户后，我们需要添加一个站点，也就是你申请到的域名。\n\n选择域名解析方案进入选择套餐界面，选择免费的解析套餐，点 Continue；\n\n更改名服务器Cloudflare 会为你提供两个新的域名服务器（Name Server）地址。\n\n你需要在你的域名注册商处更新你的域名服务器设置，将现有的域名服务器替换为 Cloudflare 提供的地址。这一步使得你的域名流量经过 Cloudflare 的网络。\n比如我是 en.org 的。登陆 eu.org 后台，找到Nameservers\n\n将上面申请的两组 Nameservers 填入 Name1 和 Name2\n\n确认提交，等待 NS 记录生效后，Cloudflare会进行验证。这可能需要一些时间，一般是 24 小时之内会有 Cloudflare 的邮件通知。我们可以先回到Cloudflare界面，点击完成。\n\n安全性设置（可选）设置 SSL 安全为 strict\n设置自动 https 重写在SSL/TLS-&gt;边缘证书中开启“始终使用 HTTPS”。注意，这里的“始终使用 HTTPS”选项不能和 nginx 端同时开启，两端只能开启一个，否则会出错。\n\n打开速度优化\n设置 DNS 记录完成上面的步骤后，点击 DNS ，进行主域名的 ip 解析。通过 A 记录解析我们的 ip 地址。设置好解析记录后，等待 5 分钟，就可以 ping 通这个域名了。\n\n记得把代理状态设置为仅限 DNS，即不开启小云朵。\n小云朵开启表示：完全代理，让 Cloudflare 完全代理网站，这样可以避免用户检测到真实的服务器 ip，每次检测都是 Cloudflare 公司的节点 ip；小云朵关闭（灰色）就表示：不使用 Cloudflare 的节点代理，相当于直连到你的服务器。\n特别是如果你使用了 Nginx Proxy Manager 进行域名反代，就不能开启小云朵。\n","categories":["折腾系列"],"tags":["建站","域名"]},{"title":"Github Action 自动化部署 Hexo 博客","url":"/165643616.html","content":"前言每次部署 Hexo 都需要运行 hexo clean &amp; hexo g &amp; hexo d 指令三件套完成推送到远程仓库，随着文章越来越多，编译的时间也会越来越长。\nGithub Actions 可以很方便实现 CI&#x2F;CD 工作流，类似 Travis 的用法，来帮我们完成一些工作，比如实现自动化测试、打包、部署等操作。当我们运行 Jobs 时，它会创建一个容器 (runner)，容器支持：Ubuntu、Windows 和 MacOS 等系统，在容器中我们可以安装软件，利用安装的软件帮我们处理一些数据，然后把处理好的数据推送到某个地方。\n通过 Github Actions，我们只需要在每次完成博客的编写或修改以后，将改动直接 push 到远程仓库，之后的编译部署的工作统统交给 CI 来完成即可。\n创建仓库为什么还要创建新的仓库呢，我们之前根据 Hexo 博客搭建部署的 Hexo 博客，your.github.io 这个仓库是用来存放静态博客页面，只有前端页面的文件，所以我们需要创建一个私有仓库存放 Hexo 项目源码，下面用HexoBlog称呼。\n\n上传仓库代码创建完私有仓库后，在本地博客文件中复制几个文件到另外一个文件夹，其中包括.github，scaffolds，source，themes，.gitignore，_config.yml，package.json，package-lock.json还有一个很重要的一步：在.gitignore中添加themes/keep/.git，不然没法提交代码。\ngit initgit add .git commit -m &quot;first commit&quot;git remote add origin git@github.com:用户名/自动化仓库名.gitgit push -u origin master\n\n生成部署密钥任意目录下，ssh-keygen -f github-deploy-key，然后一路按回车直到生成成功。当前目录下会有github-deploy-key和github-deploy-key.pub两个文件。\n复制github-deploy-key文件内容，在 Github 的HexoBlog仓库点击Settings -&gt; Secrets and variables -&gt; Actions -&gt; New repository secret页面上添加。\n\n在Name输入框填写HEXO_DEPLOY_PRI；\n在Value输入框填写github-deploy-key文件内容；\n\n复制github-deploy-key.pub文件内容，在 Github 的your.github.io仓库点击Settings -&gt; Deploy keys -&gt; Add deploy key页面上添加。\n\n在Title输入框填写HEXO_DEPLOY_PUB；\n在Key输入框填写github-deploy-key.pub文件内容；\n勾选Allow write access选项；\n\n编写 Github Actions在本地HexoBlog根目录下创建.github/workflows/deploy.yml文件，目录结构如下。\nblog (repository)└── .github    └── workflows        └── deploy.yml\n在deploy.yml文件中粘贴以下内容。\nname: CI  # 自动部署on:  push:    branches:      - masterenv:  GIT_USER: xxx  GIT_EMAIL: xxx  THEME_REPO: XPoet/hexo-theme-keep   # Hexo所使用的主题的仓库  THEME_BRANCH: master  DEPLOY_REPO: FelicxFoster/FelicxFoster.github.io    # Hexo编译后要部署的仓库  DEPLOY_BRANCH: masterjobs:  build:    name: Build on node $&#123;&#123; matrix.node_version &#125;&#125; and $&#123;&#123; matrix.os &#125;&#125;    runs-on: ubuntu-latest    strategy:      matrix:        os: [ubuntu-latest]        node_version: [16.x]    steps:      - name: Checkout        uses: actions/checkout@v4      - name: Checkout theme repo        uses: actions/checkout@v4        with:          repository: $&#123;&#123; env.THEME_REPO &#125;&#125;          ref: $&#123;&#123; env.THEME_BRANCH &#125;&#125;          path: themes/keep     # 主题路径      - name: Checkout deploy repo        uses: actions/checkout@v4        with:          repository: $&#123;&#123; env.DEPLOY_REPO &#125;&#125;          ref: $&#123;&#123; env.DEPLOY_BRANCH &#125;&#125;          path: .deploy_git      - name: Use Node.js $&#123;&#123; matrix.node_version &#125;&#125;        uses: actions/setup-node@v4        with:          node-version: $&#123;&#123; matrix.node_version &#125;&#125;      - name: Configuration environment        env:          HEXO_DEPLOY_PRI: $&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125;        run: |          sudo timedatectl set-timezone &quot;Asia/Shanghai&quot;          mkdir -p ~/.ssh/          echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa          chmod 600 ~/.ssh/id_rsa          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts          git config --global user.name $GIT_USER          git config --global user.email $GIT_EMAIL      - name: Install dependencies        run: |          npm install      - name: Deploy hexo        run: |          npm run deploy\n\n查看部署git add .git commit -m &quot;&quot;git push\n重新提交后，即可在 Github 的HexoBlog仓库查看Actions部署结果。\n","categories":["折腾系列"],"tags":["hexo"]},{"title":"Coursera 视频无法播放问题解决","url":"/2693822199.html","content":"前言碎碎念：本来这篇文章是挂 CSDN 的，老说我翻墙不给我审核通过，没办法只好迁来自己的博客了。\n最近想看下 coursera 上的课程，却发现视频加载不出来，挂了 VPN 也不好用。\n解决方法在浏览器上按 F12 调用 console 窗口查看发现 d3c33hcgiwev3.cloudfront.net 网站无法访问。只能想办法改 hosts 绕过去。\n以下是 Windows 系统修改hosts，其他系统类似：\n\n用管理员权限打开 hosts 文件(C:\\Windows\\System32\\drivers\\etc)\n将下面内容复制到文件末尾并保存：\n\n# coursera ip54.230.96.102\t\t\td3c33hcgiwev3.cloudfront.net54.230.96.174\t\t\td3c33hcgiwev3.cloudfront.net54.230.96.221\t\t\td3c33hcgiwev3.cloudfront.net54.230.96.57\t\t\td3c33hcgiwev3.cloudfront.net54.192.99.52\t\t\td3njjcbhbojbot.cloudfront.net54.192.99.85\t\t\td3njjcbhbojbot.cloudfront.net54.192.99.124\t\t\td3njjcbhbojbot.cloudfront.net54.192.99.42\t\t\td3njjcbhbojbot.cloudfront.net\n\n\n刷新 DNS 缓存在 cmd 里面输入 ipconfig /flushdns 命令后按回车\n\n更新：有朋友说 ip 失效了。正常，因为 coursera 是动态 ip，会经常变的。这里贴一个授之以渔的方法：用这个在线解析工具 在输入框里输入域名 d3c33hcgiwev3.cloudfront.net （如果打不开这个在线解析工具，可以百度找其他的在线解析工具）他就会返回一连串的 ip 地址\n\n替换 hosts 文件里的 ip 即可。\nPS：发现知乎有人（不为谁而读的研）盗用我文章，无所谓啦，这正好说明我这篇文章是对大家有帮助的，不然别人也不会抄。\n","categories":["工具脚本"],"tags":["course"]},{"title":"Docusaurus 搭建个人知识库","url":"/2483129101.html","content":"前言博客是用来展示自己的，想写啥就写啥，所以会比较杂。而 Wiki 更偏向于电子百科，可以作为个人知识库。市面上有很多优秀的 Wiki 系统，但我不想花钱买数据库服务，只能找不需要数据库的这一类系统。因此找到了 Docusaurus ，支持用 jsx 语法的 markdown，无缝结合 React。具体效果可以参考我的 Wiki\nDocusaurus 安装主要参考了官方文档\n系统需求Node.js &gt;&#x3D; 16.14 或 yarn &gt;&#x3D; 1.5\n创建站点安装 Docusaurus 的最简单方法是使用命令行工具，该工具会搭建 Docusaurus 网站骨架。\n在新的空存储库中或现有存储库中的任何位置运行此命令，将创建一个包含支架文件的新目录，并自动下载安装需要的库。\nnpx create-docusaurus@latest my-website classic# `my-website` 为你想要创建的目录，`classic` 为你想要用的模板# 也可以选择 `facebook`、`bootstrap` 等模板\n\n运行站点要在编辑文件时预览更改，可以运行一个本地服务器并启动你的网站，最新更改就能立即反映出来了。\ncd my-websitenpm start\n\n默认情况下，浏览器将打开 http://localhost:3000 网址。\n恭喜你！您刚刚创建了第一个 Docusaurus 网站！浏览网站以查看可用内容吧。\n配置站点信息由于我只是想搭建个人知识库，因为已经搭建好了个人博客，所以修改了下 docusaurus.config.js 中的presets，删除了 blog 页面，只保留 Docs\npresets: [  [    &#x27;classic&#x27;,    /** @type &#123;import(&#x27;@docusaurus/preset-classic&#x27;).Options&#125; */    (&#123;      docs: &#123;        sidebarPath: &#x27;./sidebars.js&#x27;,        // Please change this to your repo.        // Remove this to remove the &quot;edit this page&quot; links.        editUrl:          &#x27;https://github.com/FelicxFoster/WikiPage/tree/master&#x27;,      &#125;,      theme: &#123;        customCss: &#x27;./src/css/custom.css&#x27;,      &#125;,    &#125;),  ],],\n\n找到 docusaurus.config.js 中的 navbar，注释掉 blog 那一行\nnavbar: &#123;  title: &#x27;YOLOのWiki&#x27;,  logo: &#123;    alt: &#x27;YOLOのWiki Logo&#x27;,    src: &#x27;img/logo.svg&#x27;,  &#125;,  items: [    &#123;      type: &#x27;docSidebar&#x27;,      sidebarId: &#x27;tutorialSidebar&#x27;,      position: &#x27;left&#x27;,      label: &#x27;Note&#x27;,    &#125;,    // &#123;to: &#x27;/blog&#x27;, label: &#x27;Blog&#x27;, position: &#x27;left&#x27;&#125;,    &#123;      href: &#x27;https://github.com/FelicxFoster/&#x27;,      label: &#x27;GitHub&#x27;,      position: &#x27;right&#x27;,    &#125;,  ],&#125;,\n\nDocusaurus 部署Vercel 有个好处，可以自动编译并部署，所以只需要把代码提交到 Github 仓库，并在 Vercel 里 import 该仓库就可以了。\n由于每次部署 Vercel 编译需要时间太久，所以尽量在本地调试好再推送到 Vercel。\nnpm run build       # 编译生成 build 文件npm run serve       # 可视化编译的效果\n\nDocusaurus 美化搜索插件Docusaurus 默认是没有搜索功能的，这里使用 docusaurus-search-local 这款本地搜索插件来实现。\n插件安装npm i @easyops-cn/docusaurus-search-local\n\n配置在 docusaurus.config.js 中的 config 内容中新增，与 themeConfig 同级\nthemes: [  [    require.resolve(&quot;@easyops-cn/docusaurus-search-local&quot;),    &#123;      hashed: true,      language: [&quot;en&quot;, &quot;zh&quot;],      highlightSearchTermsOnTargetPage: true,      explicitSearchResultPath: true,    &#125;,  ],],\n\n配置完后，可能会报错，显示 Module not found: Error: Can&#39;t resolve &#39;@theme/SearchPage&#39;，不用担心，根据 issue，只需要重新 npm start 即可。\n语法高亮Docusaurus 默认使用 prismjs 进行代码块的语法高亮，但是需要自己安装这个库，下面参考Docusaurus 代码块。\n库安装npm i prismjs\n\n配置安装完后，使用 3 个反引号包裹文本块，就可以实现代码块高亮了，比如\n```js console.log(&#x27;每个仓库都应该有个吉祥物。&#x27;); ```\n\n但是 prismjs 默认只有部分语言可以高亮，像 bash、poweshell 这些，需要在 docusaurus.config.js 中的 prism 内容中新增 additionalLanguages，如下所示，具体要添加的内容，可以在 Supported languages 中查找。\nprism: &#123;  theme: prismThemes.github,  darkTheme: prismThemes.dracula,  additionalLanguages: [&#x27;Bash&#x27;],&#125;,\n\n注意添加了 additionalLanguages，需要重新启动 Docusaurus 才能生效。\nemoji 使用想要在文档中添加 emoji，如📝，需要安装 remark-emoji 库。\n库安装npm i remark-emoji\n\n更改字体Docusaurus 默认字体有点不好看，本站使用霞鹜文楷来替换。\n法一在 releases 下载想要的 ttf 字体（我选的是 LXGWWenKai-Bold.ttf ），放在 Docusaurus 项目的 static&#x2F;font 目录下。\n修改 src&#x2F;css&#x2F;custom.css 添加字体 ，在最前面添加如下内容：\n@font-face &#123;  font-family: &#x27;LXGWWenKai Regular&#x27;;  src: url(&#x27;/font/LXGWWenKai-Regular.ttf&#x27;);&#125;\n\n设置 ifm-font-family-base:\n:root &#123;  ...  --ifm-font-family-base: &quot;LXGWWenKai Regular&quot;;&#125;\n\n保存即可生效。\n法二上面这种方法每次都要在网页端加载 ttf 字体，会导致网页加载很慢。其实我们可以使用 CDN，网页加载时只需获取所使用的文字所在的分包，大幅降低所需加载的大小，从而提升网页加载速度。\n参考 lxgw-wenkai-webfont 的使用文档，先安装字体\nnpm install --save lxgw-wenkai-webfont\n\n然后将 CDN 地址添加到 docusaurus.config.js 的 stylesheets 属性（与 themes 配置同一级）\nstylesheets: [  // String format.  &#x27;https://docusaurus.io/style.css&#x27;,  // Object format.  &#123;    href: &#x27;https://cdn.bootcdn.net/ajax/libs/lxgw-wenkai-webfont/1.7.0/style.min.css&#x27;,  &#125;,],\n\n最后像上面一样修改 src&#x2F;css&#x2F;custom.css 的 :root 属性（注意和上面的有点区别）\n:root &#123;  ...  --ifm-font-family-base: &quot;LXGW WenKai&quot;;&#125;\n\n","categories":["折腾系列"],"tags":["docusaurus"]},{"title":"Halo1.0 博客搭建","url":"/4287437300.html","content":"Halo1.0博客搭建简介Halo [ˈheɪloʊ]，意为光环。当然，你也可以当成拼音读(哈喽)。轻快，简洁，功能强大，使用 Java 开发的博客系统。\n使用 Docker 部署 Halo本篇教程以 CentOS 7.9 为例，其他系统大同小异。\n环境要求推荐的配置：\n\nCentOS 7.x\n1G 以上内存\n\n服务器配置更新软件包请确保服务器的软件包已经是最新的。\nsudo yum update -y\n\n创建 Halo 用户推荐创建一个低权限的用户运行 halo：\n创建一个名为 halo 的用户（名字可以随意）\nuseradd -m halo\n\n给予 sudo 权限\nusermod -aG wheel halo\n\n为 halo 用户创建密码\npasswd halo\n\n登录到 halo 用户\nsu - halo\n\n配置 Docker 运行环境安装Docker必要依赖sudo yum install -y yum-utils device-mapper-persistent-data lvm2\n\n添加软件源信息sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n\n更新 yum 缓存sudo yum makecache fast\n\n安装 Dockersudo yum install docker-ce docker-ce-cli containerd.io\n\n启动 Docker 后台服务sudo systemctl start docker\n\n允许当前用户直接运行 docker 命令需要将当前用户加入 docker 用户组。这样每次运行 docker 命令的时候，就不需要加 sudo。\nsudo usermod -aG docker halo(your_name)\n\n\n注意：设置成功之后需要重新登录才会生效。\n\n镜像加速# 新建 daemon.json 文件sudo vim /etc/docker/daemon.json\n\n将下面的配置复制进去即可：\n&#123;  &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot; ,  &quot;https://docker.mirrors.ustc.edu.cn&quot; ,  &quot;https://zxwb55s8.mirror.aliyuncs.com&quot;]&#125;\n\n\n注意：修改完配置文件之后需要执行 service docker restart 才可生效。\n\n安装 Halo自定义配置文件考虑到部分用户的需要，可能需要自定义比如端口等设置项，我们提供了公共的配置文件，并且该配置文件是完全独立于安装包的。当然，你也可以使用安装包内的默认配置文件，但是安装包内的配置文件是不可修改的。请注意：配置文件的路径为 ~/.halo/application.yaml。\n# 下载配置文件到 ~/.halo 目录curl -o ~/.halo/application.yaml --create-dirs https://dl.halo.run/config/application-template.yaml\n\n修改配置文件完成上一步操作，我们就可以自己配置 Halo 的运行端口，以及数据库相关的配置了。\n# 使用 Vim 工具修改配置文件vim ~/.halo/application.yaml\n\n打开之后我们可以看到：\nserver:  port: 8090  # Response data gzip.  compression:    enabled: falsespring:  datasource:    # H2 database configuration.    driver-class-name: org.h2.Driver    url: jdbc:h2:file:~/.halo/db/halo    username: admin    password: 123456    # MySQL database configuration.#    driver-class-name: com.mysql.cj.jdbc.Driver#    url: jdbc:mysql://127.0.0.1:3306/halodb?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true#    username: root#    password: 123456  # H2 database console configuration.  h2:    console:      settings:        web-allow-others: false      path: /h2-console      enabled: falsehalo:  # Your admin client path is https://your-domain/&#123;admin-path&#125;  admin-path: admin  # memory or level  cache: memory\n\n\n如果需要自定义端口，修改 server 节点下的 port 即可。\n默认使用的是 H2 Database 数据库，这是一种嵌入式的数据库，使用起来非常方便。需要注意的是，默认的用户名和密码为 admin 和 123456，这个是自定义的，最好将其修改，并妥善保存。\n如果需要使用 MySQL 数据库，需要将 H2 Database 的所有相关配置都注释掉，并取消 MySQL 的相关配置。另外，MySQL 的默认数据库名为 halodb，请自行配置 MySQL 并创建数据库，以及修改配置文件中的用户名和密码。\nh2 节点为 H2 Database 的控制台配置，默认是关闭的，如需使用请将 h2.console.settings.web-allow-others 和 h2.console.enabled 设置为 true。控制台地址即为 域名/h2-console。注意：非紧急情况，不建议开启该配置。\nserver.compression.enabled 为 Gzip 功能配置，如有需要请设置为 true，需要注意的是，如果你使用 Nginx 或者 Caddy 进行反向代理的话，默认是有开启 Gzip 的，所以这里可以保持默认。\nhalo.admin-path 为后台管理的根路径，默认为 admin，如果你害怕别人猜出来默认的 admin（就算猜出来，对方什么都做不了），请自行设置。仅支持一级，且前后不带 /。\nhalo.cache 为系统缓存形式的配置，可选 memory 和 level，默认为 memory，将数据缓存到内存，使用该方式的话，重启应用会导致缓存清空。如果选择 level，则会将数据缓存到磁盘，重启不会清空缓存。如不知道如何选择，建议默认。\n\n拉取最新 Halo 镜像sudo docker pull ruibaby/halo\n\n创建容器并运行docker run --rm -it -d --name halo -p 8090:8090  -v ~/.halo:/root/.halo ruibaby/halo\n\n\n–rm：停止之后自动删除容器。\n–name：容器名。\n-p：占用端口，前者为宿主机端口，后者为 Halo 的运行端口，可在 application.yaml 配置。\n-v：目录映射，一般不要修改。\n\n完成以上操作即可通过 ip:端口 访问了。不过在此之前，最好先完成后续操作，我们还需要让域名也可以访问到 Halo，请继续往下看。\n更新 Halo 版本# 停止容器sudo docker stop halo# 拉取最新的 Halo 镜像sudo docker pull ruibaby/halo# 创建容器docker run --rm -it -d --name halo -p 8090:8090  -v ~/.halo:/root/.halo ruibaby/halo\n\n配置域名访问预备条件1、请确保域名已经成功解析到服务器 IP，可以通过ping域名看是否成功。\n2、请检查服务器的 80 和 443 端口是否开放。\n3、请开放宿主机端口，我上面的是8090。\n使用 Caddy 进行反向代理Caddy 是一款使用 Go 语言开发的 Web 服务器。其配置更为简洁，并可以自动申请及配置 SSL 证书（推荐）。\n也可以用Nginx反向代理，具体可以参考\n安装 Caddy# 安装 Caddy 软件包yum install caddy -y\n\n配置 Caddy# 下载 Halo 官方的 Caddy 配置模板curl -o /etc/caddy/conf.d/Caddyfile.conf --create-dirs https://dl.halo.run/config/Caddyfile\n\n下载完成之后，我们还需要对其进行修改。\n# 使用 vim 编辑 Caddyfilevim /etc/caddy/conf.d/Caddyfile.conf\n\n打开之后我们可以看到\nhttps://www.simple.com &#123; gzip tls xxxx@xxx.xx proxy / localhost:port &#123;  transparent &#125;&#125;\n\n\n请把 https://www.simple.com 改为自己的域名。\ntls 后面的 xxxx@xxx.xx 改为自己的邮箱地址，这是用于自动申请 SSL 证书用的。需要注意的是，不需要你自己配置 SSL 证书，而且会自动帮你续签。\nlocalhost:port 请将 port 修改为 Halo 的运行端口，默认为 8090。\n\n比如我的\nfelicx.xyz &#123; gzip tls xxx@xxx.com proxy / localhost:8090 &#123;  transparent &#125;&#125;\n\n修改完成之后启动 Caddy 服务即可。\n# 开启自启 Caddy 服务systemctl enable caddy# 启动 Caddyservice caddy start# 停止运行 Caddyservice caddy stop# 重启 Caddyservice caddy restart# 查看 Caddy 运行状态service caddy status\n\n到这一步你就能通过域名访问了，这是我的博客。\n","categories":["折腾系列"],"tags":["halo"]},{"title":"Halo2.0 博客搭建","url":"/3594890502.html","content":"前言之前在 Halo 1.0 时，是直接使用 jar 部署的，每次更新啥都还是有点麻烦，这次直接使用 Docker Compose 部署，省时省事，建站必备。\n环境搭建因为是使用 Docker Compose 部署，所以需要安装 Docker 和 Docker Compose 。\nDocker 安装主要是参考官方文档安装。\n\nUninstall old versionsfor pkg in docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; do sudo apt-get remove $pkg; done\nSet up Docker’s apt repository# Add Docker&#x27;s official GPG key:sudo apt-get updatesudo apt-get install ca-certificates curl gnupgsudo install -m 0755 -d /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpgsudo chmod a+r /etc/apt/keyrings/docker.gpg# Add the repository to Apt sources:echo \\  &quot;deb [arch=&quot;$(dpkg --print-architecture)&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\  &quot;$(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;)&quot; stable&quot; | \\  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullsudo apt-get update\nInstall the latest version Docker packagessudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\nVerify that the Docker Engine installationsudo docker --version\nUse docker without sudosudo groupadd dockersudo usermod -aG docker $USERgrep docker /etc/group\n\nDocker Compose 安装主要是参考官方文档安装。\n\ndownload and install the Compose CLI plugincurl -SL https://github.com/docker/compose/releases/download/v2.23.0/docker-compose-linux-x86_64 -o /usr/local/lib/docker/cli-plugins/docker-compose\n可能服务器没法下载github的链接，可以本地下载 docker-compose-linux-x86_64 这个文件，改名字成 docker-compose ，然后 scp 传到服务器/usr/local/lib/docker/cli-plugins/这个路径下\nApply executable permissions to the binarysudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose\nTest the installationdocker compose versionDocker Compose version v2.23.0\n\n创建容器组\n在系统任意位置创建一个文件夹，我用的是之前 1.0 时候的 ~&#x2F;halomkdir ~/halo &amp;&amp; cd ~/halo\n创建 docker-compose.yaml这里创建 Halo + MySQL 的实例version: &quot;3&quot;services:  halo:    image: halohub/halo:2.10    container_name: halo    restart: on-failure:3    depends_on:      halodb:        condition: service_healthy    networks:      halo_network:    volumes:      - ./halo2:/root/.halo2    ports:      - &quot;8090:8090&quot;    healthcheck:      test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:8090/actuator/health/readiness&quot;]      interval: 30s      timeout: 5s      retries: 5      start_period: 30s    command:      - --spring.r2dbc.url=r2dbc:pool:mysql://halodb:3306/halo      - --spring.r2dbc.username=root      # MySQL 的密码，请保证与下方 MYSQL_ROOT_PASSWORD 的变量值一致。      - --spring.r2dbc.password=o#DwN&amp;JSa56      - --spring.sql.init.platform=mysql      # 外部访问地址，如果设置了域名反代直接写https://xxx.com，没有就先把localhost替换成服务器ip，后面设置了域名反代再修改      - --halo.external-url=http://localhost:8090/  halodb:    image: mysql:8.1.0    container_name: halodb    restart: on-failure:3    networks:      halo_network:    command:      - --default-authentication-plugin=caching_sha2_password      - --character-set-server=utf8mb4      - --collation-server=utf8mb4_general_ci      - --explicit_defaults_for_timestamp=true    volumes:      - ./mysql:/var/lib/mysql      - ./mysqlBackup:/data/mysqlBackup    ports:      - &quot;3306:3306&quot;    healthcheck:      test: [&quot;CMD&quot;, &quot;mysqladmin&quot;, &quot;ping&quot;, &quot;-h&quot;, &quot;127.0.0.1&quot;, &quot;--silent&quot;]      interval: 3s      retries: 5      start_period: 30s    environment:      # 请修改此密码，并对应修改上方 Halo 服务的 SPRING_R2DBC_PASSWORD 变量值      - MYSQL_ROOT_PASSWORD=o#DwN&amp;JSa56      - MYSQL_DATABASE=halonetworks:  halo_network:\n启动 Halo 服务第一次会自动下载 halo 和 halodb 镜像# 进入 ~/halo 目录下，启动 halodocker compose up -d# 关闭 halodocker compose down# 实时查看日志docker compose logs -f\n用浏览器访问http://ip:端口号/console即可进入 Halo 管理页面，首次启动会进入初始化页面，可以设置密码、导入文件这些\n\nHalo 1.0数据迁移安装插件因为 Halo 2.0 的底层架构变动，无法兼容 1.x 的数据，导致无法平滑升级。所以需要使用官方给的迁移插件，才能进行数据迁移。\n点击侧边栏应用市场，搜索安装一下几个插件：\n\n站点迁移\n站点迁移：https://halo.run/store/apps/app-TlUBt\n\n\nMarkdown 编辑器插件\nStackEdit：https://halo.run/store/apps/app-hDXMG\nByteMD：https://halo.run/store/apps/app-HTyhC\n\n\n友情链接、日志、图库插件\n链接管理：https://halo.run/store/apps/app-hfbQg\n图库：https://halo.run/store/apps/app-BmQJW\n瞬间（原日志）：https://halo.run/store/apps/app-SnwWD\n\n\n\n导出 Halo 1.0 数据在 Halo 1.0 后台，依次点击系统-小工具-博客备份-数据导出，将json格式数据下载。\n数据导入 Halo 2.0\n安装完插件后，点击左侧菜单的迁移进入迁移页面。\n点击选择文件按钮，选择在 Halo 1.0 导出的数据文件（JSON 格式）。\n如果在 1.0 中使用了云存储，会弹出选择云存储的对话框，选择之前创建的存储策略即可。\n最后点击页面下方的执行导入即可。\n\n反向代理做完上面的操作，你就可以通过http://ip:端口号/来访问你的博客了，和之前 Halo 1.0 内容应该差别不大。但是你肯定不想暴露自己的ip和端口到公网，那就需要用到反代神器 Nginx Proxy Manager(NPM) 了。\nNPM 介绍顾名思义，Nginx Proxy Manager 就是一个 Nginx 的代理管理器，它最大的特点是简单方便。\n即使是没有 Nginx 基础的小伙伴，也能轻松地用它来完成反向代理的操作，而且因为自带面板，操作极其简单，非常适合配合 docker 搭建的应用使用。\nNginx Proxy Manager 后台还可以一键申请 SSL 证书，并且会自动续期，方便省心。\n下面我们就来介绍如何用 Nginx Proxy Manger 来配合 Halo，实现反向代理和 HTTPS 访问。\nNPM 安装\n停止 nginx、apache2、halo 1.0，不然会占用端口# 关闭进程sudo service nginx stopsudo service apache2 stopsudo service halo stop# 禁止开机自启动sudo systemctl disable nginx.servicesudo systemctl disable apache2.servicesudo systemctl disable halo.service\n创建一个文件夹来存放 NPM 的数据和证书mkdir -p ~/data/docker_data/nginxproxymanager\n修改上面 ~&#x2F;halo&#x2F;docker-compose.yaml 文件，将 NPM 和 Halo 部署放在同一个文件# 参考原来的布局，在services子类下添加  app:    image: &#x27;jc21/nginx-proxy-manager:latest&#x27;    restart: unless-stopped    ports:      - &#x27;80:80&#x27;              # 不建议修改端口      - &#x27;81:81&#x27;              # 可以把冒号左边的 81 端口修改成你服务器上没有被占用的端口      - &#x27;443:443&#x27;            # 不建议修改端口    volumes:      - ~/data/docker_data/nginxproxymanager/data:/data         # 冒号左边是创建一个 data 目录，用于存放数据，如果不存在的话，会自动&gt;创建      - ~/data/docker_data/nginxproxymanager/letsencrypt:/etc/letsencrypt  # 创建一个 letsencrypt 目录，用于存放证书，如果不存在的话&gt;，会自动创建\n这样就可以通过docker compose up -d来启动 NPM 了\n\nNPM 访问浏览器输入ip:81就可以访问 NPM 的网页端了。\n默认登陆的用户名：admin@example.com，密码：changeme\n第一次登陆会提示更改用户名和密码，建议修改一个复杂一点的密码。\n至此，我们已经完成了 Nginx Proxy Manager 的搭建，之后就可以用它给我们的 Halo 或者其他 Web 应用做反向代理了。\nNPM 配置依次点击Dashboard - Proxy Hosts - Add Proxy Host - Details，分别填入以下信息\n\nDomain Names：填我们 Halo 网站的域名，首先记得做好 DNS 解析，把域名绑定到我们的服务器的 IP 上\nScheme：默认 http 即可，除非你有自签名证书\nForward Hostname/IP：填入服务器的 IP，或者 Docker 容器内部的 IP（如果 NPM 和 Halo 搭建在同一台服务器上的话）\n通过ip addr show docker0查看，inet 后面跟着的就是 Docker 容器内部的 IP\n\n\nForward Port：填入 Halo 映射出的端口，这边默认是 8090\nCache Assets：缓存，可以选择打开\nBlock Common Exploits：阻止常见的漏洞，可以选择打开\nWebsockets Support：WS 支持，可以选择打开\n\n然后就是申请 SSL 证书。参考这篇文章进行申请，这里只讲怎么使用证书。\n点击SSL，SSL Certificate选择上面申请的证书，打开Force SSL，点击Save即可。\n至此，你已经成功完成了 Halo 的反向代理，快尝试使用域名访问一下看看吧！\n参考\nhttps://docs.halo.run/getting-started/install/docker-compose\n\n","categories":["折腾系列"],"tags":["halo"]},{"title":"Hexo 博客搭建","url":"/426584999.html","content":"前言之前博客用的是 Halo 2.0 搭建，最近服务器到期了，在国内服务器需要备案，不想再续费了。对我而言，写博客重点是写，而不是一直折腾外观，所以没必要选择动态博客。搜索了很久，最终选择了 Hexo+Github+Vercel 的组合，既能满足我写博客的需求，又能省钱，两全其美。具体效果可以参考我的博客。\nHexo 安装因为 Hexo 是基于 Node.js 的，所以要使用 Hexo，那么第一步肯定是安装 Node.js。\n安装 Node.js进入下载地址下载\n直接安装，完成后，在 cmd 上输入 node -v 和 npm -v 查看是否安装成功，这两条命令如果都输出了版本号，那么就表示安装成功了。\n安装完之后，因为 Node.js 仓库会被墙掉，所以我们需要更换为国内镜像仓库，在终端中执行：\nnpm config set registry https://registry.npm.taobao.org\n\n安装 Hexo 工具执行命令\nnpm install hexo-cli -g\n\n出现 Hexo 的相关信息则表示 Hexo 安装成功\n创建 Hexo 本地程序在电脑上创建一个目录 HexoBlog，cmd 命令进入该目录（不要用 Git Bash Here，不然你没法用 Ctrl+C 关闭）\n执行命令：\nhexo init# 下面是在执行上面的命令之后的结果INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitINFO  Install dependenciesINFO  Start blogging with Hexo!\n\n启动 Hexo 本地服务安装完成 Hexo 程序直接执行 hexo s 或者 hexo server 命令就可以打开 Hexo 的本地服务。在命令行上会显示启动后的服务地址。\nhexo s# 下面是在执行上面的命令之后的结果INFO  Validating configINFO  Start processingINFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.\n\n复制上文中的 http://localhost:4000 并在浏览器中打开，就可以看到你的网站在本地的部署\n\nGitHub 同步新建仓库前往 GitHub 新建一个仓库，而且得确保你的仓库是 public，同时，仓库名最好是 用户名.github.io（其实自定义也是可以的，是为了防止后面 vercel 被封了还可以迁移到 GithubPage）。\n\n设置 Git打开 Git Bash ，运行下面的命令 :\nssh-keygen -t rsa -C &quot;&#123;&#123;你的电子邮箱地址&#125;&#125;&quot;\n\n连续 3 次回车，最终会在用户目录下生成个包含公钥私钥等数据的目录 ( 一般是 C:/Users/&#123;&#123;你的用户名&#125;&#125;/.ssh/ ) 。\n\n打开这个目录，找到 id_rsa.pub 文件，用记事本打开并复制里面的内容\n粘贴到GitHub仓库的 Key 中，Title 填你喜欢的，点击保存 ( Add SSH Key )\n\n运行下方命令 :\ngit config --global user.name &quot;&#123;&#123;你的 GitHub username&#125;&#125;&quot;git config --global user.email &quot;&#123;&#123;你的 GitHub 注册邮箱地址&#125;&#125;&quot;\n\n验证是否成功打开 Git Bash ，运行下面的命令 :\nssh -T git@github.com # 此处邮箱地址不用改\n\n如果提示 Are you sure you want to continue connecting (yes/no)? 请输入 yes 并回车。\nHi &#123;&#123;你的 GitHub username&#125;&#125;! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.\n\n看到这个信息则说明配置成功。\n部署到 GitHub完成上面的步骤后，接下来就是推送网站到 Github Pages 了，然后我们就能被其他人访问了。\n只需要在我们刚才的 HexoBlog 目录中的站点配置文件 _config.yml ，找到最后一行，修改它\n\n在你新建的仓库这里，可以找到repo，复制它\n\ncmd 进入 HexoBlog 目录中，依次执行以下命令\nhexo cleanhexo ghexo d\n\n完成上述步骤之后，主要使用如下命令，就能将我们本地的内容推送到远程 GitHub 仓库了，然后在浏览器中访问：https://用户名.github.io。\nVercel 部署我们知道，GitHub 是国外网站，所以有时候访问会很慢，这时，我们可以尝试用 vercel 加速博客访问。\n注册账号进入登陆页面，使用 GitHub 账号登陆即可（需要手机号码验证，直接填手机号收验证码即可，不会收集你的信息的）。\n导入项目选择 Create a New Project\n在关联的 github 账户中，找到刚才的博客仓库，选择 import\n进入部署页面选择 deploy，注意 Framework Preset 要选择 Other 而不是 Hexo，其他的默认\n生成之后点击 Continue to Dashboard\n访问 Vercel 给你的域名（类似于https://xxx.vercel.app/），就能加速访问你的网站了\n自定义域名然而，你用上面 vercel 自动分配的域名是无法访问你的网站的，因为 vercel 在国内已经被墙了。所以你需要在 vercel 中绑定自己的域名。\n选择 Settings 中的 Domains 添加域名\n另外，需要在域名解析处（比如我是 Cloudfalre）填写相应的 CNAME 值。\n\n\n\nType\nName\nValue\n\n\n\nCNAME\nblog\ncname.vercel-dns.com\n\n\n博客使用常见命令hexo new &quot;name&quot;       # 新建文章hexo new page &quot;name&quot;  # 新建页面hexo g                # 生成页面hexo d                # 部署hexo g -d             # 生成页面并部署hexo s                # 本地预览hexo clean            # 清除缓存和已生成的静态文件hexo help             # 帮助\n\n主题美化你可以通过更换主题，并写上你的名字以便修改自己网站的信息并美化它\n我用的是 keep 主题\n他的介绍文档写得非常的详细，简直是保姆级教程，大家可以慢慢去探索。\n参考资料\nHexo+Github+Netlify博客搭建教程\n\n","categories":["折腾系列"],"tags":["hexo"]},{"title":"Hexo 博客美化","url":"/3164120416.html","content":"前言Hexo 默认的博客主题有点单调，挑来挑去选择了 keep 主题，下面是我的一些踩坑操作。\n评论系统我的博客使用的是 Waline 这款简洁、安全的评论系统。要在博客中使用 Waline，分为三步\n\n通过 LeanCloud 配置 Waline 评论系统的数据库\n通过 Vercel 部署 Waline 评论系统的服务端\n在主题配置文件中配置 Waline 服务端地址\n\nLeanCloud 设置\n登录 或 注册 LeanCloud 国际版 并进入 控制台\n\n点击左上角 创建应用 并起一个你喜欢的名字 (请选择免费的开发版):\n\n进入应用，选择左下角的 设置 &gt; 应用 Key。你可以看到你的 APP ID，APP Key 和 Master Key。请记录它们，以便后续使用。\n\n\nVercel 部署\n点击按钮，跳转至 Vercel 进行 Server 端部署。\n\n输入一个你喜欢的 Vercel 项目名称并点击 Create 继续:\n\n\n\n\n此时 Vercel 会基于 Waline 模板帮助你新建并初始化仓库，仓库名为你之前输入的项目名。\n\n\n一两分钟后，满屏的烟花会庆祝你部署成功。此时点击 Go to Dashboard 可以跳转到应用的控制台。\n\n\n点击顶部的 Settings - Environment Variables 进入环境变量配置页，并配置填入三个环境变量 LEAN_ID, LEAN_KEY 和 LEAN_MASTER_KEY 。它们的值分别对应上一步在 LeanCloud 中获得的 APP ID, APP KEY, Master Key。\n\n\n\n环境变量配置完成之后点击顶部的 Deployments 点击顶部最新的一次部署右侧的 Redeploy 按钮进行重新部署。该步骤是为了让刚才设置的环境变量生效。\n\n\n\n此时会跳转到 Overview 界面开始部署，等待片刻后 STATUS 会变成 Ready。此时请点击 Visit ，即可跳转到部署好的网站地址，此地址即为你的服务端地址。\n\n\n绑定域名 (可选)\n点击顶部的 Settings - Domains 进入域名配置页\n\n输入需要绑定的域名并点击 Add\n\n\n\n\n在域名服务器商处添加新的 CNAME 解析记录\n\n\n\n\nType\nName\nValue\n\n\n\nCNAME\nexample\ncname.vercel-dns.com\n\n\n\n等待生效，你可以通过自己的域名来访问了🎉\n\n\n评论系统：example.yourdomain.com\n评论管理：example.yourdomain.com&#x2F;ui\n\n\n主题配置keep 主题已经支持 Waline 了，所以只修改主题中的 _config.yml 文件\nwaline:  server_url: https://example.yourdomain.com  # 这里填上面设置的域名\n\n设置文章加密访问有时想写一些私密博客，这里推荐一款适用于 Hexo 的静态博客加密插件 hexo-blog-encrypt。\n安装插件cd your-hexonpm install hexo-blog-encrypt\n\n文章配置在想要加密的文章里添加\n---......password: xxx# 下面两个可选message: &#x27;Hey, password is required here.&#x27;wrong_pass_message: &#x27;Oh, this is an invalid password. Check and try again, please.&#x27;---","categories":["折腾系列"],"tags":["hexo"]},{"title":"Nginx Proxy Manager 上部署静态网站","url":"/2175112272.html","content":"前言众所周知，对于一些 Docker 搭建的 Web 项目，NPM 能够很轻松地给他们做反向代理。\n然而对于一些静态网站，小伙伴们可能不知道怎么用 NPM 来展示，这篇文章就来简单和大家分享一下，如何用 NPM 来托管一些简单的 HTML 单页。\n实操因为我们已经有 NPM 在运行，监听了 443 端口和 80 端口，避免为了一个静态网站而建立另一个 Web 服务器。\n托管一些简单的 HTML 单页是一个简单的、低流量的需求，使用 NPM 已经运行的内置 nginx 就可以了。\n放置静态网页找到你用 docker compose 构建的 NPM 目录，比如我的是~/data/docker_data/nginxproxymanager/，进入里面的 data 文件夹，建立一个空文件夹\ncd ~/data/docker_data/nginxproxymanager/data/mkdir web_html\n然后将网页文件 index.html 放置在该文件夹下（注意只支持 index.html，php 不支持）\nNPM 配置登陆 NPM，在网页里新建一个 Proxy Host\nDetails 填入\n\nDomain Names：域名\nScheme：http\nForward Hostname / IP：docker 容器 ip\nForward Port：这个随便填，最后都是走服务器80口出\n\nSSL 填入\n\nSSL Certificate：SSL 证书\nForce SSL：勾选\n\nAdvanced 填入\nlocation / &#123;  root /data; # index.html 所在目录&#125;\n\n保存，然后就可以通过域名访问你的静态网页了。\n","categories":["折腾系列"],"tags":["建站"]},{"title":"LRU缓存问题","url":"/1876725769.html","content":"一、LRU 缓存（中）题目请你设计并实现一个满足LRU (最近最少使用) 缓存约束的数据结构。实现LRUCache类：\n\nLRUCache(int capacity) 以正整数作为容量capacity初始化 LRU 缓存\nint get(int key)如果关键字key存在于缓存中，则返回关键字的值，否则返回-1。\nvoid put(int key, int value)如果关键字key已经存在，则变更其数据值value；如果不存在，则向缓存中插入该组key-value。如果插入操作导致关键字数量超过capacity，则应该逐出最久未使用的关键字。函数get和put必须以O(1)的平均时间复杂度运行。\n\n \n示例：\n\n输入[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”][ [2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4] ]输出[null, null, null, 1, null, -1, null, -1, 3, 4]解释LRUCache lRUCache &#x3D; new LRUCache(2);lRUCache.put(1, 1); &#x2F;&#x2F; 缓存是 {1&#x3D;1}lRUCache.put(2, 2); &#x2F;&#x2F; 缓存是 {1&#x3D;1, 2&#x3D;2}lRUCache.get(1);    &#x2F;&#x2F; 返回 1lRUCache.put(3, 3); &#x2F;&#x2F; 该操作会使得关键字 2 作废，缓存是 {1&#x3D;1, 3&#x3D;3}lRUCache.get(2);    &#x2F;&#x2F; 返回 -1 (未找到)lRUCache.put(4, 4); &#x2F;&#x2F; 该操作会使得关键字 1 作废，缓存是 {4&#x3D;4, 3&#x3D;3}lRUCache.get(1);    &#x2F;&#x2F; 返回 -1 (未找到)lRUCache.get(3);    &#x2F;&#x2F; 返回 3lRUCache.get(4);    &#x2F;&#x2F; 返回 4\n \n\n提示：$1 &lt;&#x3D; capacity &lt;&#x3D; 3000$$0 &lt;&#x3D; key &lt;&#x3D; 10000$$0 &lt;&#x3D; value &lt;&#x3D; 10^5$最多调用 $2 * 10^5$ 次get和put\n题解1题目要求实现一个可以存储key-value形式数据的数据结构，并且可以记录最近访问的key值。首先想到的就是用字典来存储key-value结构，这样对于查找操作时间复杂度就是$O(1)$。\n但是因为字典本身是无序的，所以我们还需要一个类似于队列的结构来记录访问的先后顺序，这个队列需要支持如下几种操作：\n\n在末尾加入一项\n删除头部一项\n将队列中某一项移到末尾\n\n所以我们可以想到链表。链表有顺序之分，插入删除快，但是查找慢。那是用单向链表还是双向链表呢？\n对于单向链表，哈希表的结构类似于&#123;key: ListNode(value)&#125;，即键所对应的是一个节点地址，节点的值是value。对于单向链表，可以在常数的时间内找到对应的节点，但是如果想删除节点或者将它移到尾部，则需要从头遍历整个链表，对于这种情况需要的时间复杂度也是$O(n)$。而对于双向链表，可以在常数时间内在任何位置插入或删除节点，而且可以方便地维护头尾节点的指针。\n因此，这道题就用一种新的数据结构：哈希链表。双向链表可以用来维护缓存中数据的访问顺序，链表头部是最近访问过的数据，链表尾部是最久没有访问过的数据。同时哈希表用来快速查找键对应的链表节点，以及在链表中删除或移动节点。\n双向链表可以直接用list&lt;pair&lt;int, int&gt;&gt;表示，它是C++标准库中的一个容器，可以在任何位置进行常数时间的插入和删除。哈希表直接用unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt;即可。\nclass LRUCache &#123; public:  // 构造函数，初始化缓存容量  LRUCache(int capacity) : cap(capacity) &#123;&#125;  // 获取键为key的值  int get(int key) &#123;    // 如果哈希表中不存在该键，返回-1    if (hash_map.find(key) == hash_map.end())      return -1;    // 否则，将该键值对移到链表头部（表示最近使用）    auto it = hash_map[key];    link_list.splice(link_list.begin(), link_list, it);    // 返回值    return it-&gt;second;  &#125;  // 插入或更新键值对  void put(int key, int value) &#123;    // 如果哈希表中已经存在该键    if (hash_map.find(key) != hash_map.end()) &#123;      // 更新值      auto it = hash_map[key];      it-&gt;second = value;      // 将该键值对移到链表头部（表示最近使用）      link_list.splice(link_list.begin(), link_list, it);      return;    &#125;    // 如果缓存已满    if (link_list.size() == cap) &#123;      // 删除最近最少使用的键值对（即链表尾部的键值对）      auto last = link_list.back();      hash_map.erase(last.first);      link_list.pop_back();    &#125;    // 在链表头部插入新的键值对    link_list.push_front(&#123;key, value&#125;);    // 在哈希表中添加映射关系    hash_map[key] = link_list.begin();  &#125; private:  int cap;                         // 缓存容量  list&lt;pair&lt;int, int&gt;&gt; link_list;  // 双向链表，用来维护最近最少使用的顺序  unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt;      hash_map;  // 哈希表，用来快速查找键值对&#125;;\n\n题解2上面的双向链表是直接用标准库list&lt;pair&lt;int, int&gt;&gt;实现的，当然我们也可以建立Node、实现双链表。首先定义一个Node结构，然后创建一个头节点和一个尾节点，分别指向链表的第一个和最后一个节点。你还需要定义一些函数来在链表中插入、删除和查找节点。下面是一个简单的例子：\n// 定义双向链表节点struct Node &#123;  int data;    // 数据域  Node* prev;  // 指向前一个节点的指针  Node* next;  // 指向后一个节点的指针  Node(int x) : data(x), prev(nullptr), next(nullptr) &#123;&#125;&#125;;class DoublyLinkedList &#123; private:  Node* head;  // 头指针，指向链表的第一个节点  Node* tail;  // 尾指针，指向链表的最后一个节点 public:  DoublyLinkedList() : head(nullptr), tail(nullptr) &#123;&#125;  // 在双向链表头部插入新节点  void insertAtHead(int data) &#123;    Node* newNode = new Node(data);  // 创建新节点    newNode-&gt;next = head;  // 将新节点的next指针指向原来的头节点    if (head != nullptr) &#123;   // 如果原来的头节点不为空      head-&gt;prev = newNode;  // 将原来头节点的prev指针指向新节点    &#125;    head = newNode;  // 更新头指针为新创建的节点    if (tail == nullptr) &#123;  // 如果尾指针为空，说明链表为空      tail = newNode;       // 更新尾指针为新创建的节点    &#125;  &#125;  // 在双向链表尾部插入新节点  void insertAtTail(int data) &#123;    if (head == nullptr) &#123;  // 如果链表为空，直接在头部插入新节点即可      insertAtHead(data);      return;    &#125;    Node* newNode = new Node(data);  // 创建新节点    tail-&gt;next = newNode;            // 将尾节点的next指针指向新节点    newNode-&gt;prev = tail;  // 将新节点的prev指针指向原来的尾节点    tail = newNode;        // 更新尾指针为新创建的节点  &#125;  // 在双向链表中查找给定值为val的节点  Node* search(int val) &#123;    Node* temp = head;    while (temp != nullptr) &#123;   // 遍历链表      if (temp-&gt;data == val) &#123;  // 如果找到了给定值为val的节点        return temp;            // 返回该节点的指针      &#125;      temp = temp-&gt;next;  // 继续遍历下一个节点    &#125;    return nullptr;  // 没有找到给定值为val的节点，返回空指针  &#125;  // 在双向链表中删除给定值为val的所有节点  void deleteAll(int val) &#123;    Node* temp = head;    while (temp != nullptr) &#123;      // 遍历链表      if (temp-&gt;data == val) &#123;     // 如果找到了给定值为val的节点        if (temp == head) &#123;        // 如果要删除的是头节点          head = head-&gt;next;       // 更新头指针为下一个节点          if (head != nullptr) &#123;   // 如果新的头节点不为空            head-&gt;prev = nullptr;  // 将新头节点的prev指针设为nullptr          &#125;        &#125; else if (temp == tail) &#123;  // 如果要删除的是尾节点          tail = tail-&gt;prev;        // 更新尾指针为前一个节点          tail-&gt;next = nullptr;     // 将新尾节点的next指针设为nullptr        &#125; else &#123;                    // 如果要删除的是中间节点          temp-&gt;prev-&gt;next =              temp-&gt;next;  // 将前一个节点的next指针指向后一个节点          temp-&gt;next-&gt;prev =              temp-&gt;prev;  // 将后一个节点的prev指针指向前一个节点        &#125;        Node* delNode = temp;  // 记录要删除的节点        temp = temp-&gt;next;     // 继续遍历下一个节点        delete delNode;        // 删除节点      &#125; else &#123;        temp = temp-&gt;next;  // 继续遍历下一个节点      &#125;    &#125;  &#125;  // 打印双向链表中的所有元素  void printList() &#123;    Node* temp = head;    while (temp != nullptr) &#123;  // 遍历链表      std::cout &lt;&lt; temp-&gt;data &lt;&lt; &quot; &quot;;      temp = temp-&gt;next;    &#125;    std::cout &lt;&lt; std::endl;  &#125;&#125;;\n\n完整代码如下：\nstruct Node &#123;  int key;  int value;  Node* prev;  Node* next;  Node(int k, int v) : key(k), value(v), prev(nullptr), next(nullptr) &#123;&#125;&#125;;class LRUCache &#123; private:  unordered_map&lt;int, Node*&gt; cache;  // 哈希表  Node* head;                       // 头节点  Node* tail;                       // 尾节点  int size;                         // 当前大小  int capacity;                     // 最大容量 public:  LRUCache(int capacity) &#123;    this-&gt;capacity = capacity;    size = 0;    head = new Node(0, 0);    tail = new Node(0, 0);    head-&gt;next = tail;    tail-&gt;prev = head;  &#125;  int get(int key) &#123;    if (cache.count(key) == 0)      return -1;    // 如果key存在，先通过哈希表定位，再移到头部    Node* node = cache[key];    moveToHead(node);    return node-&gt;value;  &#125;  void put(int key, int value) &#123;    if (cache.count(key) == 0) &#123;      // 如果key不存在，创建一个新的节点      Node* node = new Node(key, value);      // 添加进哈希表      cache[key] = node;      // 添加至双向链表的头部      addToHead(node);      ++size;      if (size &gt; capacity) &#123;        // 如果超出容量，删除双向链表的尾部节点，并删除哈希表中对应项        Node* removed = removeTail();        cache.erase(removed-&gt;key);        delete removed;        --size;      &#125;    &#125; else &#123;      // 如果key存在，先通过哈希表定位，再修改value，并移到头部      Node* node = cache[key];      node-&gt;value = value;      moveToHead(node);    &#125;  &#125; private:  void addToHead(Node* node) &#123;    node-&gt;prev = head;    node-&gt;next = head-&gt;next;    head-&gt;next-&gt;prev = node;    head-&gt;next = node;  &#125;  void removeNode(Node* node) &#123;    node-&gt;prev-&gt;next = node-&gt;next;    node-&gt;next-&gt;prev = node-&gt;prev;  &#125;  void moveToHead(Node* node) &#123;    removeNode(node);    addToHead(node);  &#125;  Node* removeTail() &#123;    Node* node = tail-&gt;prev;    removeNode(node);    return node;  &#125;&#125;;\n","categories":["算法交流"],"tags":["刷题笔记"]},{"title":"Nginx Proxy Manager 在线申请 SSL 证书","url":"/376257426.html","content":"前言我们知道，Nginx Proxy Manager 反代域名使用 HTTPS，需要 SSL 证书，我们可以用 NPM 的一键申请证书，但这样每个域名都需要单独申请，太麻烦了。这里介绍一种申请泛域名的 SSL 证书，一级域名、二级域名都共用一个证书，省时省事。\n验证方式NPM 中 Let’s Encrypt 证书申请有两种验证方式：一种是基于 HTTP 的验证方式，另一种是基于 DNS 的验证方式。\nHTTP-01 验证关于 HTTP-01 验证的详细描述可以看官方文档。\n这种方式最简单，不需要任何关于域名配置的额外知识，但是必须使用 80 端口，绝大部分人可能用不了，所以这里就不说了。\nDNS-01 验证关于 DNS-01 验证的详细描述可以看官方文档。\n此验证方式要求您在该域名下的 TXT 记录中放置特定值来证明您控制域名的 DNS 系统，这需要您的 DNS 提供商提供 API。\n申请 SSL 证书进入 NPM，点击SSL Certificates - Add SSL Certificate - Let&#39;s Encrypt，输入以下配置：\nDomain Names：输入一级域名和泛域名，example.com 和 *.example.comEmail Address for Let&#39;s Encrypt：选择 Cloudflare 登录邮箱；\n点击 Use a DNS Challenge 使用 DNS 申请，DNS Provider 选择 Cloudflare，下一步就是申请 Cloudflare API Token，可以先往下看。\n\n点击“I Agree to the Let’s Encrypt Terms of Service”，然后点击“Save”，就会自动申请 SSL 证书了。\n申请 Cloudflare API Token打开 Cloudflare 官网并登录账号，在页面右上角的个人头像下拉菜单中点击“我的个人资料”。切换到“API 令牌”，点击“创建令牌”；\n\n在 “API 令牌模板”中选择“编辑区域 DNS”后面的“使用模板”；\n\n进入模板之后选择需要控制的域名之后下一步并创建令牌；\n\n此时已经添加了令牌权限并生成了令牌，把生成结果填入 NPM 的dns_cloudflare_api_token即可。\n\n最后一行可以看到 SSL 证书已经申请完成，有效期3个月，到期会自动续期。\n","categories":["折腾系列"],"tags":["建站","halo"]},{"title":"Opencv 录制多路 camera","url":"/3944038877.html","content":"前言最近在写个小需求，利用opencv录制多路usb摄像头数据，并将拍摄视频拼接显示在同一个窗口。\n思路挺简单的，就是通过cv2.VideoCapture获取/dev/video*的信息，获取每个摄像头的frame后，通过numpy的hstack和vstack将两帧拼接起来。代码如下：\nimport cv2import numpy as np# 0,2,4代表/dev/video后缀videoFront = cv2.VideoCapture(0)videoLeft = cv2.VideoCapture(2)videoRight = cv2.VideoCapture(4)width = (int(videoFront.get(cv2.CAP_PROP_FRAME_WIDTH)))height = (int(videoFront.get(cv2.CAP_PROP_FRAME_HEIGHT)))# 设置保存视频的宽高、帧率、格式sz = (width*2, height*2)fps = 30fourcc = cv2.VideoWriter_fourcc(&#x27;m&#x27;, &#x27;p&#x27;, &#x27;4&#x27;, &#x27;v&#x27;)vout = cv2.VideoWriter()vout.open(&#x27;./output.mp4&#x27;, fourcc, fps, sz, True)write_ok = False# while (videoLeft.isOpened() and videoRight.isOpened()):while (True):    retFront, frameFront = videoFront.read()    retLeft, frameLeft = videoLeft.read()    retRight, frameRight = videoRight.read()    if(retFront and retLeft and retRight):        frameFront = cv2.resize(frameFront, (width, height), interpolation=cv2.INTER_CUBIC)        frameUp = np.hstack((frameFront, frameFront))        frameLeft = cv2.resize(frameLeft, (width, height), interpolation=cv2.INTER_CUBIC)        frameRight = cv2.resize(frameRight, (width, height), interpolation=cv2.INTER_CUBIC)        frameDown = np.hstack((frameLeft, frameRight))        frame = np.vstack((frameUp, frameDown))        if write_ok:            print(&quot;saving video...&quot;)            vout.write(frame)        cv2.imshow(&#x27;frame&#x27;, frame)    key = cv2.waitKey(1) &amp; 0xFF    if key == ord(&quot;w&quot;):        write_ok = write_ok is not True    if key == ord(&quot;q&quot;):        breakvideoLeft.release()videoRight.release()","categories":["工具脚本"],"tags":["python","opencv"]},{"title":"Nginx Proxy Manager 实现公网访问家庭 NAS","url":"/2431342973.html","content":"前言有些小伙伴建站没有用云服务器，而是移到了自己的 NAS 上。但是运营商是封堵我们的 80，443端口的，那如何实现公网 IP 无 443 和 80 端口外网访问呢？\n我们可以用 Nginx Proxy Manager 里自带一个端口转发功能，绕过封堵的 80，443端口，实现从公网对家里服务器的访问，在此记录一下。\n实操在 Nginx Proxy Manager 面板里点击Dashboard-Streams-Add Streams，分别填入以下信息：\nIncoming Port：入站端口，填一个你要用来代替 80&#x2F;443 的端口Forward Host：转发主机，填本机 ip：127.0.0.1Forward Port：转发端口，填被封堵的端口，80 或者 443\n然后点保存。设置以后，从外网访问你部署在家庭服务器上的网站需要在域名后加上你设置的入站端口。\n比如原来你访问在地址栏输入的 url 是https://www.domain.cn，443 端口被封了访问不了了，按上图设置之后，在浏览器地址栏输入https://www.domain.cn:9443就能访问了。\n同理，如果你没有上 https，要绕过被封堵的 http 的默认端口 80，就把转发端口设置为 80 即可。然后访问的时候在域名后加上你设置的入站端口即可绕过运营商对 80 端口的封堵访问。\n","categories":["折腾系列"],"tags":["建站"]},{"title":"Opencv 合并视频","url":"/982081792.html","content":"前言最近在写个小需求，利用opencv将4个独立的视频文件并列合并成了一个视频文件，并在屏幕的4个区域进行播放。\n思路代码如下：\nimport cv2import numpy as npvideoLeftUp = cv2.VideoCapture(&#x27;./video/1.mp4&#x27;)videoLeftDown = cv2.VideoCapture(&#x27;./video/2.mp4&#x27;)videoRightUp = cv2.VideoCapture(&#x27;./video/3.mp4&#x27;)videoRightDown = cv2.VideoCapture(&#x27;./video/4.mp4&#x27;)fps = videoLeftUp.get(cv2.CAP_PROP_FPS)width = (int(videoLeftUp.get(cv2.CAP_PROP_FRAME_WIDTH)))height = (int(videoLeftUp.get(cv2.CAP_PROP_FRAME_HEIGHT)))videoWriter = cv2.VideoWriter(&#x27;./merge.mp4&#x27;, cv2.VideoWriter_fourcc(&#x27;m&#x27;, &#x27;p&#x27;, &#x27;4&#x27;, &#x27;v&#x27;), fps, (width, height))successLeftUp, frameLeftUp = videoLeftUp.read()successLeftDown , frameLeftDown = videoLeftDown.read()successRightUp, frameRightUp = videoRightUp.read()successRightDown, frameRightDown = videoRightDown.read()while successLeftUp and successLeftDown and successRightUp and successRightDown:    frameLeftUp = cv2.resize(frameLeftUp, (int(width / 2), int(height / 2)), interpolation=cv2.INTER_CUBIC)    frameLeftDown = cv2.resize(frameLeftDown, (int(width / 2), int(height / 2)), interpolation=cv2.INTER_CUBIC)    frameRightUp = cv2.resize(frameRightUp, (int(width / 2), int(height / 2)), interpolation=cv2.INTER_CUBIC)    frameRightDown = cv2.resize(frameRightDown, (int(width / 2), int(height / 2)), interpolation=cv2.INTER_CUBIC)    frameUp = np.hstack((frameLeftUp, frameRightUp))    frameDown = np.hstack((frameLeftDown, frameRightDown))    frame = np.vstack((frameUp, frameDown))    videoWriter.write(frame)    successLeftUp, frameLeftUp = videoLeftUp.read()    successLeftDown, frameLeftDown = videoLeftDown.read()    successRightUp, frameRightUp = videoRightUp.read()    successRightDown, frameRightDown = videoRightDown.read()videoWriter.release()videoLeftUp.release()videoLeftDown.release()videoRightUp.release()videoRightDown.release()","categories":["工具脚本"],"tags":["python","opencv"]},{"title":"Pyinstaller 反编译","url":"/1915330816.html","content":"前言上一篇介绍了如何用Pyinstaller打包python文件成bin文件，那问题来了，我们拿到一个Pyinstaller打包的bin文件，想看代码怎么办，这就要用到Pyinstaller反编译了。\n方法一、获取pyc文件我们第一步采用的工具是pyinstxtractor.py，可以将Pyinstaller生成的bin文件解包成pyc文件。之后把这个文件复制到bin文件同级目录下，运行如下命令：\npython pyinstxtractor.py xxbin\n\n运行后生成xxbin.extracted文件夹 ，里面有一堆so ,pyc等文件；\n我们还注意到此目录下还有一个PYZ-00.pyz_extracted文件夹，里面都是引入的依赖库，但是注意，里面文件都是.pyc.extracted格式，是加密的，需要进一步反编译\n二、pyc文件解密在反编译python生成可执行文件bin时，引用的类库文件经常遇到使用Crypto 模块AES算法加密，解包生成的并不是pyc文件，而是加密的pyc. encrypted文件，当然它也无法查看编译。当然，它也是可以解密的。\n第一步，获取Crypto的key，这是打包时由开发者指定的。解包完成后将在根目录形成名为&quot;pyimod00_crypto_key.pyc&quot;的文件，将它转为py文件即可查看key文件。key是必须文件，否则无法进行解密;\n第二步，对于不同pyton版本头文件（header）也不相同，2.7~3.10如下所示：\nPython 2.7: \\x03\\xf3\\x0d\\x0a\\0\\0\\0\\0Python 3.0: \\x3b\\x0c\\x0d\\x0a\\0\\0\\0\\0Python 3.1: \\x4f\\x0c\\x0d\\x0a\\0\\0\\0\\0Python 3.2: \\x6c\\x0c\\x0d\\x0a\\0\\0\\0\\0Python 3.3: \\x9e\\x0c\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0Python 3.4: \\xee\\x0c\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0Python 3.5: \\x17\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0Python 3.6: \\x33\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0Python 3.7: \\x42\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0Python 3.8: \\x55\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0Python 3.9: \\x61\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0Python 3.10: \\x6f\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\n\n第三步，编写解密处理的脚本代码，将加密的pyc. encrypted文件转成不加密的pyc文件。\nimport globimport zlibimport tinyaesfrom pathlib import PathCRYPT_BLOCK_SIZE = 16# key obtained from pyimod00_crypto_keykey = bytes(&#x27;0000000000013983&#x27;, &#x27;utf-8&#x27;)for p in Path(&quot;PYZ-00.pyz_extracted&quot;).glob(&quot;**/*.pyc.encrypted&quot;):    inf = open(p, &#x27;rb&#x27;) # encrypted file input    outf = open(p.with_name(p.stem), &#x27;wb&#x27;) # output file    # Initialization vector    iv = inf.read(CRYPT_BLOCK_SIZE)    cipher = tinyaes.AES(key, iv)    # Decrypt and decompress    plaintext = zlib.decompress(cipher.CTR_xcrypt_buffer(inf.read()))    # Write pyc header    # The header below is for Python 3.8    outf.write(b&#x27;\\x42\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0&#x27;)    # Write decrypted data    outf.write(plaintext)    inf.close()    outf.close()    # Delete .pyc.encrypted file    p.unlink()\n\n\n\n三、pyc反编译为pyLinux下可以使用uncompyle6或者decompyle3来将pyc文件转成py文件，这里使用decompyle3，直接decompyle3 xx.pyc &gt; xx.py即可。\n当然，有个在线工具可以直接pyc转py。\n四、Code#!/usr/bin/env python# coding: utf-8import osimport sysimport pyinstxtractorimport globimport zlibimport tinyaesfrom pathlib import Pathimport reclass Main():    def __init__(self, parent=None):        self.exe_file = sys.argv[1]        self.pyc_dir = &quot;&quot;        self.key = &quot;&quot;        self.files = []    def exe2pyc(self):        # 将exe转化为pyc文件        sys.argv = [&#x27;pyinstxtractor.py&#x27;, self.exe_file]        pyinstxtractor.main()    def get_pyc_dir(self):        self.pyc_dir = os.path.basename(self.exe_file) + &quot;_extracted&quot;    def encrypted2pyc(self, root):        CRYPT_BLOCK_SIZE = 16        # key obtained from pyimod00_crypto_key        key = bytes(self.key[0], &#x27;utf-8&#x27;)        # key = bytes(&#x27;0000000000013983&#x27;, &#x27;utf-8&#x27;)        for p in Path(root).glob(&quot;**/*.pyc.encrypted&quot;):            inf = open(p, &#x27;rb&#x27;) # encrypted file input            outf = open(p.with_name(p.stem), &#x27;wb&#x27;) # output file            # Initialization vector            iv = inf.read(CRYPT_BLOCK_SIZE)            cipher = tinyaes.AES(key, iv)            # Decrypt and decompress            plaintext = zlib.decompress(cipher.CTR_xcrypt_buffer(inf.read()))            # Write pyc header            # The header below is for Python 3.7            outf.write(b&#x27;\\x42\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0&#x27;)            # Write decrypted data            outf.write(plaintext)            inf.close()            outf.close()            # Delete .pyc.encrypted file            # p.unlink()            print(&quot;change %s ---&gt; %s&quot;%(p, p.with_name(p.stem)))    def pyc2py(self, root, files):        for file_name in files:            if file_name.endswith(&#x27;.pyc&#x27;):                if not self.check_if_file_exists(file_name):                    if file_name.endswith(&#x27;.pyc&#x27;):                        part_name = file_name[0:-4]                        part_file_name = os.path.join(root, part_name).replace(&quot;\\\\&quot;,&quot;/&quot;)                        os.system(&quot;decompyle3 %s.pyc &gt; %s.py&quot;%(part_file_name, part_file_name))                        print(&quot;change %s.pyc ---&gt; %s.py&quot;%(part_file_name, part_file_name))                else:                    print(&quot;%s already exist, skip&quot;%(file_name[0:-4]+&#x27;.py&#x27;))                    continue    def get_key_from_crypto_key(self):        for root, dirs, files in os.walk(self.pyc_dir, True):            for file_name in files:                if file_name == &quot;pyimod00_crypto_key.pyc&quot;:                    part_name = file_name[0:-4]                    part_file_name = os.path.join(root, part_name).replace(&quot;\\\\&quot;,&quot;/&quot;)                    os.system(&quot;decompyle3 %s.pyc &gt; %s.py&quot;%(part_file_name, part_file_name))                    print(&quot;change %s.pyc ---&gt; %s.py&quot;%(part_file_name, part_file_name))                    with open(part_file_name+&#x27;.py&#x27;, &#x27;r&#x27;) as f:                        for line in f.readlines():                            if &quot;key = &quot; in line:                                self.key = re.findall(r&quot;&#x27;([^&#x27;]*)&#x27;&quot;, line)    def check_if_file_exists(self, file_name):        part_name = file_name[0:-4] + &#x27;.py&#x27;        if part_name in self.files:            return True        return False    def exe2py(self):        self.exe2pyc()        # 恢复当前目录位置        os.chdir(&quot;..&quot;)        self.get_pyc_dir()        self.get_key_from_crypto_key()        pyz_file = self.pyc_dir+&quot;/PYZ-00.pyz_extracted&quot;        self.encrypted2pyc(pyz_file)        for root, dirs, files in os.walk(self.pyc_dir, True):            self.files = files            self.pyc2py(root, files)if __name__==&quot;__main__&quot;:    if len(sys.argv) &lt; 2:        print(&#x27;[+] Usage: exe2py.py &lt;filename&gt;&#x27;)    mainFunc = Main()    magic = mainFunc.exe2py()\n","categories":["开发运维"],"tags":["python"]},{"title":"Python 实现每日自动推送 URL 到百度站长收录","url":"/3225872756.html","content":"前言闲来无事，看了下自己写的博客没有一篇文章被百度收录，无奈只好写了一个百度主动提交工具的小脚本，实现每日自动爬取当前博客文章并推送文章URL到百度站长收录，提高下曝光率。\n解决其实百度站长后台也给出了示例：curl推送示例、post推送示例、php推送示例、ruby推送示例一大堆，下面就给大家用Python写一个几句代码就可以实现百度主动提交。\n# coding:utf-8import requestsimport re# 获取网站html数据def get_html(url):    try:        r = requests.get(url+&quot;/archives&quot;)        r.encoding = &quot;utf-8&quot;        html = r.text        return html    except Exception:        passdef main(url):    headers = &#123;        &#x27;Accept&#x27;: &#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;,        &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate, br&#x27;,        &#x27;Accept-Language&#x27;: &#x27;zh-CN,zh;q=0.9,en;q=0.8&#x27;,        &#x27;Cache-Control&#x27;: &#x27;max-age=0&#x27;,        &#x27;Connection&#x27;: &#x27;keep-alive&#x27;,        &#x27;Cookie&#x27;: &#x27;&#x27;,        &#x27;Host&#x27;: &#x27;data.zz.baidu.com&#x27;,        &#x27;Upgrade-Insecure-Requests&#x27;: &#x27;1&#x27;,        &#x27;User-Agent&#x27;: &#x27;curl/7.12.1&#x27;,    &#125;    # 百度提交api    seo_url = &#x27;http://data.zz.baidu.com/urls?site=121.196.169.103&amp;token=&#123;token&#125;&#x27;    html = get_html(url)    # 正则匹配,筛选出文章链接    result = re.findall(&#x27;&lt;li.*?href=(&quot;/archives/.*?&quot;)&gt;&#x27;, html, re.S)    urls = &quot;&quot;    for res in result:        urls += url+res.split(&#x27;&quot;&#x27;)[1] + &#x27;\\n&#x27;    print(urls)    response = requests.post(seo_url, data=urls.encode(), headers=headers)    print(response.text)if __name__ == &#x27;__main__&#x27;:    url = &quot;http://121.196.169.103&quot;  # 网站链接    main(url)","categories":["工具脚本"],"tags":["python"]},{"title":"Python 处理错误的 json 文件","url":"/3741772592.html","content":"前言最近在做数据分析，拿到一组json格式文件，但是文件却不是规范的json格式，需要将文件过滤一波，恢复规范的json格式。这里做个记录。\n问题json文件如下，其中&quot;planning_status&quot;的value是个list，同时这个list占了5行，每行末尾都有换行符。\n&#123;    &quot;planning_status&quot;: [&quot;Now: 1390.04, Gap: 0.10, Delay: 0.20,    Se: -0.3, Le: +0.06,    Real ka al: 0.00036,        0.037,    in_HDmap_mode&quot;],    &quot;distance_to_ramp&quot;: 1291.777709961&#125;\n\n解决import jsonfpath = &quot;test.json&quot;with open(fpath, &#x27;r+&#x27;, encoding=&#x27;utf-8&#x27;) as infile:    lines = infile.readlines()\t# 逐行读取pi_string = &#x27;&#x27;for line in lines:    pi_string += line.strip()    # strip() 删除 string 字符串末尾的指定字符，    # 若参数为空，默认为空白符，包括空格、换行符、回车符、制表符j = json.loads(pi_string)\t# 转为dict# 重新写入with open(&#x27;test.json&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as outfile:    json.dump(j, outfile, ensure_ascii=False)def listToJson(lst):    import json    import numpy as np    keys = [str(x) for x in np.arange(len(lst))]    list_json = dict(zip(keys, lst))    str_json = json.dumps(list_json, indent=2,                          ensure_ascii=False)  # json转为string    return str_json\n\n","categories":["工具脚本"],"tags":["python"]},{"title":"Python 文件之 QT 界面打包","url":"/2425545972.html","content":"前言相信大家都试过用Pyinstaller将Python文件打包成exe，来发给其他没有安装Python环境的用户使用。但通常情况下，打包生成的exe文件都很大，因为Pyinstaller默认是把本地所有安装的Python库都打包进去。这时，创建一个虚拟环境就是最好的选择，然后在虚拟环境中进行打包。这里介绍打包QT5界面的操作。\n解决安装Pipenvpipenv 是用来管理虚拟环境，使用 pip install pipenv 安装 pipenv，pip show pipenv 检查是否安装成功。\n添加环境变量打包QT5需要用到QT5的platforms，所以需要添加环境变量。新建QT_QPA_PLATFORM_PLUGIN_PATH，路径是platforms路径。比如我电脑下的platforms路径是D:\\Programfiles\\anaconda3\\Lib\\site-packages\\PyQt5\\Qt5\\plugins\\platforms。重启电脑，让环境变量生效。\n\n    \n    \n\n\n具体操作# 创建一个文件夹，来保存虚拟环境相关文件，并cd进入该文件夹下# 创建Python3虚拟环境pipenv install --three# 进入虚拟环境pipenv shell# 安装要打包py文件所用到的库以及Pyinstaller# Pyinstaller是必须要在虚拟环境中安装的，不然会调用环境外的Pyinstaller，这样打包没效果pipenv install requestspipenv install pyinstaller# 开始打包# -F 表示打包成一个exe，-i 后面接exe的图标pipenv run pyinstaller -F -w main.py -i shop.ico\n\nPipenv常用命令# 1.进入到项目目录[root@localhost ~]# cd /www/wwwroot/myproject# 2.创建虚拟环境[root@localhost myproject]# pipenv install[root@localhost myproject]# pipenv install --three              # 使用当前系统的Python3创建环境[root@localhost myproject]# pipenv --two                        # 使用python2创建环境[root@localhost myproject]# pipenv --three                      # 使用python3创建环境[root@localhost myproject]# pipenv --python 3.6                 # 指定某个Python版本创建环境[root@localhost myproject]# pipenv --python &lt;path/to/python&gt;    # 指定某个位置的Python创建环境# 3.激活并进入虚拟环境[root@localhost myproject]# pipenv shell# 4.在虚拟环境中安装模块，并加入到Pipfile。可以不进入虚拟环境中，直接在项目目录下面使用pipenv安装即可。(myproject) [root@localhost myproject]# pipenv install requests(myproject) [root@localhost myproject]# pipenv install django==1.11(myproject) [root@localhost myproject]# pipenv uninstall requests# 5.运行python项目(myproject) [root@localhost myproject]# python Main.py(myproject) [root@localhost myproject]# pipenv run python main.py# 6.退出虚拟环境(myproject) [root@localhost myproject]# exit# pipenv常见命令# 创建pipenv虚拟环境[root@localhost myproject]# pipenv install[root@localhost myproject]# pipenv --two/--three# 查看项目所在路径[root@localhost myproject]# pipenv --where# 查看虚拟环境所在路径[root@localhost myproject]# pipenv --venv# 查看虚拟环境中Python执行文件所在位置（即显示Python解释器信息）[root@localhost myproject]# pipenv --py# 进入pipenv虚拟环境（未存在虚拟环境可自动创建）　　[root@localhost myproject]# pipenv shell# 安装与卸载包(myproject) [root@localhost myproject]# pipenv install requests(myproject) [root@localhost myproject]# pipenv uninstall requests(myproject) [root@localhost myproject]# pipenv uninstall --all       # 卸载全部包并从Pipfile中移除# 查看虚拟环境内安装的包以及包之间的依赖关系(myproject) [root@localhost myproject]# pipenv graph# 查找虚拟环境所有安装包(myproject) [root@localhost myproject]# pip list# 导出虚拟环境内所有依赖包名(myproject) [root@localhost myproject]# pip freeze &gt; requirements.txt# 安装项目所依赖全部模块(myproject) [root@localhost myproject]# pip install -r requirements.txt# 检查包的安全性(myproject) [root@localhost myproject]# pipenv check# 生成Pipenv.lock，Pipfile.lock用来冻结软件包名称及其版本以及其自己的依赖关系的列表(myproject) [root@localhost myproject]# pipenv lock# 退出pipenv虚拟环境　　(myproject) [root@localhost myproject]# exit# 删除pipenv当前虚拟环境[root@localhost myproject]# pipenv --rm\n\nPyinstaller打包参数pyinstaller打包有不少可选参数，可以根据自己的需要进行添加。\n\n-F：打包单个文件，产生一个文件用于部署(默认)，如果代码都写在一个 .py 文件时使用，项目有多个文件时不要使用\n-D：打包多个文件，产生一个目录用于部署(默认)，用于框架编写的代码打包\n--key=keys：使用 keys 进行加密打包\n-d：产生 debug 版本的可执行文件\n-p：用来添加程序所用到的包的所在位置，设置导入路径，可以用 ; ( Linux 使用 :)分割来指定多个目录。\n-w：表示不用控制台窗口，使用 Windows 子系统执行，当程序启动的时候不会打开命令行(只对 Windows 有效)\n-c：表示打开控制台窗口，使用控制台子系统执行,当程序启动的时候会打开命令行(默认)(只对 Windows 有效)\n-i：将 file.ico 添加为可执行文件的资源，改变程序的图标(只对 Windows 系统有效)\n\n注意的是，如果是打包QT5的界面，在其他电脑使用，还需要拷贝QT5的platforms，放到其他电脑（路径随意），然后像上面步骤一样添加环境变量，重启电脑，让环境变量生效。\n","categories":["开发运维"],"tags":["python"]},{"title":"ROS 之 TF 理解","url":"/768008996.html","content":"TF转换（参考）1、URDF、TF和odom的关系在机器人自主导航中，ROS会构建这几个很重要的坐标系，即frame。在urdf文件中定义base_link，它代表了机器人的主干，其它所有的frame都是相对于base_link定义并粘在一起的。它们一起相对于大地图map移动，让机器人移动就是向tf发布geometry_msgs::TransformStamped消息通知ros base_link相对于map的tf转换关系 。\n2、概念理解\n\n\n\n物理语义\n理解\n原点\n\n\n\nbase_link\n为相对机器人的本体的坐标系\n位于tf tree的最根部\n原点一般为表示机器人中心\n\n\nodom\n一个对于机器人全局位姿的粗略估计\n直接与base_link 相链接，数据一般来源于里程计(odometry)\n原点为开始计算位姿那个时刻的机器人的位置\n\n\nmap\n一个经过先验（或者SLAM）地图数据矫正过的，在地图中的位姿信息\n与odom（或者odom_combined）相连,与odom同为全局坐标系\n原点为地图原点（地图原点在地图相应的yaml文件中有规定）\n\n\n3、关系 map --&gt; odom --&gt; base_link odom到base_link的坐标转换是从运动源计算出来广播的。map到base_link的坐标转换是被定位模块计算出来的. 但定位模块不发布map到base_link的转换. 相反它先接受从odom到base_link的转换, 再计算并广播map到odom的位置转换关系\nfixed_frame：RViz中认定的大世界就是fixed_frame\ntarget_frame：Rviz中视觉跟踪的frame是 target_frame\n4、坐标转换在lidar的launch启动文件中增加：\n&lt;node pkg=&quot;tf&quot; type=&quot;static_transform_publisher&quot; name=&quot;base_link_to_laser4&quot;    args=&quot;0.0 0.0 0.2 0.0 3.1415926 0.0 /base_link /laser_frame 40&quot; /&gt;&lt;/launch&gt;\n\n\n\nargs=&quot;0.0 0.0 0.2 0.0 3.1415926 0.0 /base_link /laser_frame 40&quot;// 参数意义，分别对应static_transform_publisher的// x y z yaw pitch roll frame_id child_frame_id period_in_ms// x y z 是 x y z 的坐标// yaw pitch roll 是 绕 z旋转弧度角，绕y旋转弧度角，绕x旋转弧度角// frame_id child_frame_id period_in_ms 父坐标系，子坐标系，发布间隔（ms）// 上述是指的 z方向增加0.2m，绕y旋转180°// 这些相对变换就是固定base-link，看其他坐标在base_link下的偏移\n\n\n\n修改urdf文件的坐标 找到urdf的描述文件，如turtlebot_description&#x2F;urdf&#x2F;turtlebot_library.urdf.xacro，在文件中修改坐标\n&lt;joint name=&quot;laser&quot; type=&quot;fixed&quot;&gt;    &lt;origin xyz=&quot;0.00 0.00 0.20&quot; rpy=&quot;0 3.1415926 0&quot; /&gt;    &lt;parent link=&quot;base_link&quot; /&gt;    &lt;child link=&quot;base_laser_link&quot; /&gt;  &lt;/joint&gt;  &lt;link name=&quot;base_laser_link&quot;&gt;    &lt;visual&gt;      &lt;geometry&gt;        &lt;box size=&quot;0.00 0.05 0.06&quot; /&gt;      &lt;/geometry&gt;      &lt;material name=&quot;Green&quot; /&gt;    &lt;/visual&gt;    &lt;inertial&gt;      &lt;mass value=&quot;0.000001&quot; /&gt;      &lt;origin xyz=&quot;0 0 0&quot; /&gt;      &lt;inertia ixx=&quot;0.0001&quot; ixy=&quot;0.0&quot; ixz=&quot;0.0&quot;        iyy=&quot;0.0001&quot; iyz=&quot;0.0&quot;        izz=&quot;0.0001&quot; /&gt;    &lt;/inertial&gt;  &lt;/link&gt;","categories":["机器人"],"tags":["ros"]},{"title":"ROS 之 topic 发布","url":"/2149880123.html","content":"Ros使用topic发布array：C++实现publish这里只需要数据data数据#include &quot;ros/ros.h&quot;#include &quot;std_msgs/Float32MultiArray.h&quot;int main(int argc, char **argv)&#123;    ros::init(argc, argv, &quot;Array_pub&quot;);    ros::NodeHandle nh;    ros::Publisher chatter_pub = nh.advertise&lt;std_msgs::Float32MultiArray&gt;(&quot;chatter&quot;, 1000);    ros::Rate loop_rate(10);    while (ros::ok())    &#123;        std_msgs::Float32MultiArray msg;        msg.data.push_back(1.0);//自己写的，可行        msg.data.push_back(2.0);        msg.data.push_back(3.0);        msg.data.push_back(4.0);        chatter_pub.publish(msg);        ros::spinOnce();        loop_rate.sleep();    &#125;    return 0;&#125;// 订阅#include &quot;ros/ros.h&quot;#include &quot;std_msgs/Float32MultiArray.h&quot;void chatterCallback(const std_msgs::Float32MultiArray::ConstPtr&amp; msg)&#123;    ROS_INFO(&quot;I heard: [%f],[%f],[%f],[%f]&quot;, msg-&gt;data.at(0),msg-&gt;data.at(1),msg-&gt;data.at(2),msg-&gt;data.at(3));&#125;int main(int argc, char **argv)&#123;    ros::init(argc, argv, &quot;Array_sub&quot;);    ros::NodeHandle nh;    ros::Subscriber sub = nh.subscribe(&quot;chatter&quot;, 1000, chatterCallback);    ros::spin();    return 0;&#125;\n\n\n\npython实现#! /usr/bin/python# -*- coding: utf-8 -*-import rospyfrom std_msgs.msg import Float32MultiArraydef talker():    pub_p = rospy.Publisher(&#x27;lefttop_point&#x27;, Float32MultiArray, queue_size=1)    rospy.init_node(&#x27;talker&#x27;, anonymous=True)    rate = rospy.Rate(10) # 10hz    while not rospy.is_shutdown():    array = [521,1314]    left_top = Float32MultiArray(data=array)        #也可以采用下面的形式赋值        #left_top = Float32MultiArray()        #left_top.data = [521,1314]        #left_top.label = &#x27;love&#x27;        rospy.loginfo(left_top)    pub_p.publish(left_top)        rate.sleep()if __name__ == &#x27;__main__&#x27;:    try:        talker()    except rospy.ROSInterruptException:        pass\n\n\n\nROS Publish&#x2F;Subscribe Arrays Example// Publish.cpp#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;ros/ros.h&quot;#include &quot;std_msgs/MultiArrayLayout.h&quot;#include &quot;std_msgs/MultiArrayDimension.h&quot;#include &quot;std_msgs/Int32MultiArray.h&quot;int main(int argc, char **argv)&#123;    ros::init(argc, argv, &quot;arrayPublisher&quot;);    ros::NodeHandle n;    ros::Publisher pub = n.advertise&lt;std_msgs::Int32MultiArray&gt;(&quot;array&quot;, 100);    while (ros::ok())    &#123;        std_msgs::Int32MultiArray array;        //Clear array        array.data.clear();        //for loop, pushing data in the size of the array        for (int i = 0; i &lt; 90; i++)        &#123;            //assign array a random number between 0 and 255.            array.data.push_back(rand() % 255);        &#125;        //Publish array        pub.publish(array);        //Let the world know        ROS_INFO(&quot;I published something!&quot;);        //Do this.        ros::spinOnce();        //Added a delay so not to spam        sleep(2);    &#125;&#125;// Subscribe.cpp#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &quot;ros/ros.h&quot;#include &quot;std_msgs/MultiArrayLayout.h&quot;#include &quot;std_msgs/MultiArrayDimension.h&quot;#include &quot;std_msgs/Int32MultiArray.h&quot;int Arr[90];void arrayCallback(const std_msgs::Int32MultiArray::ConstPtr&amp; array);int main(int argc, char **argv)&#123;    ros::init(argc, argv, &quot;arraySubscriber&quot;);    ros::NodeHandle n;    ros::Subscriber sub3 = n.subscribe(&quot;array&quot;, 100, arrayCallback);    ros::spinOnce();    for(j = 1; j &lt; 90; j++)    &#123;        printf(&quot;%d, &quot;, Arr[j]);    &#125;    printf(&quot;\\n&quot;);    return 0;&#125;void arrayCallback(const std_msgs::Int32MultiArray::ConstPtr&amp; array)&#123;    int i = 0;    // print all the remaining numbers    for(std::vector&lt;int&gt;::const_iterator it = array-&gt;data.begin(); it != array-&gt;data.end(); ++it)    &#123;        Arr[i] = *it;        i++;    &#125;    return;&#125;\n\n\n\nstd_msgs、geometry_msgs这些直接搜ros wiki，都有用法的。\nRos使用topic发布LaserScan和PointCloud：消息类型：sensor_msgs&#x2F;LaserScan和 sensor_msgs&#x2F;PointCloud跟其他的消息一样，包括tf帧和与时间相关的信息。为了标准化发送这些信息，消息类型Header被用于所有此类消息的一个字段。 Header类型：Header包括是哪个字段。字段seq对应一个标识符，随着消息被发布，它会自动增加。字段stamp存储与数据相关联的时间信息。以激光扫描为例，stamp可能对应每次扫描开始的时间。字段frame_id存储与数据相关联的tf帧信息。以激光扫描为例，它将是激光数据所在帧。\nsensor_msgs&#x2F;LaserScan Message：# 这里有啥就填啥,就相当一个结构体X，然后(X.参数)即可# 测量的激光扫描角度，逆时针为正# 设备坐标帧的0度面向前（沿着X轴方向）#Header headerfloat32 angle_min        # scan的开始角度 [弧度]float32 angle_max        # scan的结束角度 [弧度]float32 angle_increment  # 测量的角度间的距离 [弧度]float32 time_increment   # 测量间的时间 [秒]float32 scan_time        # 扫描间的时间 [秒]float32 range_min        # 最小的测量距离 [米]float32 range_max        # 最大的测量距离 [米]float32[] ranges         # 测量的距离数据 [米] (注意: 值 &lt; range_min 或 &gt; range_max 应当被丢弃)float32[] intensities    # 强度数据 [device-specific units]\n\n\n\n#include &lt;ros/ros.h&gt;#include &lt;sensor_msgs/LaserScan.h&gt;int main(int argc, char** argv)&#123;  ros::init(argc, argv, &quot;laser_scan_publisher&quot;);  ros::NodeHandle n;  ros::Publisher scan_pub = n.advertise&lt;sensor_msgs::LaserScan&gt;(&quot;scan&quot;, 50);  unsigned int num_readings = 100;  double laser_frequency = 40;  double ranges[num_readings];  double intensities[num_readings];  int count = 0;  ros::Rate r(1.0);  while(n.ok())&#123;    //generate some fake data for our laser scan    //设置消息的长度，便于填充一些虚拟数据。真正的应用程序将从他们的激光扫描仪中获取数据    for(unsigned int i = 0; i &lt; num_readings; ++i)&#123;      ranges[i] = count;      intensities[i] = 100 + count;    &#125;    ros::Time scan_time = ros::Time::now();    //populate the LaserScan message    sensor_msgs::LaserScan scan;    scan.header.stamp = scan_time;    scan.header.frame_id = &quot;laser_frame&quot;;    scan.angle_min = -1.57;    scan.angle_max = 1.57;    scan.angle_increment = 3.14 / num_readings;    scan.time_increment = (1 / laser_frequency) / (num_readings);    scan.range_min = 0.0;    scan.range_max = 100.0;    scan.ranges.resize(num_readings);   //使用resize设定激光点的多少    scan.intensities.resize(num_readings);    //用每秒增加1的值填充虚拟激光数据    for(unsigned int i = 0; i &lt; num_readings; ++i)&#123;      scan.ranges[i] = ranges[i];      scan.intensities[i] = intensities[i];    &#125;    scan_pub.publish(scan);    ++count;    r.sleep();  &#125;&#125;\n\n\n\n\n\nsensor_msgs&#x2F;PointCloud Message： 可参考这篇#This message holds a collection of 3d points, plus optional additional information about each point.#Each Point32 should be interpreted as a 3d point in the frame given in the headerHeader headergeometry_msgs/Point32[] points  #Array of 3d pointsChannelFloat32[] channels       #Each channel should have the same number of elements as points array, and the data in each channel should correspond 1:1 with each point\n\n\n\n#include &lt;ros/ros.h&gt;#include &lt;sensor_msgs/PointCloud.h&gt;int main(int argc, char** argv)&#123;  ros::init(argc, argv, &quot;point_cloud_publisher&quot;);  ros::NodeHandle n;  ros::Publisher cloud_pub = n.advertise&lt;sensor_msgs::PointCloud&gt;(&quot;cloud&quot;, 50);  unsigned int num_points = 100;  int count = 0;  ros::Rate r(1.0);  while(n.ok())&#123;    sensor_msgs::PointCloud cloud;    cloud.header.stamp = ros::Time::now();    cloud.header.frame_id = &quot;sensor_frame&quot;;//填充 PointCloud 消息的头：frame 和 timestamp．    cloud.points.resize(num_points);//设置点云的数量．    //增加信道 &quot;intensity&quot; 并设置其大小，使与点云数量相匹配．    cloud.channels.resize(1);    cloud.channels[0].name = &quot;intensities&quot;;    cloud.channels[0].values.resize(num_points);    //使用虚拟数据填充 PointCloud 消息．同时，使用虚拟数据填充 intensity 信道．    for(unsigned int i = 0; i &lt; num_points; ++i)&#123;      cloud.points[i].x = 1 + count;      cloud.points[i].y = 2 + count;      cloud.points[i].z = 3 + count;      cloud.channels[0].values[i] = 100 + count;    &#125;    cloud_pub.publish(cloud);    ++count;    r.sleep();  &#125;&#125;\n\n\n\n\n\nros订阅velodyne激光的点云数据import numpy as npimport rospyfrom sensor_msgs.msg import PointCloud2import sensor_msgs.point_cloud2 as pc2import scipy.miscimport osdef point_cloud_2_birdseye(points):    x_points = points[:, 0]    y_points = points[:, 1]    z_points = points[:, 2]    f_filt = np.logical_and((x_points &gt; -50), (x_points &lt; 50))    # logical_and（逻辑与）    s_filt = np.logical_and((y_points &gt; -50), (y_points &lt; 50))    filter = np.logical_and(f_filt, s_filt)    indices = np.argwhere(filter)\t# 筛选符合范围的points    # 返回符合filter条件的位置索引，即第几个位置    x_points = x_points[indices]    y_points = y_points[indices]    z_points = z_points[indices]    x_img = (-y_points*10).astype(np.int32)+500    # 转换数组的数据类型    # 点云数据通常是浮点数，而图像数据通常是整数，所以要float映射到int    y_img = (-x_points *10).astype(np.int32)+500    pixel_values = np.clip(z_points,-2,2)    # numpy.clip(a, a_min, a_max, out=None)    # 将数组中的元素限制在-2和2之间，大于2的就使得它等于2，小于-2,的就使得它等于-2    pixel_values = ((pixel_values +2) / 4.0) * 255    im = np.zeros([1001, 1001], dtype=np.uint8)    im[y_img, x_img] = pixel_values    return imdef callback(lidar):    lidar = pc2.read_points(lidar)    # 函数 point_cloud2.read_points(data, field_names=(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;), skip_nans=True)    # 这个函数返回值是一个generator（python中的生成器，属于Iterator迭代器的一种）    points = np.array(list(lidar))    # 如果需要一次获得全部点，可以用list()转换为列表    im = point_cloud_2_birdseye(points)    scipy.misc.imsave(&#x27;./lidar.png&#x27;, im)\t# 将数组保存成图像    os._exit(0)\t\t# python无错误退出程序def cloud_subscribe():    rospy.init_node(&#x27;cloud_subscribe_node&#x27;)    rospy.Subscriber(&quot;/velodyne_points&quot;, PointCloud2, callback)    rospy.spin()cloud_subscribe()\n\n\n\n\n\nRos将回调函数写成类的形式：wiki 上介绍，在ROS中，想在回调函数中发布消息，有两个思路：1、把函数写成类的形式，把需要的一些变量在类中声明为全局变量。【推荐，模块化好】2、在函数中，把回调函数需要调用的变量声明为全局变量。也可以解决这个问题。【不好，不符合面向对象的风格】 下面的例子是在同一个节点中实现订阅一个消息，然后在该消息的回调函数中处理一下这些数据后再发布到另一个topic上。\n#include &lt;ros/ros.h&gt;class SubscribeAndPublish&#123;    public:    SubscribeAndPublish()    &#123;        //Topic you want to publish        pub_ = n_.advertise&lt;PUBLISHED_MESSAGE_TYPE&gt;(&quot;/published_topic&quot;, 1);        //PUBLISHED_MESSAGE_TYPE例如std_msgs::String        //Topic you want to subscribe        sub_ = n_.subscribe(&quot;/subscribed_topic&quot;, 1, &amp;SubscribeAndPublish::callback, this);  //注意这里，和wiki上不一样。&amp;SubscribeAndPublish这个是类名        //之所以用this，是因为第四个参数是一个指向【回调函数所在对象】的指针，官方文档例子里把sub定义在了类外面，我们把sub定义在了类的构造函数里面，所以this就是在实例化对象的时候指向对象的指针。（关于this：当调用成员函数a.volume 时，编译系统就把对象a的起始地址赋给this指针；构造函数：建立对象时自动执行。结合两者，在本例中建立类对象时，自动生成指向本对象的指针。）    &#125;    //SUBSCRIBED_MESSAGE_TYPE例如std_msgs::String,记得&amp;要保留    void callback(const SUBSCRIBED_MESSAGE_TYPE&amp; input)    &#123;        PUBLISHED_MESSAGE_TYPE output;        //.... do something with the input and generate the output...        //output = ...        pub_.publish(output);    &#125;    private:    ros::NodeHandle n_;    ros::Publisher pub_;    ros::Subscriber sub_;&#125;;//End of class SubscribeAndPublishint main(int argc, char **argv)&#123;    //Initiate ROS    ros::init(argc, argv, &quot;subscribe_and_publish&quot;);    //Create an object of class SubscribeAndPublish that will take care of everything    SubscribeAndPublish SAPObject;    ros::spin();    return 0;&#125;","categories":["机器人"],"tags":["ros"]},{"title":"ROS 之点云数据格式转换","url":"/2845537480.html","content":"前言使用ROS处理点云数据时，经常需要进行数据格式转换，这里做个记录。\n数据格式首先要了解点云常见的两种格式sensor_msgs/PointCloud2和pcl::PointT。\n\nsensor_msgs/PointCloud2是传感器中用的，像订阅激光点云或者相机点云topic返回的格式。格式如下header:            // 点云的头信息  seq: 963         // 次数  stamp:           // 时间戳    secs: 1541143772    nsecs: 912011000  frame_id: &quot;/camera_init&quot;height: 1          // 如果cloud 是无序的 height 是 1width: 852578      // 点云的长度fields:            // sensor_msgs/PointField[] fields  -    name: &quot;x&quot;    offset: 0    datatype: 7          // uint8 INT8    = 1                         // uint8 UINT8   = 2                         // uint8 INT16   = 3                         // uint8 UINT16  = 4                         // uint8 INT32   = 5                         // uint8 UINT32  = 6                         // uint8 FLOAT32 = 7                         // uint8 FLOAT64 = 8    count: 1  -    name: &quot;y&quot;    offset: 4    datatype: 7    count: 1  -    name: &quot;z&quot;    offset: 8    datatype: 7    count: 1  -    name: &quot;intensity&quot;    offset: 16    datatype: 7    count: 1is_bigendian: Falsepoint_step: 32      //  一个点占的比特数row_step: 27282496  // 一行的长度占用的比特数，就是width*point_step的大小data: [ ................... ] // Actual point data, size is (row_step*height)is_dense: True      // 没有非法数据点\npcl::PointT是一类格式，包括PointXYZ、PointXYZI、PointXYZRGBA、PointXYZRGB、PointXY等。一般处理点云就要将PointCloud2转为PCL格式，再进行操作。PointXYZI格式如下union&#123;    float data[4];    struct    &#123;       float x;       float y;       float z;    &#125;;&#125;;union&#123;    struct    &#123;       float intensity;     &#125;;    float data_c[4];&#125;;\n\nPointCloud2转PointXYZI有两种方法，一种是直接调用pcl自带的函数，一种是采用mencpy的方式，直接从地址提取部分点云。\n方法一直接调用pcl自带的函数函数pcl::fromROSMsg(const sensor_msgs::PointCloud2 &amp;cloud, pcl::PointCloud&lt;T&gt; &amp;pcl_cloud)。注意这个需要添加头文件#include &lt;pcl_conversions/pcl_conversions.h&gt;使用举例：\nvoid callback(const sensor_msgs::PointCloud2ConstPtr&amp; cloud) &#123;  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr pcl_cloud(      new pcl::PointCloud&lt;pcl::PointXYZI&gt;);  pcl::fromROSMsg(*cloud, *pcl_cloud);&#125;\n我们可以看下pcl::fromROSMsg做了啥\nnamespace pcl &#123;/** Provide to/fromROSMsg for sensor_msgs::PointCloud2 &lt;=&gt; pcl::PointCloud&lt;T&gt; * **/// pcl::PointCloud 与 sensor_msgs::PointCloud2 间的转换template &lt;typename T&gt;void toROSMsg(const pcl::PointCloud&lt;T&gt;&amp; pcl_cloud,              sensor_msgs::PointCloud2&amp; cloud) &#123;  pcl::PCLPointCloud2 pcl_pc2;  pcl::toPCLPointCloud2(pcl_cloud, pcl_pc2);  pcl_conversions::moveFromPCL(pcl_pc2, cloud);&#125;template &lt;typename T&gt;void fromROSMsg(const sensor_msgs::PointCloud2&amp; cloud,                pcl::PointCloud&lt;T&gt;&amp; pcl_cloud) &#123;  pcl::PCLPointCloud2 pcl_pc2;  pcl_conversions::toPCL(cloud, pcl_pc2);  pcl::fromPCLPointCloud2(pcl_pc2, pcl_cloud);&#125;template &lt;typename T&gt;void moveFromROSMsg(sensor_msgs::PointCloud2&amp; cloud,                    pcl::PointCloud&lt;T&gt;&amp; pcl_cloud) &#123;  pcl::PCLPointCloud2 pcl_pc2;  pcl_conversions::moveToPCL(cloud, pcl_pc2);  pcl::fromPCLPointCloud2(pcl_pc2, pcl_cloud);&#125;&#125;  // namespace pcl\n根据这个，其实我们也可以直接用pcl::fromPCLPointCloud2来实现\nvoid toPCL(const sensor_msgs::PointCloud2&amp; cloud,           pcl::PointCloud&lt;pcl::PointXYZI&gt;&amp; pcl_cloud) &#123;  pcl::PCLPointCloud2 pcl_pc2;  pcl_conversions::toPCL(cloud, pcl_pc2);  pcl::fromPCLPointCloud2(pcl_pc2, pcl_cloud);&#125;\n\n方法二当订阅得到的初始点云话题数据量过大时，使用pcl::fromROSMsg转成pcl点云再做处理，会用去大量的时间。因此采用mencpy的方式，直接从地址提取部分点云，可以有效节省时间。mencpy格式为void *memcpy(void *dest, const void *src, size_t n);第一个参数是接收数据的参数，第二个参数是数据的地址，第三个参数是数据的大小。根据上面sensor_msgs/PointCloud2的格式，datatype是7，所以对应的是FLOAT32。也就是说每个点都有x,y,z,intensity四个数据，数据类型都是float32，占四个字节。另外，point_step是32，即4x8。所以x,y,z占用前面12个字节，再空出4个字节后，存储intensity，再空出12个字节这四个数据的存储方式如下所示：\n\n\n\nx\ny\nz\n\nintensity\n\n\n\n\n\n\n所有点云的数据是保存在uint8[] data中的，所以我们只要每隔32个字节，把其中对应的数据取出，就完成了ROS话题转换pcl话题：\nvoid callback(const sensor_msgs::PointCloud2ConstPtr&amp; cloud) &#123;  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr pcl_cloud(      new pcl::PointCloud&lt;pcl::PointXYZI&gt;);  for (int i = 0; i &lt; cloud-&gt;width * cloud-&gt;height; i++) &#123;    pcl::PointXYZI p;    std::memcpy(&amp;p.x, &amp;cloud-&gt;data[32 * i], 4);    std::memcpy(&amp;p.y, &amp;cloud-&gt;data[32 * i + 4], 4);    std::memcpy(&amp;p.z, &amp;cloud-&gt;data[32 * i + 8], 4);    std::memcpy(&amp;p.intensity, &amp;cloud-&gt;data[32 * i + 16], 4);    pcl_cloud-&gt;points.push_back(p);  &#125;&#125;\nPointXYZI转PointCloud2和上面类似，直接调用pcl自带的函数函数pcl::toROSMsg(const pcl::PointCloud&lt;T&gt;&amp; pcl_cloud, sensor_msgs::PointCloud2&amp; cloud)。使用举例：\nvoid callback(const const pcl::PointCloud&lt;pcl::PointXYZI&gt;::ConstPtr pcl_cloud) &#123;  sensor_msgs::PointCloud2::Ptr cloud(new sensor_msgs::PointCloud2);  pcl::toROSMsg(*pcl_cloud, *cloud);&#125;\n同样，也可以直接调用pcl::toPCLPointCloud2来实现\nvoid fromPCL(const pcl::PointCloud&lt;pcl::PointXYZI&gt;&amp; pcl_cloud,             sensor_msgs::PointCloud2&amp; cloud) &#123;  pcl::PCLPointCloud2 pcl_pc2;  pcl::toPCLPointCloud2(pcl_cloud, pcl_pc2);  pcl_conversions::moveFromPCL(pcl_pc2, cloud);&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["机器人"],"tags":["ros"]},{"title":"ROS 之坐标系理解","url":"/3018098590.html","content":"﻿### 地理坐标系\n北东地。北为X轴、东为Y轴、地为Z轴。\n地面坐标系（earth-surface inertial reference frame）①在地面上选一点Og②使xg轴在水平面内并指向某一方向③zg轴垂直于地面并指向地心④yg轴在水平面内垂直于xg轴，其指向按右手定则确定\n\n机体坐标系(Aircraft-body coordinate frame)①原点O取在飞机质心处，坐标系与飞机固连②x轴在飞机对称平面内并平行于飞机的设计轴线指向机头③y轴垂直于飞机对称平面指向机身右方④z轴在飞机对称平面内，与x轴垂直并指向机身下方\n\n\n姿态角（Euler角）：机体坐标系与地面坐标系的关系是三个Euler角：yaw，pitch，roll，反应了飞机相对地面的姿态。我的理解是，roll角是Zb在ZOY平面与Z轴的夹角。pitch角是Zb在ZOX平面与Z轴的夹角。yaw角是Xb在XOY平面与X轴的夹角。\n\n\nroll（横滚角）ϕ：飞机对称平面与通过飞机机体纵轴的铅垂平面间的夹角，右滚为正；pitch（俯仰角）θ：机体轴与地平面（水平面 ）之间的夹角，飞机抬头为正；yaw（偏航角）ψ：机体轴在水平面上的投影与地轴之间的夹角，以机头右偏为正。\n旋转矩阵：地理坐标系到机体坐标系的转换矩阵。旋转矩阵为正交阵，逆即转置。\n传感器：都是基于机体坐标系的。加速度计测三轴的加速度，磁力计测三轴的磁感应强度，陀螺仪测三轴的角速度。注意角速度的定义，方向是沿着三轴的。得到姿态角主要靠陀螺仪测得的角速度积分，但存在漂移误差，因此要用加速度计和磁力计随时校正。\n很重要的：在地理坐标系下，重力加速度坐标始终为（0,0,1g），磁场坐标为（M,0,D）。在地球表面，磁场始终是沿着磁感应线指北的，某点的磁场强度为磁感应线在该点的切线，它在北方有个分量，在垂直方向有个分量，在Y轴是没有分量的，即（M,0，D）。这里还有一点，地理的北极和磁场的北极是不重合的，有一定的夹角，即磁偏角。根据经纬度是可以查到这个夹角的大小的。我们定义的地理坐标系的北当然是地理的北。但用磁力计求得实际是Xb与地磁的北的夹角，我们最后会加上磁偏角，这样就是Xb与地理北的夹角了，就是真正的航向角啦。\n\n\n惯性坐标系地心惯性坐标系（earth-centered inertial frame, ECI）\n","categories":["机器人"],"tags":["ros"]},{"title":"ROS 之工作空间","url":"/1309878189.html","content":"ROS创建功能包$ cd %TOP_DIR_YOUR_CATKIN_WS%/src$ catkin_create_pkg robot_setup_tf roscpp tf geometry_msgs\n\nTF变换(参考)// tf_broadcaster.cpp#include &lt;ros/ros.h&gt;#include &lt;tf/transform_broadcaster.h&gt;int main(int argc, char** argv)&#123;  ros::init(argc, argv, &quot;robot_tf_publisher&quot;);  ros::NodeHandle n;  ros::Rate r(100);  tf::TransformBroadcaster broadcaster;    //创建一个tf::TransformBroadcaster类的实例，用来广播 base_link → base_laser的变换关系  while(n.ok())&#123;    broadcaster.sendTransform(      tf::StampedTransform(        tf::Transform(tf::Quaternion(0, 0, 0, 1), tf::Vector3(0.1, 0.0, 0.2)),        ros::Time::now(),&quot;base_link&quot;, &quot;base_laser&quot;));//Quaternion四元数来存储旋转变换的参数,第二个参数是坐标的位移变换,第三个参数是时间戳,第四个参数是母节点存储的参考系，即base_link，最后一个参数是子节点存储的参考系，即base_laser    r.sleep();  &#125;&#125;// tf_listener.cpp#include &lt;ros/ros.h&gt;#include &lt;geometry_msgs/PointStamped.h&gt;#include &lt;tf/transform_listener.h&gt;//一个TransformListener对象自动订阅了ROS变换消息话题和管理所有的进入的转换数据void transformPoint(const tf::TransformListener&amp; listener)&#123;  //创建一个函数，给定TransformListener，在“base_laser”坐标系中取一个点，并将其转换为“base_link”坐标系  geometry_msgs::PointStamped laser_point;//创建一个点作为geometry_msgs::PointStamped,这里“Stamped”只是意味着它包含一个头，允许我们将时间戳和frame_id与消息相关联  laser_point.header.frame_id = &quot;base_laser&quot;;//因为我们在“base_laser”坐标系中创建一个点  //we&#x27;ll just use the most recent transform available for our simple example  laser_point.header.stamp = ros::Time();  //just an arbitrary point in space  laser_point.point.x = 1.0;  laser_point.point.y = 0.2;  laser_point.point.z = 0.0;  try&#123;    geometry_msgs::PointStamped base_point;    listener.transformPoint(&quot;base_link&quot;, laser_point, base_point);//参数为我们想要将点转换为的坐标系的名称,我们正在转换的点,存储变换点      //TransformListener对象d transformPoint()函数就是用来变换的    ROS_INFO(&quot;base_laser: (%.2f, %.2f. %.2f) -----&gt; base_link: (%.2f, %.2f, %.2f) at time %.2f&quot;,        laser_point.point.x, laser_point.point.y, laser_point.point.z,        base_point.point.x, base_point.point.y, base_point.point.z, base_point.header.stamp.toSec());  &#125;  catch(tf::TransformException&amp; ex)&#123;    ROS_ERROR(&quot;Received an exception trying to transform a point from \\&quot;base_laser\\&quot; to \\&quot;base_link\\&quot;: %s&quot;, ex.what());  &#125;//打印错误&#125;int main(int argc, char** argv)&#123;  ros::init(argc, argv, &quot;robot_tf_listener&quot;);  ros::NodeHandle n;  tf::TransformListener listener(ros::Duration(10));  //we&#x27;ll transform a point once every second  ros::Timer timer = n.createTimer(ros::Duration(1.0), boost::bind(&amp;transformPoint, boost::ref(listener)));  ros::spin();&#125;\n\nrviz(参考)joint_state_publisher包sudo apt-get install ros-kinetic-joint-state-publisher\n\n在launch文件里加入下面这句，用来描述机器人各个关节状态的主题\n&lt;node name=&quot;joint_state_publisher&quot; pkg=&quot;learning_urdf&quot; type=&quot;joint_state_publisher&quot; /&gt;\n\nrobot_state_publisher包sudo apt-get install ros-kinetic-robot-state-publisher\n\n在launch文件里加入下面这句，用来加载robot状态发布节点\n&lt;node name=&quot;robot_state_publisher&quot; pkg=&quot;robot_state_publisher&quot; type=&quot;state_publisher&quot; /&gt;\n\n“robot_state_publisher”就是一个tf广播器， 它是一个C++的程序，订阅了”joint_states”主题，计算各个坐标系之间的变换关系，并将之广播出去\n主题的发布者只有joint_state_publisher，订阅者是robot_state_publisher。\n保存地图rosrun map_server map_saver -f map(地图名称)","categories":["机器人"],"tags":["ros"]},{"title":"ROS 之自定义 msg","url":"/921871846.html","content":"代码层级图|- usbacn_ws    |- build    |- devel    |- src        |- CMakeLists.txt        |- usbcan_test            |- include                |- .h*            |- lib                |- .so*            |- msg                |- test.msg            |- main.cpp            |- CmakeLists.txt            |- package.xml\n\n\n\n步骤1、新建功能包首先创建一个空的package单独存放msg类型（当然也可以在任意的package中自定义msg类型） 这里为便于说明，建立一个名为usbcan_test的包，用于对自定义msg类型的用法举例\n$ cd usbacn_ws/src$ catkin_create_pkg usbcan_test\n\n\n\n2、新建msg文件在usbcan_test中创建msg文件夹，在msg文件夹其中新建一个名为test.msg消息类型文件\n$ cd usbcan_test$ mkdir msg$ gedit test.msg# 内容如下：std_msgs/Header headerint16 idint16 lenint32[8] data\n\n\n\n3、修改package.xml需要message_generation生成C++或Python能使用的代码，即将将.msg文件编译生成.h文件，需要message_runtime提供运行时的支持，所以package.xml中添加以下两句(一般生成的文件中都有了，去注释就行)\n&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;run_depend&gt;message_runtime&lt;/run_depend&gt;# 或者这一句&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;\n\n\n\n如果还要ros支持，同样去注释\n&lt;build_depend&gt;roscpp&lt;/build_depend&gt;&lt;exec_depend&gt;roscpp&lt;/exec_depend&gt;\n\n\n\n4、修改CMakeLists.txt这个CMakeLists.txt是功能包下的，有几点注意：(1) 首先调用find_package查找依赖的包，必备的有roscpp 、rospy 、message_generation，其他根据具体类型添加，比如上面的msg文件中用到了std_msgs/Header header类型，那么必须查找std_msgs\nfind_package(catkin REQUIRED COMPONENTS   roscpp   rospy   std_msgs   message_generation)\n\n\n\n(2) 然后是add_message_files，指定msg文件\nadd_message_files(    FILES    test.msg)\n\n\n\n(3) 然后是generate_messages，指定生成消息文件时的依赖项，比如上面嵌套了其他消息类型std_msgs，那么必须注明\n# generate_messages必须在catkin_package前面generate_messages(    DEPENDENCIES    std_msgs)\n\n\n\n(4) 然后是catkin_package设置运行依赖\ncatkin_package(#    INCLUDE_DIRS include    LIBRARIES usbcan_test    CATKIN_DEPENDS roscpp message_runtime    DEPENDS system_lib)\n\n\n\n到这里新的msg类型usbcan_test/test就可以使用了，下面编译这个包，然后利用rosmsg show指令查看\n$ cd catkin_ws$ catkin_make$ rosmsg show usbcan_test/teststd_msgs/Header header  uint32 seq  time stamp  string frame_idint16 idint16 lenint32[8] data\n\n\n\n5、调用自定义msg类型如果是在usbcan_test包内的节点中调用usbcan_test/test类型，只需要在.cpp文件中如下调用即可\n#include &quot;usbcan_test/test.h&quot;usbcan_test::test msg;// (usbcan_test文件夹)::(test.msg) (随便一个名称)\n\n\n\n然后修改CMakeLists.txt\n# add_executable($&#123;PROJECT_NAME&#125;_node src/usbcan_test_node.cpp)add_executable(cantest /home/fu/usbcan_ws/src/usbcan_test/main.cpp)# add_dependencies($&#123;PROJECT_NAME&#125; $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)# 这个PROJECT_NAME就是你到时rosrun的节点名add_dependencies(cantest $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)# 动态库依赖(如果需要的话)target_link_libraries(cantest $&#123;catkin_LIBRARIES&#125;    /usr/lib/libECanVci.so    /usr/lib/libusb.so    /usr/lib/libusb-1.0.so)\n\n\n\n因为还用到include文件夹里的头文件，所以CMakeLists.txt要去注释\ninclude_directories(    include    $&#123;catkin_INCLUDE_DIRS&#125;)\n\n\n\n6、其他包调用自定义msg类型如果是在其他包调用usbcan_test/test类型则需要修改package.xml和CMakeLists.txt，比如同样在工作空间usbacn_ws内有一个名为test的包，我们可以在这个包内写一个节点，使用我们刚才自定义的消息类型usbcan_test/test，如下： (1) 修改package.xml 养成好习惯，维护软件包清单的更新，以便于别人使用你的软件前安装各种依赖项，当然这个文件不影响程序编译\n&lt;build_depend&gt;roscpp&lt;/build_depend&gt;&lt;run_depend&gt;roscpp&lt;/run_depend&gt;&lt;build_depend&gt;usbcan_test&lt;/build_depend&gt;&lt;run_depend&gt;usbcan_test&lt;/run_depend&gt;\n\n\n\n(2) 修改CMakeLists.txt调用自定义消息类型主要修改两个地方，以下是重点： 一是find_package中需要声明查找包含该消息类型的包； 二是add_dependencies要注明该消息的依赖，其他地方和普通节点一样\nfind_package(catkin REQUIRED COMPONENTS  roscpp  rospy  message_generation  usbcan_test)add_dependencies(test1 usbcan_test_gencpp)#调用同一工作空间的自定义消息类型时注明依赖关系，防止发生头文件找不到的报错\n\n\n\n完整工程参考\n","categories":["机器人"],"tags":["ros"]},{"title":"SLAM 之拟合直线","url":"/1673567539.html","content":"最小二乘法拟合直线上周面试了一家做机器人的公司，他们发我一道题目，顺便记录学习下。\n问题给定一组2D平面上的离散点： 请求解出对应拟合直线\n要求有几点：1、建立该问题的数学模型，并且基于C++予以实现，包括：类/接口定义，以及实现细节2、建议选择如下两种方法之一，或者酌情选择其他的方法：\n\n基于ceres优化库，建立优化问题，并求解\n基于Eigen工具库求解（提示：通过特征向量分解的方式）\n\n3、生成测试数据集，并对比验证不同实现的拟合效果4、输出一份报告，包括：问题的定义，求解细节，以及验证结果等\n\n分析其实就是直线拟合，这里就想到了最小二乘（视觉SLAM十四讲有写）。\n最小二乘法，又称最小平方法。它通过最小化误差的平方和寻找数据的最佳函数匹配。主要作用是从一堆相关数据中求解数据的一般性规律。在图像处理方面多用于各种形状的拟合。\n最小二乘拟合直线，主要体现为找到一条直线，使得所有已知的点到这条直线的欧式距离的和最小（或者理解为点到直线的误差平方和最小）。\n那我是思考了两种方法，一种是直接求解最小二乘，一种是使用Ceres库优化迭代最小二乘。\n解决数学模型的建立\n目标\n\n对于等精度测量所得的N组数据，。其中值被认为是准确的，所有误差只与有关。需要把这组观测数据拟合成一条直线，并求对应法向量。\n\n\n约束\n\n要求观测值的偏差的加权平方和为最小，即最小。\n\n\n变量\n\n对于一条直线，有两个待定参数，代表截距，代表斜率（代码里取）。\n\n\n\n法一：直接求解采用直线斜截式，通过最小二乘拟合方程系数\n根据最小二乘原理，误差平方和最小，得误差函数：\n高数中极值定理可知，误差方程一阶导数等于处取得极值，因此分别对其关于和求导，解,值使得误差函数取最小值。\n但是直线斜截式无法表示垂直x轴的直线，如：。\n\n\n\n令，得\n\n\n\n\n上面过程繁琐，只适用于直线的最小二乘解。下面将直线斜截式拓展导任意曲线，任意曲线方程\n。可以看到直线斜截式即，时的曲线方程。将曲线方程，写成矩阵乘积的形式：\n\n上面乘积形式，即,解出的 就是最小二乘解。\n代码如下：\nvoid LeastSquares(std::vector&lt;double&gt; &amp;data_x, std::vector&lt;double&gt; &amp;data_y,                  int data_n) {  double A, B, C, D, E, F = 0.0;  double x_square_sum, x_sum, y_sum, xy_multi_sum = 0.0;  for (int i = 0; i &lt; data_n; i++) {    x_square_sum += data_x[i] * data_x[i];    x_sum += data_x[i];    xy_multi_sum += data_x[i] * data_y[i];    y_sum += data_y[i];  }  // 计算斜率k和截距b  double k, b, temp = 0;  if (temp = (data_n * x_square_sum - x_sum * x_sum)) {    k = (data_n * xy_multi_sum - x_sum * y_sum) / temp;    b = (x_square_sum * y_sum - x_sum * xy_multi_sum) / temp;  } else {    k = 1;    b = 0;  }  // 计算x和y线性相关系数r  double Xmean, Ymean;  Xmean = x_sum / data_n;  Ymean = y_sum / data_n;  double tempSumXX = 0.0, tempSumYY = 0.0;  for (int i = 0; i &lt; data_n; i++) {    tempSumXX += (data_x[i] - Xmean) * (data_x[i] - Xmean);    tempSumYY += (data_y[i] - Ymean) * (data_y[i] - Ymean);    E += (data_x[i] - Xmean) * (data_y[i] - Ymean);  }  F = sqrt(tempSumXX) * sqrt(tempSumYY);  double r;  r = E / F;  std::cout &lt;&lt; \"k: \" &lt;&lt; k &lt;&lt; \"\\n\"            &lt;&lt; \"b: \" &lt;&lt; b &lt;&lt; \"\\n\"            &lt;&lt; \"r: \" &lt;&lt; r &lt;&lt; std::endl;  // AX + BY + C = 0  std::cout &lt;&lt; \"Direction Vector   (B,-A): (\" &lt;&lt; -1 &lt;&lt; \",\" &lt;&lt; -k &lt;&lt; \")\\n\";  std::cout &lt;&lt; \"Normal Vector      (A,B): (\" &lt;&lt; k &lt;&lt; \",\" &lt;&lt; -1 &lt;&lt; \")\\n\";  const char *title = \"curve fitting by LS\";  Plot(data_x, data_y, k, b, title);}\n\n法二：Ceres优化首先是定义残差快\nstruct ExponentialResidual {  ExponentialResidual(double x, double y) : x_(x), y_(y) {}  template &lt;typename T&gt;  bool operator()(const T *const k, const T *const b, T *residual) const {    // r = y - f(x)    residual[0] = y_ - (k[0] * x_ + b[0]);    return true;  } private:  const double x_;  const double y_;};\n\n然后构建最小二乘问题\nfor (int i = 0; i &lt; data_x.size(); ++i) {    problem.AddResidualBlock(        new ceres::AutoDiffCostFunction&lt;ExponentialResidual, 1, 1, 1&gt;(            new ExponentialResidual(data_x[i], data_y[i])),        NULL, &amp;k, &amp;b);}\n\n最后优化求解\nceres::Solver::Options options;options.max_num_iterations = 20;options.linear_solver_type = ceres::DENSE_QR;options.minimizer_progress_to_stdout = true;ceres::Solver::Summary summary;ceres::Solve(options, &amp;problem, &amp;summary);\n\n结果\n\n代码仓库Least_Square_Fitting_Line\n参考1、最小二乘法求解直线方程系数\n2、ceres拟合直线\n","categories":["工具脚本"],"tags":["数学","slam"]},{"title":"Tmux 入坑指南","url":"/15239708.html","content":"前言tmux是程序员们必备的一款神器，有了它，就可以轻松地在服务器上开启多个shell来进行工作。这些shell会很好地运行着，在下一次连接到服务器上的时候，可以接着上次的工作继续进行下去。\n简介tmux 是一个优秀的终端复用器类自由软件，功能类似 GNU Screen，但使用 BSD 许可发布。用户可以通过 tmux 在一个终端内管理多个分离的会话，窗口及面板，对于同时使用多个命令行，或多个任务时非常方便。功能很多，总而言之，入坑就对了。\n\n一个虚拟终端可以管理多个会话，窗口和面板\n支持分屏，同时处理多个操作\n窗口、面板可以在会话间自由移动，切换\n丰富灵活的状态行展示\n支持自定义快捷键，依照个人习惯配置令操作更高效\n不受断网影响，避免丢失重要工作进度\n结对编程，方便演示与协作\n自带复制粘贴缓冲区管理\n脚本化配置，可配置多种操作环境\n\n层次结构tmux的主要元素分为三层：\n\nSession，一组窗口的集合。通常用来概括同一个任务。session可以有自己的名字便于任务之间的切换。\nWindow，单个可见窗口。Windows有自己的编号，也可以认为和ITerm2中的Tab类似。\nPane，窗格。被划分成小块的窗口，类似于Vim中 C-w +v 后的效果。\n\n安装sudo apt-get install tmux\n使用\n查询Session，tmux ls\n创建Session，tmux new -s session-name\n断开Session，tmux detach\n重新连接Session，tmux a -t session-name\n关闭Session，tmux kill-session -t session-name\n\n默认快捷键\n\n\n系统指令\n\n\n\n\n\nCtrl+b\n?\n显示快捷键帮助文档\n\n\nCtrl+b\nd\n断开当前会话\n\n\nCtrl+b\nD\n选择要断开的会话\n\n\nCtrl+b\nCtrl+z\n挂起当前会话\n\n\nCtrl+b\nr\n强制重载当前会话\n\n\nCtrl+b\ns\n显示会话列表用于选择并切换\n\n\nCtrl+b\n:\n进入命令行模式，此时可直接输入ls等命令\n\n\nCtrl+b\n[\n进入复制模式，按q退出\n\n\nCtrl+b\n]\n粘贴复制模式中复制的文本\n\n\nCtrl+b\n~\n列出提示信息缓存\n\n\n\n\n\n窗口指令\n\n\n\n\n\nCtrl+b\nc\n新建窗口\n\n\nCtrl+b\n&amp;\n关闭当前窗口（关闭前需输入y or n确认）\n\n\nCtrl+b\n0~9\n切换到指定窗口\n\n\nCtrl+b\np\n切换到上一窗口\n\n\nCtrl+b\nn\n切换到下一窗口\n\n\nCtrl+b\nw\n打开窗口列表，用于且切换窗口\n\n\nCtrl+b\n,\n重命名当前窗口\n\n\nCtrl+b\n.\n修改当前窗口编号（适用于窗口重新排序）\n\n\nCtrl+b\nf\n快速定位到窗口（输入关键字匹配窗口名称）\n\n\n\n\n\n窗格指令\n\n\n\n\n\nCtrl+b\n“\n当前面板上下一分为二，下侧新建面板\n\n\nCtrl+b\n%\n当前面板左右一分为二，右侧新建面板\n\n\nCtrl+b\nx\n关闭当前面板（关闭前需输入y or n确认）\n\n\nCtrl+b\nz\n最大化当前面板，再重复一次按键后恢复正常（v1.8版本新增）\n\n\nCtrl+b\n!\n将当前面板移动到新的窗口打开（原窗口中存在两个及以上面板有效）\n\n\nCtrl+b\n;\n切换到最后一次使用的面板\n\n\nCtrl+b\nq\n显示面板编号，在编号消失前输入对应的数字可切换到相应的面板\n\n\nCtrl+b\n{\n向前置换当前面板\n\n\nCtrl+b\n}\n向后置换当前面板\n\n\nCtrl+b\nCtrl+o\n顺时针旋转当前窗口中的所有面板\n\n\nCtrl+b\n方向键\n移动光标切换面板\n\n\nCtrl+b\no\n选择下一面板\n\n\nCtrl+b\n空格键\n在自带的面板布局中循环切换\n\n\nCtrl+b\nAlt+方向键\n以5个单元格为单位调整当前面板边缘\n\n\nCtrl+b\nCtrl+方向键\n以1个单元格为单位调整当前面板边缘（Mac下被系统快捷键覆盖）\n\n\nCtrl+b\nt\n显示时钟\n\n\n配置文件tmux 中的很多操作都是通过快捷键去实现的 ，每次基本都要先执行prefix（默认是Ctrl+b），这个前缀键对我是十分不友好的，所以我通过配置文件修改成Ctrl+a。通常配置文件路径为~/.tmux.conf，根目录没有就新建一个。以下是我的配置。\n# Send prefix，设置Ctrl+a为前缀键set-option -g prefix C-aunbind-key C-abind-key C-a send-prefix# Mouse mode，设置可以鼠标点击不同窗格set -g mouse on# Set easier window split keys，设置‘=’为向右新开窗格，‘-’为向下新开窗格bind-key = split-window -hbind-key - split-window -v# tmux插件，用于备份session，免得电脑重启需要重新打命令set -g @plugin &#x27;tmux-plugins/tpm&#x27;set -g @plugin &#x27;tmux-plugins/tmux-resurrect&#x27;set -g @plugin &#x27;tmux-plugins/tmux-continuum&#x27;set -g @continuum-save-interval &#x27;60&#x27;set -g @continuum-restore &#x27;on&#x27;set -g @resurrect-capture-pane-contents &#x27;on&#x27;run-shell ~/.tmux/plugins/tmux-resurrect/resurrect.tmuxrun-shell ~/.tmux/plugins/tmux-continuum/continuum.tmux\n修改完配置需要source配置文件才能完成\ntmux source ~/.tmux.conf\n自动备份到这里是不是跃跃欲试了，稍等，有些特殊bug我们需要注意。当机器需要重启或者意外断电等导致关机，这个时候tmux的session就全部丢失了。作为tmux的重度用户，有时候会有上百个session，有些session中保存了历史命令有可能已经记不清了，session的丢失无疑是个重大的损失。好在开源社区早已经有了解决方案，只需要简单地配置就可以实现session的会话的自动保存和加载。\n原理整个解决方案由三个tmux插件组成。\n\ntpm：tmux plugin manager\n这个是用来管理tmux插件的。有了它之后，就可以很轻松地安装和写在tmux插件\n\n\ntmux-resurrect\n这个是主角，提供了保存tmux会话到磁盘，以及从磁盘上加载保存的会话的功能。但是只能在需要的时候手动操作\n\n\ntmux-continuum\n提供了定时保存，自动加载，以及开机设置自动启动tmux的功能。需要tmux-resurrect来完成具体的工作\n\n\n\n安装配置git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpmgit clone https://github.com/tmux-plugins/tmux-resurrect.git ~/.tmux/plugins/tmux-resurrectgit clone https://github.com/tmux-plugins/tmux-continuum.git ~/.tmux/plugins/tmux-continuum\n然后，在~/.tmux.conf中配置：\nset -g @plugin &#x27;tmux-plugins/tpm&#x27;set -g @plugin &#x27;tmux-plugins/tmux-resurrect&#x27;set -g @plugin &#x27;tmux-plugins/tmux-continuum&#x27;set -g @continuum-save-interval &#x27;60&#x27;set -g @continuum-restore &#x27;on&#x27;set -g @resurrect-capture-pane-contents &#x27;on&#x27;run-shell ~/.tmux/plugins/tmux-resurrect/resurrect.tmuxrun-shell ~/.tmux/plugins/tmux-continuum/continuum.tmux\n最后使配置文件生效tmux source ~/.tmux.conf这样每隔60分钟就会自动备份一波，你也可以手动备份，快捷键是prefix + Ctrl+s，下次重启后想要恢复，先执行tmux进入，然后prefix + Ctrl+r即可恢复先来的窗口，美滋滋。另外，如果不小心手动备份一个错误的tmux，想要回滚，可以进入.tmux/resurrect，使用ln -s将last链接到指定的tmux_resurrect_xxx.txt文件即可\n参考\ntmux-plugins&#x2F;tmux-resurrect\n\n题外话oh-my-zsh与tmux搭配更丝滑哦\n","categories":["开发运维"],"tags":["linux"]},{"title":"ROS 使用 move_base 做4个点循环跑的导航","url":"/2024475831.html","content":"前言记录一下用move_base跑4个目标点的程序。\n首先《ros by example 1》里有个用move_base跑4个目标点的程序，先去看了下源码，发现它仅仅是把目标点发送出去，然后等待move_base 60s，如果这段时间内成功完成导航任务，则继续发布下个目标点，否则退出。代码如下所示：\ndef move(self, goal):    # Send the goal pose to the MoveBaseAction server    self.move_base.send_goal(goal)    # Allow 1 minute to get there    finished_within_time = self.move_base.wait_for_result(rospy.Duration(60))    # If we don&#x27;t get there in time, abort the goal    if not finished_within_time:        self.move_base.cancel_goal()        rospy.loginfo(&quot;Timed out achieving goal&quot;)        else:            # We made it!            state = self.move_base.get_state()            if state == GoalStatus.SUCCEEDED:                rospy.loginfo(&quot;Goal succeeded!&quot;)\n\n当时觉得好无语，哪有做控制是靠等待时间来判断的啊，通过当前位姿与目标点位姿的距离才能判断出导航任务是否完成啊。所以，只要把这段代码中添加一个距离的判断就可以实现基于move_base的循环导航了。即：\nif distance &lt; 1.0:    move_base.send_goal(goal)\n\n只要当前位姿与目标点位姿的距离小于1米了，我就重新发送一个目标点给move_base，这样就可以实现循环导航了（在实验时试过：在导航过程中重新发送目标点，机器人会重新规划处一条到新目标点的路径及轨迹）。那当前时刻的位姿怎么确定呢？有2种方式，一种是订阅定位节点发布的位姿话题；感觉这种有点low，就pass掉了，更优越的方法就是用Actionlib。\nActionlib为了寻找这种更优的方法，只有去看move_base的源码了！看了代码发现move_base其实是actionlib的服务端的实现，好吧，不知道actionlib是啥。后来又去看actionlib的概念。action也是一种类似于~的问答通讯机制，不一样的地方是action还带有一个反馈机制，可以不断反馈任务的实施进度，而且可以在任务实施过程中，中止运行。哇，带反馈，这不就是我要的更优越的方法么。之后通过下面2位大神的文章以及ROS官网中的教程简单学习了一下actionlib的使用。ROS探索总结（三十二）——actionROS知识（15）—-Actionlib的使用（一）actionlib&#x2F; Tutorials\n如下图可以看出，action分为服务端和客户端，服务端会不断的向客服端发送反馈信息，而move_base为服务端，上述《ros by example 1 》中的例子为客服端。所以只需要在客户端中使用这个反馈就可以了。那么，怎么实现呢？\n\n问题1：是否发出了反馈消息我们先从第一个问题开始：通过这篇文章，知道了move_base确实是发布了反馈信息，而且反馈信息就是当前的位姿。ok，成功解决第一个问题。注意，这个反馈消息不是move_base发出来的，而是actionlib发出来的！\nbool MoveBase::executeCycle(    geometry_msgs::PoseStamped&amp; goal,    std::vector&lt;geometry_msgs::PoseStamped&gt;&amp; global_plan) &#123;  //发布速度topic  geometry_msgs::Twist cmd_vel;  // push the feedback out  //发布一些反馈信息  move_base_msgs::MoveBaseFeedback feedback;  feedback.base_position = current_position;  as_-&gt;publishFeedback(feedback);  //省略。。。&#125;void MoveBase::executeCb(    const move_base_msgs::MoveBaseGoalConstPtr&amp; move_base_goal) &#123;  // we have a goal so start the planner(通知planner线程进行路径规划)  boost::unique_lock&lt;boost::mutex&gt; lock(planner_mutex_);  planner_goal_ = goal;  runPlanner_ = true;  // 通知规划路径线程  planner_cond_.notify_one();  lock.unlock();  ros::NodeHandle n;  while (n.ok()) &#123;    // 被抢占了(可能是发出新的goal，也可能是取消了)    if (as_-&gt;isPreemptRequested()) &#123;      if (as_-&gt;isNewGoalAvailable()) &#123;        // 发布新的goal，通知planner线程工作。        planner_cond_.notify_one();      &#125; else &#123;        // if we&#x27;ve been preempted explicitly we need to shut things down        //强制退出        return;      &#125;    &#125;    //省略。。。  &#125;&#125;\n\n与此同时，我也看到了在新的目标点到来时，新的任务抢占了之前的任务，move_base会将新的目标点发送到actionlib中并重新规划路径。\n问题2：消息类型move_base的action通讯的消息类型在安装move_base时会自动安装，ROS中的move_base_msgs提供了这个消息的说明。简单说明一下，消息类型是由2个“—”分隔开的三种数据类型组成。第一条为目标点的消息类型；第二条为当此次动作执行完成时向客户端发送的消息类型，仅在动作结束时发送一次；第三条为反馈的消息类型，这个是在动作执行过程中一直发送的。\n在这里可以看到，move_base的反馈消息类型为 geometry_msgs/PoseStamped ，消息的名字为 base_position。\n#goal definitiongeometry_msgs/PoseStamped target_pose---#result definition---#feedbackgeometry_msgs/PoseStamped base_position\n\n 这个反馈消息是发送在/move_base命名空间下的/feedback话题上，也就是/move_base/feedback。通过接收这个话题得到的消息如下所示：\n---header:  seq: 640  stamp:    secs: 1547635103    nsecs: 592393429  frame_id: &#x27;&#x27;status:  goal_id:    stamp:      secs: 1547635097      nsecs: 258239984    id: &quot;/nav_test-4-1547635097.258&quot;  status: 1  text: &quot;This goal has been accepted by the simple action server&quot;feedback:  base_position:    header:      seq: 0      stamp:        secs: 1547635103        nsecs: 550548076      frame_id: &quot;map&quot;    pose:      position:        x: 0.00729128714117        y: 0.0192558593724        z: 0.0      orientation:        x: 0.0        y: 0.0        z: -0.0199257022983        w: 0.999801463486---\n\nOK，第二个问题成功解决掉。\n问题3：怎么接收反馈消息在学习actionlib时知道了actionlib的使用方式，即，一方为服务端，负责发送动作执行的状态与结果；一方为客户端，负责发送动作目标并监听动作状态。反馈消息是从服务端按照着自己定义的消息类型向客户端发出。所以，反馈消息的处理是在客服端内进行，通过回调函数的方式进行处理。ROS中有例子如下：\n#include &lt;actionlib/client/simple_action_client.h&gt;#include &lt;actionlib_tutorials/FibonacciAction.h&gt;#include &lt;ros/ros.h&gt;using namespace actionlib_tutorials;typedef actionlib::SimpleActionClient&lt;FibonacciAction&gt; Client;// Called once when the goal completesvoid doneCb(const actionlib::SimpleClientGoalState&amp; state,            const FibonacciResultConstPtr&amp; result) &#123;  ROS_INFO(&quot;Finished in state [%s]&quot;, state.toString().c_str());  ROS_INFO(&quot;Answer: %i&quot;, result-&gt;sequence.back());  ros::shutdown();&#125;// Called once when the goal becomes activevoid activeCb() &#123; ROS_INFO(&quot;Goal just went active&quot;); &#125;// Called every time feedback is received for the goalvoid feedbackCb(const FibonacciFeedbackConstPtr&amp; feedback) &#123;  ROS_INFO(&quot;Got Feedback of length %lu&quot;, feedback-&gt;sequence.size());&#125;int main(int argc, char** argv) &#123;  ros::init(argc, argv, &quot;test_fibonacci_callback&quot;);  // Create the action client  Client ac(&quot;fibonacci&quot;, true);  ROS_INFO(&quot;Waiting for action server to start.&quot;);  ac.waitForServer();  ROS_INFO(&quot;Action server started, sending goal.&quot;);  // Send Goal  FibonacciGoal goal;  goal.order = 20;  ac.sendGoal(goal, &amp;doneCb, &amp;activeCb, &amp;feedbackCb);  ros::spin();  return 0;&#125;\n\n可以看到，通过在发送目标点时将回调函数注册进去，从而在每次反馈消息到来时将自动调用回调函数，也就是上文中的feedbackCb()函数。在actionlib的源码中可以找到sendGoal()的声明，它为后面三个回调函数给了默认的初始值，一个指向空函数的函数指针。\n/** * \\brief Sends a goal to the ActionServer, and also registers callbacks * * If a previous goal is already active when this is called. We simply forget * about that goal and start tracking the new goal. No cancel requests are made. * \\param done_cb     Callback that gets called on transitions to Done * \\param active_cb   Callback that gets called on transitions to Active * \\param feedback_cb Callback that gets called whenever feedback for this goal * is received */void sendGoal(const Goal&amp; goal,              SimpleDoneCallback done_cb = SimpleDoneCallback(),              SimpleActiveCallback active_cb = SimpleActiveCallback(),              SimpleFeedbackCallback feedback_cb = SimpleFeedbackCallback());\n\n知道了回调函数的使用方式就可以接受反馈消息了。不完整的几行代码如下：在下面的代码中，每次反馈消息的到来都会调用feedbackCb()，并将base_position赋值到全局变量current_point当中。\ntypedef actionlib::SimpleActionClient&lt;move_base_msgs::MoveBaseAction&gt; Client;geometry_msgs::Point current_point;// Called once when the goal becomes activevoid activeCb() &#123; ROS_INFO(&quot;Goal Received&quot;); &#125;// Called every time feedback is received for the goalvoid feedbackCb(const move_base_msgs::MoveBaseFeedbackConstPtr&amp; feedback) &#123;  //\tROS_INFO(&quot;Got base_position of Feedback&quot;);  current_point.x = feedback-&gt;base_position.pose.position.x;  current_point.y = feedback-&gt;base_position.pose.position.y;  current_point.z = feedback-&gt;base_position.pose.position.z;&#125;int main(int argc, char** argv) &#123;  ros::init(argc, argv, &quot;nav_move_base&quot;);  ros::NodeHandle node;  // Subscribe to the move_base action server  Client ac(&quot;move_base&quot;, true);  // Publisher to manually control the robot (e.g. to stop it, queue_size=5)  cmdVelPub = node.advertise&lt;geometry_msgs::Twist&gt;(&quot;/cmd_vel&quot;, 5);  move_base_msgs::MoveBaseGoal goal;  // Use the map frame to define goal poses  goal.target_pose.header.frame_id = &quot;map&quot;;  // Set the time stamp to &quot;now&quot;  goal.target_pose.header.stamp = ros::Time::now();  // Set the goal pose to the i-th waypoint  goal.target_pose.pose = pose_list[count];  // Start the robot moving toward the goal  ac.sendGoal(goal, Client::SimpleDoneCallback(), &amp;activeCb, &amp;feedbackCb);  return 0;&#125;\n\n可以看到，在sendGoal()函数中，第一个回调函数按照默认的声明给定了空值，并将在客户端中实现的后两个回调函数注册到actionlib中。\nac.sendGoal(goal, Client::SimpleDoneCallback(), &amp;activeCb, &amp;feedbackCb);\n\n这个方法使用了全局函数，但是假如我想使用类该怎么做呢？这就需要boost库中的bind了，用法如下：\nactionlib::SimpleActionClient&lt;FibonacciAction&gt; ac;// Need boost::bind to pass in the &#x27;this&#x27; pointerac.sendGoal(goal, boost::bind(&amp;MyNode::doneCb, this, _1, _2),            Client::SimpleActiveCallback(), Client::SimpleFeedbackCallback());\n\nOK，至此，我们已经成功解决上述3个问题并且成功的接受到了作为反馈消息的当前位姿。有了当前位姿我们就可以做很多事情了，包括编写一个基于move_base的循环跑的小程序。\n完整程序如下：\n#!/usr/bin/env pythonimport rospyimport actionlibfrom actionlib_msgs.msg import *from geometry_msgs.msg import Pose, Point, Quaternion, Twistfrom move_base_msgs.msg import MoveBaseAction, MoveBaseGoalfrom tf.transformations import quaternion_from_eulerfrom visualization_msgs.msg import Markerfrom math import radians, piclass MoveBaseSquare():    def __init__(self):        rospy.init_node(&#x27;nav_test&#x27;, anonymous=False)        rospy.on_shutdown(self.shutdown)        # How big is the square we want the robot to navigate?        square_size = rospy.get_param(&quot;~square_size&quot;, 1.0)  # meters        # Create a list to hold the target quaternions (orientations)        quaternions = list()        # First define the corner orientations as Euler angles        euler_angles = (pi/2, pi, 3*pi/2, 0)        # Then convert the angles to quaternions        for angle in euler_angles:            q_angle = quaternion_from_euler(0, 0, angle, axes=&#x27;sxyz&#x27;)            q = Quaternion(*q_angle)            quaternions.append(q)        # Create a list to hold the waypoint poses        waypoints = list()        # Append each of the four waypoints to the list.  Each waypoint        # is a pose consisting of a position and orientation in the map frame.        waypoints.append(Pose(Point(square_size, 0.0, 0.0), quaternions[0]))        waypoints.append(            Pose(Point(square_size, square_size, 0.0), quaternions[1]))        waypoints.append(Pose(Point(0.0, square_size, 0.0), quaternions[2]))        waypoints.append(Pose(Point(0.0, 0.0, 0.0), quaternions[3]))        # Initialize the visualization markers for RViz        self.init_markers()        # Set a visualization marker at each waypoint        for waypoint in waypoints:            p = Point()            p = waypoint.position            self.markers.points.append(p)        # Publisher to manually control the robot (e.g. to stop it, queue_size=5)        self.cmd_vel_pub = rospy.Publisher(&#x27;cmd_vel&#x27;, Twist, queue_size=5)        # Subscribe to the move_base action server        self.move_base = actionlib.SimpleActionClient(            &quot;move_base&quot;, MoveBaseAction)        rospy.loginfo(&quot;Waiting for move_base action server...&quot;)        # Wait 60 seconds for the action server to become available        self.move_base.wait_for_server(rospy.Duration(60))        rospy.loginfo(&quot;Connected to move base server&quot;)        rospy.loginfo(&quot;Starting navigation test&quot;)        # Initialize a counter to track waypoints        i = 0        # Cycle through the four waypoints        while i &lt; 4 and not rospy.is_shutdown():            # Update the marker display            self.marker_pub.publish(self.markers)            # Intialize the waypoint goal            goal = MoveBaseGoal()            # Use the map frame to define goal poses            goal.target_pose.header.frame_id = &#x27;map&#x27;            # Set the time stamp to &quot;now&quot;            goal.target_pose.header.stamp = rospy.Time.now()            # Set the goal pose to the i-th waypoint            goal.target_pose.pose = waypoints[i]            # Start the robot moving toward the goal            self.move(goal)            i += 1    def move(self, goal):            # Send the goal pose to the MoveBaseAction server        self.move_base.send_goal(goal)        # Allow 1 minute to get there        finished_within_time = self.move_base.wait_for_result(            rospy.Duration(60))        # If we don&#x27;t get there in time, abort the goal        if not finished_within_time:            self.move_base.cancel_goal()            rospy.loginfo(&quot;Timed out achieving goal&quot;)        else:            # We made it!            state = self.move_base.get_state()            if state == GoalStatus.SUCCEEDED:                rospy.loginfo(&quot;Goal succeeded!&quot;)    def init_markers(self):        # Set up our waypoint markers        marker_scale = 0.2        marker_lifetime = 0  # 0 is forever        marker_ns = &#x27;waypoints&#x27;        marker_id = 0        marker_color = &#123;&#x27;r&#x27;: 1.0, &#x27;g&#x27;: 0.7, &#x27;b&#x27;: 1.0, &#x27;a&#x27;: 1.0&#125;        # Define a marker publisher.        self.marker_pub = rospy.Publisher(            &#x27;waypoint_markers&#x27;, Marker, queue_size=5)        # Initialize the marker points list.        self.markers = Marker()        self.markers.ns = marker_ns        self.markers.id = marker_id        self.markers.type = Marker.CUBE_LIST        self.markers.action = Marker.ADD        self.markers.lifetime = rospy.Duration(marker_lifetime)        self.markers.scale.x = marker_scale        self.markers.scale.y = marker_scale        self.markers.color.r = marker_color[&#x27;r&#x27;]        self.markers.color.g = marker_color[&#x27;g&#x27;]        self.markers.color.b = marker_color[&#x27;b&#x27;]        self.markers.color.a = marker_color[&#x27;a&#x27;]        self.markers.header.frame_id = &#x27;odom&#x27;        self.markers.header.stamp = rospy.Time.now()        self.markers.points = list()    def shutdown(self):        rospy.loginfo(&quot;Stopping the robot...&quot;)        # Cancel any active goals        self.move_base.cancel_goal()        rospy.sleep(2)        # Stop the robot        self.cmd_vel_pub.publish(Twist())        rospy.sleep(1)if __name__ == &#x27;__main__&#x27;:    try:        MoveBaseSquare()    except rospy.ROSInterruptException:        rospy.loginfo(&quot;Navigation test finished.&quot;)","categories":["机器人"],"tags":["ros"]},{"title":"Ubuntu 修改用户名和 home 目录名称","url":"/3405114981.html","content":"前言最近想修改用户名和home下目录，有两种方法。方法一：修改配置文件（这种方法修改后，home下文件名还是原名字）方法二：创建新临时用户，使用临时用户修改你想修改的用户的名字\n法一修改密码注：如果用户名和密码都要修改，请先修改密码，否则可能会出现无法登录的情况\nsudo passwd 用户名\n输入新密码，然后重启\n修改用户名sudo gedit /etc/passwd# 注：找到原用户名所在行，修改为新用户名，但是后面目录里名字不要修改sudo gedit /etc/shadow# 注：找到原用户名所在行，修改为新用户名sudo gedit /etc/group# 注：将所有组中的原用户名都修改为新用户名，建议使用搜索功能确认全部修改完毕\n重启后就行了注：如果发现无法登录到su，报错：用户xxx不在sudoers文件中，应该是group没有修改完全。注：这样修改之后，home文件下还是原名字，用修改文件夹名字的方法是不行的，会导致登录时输入密码后又回到输入密码的界面。\n法二假设原用户是user1，home下目录是dir1，新用户是new_user1，新目录是new_dir1。\n创建新用户添加新用户temp\nsudo adduser temp\n授予root权限\nsudo adduser temp sudo\n修改用户名和目录重启，登录temp用户修改用户名\nsudo usermod -l new_user1 user1\n修改目录\nsudo usermod -d /home/new_dir1 -m new_user1\n或者合二为一\nsudo usermod -l new_user1 -d /home/new_dir1 -m user1# 注：注意这里和上面在-m后面是不一样的\n删除创建的临时用户重启，登录修改后new_use1用户删除用户\nsudo deluser temp\n删除文件夹\nsudo rm -r /home/temp\n","categories":["开发运维"],"tags":["linux"]},{"title":"Ubuntu 修改启动时默认内核版本","url":"/3958869895.html","content":"前言最近每次重启工控机内核都会变化，而我安装的cuda在另一个核，每次都会忘记切。\n方法目前 Ubuntu 的默认启动版本为 4.13.0-26-generic，我想将其修改为 4.10.0-42-generic1、修改grub文件\nsudo gedit /etc/default/grub\n2、修改默认启动的内核假设，在启动选择内核时，Advananced options for Ubuntu的子菜单如下所示：\nUbuntu, with Linux 4.13.0-26-genericUbuntu, with Linux 4.13.0-26-generic (upstart)Ubuntu, with Linux 4.13.0-26-generic (recovery mode)Ubuntu, with Linux 4.10.0-42-genericUbuntu, with Linux 4.10.0-42-generic (upstart)Ubuntu, with Linux 4.10.0-42-generic (recovery mode)\nGRUB_DEFAULT=0即为默认的启动内核，0就是内核索引，比如1就是第二个内核选项，即Linux 4.13.0-26-generic (upstart)，我们可以通过改这个数字来让系统启动时选择特定内核。\n那我记不住我想要的内核是第几个咋弄。。。 那就直接改名字吧，在/etc/default/grub中修改为\nGRUB_DEFAULT=&quot;Advanced options for Ubuntu&gt;Ubuntu, with Linux 4.10.0-42-generic&quot;\n\n3、更新配置\nsudo update-grub\n下次重启系统就ok了\n","categories":["开发运维"],"tags":["linux"]},{"title":"Ubuntu 降低内核版本","url":"/1567026574.html","content":"前言最近要把工控机从Ubuntu18升级到20，同时要用Nvidia显卡，结果Nvidia驱动死活装不上，后面发现是Ubuntu20内核太高了，不支持显卡驱动，因此用到降低Ubuntu内核版本的操作。\n方法1、查看原Ubuntu内核版本\n# 原Ubuntu18内核版本$ uname -r$ 5.4.0-80-generic# 现Ubuntu20内核版本$ uname -r$ 5.15.0-60-generic\n\n2、查看要安装的内核版本\napt-cache search linux | grep 5.4.0-80\n\n3、输入命令进行安装\nsudo apt-get install linux-headers-5.4.0-80-generic linux-image-5.4.0-80-generic\n\n4、查看此时内核版本\ndpkg --get-selections | grep linux-image\n\n5、修改grub启动项安装成功后设置启动即可选择对应的项，在此处遇到的问题是按ESC一直无法进入Ubuntu高级选项，没法选择Ubuntu内核版本进行启动。解决方法如下：\n\n把 GRUB_TIMEOUT 设置为 -1 ；\n把 GRUB_TIME_STYLE=hidden 注释掉；\n将 GRUB_CMDLINE_LINUX_DEFAULT 改为”text”\n\nsudo gedit /etc/default/grub\n\n输入命令，更新grub\nsudo update-grub\n\n6、重启进入Ubuntu高级选项此时选择刚才设置的低版本的内核，不要选择recovery mode。到此ubunt内核版本降低完成。注：如果想设置固定内核，可以参考Ubuntu 修改启动时默认内核版本。\n问题按照上述过程重启后进行加载驱动，可能会因为内核没安装完全，少了某些模块。比如执行命令sudo modprobe mtd可能出现错误提示如下所示：\nmodprobe: FATAL: Module mtd not found in directory /lib/modules/5.4.0-80-generic\n此时可以通过命令查看对比与过去高版本的缺少的内容：查看命令：\ndpkg --get-selections  | grep linux\n\n后面deinstall即表示没安装的（只需要看当前内核的module）\n此时缺少什么就安装对应安装的版本内容即可：\nsudo apt-get install modules-extra-5.4.0-80-generic\n 此时再次去安装驱动，执行命令：\nsudo modprobe mtd\n发现上述问题已解决。\n","categories":["开发运维"],"tags":["linux"]},{"title":"gdb 调试 C++ 程序 core dump","url":"/356668589.html","content":"前言最近用C++写ros程序，老是有莫名其妙的core dump。而调试core dump最方便就是使用gdb，这里做个记录。\n调试准备程序执行时, 经常会因为段错误（Segment Fault）而退出，操作系统会把此程序当前内存信息dump到磁盘上，即生成core文件。那gdb主要就是分析core文件。\n设置core文件大小系统默认不会生成core文件，需要进一步设置。core文件的生成依赖于shell的设置, 在shell中运行命令：ulimit -a，从第一行的设置项可以看到系统设置的core file size 为0，即不生成core file。使用命令：ulimit -c unlimited，可以设置core file size为无限，但只限当前终端可用。\nC++文件调试如果是单一的C++文件调试，直接用在编译时加上-g添加调试信息即可比如g++ -g test.cpp -o test，遇到core dump会在test.cpp所在目录下生成core文件，直接gdb ./test core即可\nCMake文件调试如果工程是用CMake构建的，那么需要在CMakeLists.txt中加入如下代码：\nSET(CMAKE_BUILD_TYPE &quot;Debug&quot;)SET(CMAKE_CXX_FLAGS_DEBUG &quot;$ENV&#123;CXXFLAGS&#125; -O0 -Wall -g2 -ggdb&quot;)SET(CMAKE_CXX_FLAGS_RELEASE &quot;$ENV&#123;CXXFLAGS&#125; -O3 -Wall&quot;)\n和单个C++文件一样，进程奔溃时，系统会把奔溃前的信息转储在一个叫做core的文件，直接gdb ./test core即可。另外objdump这个指令也可以查看core文件，objdump -s core。\n","categories":["开发运维"],"tags":["linux","gdb"]},{"title":"Ubuntu20 安装 NVIDIA 驱动-Cuda-cuDNN","url":"/3716413998.html","content":"前言最近想在Ubuntu20的工控机上安装NVIDIA显卡驱动，把吃灰的GeForce RTX 2080 Ti用起来，顺便装一下Cuda和cuDNN。\n解决一、降内核因为显卡是2080Ti，所以先要降内核。Ubuntu20是5.15，降到5.4.0-80比较合适。\n二、安装驱动方法1：1、直接终端上输入命令来看所需的版本\n1、直接终端上输入命令来看所需的版本\nubuntu-drivers devices\n\n2、安装推荐的那个驱动\nsudo apt install nvidia-460\n\n装完之后，你可以在dashboard上搜索nvidia，看到有 NVIDIA X Server Settings的东西，那么驱动就安装成功了，如果没有，那就重启一次电脑看看（如果一直卡在登录界面，就得手动执行官方的run来安装，看方法2）\n方法2：1、更新软件安装驱动前一定要更新软件列表和安装必要软件、依赖（必须）\nsudo apt-get updatesudo apt-get install g++sudo apt-get install gccsudo apt-get install make\n\n注：Ubuntu20默认gcc是9.x，这样后面装Cuda11.2时就不用换gcc版本\n2、到官网下想要的版本，一般2080Ti装460是一定可以用的（或者去这里下想要的版本）\n3、卸载之前的nvidia驱动有两种方法，根据你之前使用何种方式安装来卸载\nsudo apt-get remove --purge nvidia*\n\nsudo chmod +x *.runsudo ./NVIDIA-Linux-x86_64-460.32.03.run --uninstall\n\n4、关闭nouveau\nsudo vim /etc/modprobe.d/blacklist.conf\n\n在末尾添加blacklist nouveau和options nouveau modeset=0\nsudo update-initramfs -urebootlsmod | grep nouveau # 如果没有输出，则关闭成功\n\n5、停止显示服务器为了安装新的Nvidia驱动程序，我们需要停止当前的显示服务器。最简单的方法是使用telinit命令更改为运行级别3。在终端输入以下linux命令后，显示服务器将停止\nsudo telinit 3\n\n进入黑漆漆的文本界面tty（如果进不去，就按Ctrl + Alt + F1~F6中的一个 (分别对应进入tty1~tty6)），然后输入用户名和密码。\n6、禁用X-window服务\n在文本界面中，禁用X-window服务,在终端输入（Ubuntu20自带gdm3，不用再装lightdm）\nsudo service gdm3 stop\n\n7、执行run脚本cd命令进入到你存放驱动的目录，输入命令：\nsudo chmod +x NVIDIA-Linux-x86_64-460.32.03.runsudo ./NVIDIA-Linux-x86_64-460.32.03.run -no-x-check -no-nouveau-check -no-opengl-files# –no-opengl-files 只安装驱动文件，不安装OpenGL文件\n\nnvidia-smi看是否装成功\n8、重新打开lightdm\nsudo service gdm3 restart\n\n然后退出文本界面到图形界面，输入sudo telinit 5或者Ctrl + Alt + F1&#x2F;F7&#x2F;F8进入登录界面，登录进系统，然后reboot看是否还会卡在登录界面\n三、安装Cuda1、确认Cuda版本根据CUDA Toolkit and Corresponding Driver Versions查找所安装nvidia驱动对应的cuda上限（cuda是向下兼容的）。我们的是RTX 2080Ti，驱动装的是460.32，所以这里装cuda11.2.2\n![CUDA Toolkit and Corresponding Driver Versions](https://cdn.staticaly.com/gh/FelicxFoster/PicXImage@master/Linux_10/CUDA Toolkit and Corresponding Driver Versions.2evmku1kmkg0.webp)\n2、确认gcc版本\ngcc --version\n\n根据官网提供的版本信息，确认Cuda11.2要gcc9.x\n\n3、下载cuda在cuda-toolkit中查找对应版本的cuda，下载run文件\nwget https://developer.download.nvidia.com/compute/cuda/11.2.2/local_installers/cuda_11.2.2_460.32.03_linux.run\n\n\n4、安装Cuda执行指令\nsudo sh cuda_11.2.2_460.32.03_linux.run\n\n进入安装，开始的一大堆文字都是End User License Agreement，可以CTRL +C 跳过，然后输入accept表示接受协议。接下来就是安装的交互界面，根据提示一步一步进行就好。\nDo you accept the previously read EULA?accept/decline/quit: accept- [] Driver# 不用选上Driver,这是显卡驱动，不用重复安装\n\n5、配置cuda环境变量在 ~&#x2F;.bashrc 的最后添加\nexport PATH=/usr/local/cuda-11.2/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;export LD_LIBRARY_PATH=/usr/local/cuda-11.2/lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;export CUDA_HOME=/usr/local/cuda\n\n然后source  ~/.bashrc\n6、测试cuda\ncd /usr/local/cuda-11.2/samples/1_Utilities/deviceQuerysudo makesudo ./deviceQuery\n\n显示 PASS，安装成功。\n四、安装cuDNN1、下载cuDNN在cudnn-archive中查找对应版本的cuDNN（需要注册成为开发者），下载2、5、6、7\n在cudnn-archive中查找对应版本的cuDNN（需要注册成为开发者），下载2、5、6、7\n\n2、安装cuDNN\n解压cudnn-11.2-linux-x64-v8.1.1.33.tgz\nsudo cp cudnn-11.2-linux-x64-v8.1.1.33/cuda/include/cudnn.h /usr/local/cuda-11.2/nvvm/include/sudo cp cudnn-11.2-linux-x64-v8.1.1.33/cuda/lib64/* /usr/local/cuda-11.2/nvvm/lib64\n\n安装其余三个deb包\nsudo dpkg -i libcudnn7_7.4.1.5-1+cuda10.0_amd64.debsudo dpkg -i libcudnn7-dev_7.4.1.5-1+cuda10.0_amd64.debsudo dpkg -i libcudnn7-doc_7.4.1.5-1+cuda10.0_amd64.deb\n\n3、测试cuDNN\ncd ~/NVIDIA_CUDA-11.2_Samples/1_Utilities/deviceQuerymake./deviceQuery\n\n出现GPU的信息，表示安装成功\n五、问题修复因为是降内核，所以可能会导致内核有部分驱动丢失，导致USB摄像头无法识别。此时可以通过命令查看对比与过去高版本的缺少的内容：\ndpkg --get-selections  | grep linux\n一般是安装modules-extra-5.4.0-80-generic即可\nsudo apt-get install modules-extra-5.4.0-80-generic\n\n六、参考1、Ubuntu 20.04 Ubuntu 21.10 安装显卡驱动\\安装CUDA和cuDNN2、ubuntu降低内核版本\n","categories":["开发运维"],"tags":["linux"]},{"title":"二叉树遍历问题","url":"/3513594645.html","content":"前言对于下面这个二叉树，不同遍历结果如下：中序遍历：ABCDEFGHIJKLM前序遍历：GDBACFEJIHLKM后序遍历：ACBEFDHIKMLJG\n一、二叉树的中序遍历（简）题目给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。\n示例 1：\ngraph TD\nA((1)) --&gt; B(( ))\nA((1)) --&gt; C((2))\nC((2)) --&gt; F((3))\nC((2)) --&gt; G(( ))\n输入：root = [1,null,2,3]输出：[1,3,2]\n示例 2：输入：root = []输出：[]\n示例 3：输入：root = [1]输出：[1]\n提示：树中节点数目在范围 [0, 100] 内-100 &lt;= Node.val &lt;= 100\n题解中序遍历：左 -&gt; 根 -&gt; 右；前序遍历：根 -&gt; 左 -&gt; 右；后序遍历：左 -&gt; 右 -&gt; 根二叉树遍历这种，最好是用stack，把需要的入栈，再按条件出栈比如二叉树如下：\ngraph TD\nA((1)) --&gt; B((2))\nA((1)) --&gt; C((3))\nB((2)) --&gt; D((4))\nB((2)) --&gt; E((5))\nC((3)) --&gt; F((6))\nC((3)) --&gt; G(( ))\nE((5)) --&gt; H((7))\nE((5)) --&gt; I((8))\n首先每个三角形的节点顺序必须是左根右，比如4-&gt;2-&gt;5，2-&gt;1-&gt;3。中序遍历的过程就是把左侧子树全部入栈，然后一个个出栈，并取值。这里1&lt;-2&lt;-4入栈，然后4出栈，取值4；到2，2有右子树5，5入栈；5也执行一遍中序遍历，即左子树7入栈，然后7出栈，取值7；到5，5有右子树8，8入栈。重复直到没有子树\nstruct TreeNode {  int val;  TreeNode* left;  TreeNode* right;  TreeNode() : val(0), left(nullptr), right(nullptr) {}  explicit TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}  TreeNode(int x, TreeNode* left, TreeNode* right)      : val(x), left(left), right(right) {}};class Solution { public:  std::vector&lt;int&gt; inorderTraversal(TreeNode* root) {    vector&lt;int&gt; res;    if (root == NULL)      return res;    stack&lt;TreeNode*&gt; s;    TreeNode* cur = root;    while (cur || !s.empty()) {      if (cur) {        s.push(cur);        cur = cur-&gt;left;  // left      } else {        cur = s.top();        s.pop();        res.push_back(cur-&gt;val);  // root        cur = cur-&gt;right;         // right      }    }    return res;  }};\n\n二、二叉树的前序遍历（简）题目给你二叉树的根节点 root ，返回它节点值的 前序 遍历。\n示例 1：\ngraph TD\nA((1)) --&gt; B(( ))\nA((1)) --&gt; C((2))\nC((2)) --&gt; F((3))\nC((2)) --&gt; G(( ))\n输入：root = [1,null,2,3]输出：[1,2,3]\n示例 2：输入：root = []输出：[]\n示例 3：输入：root = [1]输出：[1]\n示例 4：\ngraph TD\nA((1)) --&gt; B((2))\nA((1)) --&gt; C(( ))\n输入：root = [1,2]输出：[1,2]\n示例 5：\ngraph TD\nA((1)) --&gt; B(( ))\nA((1)) --&gt; C((2))\n输入：root = [1,null,2]输出：[1,2]\n提示：树中节点数目在范围 [0, 100] 内-100 &lt;= Node.val &lt;= 100\n题解首先每个三角形的节点顺序必须是根左右，比如2-&gt;4-&gt;5，1-&gt;2-&gt;3。参考中序遍历，中序遍历是左根右，所以要左子树入栈-&gt;出栈-&gt;取值-&gt;判断右子树；而先序遍历是根左右，所以要取值-&gt;左子树入栈-&gt;出栈-&gt;判断右子树\nclass Solution { public:  vector&lt;int&gt; preorderTraversal(TreeNode* root) {    vector&lt;int&gt; res;    if (root == NULL)      return res;    stack&lt;TreeNode*&gt; s;    TreeNode* cur = root;    while (cur || !s.empty()) {      if (cur) {        res.push_back(cur-&gt;val);  // root        s.push(cur);        cur = cur-&gt;left;  // left      } else {        cur = s.top();        s.pop();        cur = cur-&gt;right;  // right      }    }    return res;  }};\n\n三、二叉树的后序遍历（简）题目给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。\n示例 1：\ngraph TD\nA((1)) --&gt; B(( ))\nA((1)) --&gt; C((2))\nC((2)) --&gt; F((3))\nC((2)) --&gt; G(( ))\n输入：root = [1,null,2,3]输出：[3,2,1]\n示例 2：输入：root = []输出：[]\n示例 3：输入：root = [1]输出：[1]\n提示：树中节点数目在范围 [0, 100] 内-100 &lt;= Node.val &lt;= 100\n题解1首先每个三角形的节点顺序必须是左右根，比如4-&gt;5-&gt;2，2-&gt;3-&gt;1。参考前序遍历的根左右，输出根右左，然后倒序，就是左右根\nclass Solution { public:  vector&lt;int&gt; postorderTraversal(TreeNode* root) {    vector&lt;int&gt; res;    if (root == NULL)      return res;    stack&lt;TreeNode*&gt; s;    TreeNode* cur = root;    while (cur || !s.empty()) {      if (cur) {        res.push_back(cur-&gt;val);  // root        s.push(cur);        cur = cur-&gt;right;  // right      } else {        cur = s.top();        s.pop();        cur = cur-&gt;left;  // left      }    }    reverse(res.begin(), res.end());    return res;  }};\n\n题解2顺便记录下递归的写法\nclass Solution { public:  void postorder(TreeNode* root, vector&lt;int&gt;&amp; res) {    if (root == nullptr) {      return;    }    postorder(root-&gt;left, res);    postorder(root-&gt;right, res);    res.push_back(root-&gt;val);  }  vector&lt;int&gt; postorderTraversal(TreeNode* root) {    vector&lt;int&gt; res;    postorder(root, res);    return res;  }};\n\n四、二叉树的层序遍历（中）题目给你二叉树的根节点 root ，返回其节点值的 层序遍历 。（即逐层地，从左到右访问所有节点）。\n示例 1：\ngraph TD\nA((3)) --&gt; B((9))\nA((3)) --&gt; C((20))\nC((20)) --&gt; F((15))\nC((20)) --&gt; G((7))\n输入：root = [3,9,20,null,null,15,7]输出：[ [3],[9,20],[15,7] ]\n示例 2：输入：root = [1]输出：[1]\n示例 3：输入：root = []输出：[]\n提示：树中节点数目在范围 [0, 2000] 内-1000  &lt;= Node.val &lt;= 1000\n题解首先要知道遍历二叉树，DFS和BFS的顺序是不一样的从gif图可以看出，前中后序遍历就是DFS遍历，层序遍历就类似BFS遍历，不同的是BFS是输出一个一维数组，而层序遍历要求我们区分每一层，也就是返回一个二维数组那首先我们可以先实现BFS遍历，用队列来存储遍历的节点，因为队列是先进先出，顺序不会乱\n// 二叉树的BFS遍历class Solution { public:  vector&lt;int&gt; levelOrder(TreeNode* root) {    vector&lt;int&gt; res;    queue&lt;TreeNode*&gt; q;    if (root != NULL) {      q.push(root);    }    while (!q.empty()) {      TreeNode* node = q.front();      q.pop();      res.push_back(node-&gt;val);      if (node-&gt;left != NULL) {        q.push(node-&gt;left);      }      if (node-&gt;right != NULL) {        q.push(node-&gt;right);      }    }    return res;  }};\n有了BFS遍历，怎么把每一层的分别记录下来呢很简单，在每一层遍历开始前，先记录队列中的结点数量n（也就是这一层的结点数量），然后一口气处理完这一层的n个结点\nclass Solution { public:  vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {    vector&lt;vector&lt;int&gt;&gt; res;    queue&lt;TreeNode*&gt; q;    if (root != NULL) {      q.push(root);    }    while (!q.empty()) {      int n = q.size();      vector&lt;int&gt; temp;      for (int i = 0; i &lt; n; i++) {        TreeNode* node = q.front();        q.pop();        temp.push_back(node-&gt;val);        if (node-&gt;left != NULL) {          q.push(node-&gt;left);        }        if (node-&gt;right != NULL) {          q.push(node-&gt;right);        }      }      res.push_back(temp);    }    return res;  }};\n","categories":["算法交流"],"tags":["刷题笔记","二叉树"]},{"title":"云服务器添加虚拟内存","url":"/4224994049.html","content":"前言最近翻新了下自己的博客，部署了些 docker 应用，结果小鸡内存蹭蹭往上涨，2G 内存眨眼就没了一大半。贫穷的我真不想掏钱加配置，只能添加虚拟内存来缓缓了。\n什么是 SwapSwap 说白了就是把一块磁盘空间当成内存来使用。它包括换出和换入两个过程。\n所谓换出，就是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存。而换入，则是在进程再次访问这些内存的时候，把它们从磁盘读到内存中来。\n一个很典型的场景就是，即使内存不足时，有些应用程序也并不想被 OOM 杀死，而是希望能缓一段时间，等待人工介入，或者等系统自动释放其他进程的内存，再分配给它。\n除此之外，我们常见的笔记本电脑的休眠和快速开机的功能，也基于 Swap 。休眠时，把系统的内存存入磁盘，这样等到再次开机时，只要从磁盘中加载内存就可以。这样就省去了很多应用程序的初始化过程，加快了开机速度。\n缺点就是，swap 是存放在磁盘上的，磁盘的速度和内存比较起来慢了好几个数量级，如果不停的读写 swap，那么对系统的性能肯定有影响，尤其是当系统内存很吃紧的时候，读写 swap 空间发生的频率会很高，导致系统运行很慢，像死了一样，这个时候添加物理内存是唯一的解决办法。\n详细操作定义 Swap的大小及位置选择你 Swap 文件要放置的位置，比如我直接在根目录&#x2F;下创建，然后设置 swap 分区的名称为 swapfile。\ncd /dd if=/dev/zero of=/swapfile bs=1k count=2048000\n上面 swapfile 为你创建 Swap 文件分区的名称，你可以根据需要改成你自己的名称；bs 即 blocksizes，每个块大小为 1k；count&#x3D;2048000，总大小为 2G 的文件。\n建立 Swapmkswap /swapfile\n启动 Swapswapon /swapfile\n检查是否正确free -m\n设置开机自启修改 &#x2F;etc&#x2F;fstab 使其启动时自动 mount，这个操作与 Swap 分区法一样，在 &#x2F;etc&#x2F;fstab 中最后一行增加如下语句：\n/swapfile  swap  swap    defaults 0 0\n删除 Swap分区如果不再需要swap，可以清理该分区：\nswapoff /swapfile\n","categories":["开发运维"],"tags":["linux"]},{"title":"元素查找问题","url":"/2832781272.html","content":"二、二分查找（简）题目给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n示例 1:输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4\n示例 2:输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1\n提示：你可以假设 nums 中的所有元素是不重复的。n 将在 [1, 10000]之间。nums 的每个元素都将在 [-9999, 9999]之间。\n题解在升序数组nums中寻找目标值target，对于特定下标i，比较nums[i]和target的大小：\n\n如果nums[i] = target，则下标i即为要寻找的下标；\n如果nums[i] &gt; target，则target在下标i左侧；\n如果nums[i] &lt; target，则target在下标i右侧；\n\n所以，二分查找的做法是，1、定义查找的范围[left,right]，初始查找范围是整个数组；2、每次取查找范围的中点mid，比较nums[mid]和target的大小；3、如果相等则mid即为要寻找的下标，如果不相等则根据nums[mid]和target的大小关系将查找范围缩小一半。\nclass Solution { public:  int search(vector&lt;int&gt;&amp; nums, int target) {    int res = -1;    int left = 0, right = nums.size() - 1;    while (left &lt; right) {      int mid = (left + right) / 2;      if (nums[mid] &lt; target) {        left = mid + 1;      } else if (nums[mid] &gt; target) {        right = mid - 1;      } else {        res = mid;        break;      }    }    return res;  }};\n\n二、数组中的第K个最大元素（困）题目给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。\n示例 1:输入: [3,2,1,5,6,4], k = 2输出: 5\n示例 2:输入: [3,2,3,1,2,4,5,5,6], k = 4输出: 4\n提示：1 &lt;= k &lt;= nums.length &lt;= 10^5-10^4 &lt;= nums[i] &lt;= 10^4\n题解1最简单的，先排序，再取第k个出来，排序的话就用快排，快排也有很多种，下面是双指针法\nclass Solution { public:  int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {    int ve_len = nums.size();    QuickSort(nums, 0, ve_len - 1);    return nums[ve_len - k];  }  // 快排  void QuickSort(vector&lt;int&gt;&amp; nums, int left, int right) {    if (left &gt;= right)      return;    int pivot = nums[left], i = left, j = right;    while (i &lt; j) {      while (i &lt; j &amp;&amp; nums[j] &gt;= pivot) {        j--;      }      while (i &lt; j &amp;&amp; nums[i] &lt;= pivot) {        i++;      }      std::swap(nums[i], nums[j]);    }    std::swap(nums[left], nums[i]);    QuickSort(nums, left, i - 1);    QuickSort(nums, j + 1, right);  }};int main() {  int arr[6] = {3, 1, 5, 6, 4, 7};  vector&lt;int&gt; nums(begin(arr), end(arr));  QuickSort(nums, 0, nums.size() - 1);  for (auto i : nums) {    cout &lt;&lt; i &lt;&lt; \" \";  }  return 0;}\n题解2既然都想到排序了，何不用大根堆来实现。而且C++自带的优先队列就能实现大根堆，自动帮我们排序首先回顾下优先队列priority_queue普通队列是先进先出；而优先队列中具有最高优先级的元素将被首先删除如下所示，升序队列从大到小排列，top()返回的是最小值，即小根堆；降序队列从小到大排列，top()返回的是最大值，即大根堆\n// 升序队列priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;// 降序队列priority_queue &lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt;q;\n这道题就可以直接用降序队列，把nums存进队列中，让它自个排序，再取第k个就行\nclass Solution { public:  int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {    priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; maxHeap;    for (int x : nums)      maxHeap.push(x);    for (int i = 0; i &lt; k - 1; i++)      maxHeap.pop();    return maxHeap.top();  }};\n题解3面试官肯定不希望你调库，所以自己实现大根堆才是加分项首先要回顾下堆排序，忘记了就回去看这里大根堆就是根节点一定大过左右节点的值。这样我们就可以根据给定的数组，创建一个大根堆，让最大的值在栈顶，然后要找第k个最大值,就把堆顶的值和最末尾的子节点互换，并忽略该子节点，重新生成个大根堆，这样堆顶元素就是要求的值。\nclass Solution { public:  int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {    int n = nums.size();    build_maxHeap(nums);  // 创建大根堆    for (int i = 0; i &lt; k - 1; i++) {      // 求第i个最大值,就把栈顶的值nums[0]和叶子节点nums[n-1-i]调换      // 除去nums[n-1-i]，剩下其余节点再调整为大根堆      swap(nums[0], nums[n - 1 - i]);      adjust_down(nums, 0, n - 1 - i - 1);    }    for (auto i : nums) {      cout &lt;&lt; i &lt;&lt; \" \";    }    return nums[0];  }  void build_maxHeap(vector&lt;int&gt;&amp; nums) {    int n = nums.size();    // 堆排序最后一个非叶子节点(父节点)的序号就是n/2-1    for (int root = n / 2 - 1; root &gt;= 0; root--) {      adjust_down(nums, root, n - 1);    }  }  // 向下调整算法  void adjust_down(vector&lt;int&gt;&amp; nums, int root, int size) {    // root最开始指向根节点,child是左孩子    if (root &gt; size)      return;    int temp = nums[root];  // 把堆顶存起来    int child = 2 * root + 1;    while (child &lt;= size) {      if (child + 1 &lt;= size &amp;&amp; nums[child] &lt; nums[child + 1]) {        // 有右子树而且右子树更大        child++;      }      if (nums[child] &gt; temp) {        // 如果child比temp大,child上去填到root的位置,更新root和child,看下一层        nums[root] = nums[child];        root = child;        child = 2 * root + 1;      } else {        break;      }    }    // 不管在哪退出循环,最后都要给空位root赋值    // 如果child &gt; size,把temp放到叶子节点上    nums[root] = temp;  }};int main() {  Solution s;  vector&lt;int&gt; nums = {3, 2, 1, 5, 6, 4};  int k = 4;  s.findKthLargest(nums, k);  return 0;}\n\n三、搜索旋转排序数组（中）题目整数数组 nums 按升序排列，数组中的值 互不相同 。在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。\n示例 1：输入：nums = [4,5,6,7,0,1,2], target = 0输出：4\n示例 2：输入：nums = [4,5,6,7,0,1,2], target = 3输出：-1\n示例 3：输入：nums = [1], target = 0输出：-1\n提示：1 &lt;= nums.length &lt;= 5000-10^4 &lt;= nums[i] &lt;= 10^4nums 中的每个值都 独一无二题目数据保证 nums 在预先未知的某个下标上进行了旋转-10^4 &lt;= target &lt;= 10^4\n题解首先要明白这道题问的是啥，很简单就是从给定的数组中找出target的下标。那为啥题目描述的花里胡哨的，还有什么旋转呢，主要是怕你想不到，因为要设计O(log n)的算法，单纯暴力搜索肯定是不行的。那是不是可以用二分法呢？严格来说，标准的二分法只适用于有序数组，但题目给我们的是旋转后的数组，它不是有序的，所以需要对二分法进行修改变形。这个旋转后的数组有什么特点呢？可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。所以我们在常规二分查找的时候，可以查看当前mid为分割位置分割出来的两个部分[left, mid]和[mid+1, right]哪个部分是有序的，根据有序的那部分判断出target在不在这个部分。所以我们在用二分法时有两种情况:1、若nums[0] ≤ nums[mid]，说明[left, mid]是有序的；\n\n则当nums[0] ≤ target &lt; nums[mid]时target在[left, mid-1]中，\n否则在[mid+1, right]中；\n\n2、若nums[0] &gt; nums[mid]，说明[mid+1, right]是有序的；\n\n则当nums[mid] &lt; target ≤ nums[size-1]时target在[mid+1, right]中，\n否则在[left, mid-1]中。class Solution { public:  int search(vector&lt;int&gt;&amp; nums, int target) {    if (nums.empty()) {      return -1;    }    int n_size = nums.size();    int left = 0;    int right = n_size - 1;    int res = -1;    while (left &lt;= right) {      int mid = (left + right) / 2;      if (nums[mid] == target) {        res = mid;        break;      }      if (nums[0] &lt;= nums[mid]) {        if (nums[0] &lt;= target &amp;&amp; target &lt; nums[mid]) {          right = mid - 1;        } else {          left = mid + 1;        }      } else {        if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n_size - 1]) {          left = mid + 1;        } else {          right = mid - 1;        }      }    }    return res;  }};int main() {  Solution s;  vector&lt;int&gt; nums = {4, 5, 6, 7, 0, 1, 2};  cout &lt;&lt; s.search(nums, 0);}\n\n四、搜索旋转排序数组 II（中）题目已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。你必须尽可能减少整个操作步骤。\n示例 1：输入：nums = [2,5,6,0,0,1,2], target = 0输出：true\n示例 2：输入：nums = [2,5,6,0,0,1,2], target = 3输出：false\n提示：题目数据保证在预先未知的某个下标上进行了旋转\n题解和上一题一样，只不过因为数组中有重复元素，二分查找时可能会有num[left] = num[mid] = num[right]。比如数组[3,1,2,3,3,3,3]，target = 2，首次二分时无法判断区间[0, 3]和[4, 6]哪个是有序的。对于这种情况，我们只能将当前二分区间的左边界加一，右边界减一，然后在新区间上继续二分查找。其余的照抄上一题。\nclass Solution { public:  int search(vector&lt;int&gt;&amp; nums, int target) {    if (nums.empty()) {      return -1;    }    int n_size = nums.size();    int left = 0;    int right = n_size - 1;    bool res = false;    while (left &lt;= right) {      int mid = (left + right) / 2;      if (nums[mid] == target) {        res = true;        break;      }      if (nums[left] == nums[mid] &amp;&amp; nums[mid] == nums[right]) {        left++;        right--;      } else if (nums[0] &lt;= nums[mid]) {        if (nums[0] &lt;= target &amp;&amp; target &lt; nums[mid]) {          right = mid - 1;        } else {          left = mid + 1;        }      } else {        if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n_size - 1]) {          left = mid + 1;        } else {          right = mid - 1;        }      }    }    return res;  }};\n\n五、寻找旋转排序数组中的最小值（中）题目已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。你必须设计一个时间复杂度为  的算法解决此问题。\n示例 1：输入：nums = [3,4,5,1,2]输出：1解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。\n示例 2：输入：nums = [4,5,6,7,0,1,2]输出：0解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。\n示例 3：输入：nums = [11,13,15,17]输出：11解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。\n提示：中的所有整数互不相同原来是一个升序排序的数组，并进行了至次旋转\n题解首先对于这个旋转数组，它的特点是：1、以最小值为分界线的左子序列是单调递增的，右子序列也是单调递增的；2、对于数组中最后一个元素x，左子序列全大于x，右子序列全小于x。通过nums[mid]和nums[right]比较，判断nums[mid]在左子序列还是右子序列。有两种情况：1、如果nums[mid] &lt; nums[right]，则mid在右子序列，即在最小值右边，所以right左移；2、如果nums[mid] &gt; nums[right]，则mid在左子序列，即在最小值左边，所以left右移。\nclass Solution { public:  int findMin(vector&lt;int&gt;&amp; nums) {    int left = 0;    int right = nums.size() - 1;    while (left &lt; right) {      int mid = (left + right) / 2;      if (nums[mid] &lt; nums[right]) {        right = mid;  // right左移        // 为什么right=mid,而不是right=mid-1;        // nums[mid]&lt;nums[right]时,有可能nums[mid]本身就是最小值,然后mid-1就错过了,所以不要减1.比如{4,5,1,2,3},如果right=mid-1,则丢失了最小值1      } else {        left = mid + 1;  // left右移        // 为什么low=mid+1,而不是low=mid;        // 因为我们这题是求最小值,而nums[mid]&gt;nums[right],自然nums[mid]绝对不会是最小值,所以可以+1过滤掉mid这个下标.比如{4,5,6,1,2,3},nums[mid]=6,low=mid+1,刚好nums[low]=1      }    }    return nums[left];    // 这里返回的是left,所以只能while(left&lt;right).如果返回的是right,就可以while(left&lt;=right)和while(left&lt;right);    // 因为若循环条件为while(left&lt;=right),则进入最后一个循环的时候,left=right=mid,都指向最小值,接着执行left=mid+1.这时left便跑到mid和right右边一位去了,因此若要用while(left&lt;=right)条件必须返回 nums[right]或者nums[left-1].  }};\n\n六、寻找旋转排序数组中的最小值 II（困）题目已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。你必须尽可能减少整个过程的操作步骤。\n示例 1：输入：nums = [1,3,5]输出：1\n示例 2：输入：nums = [2,2,2,0,1]输出：0\n提示：原来是一个升序排序的数组，并进行了至次旋转\n题解这道题和上一题区别就在于数组元素是可以重复的，所以对于有重复元素的旋转数组，它的特点是：1、以最小值为分界线的左子序列是单调递增的，右子序列也是单调递增的（注意区分严格单调递增）；2、对于数组中最后一个元素x，左子序列全大于或等于x，右子序列全小于或等于x。同样通过nums[mid]和nums[right]比较，判断nums[mid]在左子序列还是右子序列。只不过因为有重复值，所以多了一种情况。有三种情况：\n\n如果nums[mid] &lt; nums[right]，则mid在右子序列，即在最小值右边，所以right左移；\n如果nums[mid] &gt; nums[right]，则mid在左子序列，即在最小值右左边，所以left右移；\n如果nums[mid] = nums[right]，则不能确定mid在左子序列还是右子序列；由于它们的值相同，所以无论nums[right]是不是最小值，都有一个最小值nums[mid]，因此我们可以忽略二分查找区间的右端点。\n\n解释下第3点，比如数组[1,0,1,1,1]，left = 0，right = 4，mid = 2，无法判断mid在在左子序列还是右子序列，我们采用right--解决此问题那这个操作会不会影响取最小值呢，事实证明不会：\n\n此操作不会使数组越界：因为迭代条件保证了right&gt;left&gt;=0；\n此操作不会使最小值丢失：假设nums[right]是最小值，有两种情况：\n若nums[right]是唯一最小值：那就不可能满足判断条件nums[mid]==nums[right]，因为mid&lt;right（left!=right &amp;&amp; mid=(left + right)/2）；\n若nums[right]不是唯一最小值，由于mid&lt;right而nums[mid]==nums[right]，即还有最小值存在于[left,right−1]区间，因此不会丢失最小值。class Solution { public:  int findMin(vector&lt;int&gt;&amp; nums) {    int left = 0;    int right = nums.size() - 1;    while (left &lt; right) {      int mid = (left + right) / 2;      if (nums[mid] &lt; nums[right]) {        right = mid;  // right左移      } else if (nums[mid] &gt; nums[right]) {        left = mid + 1;  // left右移      } else {        right--;      }    }    return nums[left];  }};\n\n\n\n","categories":["算法交流"],"tags":["刷题笔记"]},{"title":"使用向量叉积求点到直线的距离","url":"/2570302048.html","content":"前言假设有一个向量，直线上两点的点，，求到直线的垂直距离\n方法向量，向量到向量的距离=是和形成的四边形面积（两个向量叉乘得到的是面积），除以底边，得到的就是高，即到的距离\ndef point_distance_line(point: list, line_point1: list, line_point2: list):    # 计算向量    point_arr = np.array(point)    line_point1_arr = np.array(line_point1)    line_point2_arr = np.array(line_point2)    vec1 = line_point1_arr - point_arr    vec2 = line_point2_arr - point_arr    distance = np.abs(np.cross(vec1, vec2)) / np.linalg.norm(line_point1_arr - line_point2_arr)    return distance\n","categories":["工具脚本"],"tags":["python","数学"]},{"title":"判断同一坐标系下物体方向","url":"/1360797208.html","content":"前言最近在写个小需求，需要判断障碍物在自车前后左右哪个方向，然后再进行下一步的逻辑处理。当然有很多种方法，这里就做个记录。\n思路画了张图，假设A点为自车，需要判断B点在A点的哪个方向（注意我这里前向是x）。有以下公式：所以，为B点在A点前方，为B点在A点左方。\n代码如下：\n#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Vec2d { public:  //! Constructor which takes x- and y-coordinates.  constexpr Vec2d(const double x, const double y) noexcept : x_(x), y_(y) {}  //! Constructor returning the zero vector.  constexpr Vec2d() noexcept : Vec2d(0, 0) {}  //! rotate the vector itself by angle.  void SelfRotate(const double angle) {    double tmp_x = x_;    x_ = x_ * cos(angle) - y_ * sin(angle);    y_ = tmp_x * sin(angle) + y_ * cos(angle);  }  //! Getter for x component  double x() const { return x_; }  //! Getter for y component  double y() const { return y_; }  //! Setter for x component  void set_x(const double x) { x_ = x; }  //! Setter for y component  void set_y(const double y) { y_ = y; }  static Vec2d CreateUnitVec2d(const double angle) {    return Vec2d(cos(angle), sin(angle));  }  double InnerProd(const Vec2d &amp;other) const {    return x_ * other.x() + y_ * other.y();  }  double CrossProd(const Vec2d &amp;other) const {    return x_ * other.y() - y_ * other.x();  } protected:  double x_ = 0.0;  double y_ = 0.0;};int main() {  double front_edge_to_center = 3.89;  double back_edge_to_center = 1.043;  vector&lt;double&gt; track_pos = {5974.055909431665, 219.0300190522155, 0};  vector&lt;double&gt; ego_pos = {5921.028659216853, 219.4455434876256, 0};  double ego_yaw = 3.139378753137839;  Vec2d inner_u(track_pos[0] - ego_pos[0], track_pos[1] - ego_pos[1]);  Vec2d inner_v = Vec2d::CreateUnitVec2d(ego_yaw);  double inner_value = inner_u.InnerProd(inner_v);  if(inner_value &gt; 0) {    std::cout &lt;&lt; \"track is on the front\" &lt;&lt; std::endl;  } else {    std::cout &lt;&lt; \"track is on the back\" &lt;&lt; std::endl;  }  Vec2d cross_u(track_pos[0] - ego_pos[0], track_pos[1] - ego_pos[1]);  Vec2d cross_v = Vec2d::CreateUnitVec2d(ego_yaw);  double cross_value = cross_u.CrossProd(cross_v);  if(cross_value &gt; 0) {    std::cout &lt;&lt; \"track is on the right\" &lt;&lt; std::endl;  } else {    std::cout &lt;&lt; \"track is on the left\" &lt;&lt; std::endl;  }}","categories":["工具脚本"],"tags":["数学"]},{"title":"刷题笔记","url":"/2022806970.html","content":"LeetCode Hot 1001-1、反转链表(简)题解1迭代法，记录pre节点和cur节点，不断交换pre和cur，同时cur后移\nclass Solution &#123; public:  ListNode* reverseList(ListNode* head) &#123;    ListNode* pre = NULL;    ListNode* cur = head;    while (cur != NULL) &#123;      ListNode* next = cur-&gt;next;  // 这里到最后一个数字时没有next了,返回NULL      cur-&gt;next = pre;      pre = cur;      cur = next;    &#125;    return pre;  &#125;&#125;;\n题解2递归法，假设链表其余部分已被反转，怎么去反转它前面的部分假设a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f-&gt;NULL若e-&gt;f已经被反转，此时在d，我们希望d-&gt;next指向c，所以d-&gt;next-&gt;next&#x3D;c这时c和d互相指向，要断开，所以d-&gt;next&#x3D;NULL\nclass Solution &#123; public:  ListNode* reverseList(ListNode* head) &#123;    if (!head || !head-&gt;next) &#123;      return head;    &#125;    ListNode* newHead = reverseList(head-&gt;next);    head-&gt;next-&gt;next = head;    head-&gt;next = nullptr;    return newHead;  &#125;&#125;;\n\n1-2、反转链表Ⅱ(中)题解参考反转链表，这题是特定位置反转，可以根据left和right取出需要反转的链表，代入反转链表的解法进行反转，再和前后链表拼接另外，凡是链表题都可以创建个伪头节点，如下\nListNode* dummy = new ListNode(0);dummy-&gt;next = head;\nclass Solution &#123; public:  // 照搬反转链表  ListNode* reverseList(ListNode* head) &#123;    ListNode* pre = NULL;    ListNode* cur = head;    while (cur != NULL) &#123;      ListNode* next = cur-&gt;next;      cur-&gt;next = pre;      pre = cur;      cur = next;    &#125;    return pre;  &#125;  ListNode* reverseBetween(ListNode* head, int left, int right) &#123;    ListNode* dummy = new ListNode(0);    dummy-&gt;next = head;    ListNode* pre = dummy;    ListNode* end = dummy;    for (int i = 0; i &lt; left - 1; i++)      pre = pre-&gt;next;  // 要截取链表的头节点的前一个节点    ListNode* start = pre-&gt;next;  // 要截取链表的头节点    for (int i = 0; i &lt; right; i++)      end = end-&gt;next;  // 要截取链表的尾节点    ListNode* next = end-&gt;next; // 要截取链表的尾节点的后一个节点    end-&gt;next = NULL; // 截断链表,才能用于反转    pre-&gt;next = reverseList(start);    start-&gt;next = next; // 链表拼接    return dummy-&gt;next;  &#125;&#125;;\n\n1-3、K个一组翻转链表(困)题解参考反转链表Ⅱ，反转链表Ⅱ中是给定left和right进行截取来反转，这里可以通过遍历给定的链表，每k个截取一段链表，然后反转并拼接\nclass Solution &#123; public:  // 照搬反转链表  ListNode* reverseList(ListNode* head) &#123;    ListNode* pre = NULL;    ListNode* cur = head;    while (cur != NULL) &#123;      ListNode* next = cur-&gt;next;      cur-&gt;next = pre;      pre = cur;      cur = next;    &#125;    return pre;  &#125;  // 微调反转链表II  ListNode* reverseKGroup(ListNode* head, int k) &#123;    ListNode* dummy = new ListNode(0);    dummy-&gt;next = head;    ListNode* pre = dummy;    ListNode* end = dummy;    while (end-&gt;next != NULL) &#123;      ListNode* start = pre-&gt;next;  // 要截取链表的头节点      for (int i = 0; i &lt; k &amp;&amp; end != NULL; i++)        end = end-&gt;next;  // 要截取链表的尾节点      if (end == NULL)        break;      ListNode* next = end-&gt;next; // 要截取链表的尾节点的后一个节点      end-&gt;next = NULL; // 截断链表,才能用于反转      pre-&gt;next = reverseList(start);      start-&gt;next = next; // 链表拼接      // 开始下一次反转      pre = start;      end = pre;    &#125;    return dummy-&gt;next;  &#125;&#125;;\n\n2、无重复字符的最长子串(中)题解对于数组或字符串寻找找最xx这一类的，都可以用滑动窗口法这里用cur_len记录窗格的大小，有不同的字符就++，有相同的就–如何过滤窗格中的重复值，可以用set容器，因为set仅包含唯一元素通过set::count()返回元素在集合中出现的次数（由于set容器仅包含唯一元素，因此只能返回1或0）来过滤重复值\nclass Solution &#123; public:  int lengthOfLongestSubstring(std::string s) &#123;    if (s.size() == 0) &#123;      return 0;    &#125;    int max_len, cur_len = 0;    std::set&lt;int&gt; lookup;    for (int i = 0; i &lt; s.size(); i++) &#123;      cur_len++;      // 用while是因为可能有连续多个相同的字母      while (lookup.count(s[i])) &#123;        lookup.erase(s[i]);        cur_len--;      &#125;      if (cur_len &gt; max_len) &#123;        max_len = cur_len;      &#125;      lookup.insert(s[i]);    &#125;    return max_len;  &#125;&#125;;\n\n3、LRU缓存机制(中)题解4、数组中的第K个最大元素(困)题解1最简单的，先排序，再取第k个出来，排序的话就用快排，快排也有很多种，下面是双指针法\nclass Solution &#123; public:  int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;    int ve_len = nums.size();    Quick_sort(nums, 0, ve_len - 1);    return nums[ve_len - k];  &#125;  // 快排  void Quick_sort(vector&lt;int&gt;&amp; arr, int left, int right) &#123;    if (left &gt;= right)      return;    int i, j, base, temp;    i = left, j = right;    base = arr[left];    while (i &lt; j) &#123;      while (arr[j] &gt;= base &amp;&amp; i &lt; j)        j--;      while (arr[i] &lt;= base &amp;&amp; i &lt; j)        i++;      temp = arr[i];      arr[i] = arr[j];      arr[j] = temp;    &#125;    arr[left] = arr[i];    arr[i] = base;    Quick_sort(arr, left, i - 1);    Quick_sort(arr, i + 1, right);  &#125;&#125;;int main() &#123;  int arr[6] = &#123;3, 1, 5, 6, 4, 7&#125;;  vector&lt;int&gt; nums(begin(arr), end(arr));  Quick_sort(nums, 0, nums.size() - 1);  for (auto i : nums) &#123;    cout &lt;&lt; i &lt;&lt; &quot; &quot;;  &#125;  return 0;&#125;\n题解2既然都想到排序了，何不用C++自带的优先队列，自动帮我们排序首先回顾下优先队列priority_queue普通队列是先进先出；而优先队列中具有最高优先级的元素将被首先删除如下所示，升序队列从大到小排列，top()返回的是最小值；降序队列从小到大排列，top()返回的是最大值\n// 升序队列priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;// 降序队列priority_queue &lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt;q;\n这道题就可以直接用降序队列，把nums存进队列中，让它自个排序，再取第k个就行\nclass Solution &#123; public:  int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;    priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; maxHeap;    for (int x : nums)      maxHeap.push(x);    for (int i = 0; i &lt; k - 1; i++)      maxHeap.pop();    return maxHeap.top();  &#125;&#125;;\n题解3面试官肯定不希望你调库，所以自己实现大根堆才是加分项首先要回顾下堆排序，忘记了就回去看这里大根堆就是根节点一定大过左右节点的值。这样我们就可以根据给定的数组，创建一个大根堆，让最大的值在栈顶，然后要找第k个最大值,就把堆顶的值和最末尾的子节点互换，并忽略该子节点，重新生成个大根堆，这样堆顶元素就是要求的值。\nclass Solution &#123; public:  int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;    int n = nums.size();    build_maxHeap(nums);  // 创建大根堆    for (int i = 0; i &lt; k - 1; i++) &#123;      // 求第i个最大值,就把栈顶的值nums[0]和叶子节点nums[n-1-i]调换      // 除去nums[n-1-i]，剩下其余节点再调整为大根堆      swap(nums[0], nums[n - 1 - i]);      adjust_down(nums, 0, n - 1 - i - 1);    &#125;    for (auto i : nums) &#123;      cout &lt;&lt; i &lt;&lt; &quot; &quot;;    &#125;    return nums[0];  &#125;  void build_maxHeap(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();    // 堆排序最后一个非叶子节点(父节点)的序号就是n/2-1    for (int root = n / 2 - 1; root &gt;= 0; root--) &#123;      adjust_down(nums, root, n - 1);    &#125;  &#125;  // 向下调整算法  void adjust_down(vector&lt;int&gt;&amp; nums, int root, int size) &#123;    // root最开始指向根节点,child是左孩子    if (root &gt; size)      return;    int temp = nums[root];  // 把堆顶存起来    int child = 2 * root + 1;    while (child &lt;= size) &#123;      if (child + 1 &lt;= size &amp;&amp; nums[child] &lt; nums[child + 1]) &#123;        // 有右子树而且右子树更大        child++;      &#125;      if (nums[child] &gt; temp) &#123;        // 如果child比temp大,child上去填到root的位置,更新root和child,看下一层        nums[root] = nums[child];        root = child;        child = 2 * root + 1;      &#125; else &#123;        break;      &#125;    &#125;    // 不管在哪退出循环,最后都要给空位root赋值    // 如果child &gt; size,把temp放到叶子节点上    nums[root] = temp;  &#125;&#125;;int main() &#123;  Solution s;  vector&lt;int&gt; nums = &#123;3, 2, 1, 5, 6, 4&#125;;  int k = 4;  s.findKthLargest(nums, k);  return 0;&#125;\n\n5-1、二叉树的中序遍历(简)题解中序遍历：左 -&gt; 根 -&gt; 右；前序遍历：根 -&gt; 左 -&gt; 右；后序遍历：根 -&gt; 左 -&gt; 右二叉树遍历这种，最好是用stack，把需要的入栈，再按条件出栈比如二叉树如下：\ngraph TD\nA((1)) --> B((2))\nA((1)) --> C((3))\nB((2)) --> D((4))\nB((2)) --> E((5))\nC((3)) --> F((6))\nC((3)) --> G(( ))\nE((5)) --> H((7))\nE((5)) --> I((8))\nstyle G fill:#f100,stroke-width:0px %% 设置G属性为填充为白色,边框宽度为0\nlinkStyle 5 stroke:#0ff,stroke-width:0px %%将第6条连接线的宽度设为0,即隐形\n首先每个三角形的节点顺序必须是左根右，比如4-&gt;2-&gt;5，2-&gt;1-&gt;3。中序遍历的过程就是把左侧子树全部入栈，然后一个个出栈，并取值。这里1&lt;-2&lt;-4入栈，然后4出栈，取值4；到2，2有右子树5，5入栈；5也执行一遍中序遍历，即左子树7入栈，然后7出栈，取值7；到5，5有右子树8，8入栈。重复直到没有子树\nstruct TreeNode &#123;  int val;  TreeNode* left;  TreeNode* right;  TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;  explicit TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;  TreeNode(int x, TreeNode* left, TreeNode* right)      : val(x), left(left), right(right) &#123;&#125;&#125;;class Solution &#123; public:  std::vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;    vector&lt;int&gt; res;    if (root == NULL)      return res;    stack&lt;TreeNode*&gt; s;    TreeNode* cur = root;    while (cur || !s.empty()) &#123;      if (cur) &#123;        s.push(cur);        cur = cur-&gt;left;  // left      &#125; else &#123;        cur = s.top();        s.pop();        res.push_back(cur-&gt;val);  // root        cur = cur-&gt;right;         // right      &#125;    &#125;    return res;  &#125;&#125;;\n\n5-2、二叉树的前序遍历(简)题解首先每个三角形的节点顺序必须是根左右，比如2-&gt;4-&gt;5，1-&gt;2-&gt;3。参考中序遍历，中序遍历是左根右，所以要左子树入栈-&gt;出栈-&gt;取值-&gt;判断右子树；而先序遍历是根左右，所以要取值-&gt;左子树入栈-&gt;出栈-&gt;判断右子树\nclass Solution &#123; public:  vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;    vector&lt;int&gt; res;    if (root == NULL)      return res;    stack&lt;TreeNode*&gt; s;    TreeNode* cur = root;    while (cur || !s.empty()) &#123;      if (cur) &#123;        res.push_back(cur-&gt;val);  // root        s.push(cur);        cur = cur-&gt;left;  // left      &#125; else &#123;        cur = s.top();        s.pop();        cur = cur-&gt;right;  // right      &#125;    &#125;    return res;  &#125;&#125;;\n\n5-3、二叉树的后序遍历(简)题解1首先每个三角形的节点顺序必须是左右根，比如4-&gt;5-&gt;2，2-&gt;3-&gt;1。参考前序遍历的根左右，输出根右左，然后倒序，就是左右根\nclass Solution &#123; public:  vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;    vector&lt;int&gt; res;    if (root == NULL)      return res;    stack&lt;TreeNode*&gt; s;    TreeNode* cur = root;    while (cur || !s.empty()) &#123;      if (cur) &#123;        res.push_back(cur-&gt;val);  // root        s.push(cur);        cur = cur-&gt;right;  // right      &#125; else &#123;        cur = s.top();        s.pop();        cur = cur-&gt;left;  // left      &#125;    &#125;    reverse(res.begin(), res.end());    return res;  &#125;&#125;;\n\n题解2顺便记录下递归的写法\nclass Solution &#123; public:  void postorder(TreeNode* root, vector&lt;int&gt;&amp; res) &#123;    if (root == nullptr) &#123;      return;    &#125;    postorder(root-&gt;left, res);    postorder(root-&gt;right, res);    res.push_back(root-&gt;val);  &#125;  vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;    vector&lt;int&gt; res;    postorder(root, res);    return res;  &#125;&#125;;\n\n5-4、二叉树的层序遍历(中)题解首先要知道遍历二叉树，DFS和BFS的顺序是不一样的从gif图可以看出，前中后序遍历就是DFS遍历，层序遍历就类似BFS遍历，不同的是BFS是输出一个一维数组，而层序遍历要求我们区分每一层，也就是返回一个二维数组那首先我们可以先实现BFS遍历，用队列来存储遍历的节点，因为队列是先进先出，顺序不会乱\n// 二叉树的BFS遍历class Solution &#123; public:  vector&lt;int&gt; levelOrder(TreeNode* root) &#123;    vector&lt;int&gt; res;    queue&lt;TreeNode*&gt; q;    if (root != NULL) &#123;      q.push(root);    &#125;    while (!q.empty()) &#123;      TreeNode* node = q.front();      q.pop();      res.push_back(node-&gt;val);      if (node-&gt;left != NULL) &#123;        q.push(node-&gt;left);      &#125;      if (node-&gt;right != NULL) &#123;        q.push(node-&gt;right);      &#125;    &#125;    return res;  &#125;&#125;;\n有了BFS遍历，怎么把每一层的分别记录下来呢很简单，在每一层遍历开始前，先记录队列中的结点数量n（也就是这一层的结点数量），然后一口气处理完这一层的n个结点\nclass Solution &#123; public:  vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;    vector&lt;vector&lt;int&gt;&gt; res;    queue&lt;TreeNode*&gt; q;    if (root != NULL) &#123;      q.push(root);    &#125;    while (!q.empty()) &#123;      int n = q.size();      vector&lt;int&gt; temp;      for (int i = 0; i &lt; n; i++) &#123;        TreeNode* node = q.front();        q.pop();        temp.push_back(node-&gt;val);        if (node-&gt;left != NULL) &#123;          q.push(node-&gt;left);        &#125;        if (node-&gt;right != NULL) &#123;          q.push(node-&gt;right);        &#125;      &#125;      res.push_back(temp);    &#125;    return res;  &#125;&#125;;\n\n6-1、两数之和(简)题解当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。数组可以做哈希表，set也可以，map也可以，用哪个呢对于这道题，不仅要知道元素有没有遍历过，还有知道这个元素对应的下标。需要使用key-value结构来存放，key来存元素，value来存下标，那么使用map正合适而C++中map有三种类型，如下所示:\n\n\n\n映射\n底层实现\n是否有序\nkey的数量\n能否更改数值\n查询效率\n增删效率\n\n\n\nstd::map\n红黑树\nkey有序\n只能有一个key\nkey不可修改\nO(log n)\nO(log n)\n\n\nstd::multimap\n红黑树\nkey有序\n可以有多个key\nkey不可修改\nO(log n)\nO(log n)\n\n\nstd::map\n哈希表\nkey无序\n只能有一个key\nkey不可修改\nO(1)\nO(1)\n\n\n这道题目中并不需要key有序，所以选择std::unordered_map效率更高接下来就很简单了，首先把数组中的元素作为key，value用来存下标；我们只需要查找map中是否存在target-nums[i]的值，没有就将(nums[i],i)加入map，继续遍历即可\nclass Solution &#123; public:  vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;    unordered_map&lt;int, int&gt; num_map;    vector&lt;int&gt; res;    for (int i = 0; i &lt; nums.size(); i++) &#123;      auto iter = num_map.find(target - nums[i]);      if (iter != num_map.end()) &#123;        res = &#123;iter-&gt;second, i&#125;;        break;      &#125;      num_map.insert(pair&lt;int, int&gt;(nums[i], i));    &#125;    return res;  &#125;&#125;;int main() &#123;  Solution s;  vector&lt;int&gt; nums = &#123;2, 7, 11, 15&#125;;  int target = 22;  vector&lt;int&gt; res = s.twoSum(nums, target);  for (auto i : res) &#123;    cout &lt;&lt; i &lt;&lt; &quot; &quot;;  &#125;&#125;\n\n6-2、三数之和(中)题解这道题只用求值，不用求下标，就不需要用哈希表了，用双指针就是最方便的。从小到大排序后，就可以用双指针了因为有需要三个数，可以固定一个数a，双指针遍历剩下的数组，求双指针之和target为0-a即可left为数组头，right为数组尾，大于target则right--，小于target则left++主要是去重，因为有可能数组中同一个数字出现多次，排完序后，相同的数字会连在一起，只要将当前的值和前一个值比就可以去重了\nclass Solution &#123; public:  vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;    vector&lt;vector&lt;int&gt;&gt; res;    sort(nums.begin(), nums.end());    // 目的是找出a + left + right = 0    for (int i = 0; i &lt; nums.size(); i++) &#123;      if (nums[i] &gt; 0) &#123;        return res;      &#125;      if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;        // 去重a        continue;      &#125;      int left = i + 1;      int right = nums.size() - 1;      int target = 0 - nums[i];      while (left &lt; right) &#123;        if (nums[left] + nums[right] &gt; target) &#123;          right--;        &#125; else if (nums[left] + nums[right] &lt; target) &#123;          left++;        &#125; else &#123;          res.push_back(&#123;nums[i], nums[left], nums[right]&#125;);          // 找到答案时，双指针同时收缩          left++;          right--;          while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123;            // 去重left            left++;          &#125;          while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123;            // 去重right            right--;          &#125;        &#125;      &#125;    &#125;  &#125;  return res;&#125;;\n\n6-3、最接近的三数之和(中)题解和三数之和非常类似，求与target最接近的三元组，即差值的绝对值最小。和三数之和一样，从小到大排序后，固定一个数a，求双指针之和尽可能接近target-a即可如果a+b+c&gt;target，right--；如果a+b+c&lt;target，left++，同时和三数之和一样需要去重，只是增加一步，在和taget比较之前，需要先update一下三数之和，记录下最接近target的值\nclass Solution &#123; public:  int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;    int best = 1e7;    // 根据差值的绝对值来更新答案    auto update = [&amp;](int cur) &#123;      // auto的特殊用法      if (abs(cur - target) &lt; abs(best - target)) &#123;        best = cur;      &#125;    &#125;;    sort(nums.begin(), nums.end());    // 目的是找出a + left + right = 0    for (int i = 0; i &lt; nums.size(); i++) &#123;      if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;        // 去重a        continue;      &#125;      int left = i + 1;      int right = nums.size() - 1;      while (left &lt; right) &#123;        int sum = nums[i] + nums[left] + nums[right];        if (sum == target) &#123;          return target;        &#125;        update(sum);        if (sum &gt; target) &#123;          right--;          while (right &gt; left &amp;&amp; nums[right] == nums[right + 1]) &#123;            // 去重right            right--;          &#125;        &#125; else &#123;          left++;          while (right &gt; left &amp;&amp; nums[left] == nums[left - 1]) &#123;            // 去重left            left++;          &#125;        &#125;      &#125;    &#125;    return best;  &#125;&#125;;\n\n7、手撕快速排序(中)题解8、最大子数组和(中)题解9、合并两个有序链表(简)题解10-1、搜索旋转排序数组(中)题解首先要明白这道题问的是啥，很简单就是从给定的数组中找出target的下标。那为啥题目描述的花里胡哨的，还有什么旋转呢，主要是怕你想不到，因为要设计O(log n)的算法，单纯暴力搜索肯定是不行的。那是不是可以用二分法呢？严格来说，标准的二分法只适用于有序数组，但题目给我们的是旋转后的数组，它不是有序的，所以需要对二分法进行修改变形。这个旋转后的数组有什么特点呢？可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。所以我们在常规二分查找的时候，可以查看当前mid为分割位置分割出来的两个部分[left, mid]和[mid+1, right]哪个部分是有序的，根据有序的那部分判断出target在不在这个部分。所以我们在用二分法时有两种情况:1、若nums[0] ≤ nums[mid]，说明[left, mid]是有序的，则当nums[0] ≤ target &lt; nums[mid]时target在[left, mid-1]中，否则在[mid+1, right]中；2、若nums[0] &gt; nums[mid]，说明[mid+1, right]是有序的，则当nums[mid] &lt; target ≤ nums[size-1]时target在[mid+1, right]中，否则在[left, mid-1]中。\nclass Solution &#123; public:  int search(vector&lt;int&gt;&amp; nums, int target) &#123;    if (nums.empty()) &#123;      return -1;    &#125;    int n_size = nums.size();    int left = 0;    int right = n_size - 1;    int res = -1;    while (left &lt;= right) &#123;      int mid = (left + right) / 2;      if (nums[mid] == target) &#123;        res = mid;        break;      &#125;      if (nums[0] &lt;= nums[mid]) &#123;        if (nums[0] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;          right = mid - 1;        &#125; else &#123;          left = mid + 1;        &#125;      &#125; else &#123;        if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n_size - 1]) &#123;          left = mid + 1;        &#125; else &#123;          right = mid - 1;        &#125;      &#125;    &#125;    return res;  &#125;&#125;;int main() &#123;  Solution s;  vector&lt;int&gt; nums = &#123;4, 5, 6, 7, 0, 1, 2&#125;;  cout &lt;&lt; s.search(nums, 0);&#125;\n\n10-2、搜索旋转排序数组 II(中)题解和上一题一样，只不过因为数组中有重复元素，二分查找时可能会有num[left] = num[mid] = num[right]。比如数组[3,1,2,3,3,3,3]，target = 2，首次二分时无法判断区间[0, 3]和[4, 6]哪个是有序的。对于这种情况，我们只能将当前二分区间的左边界加一，右边界减一，然后在新区间上继续二分查找。\nclass Solution &#123; public:  int search(vector&lt;int&gt;&amp; nums, int target) &#123;    if (nums.empty()) &#123;      return -1;    &#125;    int n_size = nums.size();    int left = 0;    int right = n_size - 1;    bool res = false;    while (left &lt;= right) &#123;      int mid = (left + right) / 2;      if (nums[mid] == target) &#123;        res = true;        break;      &#125;      if (nums[left] == nums[mid] &amp;&amp; nums[mid] == nums[right]) &#123;        left++;        right--;      &#125; else if (nums[0] &lt;= nums[mid]) &#123;        if (nums[0] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;          right = mid - 1;        &#125; else &#123;          left = mid + 1;        &#125;      &#125; else &#123;        if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n_size - 1]) &#123;          left = mid + 1;        &#125; else &#123;          right = mid - 1;        &#125;      &#125;    &#125;    return res;  &#125;&#125;;\n\n10-3、寻找旋转排序数组中的最小值(中)题解首先对于这个旋转数组，它的特点是：1、以最小值为分界线的左子序列是单调递增的，右子序列也是单调递增的；2、对于数组中最后一个元素x，左子序列全大于x，右子序列全小于x。通过nums[mid]和nums[right]比较，判断nums[mid]在左子序列还是右子序列。右两种情况：1、如果nums[mid] &lt; nums[right]，则mid在右子序列，即在最小值右边，所以right左移；2、如果nums[mid] &gt; nums[right]，则mid在左子序列，即在最小值右左边，所以left右移。\nclass Solution &#123; public:  int findMin(vector&lt;int&gt;&amp; nums) &#123;    int left = 0;    int right = nums.size() - 1;    while (left &lt; right) &#123;      int mid = (left + right) / 2;      if (nums[mid] &lt; nums[right]) &#123;        right = mid;  // right左移        // 为什么right=mid,而不是right=mid-1;        // nums[mid]&lt;nums[right]时,有可能nums[mid]本身就是最小值,然后mid-1就错过了,所以不要减1.比如&#123;4,5,1,2,3&#125;,如果right=mid-1,则丢失了最小值1      &#125; else &#123;        left = mid + 1;  // left右移        // 为什么low=mid+1,而不是low=mid;        // 因为我们这题是求最小值,而nums[mid]&gt;nums[right],自然nums[mid]绝对不会是最小值,所以可以+1过滤掉mid这个下标.比如&#123;4,5,6,1,2,3&#125;,nums[mid]=6,low=mid+1,刚好nums[low]=1      &#125;    &#125;    return nums[left];    // 这里返回的是left,所以只能while(left&lt;right).如果返回的是right,就可以while(left&lt;=right)和while(left&lt;right);    // 因为若循环条件为while(left&lt;=right),则进入最后一个循环的时候,left=right=mid,都指向最小值,接着执行left=mid+1.这时left便跑到mid和right右边一位去了,因此若要用while(left&lt;=right)条件必须返回 nums[right]或者nums[left-1].  &#125;&#125;;\n\n10-4、寻找旋转排序数组中的最小值 II(困)题解这道题和上一题区别就在于数组元素是可以重复的，所以对于右重复元素的旋转数组，它的特点是：1、以最小值为分界线的左子序列是单调递增的，右子序列也是单调递增的；2、对于数组中最后一个元素x，左子序列全大于或等于x，右子序列全小于或等于x。同样通过nums[mid]和nums[right]比较，判断nums[mid]在左子序列还是右子序列。只不过因为右重复值，所以多了一种情况。有三种情况：1、如果nums[mid] &lt; nums[right]，则mid在右子序列，即在最小值右边，所以right左移；2、如果nums[mid] &gt; nums[right]，则mid在左子序列，即在最小值右左边，所以left右移；3、如果nums[mid] = nums[right]，则不能确定mid在左子序列还是右子序列；由于它们的值相同，所以无论nums[right]是不是最小值，都有一个最小值nums[mid]，因此我们可以忽略二分查找区间的右端点。解释下第3点，比如数组[1,0,1,1,1]，left = 0，right = 4，mid = 2，无法判断mid在在左子序列还是右子序列，我们采用right--解决此问题那这个操作会不会影响取最小值呢，证明如下：1、此操作不会使数组越界：因为迭代条件保证了right&gt;left&gt;=0；2、此操作不会使最小值丢失：假设nums[right]是最小值，有两种情况：2-1、若nums[right]是唯一最小值：那就不可能满足判断条件nums[mid]==nums[right]，因为mid&lt;right（left!=right &amp;&amp; mid=(left + right)/2）；2-2、若nums[right]不是唯一最小值，由于mid&lt;right而nums[mid]==nums[right]，即还有最小值存在于[left,right−1]区间，因此不会丢失最小值。\nclass Solution &#123; public:  int findMin(vector&lt;int&gt;&amp; nums) &#123;    int left = 0;    int right = nums.size() - 1;    while (left &lt; right) &#123;      int mid = (left + right) / 2;      if (nums[mid] &lt; nums[right]) &#123;        right = mid;  // right左移      &#125; else if (nums[mid] &gt; nums[right]) &#123;        left = mid + 1;  // left右移      &#125; else &#123;        right--;      &#125;    &#125;    return nums[left];  &#125;&#125;;\n\n11-1、买卖股票的最佳时机(简)题解1用一个变量记录一个最低价格min_price，在第i天卖出股票能得到的利润就是prices[i]-min_price我们只需要遍历一遍价格数组，求出每一天卖出股票得到的利润，取最大值max_profit，同时更新最低价格min_price\nclass Solution &#123;public:  int maxProfit(vector&lt;int&gt;&amp; prices) &#123;    int min_price = INT_MAX;    int max_profit = 0;    for (auto price : prices) &#123;      max_profit = max(max_profit, price - min_price);      min_price = min(min_price, price);    &#125;    return max_profit;  &#125;&#125;;\n题解2这道题是最基础的动态规划，下面讲下证明用动态规划解决。题目只问最大利润，没有问这几天具体哪一天买、哪一天卖，因此可以考虑使用 动态规划的方法来解决。根据题目意思，有以下两个约束条件：1、不能在买入股票前卖出股票；2、最多只允许完成一笔交易。首先先定义好现金数这个概念，买入股票手上的现金数减少，卖出股票手上的现金数增加。对于这道题，当天是否持股会影响现金数，因为持股表示你还没卖掉，不持股表示卖掉了。所以动态规划的状态需要用到二维数组表示，一方面表示第几天，一方面表示是否持股。1、状态定义：\n\ndp[i][0]表示第i天，不持股，手上拥有的现金数\ndp[i][1]表示第i天，持股，手上拥有的现金数\n\n2、状态转移方程：第1天，dp[0][0] = 0，dp[0][1] = -prices[0]第i天，对于dp[i][0]，有两种情况\n\n昨天不持股，今天什么都不做\n昨天持股，今天卖出股票（现金数增加）\n\n因此dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])同样对于dp[i][1]，也有两种情况\n\n昨天持股，今天什么都不做（现金数与昨天一样）\n昨天不持股，今天买入股票（注意：只允许交易一次，因此手上的现金数就是当天的股价的相反数）\n\n因此dp[i][1] = max(dp[i-1][1], -prices[i])\nclass Solution &#123; public:  int maxProfit(vector&lt;int&gt;&amp; prices) &#123;    int n = prices.size();    if (n &lt; 2) &#123;      return 0;    &#125;    // vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2));    // 数据量大尽量用数组,vector操作太耗时    int dp[n][2];    // dp[i][0],下标为i这天结束的时候,不持股,手上拥有的现金数    // dp[i][1],下标为i这天结束的时候,持股,手上拥有的现金数    // 初始化:不持股显然为0,持股就需要减去第1天(下标为0)的股价    dp[0][0] = 0;    dp[0][1] = -prices[0];    // 从第2天开始遍历    for (int i = 1; i &lt; n; i++) &#123;      dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);      dp[i][1] = max(dp[i - 1][1], -prices[i]);    &#125;    return dp[n - 1][0];  &#125;&#125;;\n\n11-2、买卖股票的最佳时机 II(中)题解和上一题一样，状态定义不变，只不过状态方程有点变化。第i天，对于dp[i][0]，有两种情况\n\n昨天不持股，今天什么都不做\n昨天持股，今天卖出股票（现金数增加）\n\n因此dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])同样对于dp[i][1]，也有两种情况\n\n昨天持股，今天什么都不做（现金数与昨天一样）\n昨天不持股，即dp[i-1][0]，今天买入股票（注意：允许交易多次，因此手上的现金数就是dp[i-1][0]-prices[i]）\n\n因此dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])。其余照搬\nclass Solution &#123; public:  int maxProfit(vector&lt;int&gt;&amp; prices) &#123;    int n = prices.size();    if (n &lt; 2) &#123;      return 0;    &#125;    int dp[n][2];    dp[0][0] = 0;    dp[0][1] = -prices[0];    // 从第2天开始遍历    for (int i = 1; i &lt; n; i++) &#123;      dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);      dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);    &#125;    return dp[n - 1][0];  &#125;&#125;;\n\n11-3、买卖股票的最佳时机 III(困)题解分析步骤参照11-1题，但这道题状态比11-1多。一天结束时，可能有持股、可能未持股、可能卖出过1次、可能卖出过2次、也可能未卖出过所以定义状态转移数组dp[天数][当前是否持股][卖出的次数]1、状态定义：\n\ndp[i][0][0]表示第i天，不持股，不卖出过股票，手上拥有的现金数\ndp[i][0][1]表示第i天，不持股，卖出1次股票，手上拥有的现金数\ndp[i][0][2]表示第i天，不持股，卖出2次股票，手上拥有的现金数\ndp[i][1][0]表示第i天，持股，不卖出过股票，手上拥有的现金数\ndp[i][1][1]表示第i天，持股，卖出1次股票，手上拥有的现金数\ndp[i][1][2]表示第i天，持股，卖出2次股票，手上拥有的现金数\n\n2、状态转移方程：第1天有，\n\n第1天休息：dp[0][0][0] = 0\n第1天买入：dp[0][1][0] = -prices[0]\n第1天不可能已经有卖出：dp[0][0][1] = float(&#39;-inf&#39;)、dp[0][0][2] = float(&#39;-inf&#39;)\n第一天不可能已经卖出：dp[0][1][1] = float(&#39;-inf&#39;)、dp[0][1][2] = float(&#39;-inf&#39;)\n\n第i天有，\n\n对于dp[i][0][0]，有一种情况，未持股，未卖出过，说明从未进行过买卖。因此dp[i][0][0] = 0\n对于dp[i][0][1]，有两种情况，未持股，卖出过1次，可能是之前卖的，可能是今天卖的。因此dp[i][0][1]=max(dp[i-1][0][1], dp[i-1][1][0]+prices[i])\n对于dp[i][0][2]，有两种情况，未持股，卖出过2次，可能是之前卖的，可能是今天卖的。因此dp[i][0][2]=max(dp[i-1][0][2], dp[i-1][1][1]+prices[i])\n对于dp[i][1][0]，有两种情况，持股，未卖出过，可能是之前买的，可能是今天买的。因此dp[i][0][1]=max(dp[i-1][1][0], dp[i-1][0][0]-prices[i])\n对于dp[i][1][1]，有两种情况，持股，卖出过1次，可能是之前买的，可能是今天买的。因此dp[i][0][1]=max(dp[i-1][1][1], dp[i-1][0][1]-prices[i])\n对于dp[i][1][2]，有两种情况，持股，卖出过2次，不可能（因为最多只允许买卖两次）。因此dp[i][1][2]=float(&#39;-inf&#39;)class Solution &#123; public:  int maxProfit(vector&lt;int&gt;&amp; prices) &#123;    int n = prices.size();    if (n &lt; 2) &#123;      return 0;    &#125;    int MIN_VALUE = INT_MIN / 2;    // 这里除2是因为最小值加上1就变成最大值了,会影响max()函数的结果,除数只要比1大就行    int dp[n][2][3];    dp[0][0][0] = 0;           // 第一天休息    dp[0][1][0] = -prices[0];  // 第一天买入    dp[0][0][1] = MIN_VALUE;   // 第一天不可能已经有卖出    dp[0][0][2] = MIN_VALUE;   // 第一天不可能已经卖出    dp[0][1][1] = MIN_VALUE;    dp[0][1][2] = MIN_VALUE;    // 从第2天开始遍历    for (int i = 1; i &lt; n; i++) &#123;      dp[i][0][0] = 0;  // 未持股，未卖出过      dp[i][0][1] = max(dp[i - 1][1][0] + prices[i],                        dp[i - 1][0][1]);  // 未持股，卖出过1次      dp[i][0][2] = max(dp[i - 1][1][1] + prices[i],                        dp[i - 1][0][2]);  // 未持股，卖出过2次      dp[i][1][0] =          max(dp[i - 1][0][0] - prices[i], dp[i - 1][1][0]);  // 持股，未卖出过      dp[i][1][1] =          max(dp[i - 1][0][1] - prices[i], dp[i - 1][1][1]);  // 持股，卖出过1次      dp[i][1][2] = MIN_VALUE;  // 持股，卖出过2次    &#125;    return max(max(dp[n - 1][0][1], dp[n - 1][0][2]), 0);  &#125;&#125;;\n\n12-1、环形链表(简)题解利用快慢指针，快指针一次走两步，慢指针一次走一步。因为快指针快，慢指针慢，所以如果有环快指针最后一定会追上慢指针\nclass Solution &#123; public:  bool hasCycle(ListNode *head) &#123;    if (!head || !head-&gt;next) &#123;      return false;    &#125;    ListNode *slow = head;    ListNode *fast = head;    while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;      if(!slow-&gt;next) &#123;        return false;\t\t// 稍微加个判断，减少下用时      &#125;      slow = slow-&gt;next;      fast = fast-&gt;next-&gt;next;      if (fast == slow) &#123;        return true;      &#125;    &#125;    return false;  &#125;&#125;;// 另一种表示方法是slow = head;fast = head-&gt;next;// 两种方式不同点在于,一般用fast=head-&gt;next较多,因为这样可以知道中点的上一个节点,可以用来删除等操作// fast如果初始化为head-&gt;next,则中点在slow-&gt;next// fast初始化为head,则中点在slow\n\n12-2、环形链表 II(中)题解这道题是要求入环点，首先要判断有环，这个就直接照搬上一题。主要是怎么找入环点。可以看下面这张图F为第一个节点-F到入环点0的距离；a为入环点0到相遇点h距离；b为相遇点h到入环点0距离；当fast和slow相遇时，因为fast每次走两步，slow每次一步，所以fast走过的是slow的两倍，设slow走过为S，则S&#x3D;F+a，2S&#x3D;F+a+b+a，故F&#x3D;b；现在让slow返回第一个节点，fast处于第一次相遇的节点，此时slow从第一个节点出发，因为F&#x3D;b，所以fast和slow会在入环口第二次相遇，即为所求节点。\nclass Solution &#123; public:  ListNode* detectCycle(ListNode* head) &#123;    if (!head || !head-&gt;next) &#123;      return NULL;    &#125;    bool hasCycle = false;    // 先判断是否有环    ListNode* slow = head;    ListNode* fast = head;    while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;      if (!slow-&gt;next) &#123;        break;      &#125;      slow = slow-&gt;next;      fast = fast-&gt;next-&gt;next;      if (fast == slow) &#123;        hasCycle = true;        break;      &#125;    &#125;    // 有环则找入环开始的节点    if (hasCycle) &#123;      slow = head;      while (slow != fast) &#123;        slow = slow-&gt;next;        fast = fast-&gt;next;      &#125;      return slow;    &#125;    return NULL;  &#125;&#125;;\n\n13-1、岛屿数量(中)题解我们知道，DFS通常是在树或者图结构上进行的，而我们这道题是网格，能不能用DFS呢？可以，记住，凡是网格的都应该想到用DFS，岛屿问题就是一类典型的网格问题。首先我们要清楚DFS的基本结构，先看简单的二叉树DFS遍历结构\nvoid traverse(TreeNode* root) &#123;  // 判断base case  if (root == NULL) &#123;    return;  &#125;  // 访问两个相邻结点:左子结点,右子结点  traverse(root-&gt;left);  traverse(root-&gt;right);&#125;\n可以看到，二叉树的DFS有两个要素：访问相邻结点、判断base case1、二叉树的相邻结点非常简单，只有左子结点和右子结点两个。二叉树本身就是一个递归定义的结构：一棵二叉树，它的左子树和右子树也是一棵二叉树。那么我们的DFS遍历只需要递归调用左子树和右子树即可。2、二叉树遍历的base case是root == Null。这样一个条件判断其实有两个含义：一方面，这表示 root 指向的子树为空，不需要再往下遍历了。另一方面，在root == Null的时候及时返回，可以让后面的root-&gt;left和root-&gt;right操作不会出现空指针异常。\n那么对于网格上的DFS，我们完全可以参考二叉树的DFS，写出网格DFS的两个要素。1、首先看相邻结点。很明显，网格结构中的格子的相邻结点是上下左右四个，即(row-1, col),(row+1, col),(row, col-1),(row, col+1)2、然后是base case。根据二叉树的对应过来，是超出网格范围的格子，即row &gt;= grid.size() || col &gt;= grid[0].size() || row &lt; 0 || col &lt; 0。\n根据分析，可以得出网格DFS遍历的框架代码：\nvoid dfsGrid(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int row, int col) &#123;  if (row &gt;= grid.size() || col &gt;= grid[0].size() || row &lt; 0 || col &lt; 0) &#123;    // 防止row和col越界(上下左右)    return;  &#125;  dfsGrid(grid, row - 1, col);  // 上  dfsGrid(grid, row + 1, col);  // 下  dfsGrid(grid, row, col - 1);  // 左  dfsGrid(grid, row, col + 1);  // 右&#125;\n这里有个问题，这么避免重复值，比如下面这张图，dfsGrid遍历时会一直在这里不断循环。简单的方法就是标记已经遍历过的格子。比如岛屿问题，把走过的陆地格子的值改为2.这样就能得到一个网格DFS遍历的通用框架代码：\nvoid dfsGrid(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int row, int col) &#123;  if (row &gt;= grid.size() || col &gt;= grid[0].size() || row &lt; 0 || col &lt; 0) &#123;    // 防止row和col越界(上下左右)    return;  &#125;  if (grid[row][col] != &#x27;1&#x27;) &#123;    // 遍历到海洋或者已经遍历过的陆地,退出    return;  &#125;  grid[row][col] = &#x27;2&#x27;;         // 去重,防止多次遍历  dfsGrid(grid, row - 1, col);  // 上  dfsGrid(grid, row + 1, col);  // 下  dfsGrid(grid, row, col - 1);  // 左  dfsGrid(grid, row, col + 1);  // 右&#125;\n有了网格DFS遍历的通用框架，我们只需要用两层for循环遍历整张二维表格中所有的陆地，连续的视为一个岛屿。\nclass Solution &#123; public:  int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;    int res = 0;    // 两层for循环,遍历整张二维表格中所有的陆地,i是行,j是列    for (int i = 0; i &lt; grid.size(); i++) &#123;      for (int j = 0; j &lt; grid[0].size(); j++) &#123;        if (grid[i][j] == &#x27;1&#x27;) &#123;          dfsGrid(grid, i, j);  // 深度递归，遍历所有的陆地          res++;        &#125;      &#125;    &#125;    return res;  &#125;  void dfsGrid(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int row, int col) &#123;    if (row &gt;= grid.size() || col &gt;= grid[0].size() || row &lt; 0 || col &lt; 0) &#123;      // 防止row和col越界(上下左右)      return;    &#125;    if (grid[row][col] != &#x27;1&#x27;) &#123;      // 遍历到海洋或者已经遍历过的陆地,退出      return;    &#125;    grid[row][col] = &#x27;2&#x27;;         // 去重,防止多次遍历    dfsGrid(grid, row - 1, col);  // 上    dfsGrid(grid, row + 1, col);  // 下    dfsGrid(grid, row, col - 1);  // 左    dfsGrid(grid, row, col + 1);  // 右  &#125;&#125;;\n\n13-2、岛屿的周长(简)题解这道题最牛逼的一点是你要想到，岛屿的周长就是岛屿方格和非岛屿方格相邻的边的数量（如下图所示）。也就是说，在DFS遍历中，从一个岛屿方格走向一个非岛屿方格，就将周长加1。所以，我们可以修改下网格DFS遍历的通用框架：\nint dfsGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int row, int col) &#123;  if (row &gt;= grid.size() || col &gt;= grid[0].size() || row &lt; 0 || col &lt; 0) &#123;    // 从一个岛屿方格走向网格边界,周长加1    return 1;  &#125;  if (grid[row][col] == 0) &#123;    // 从一个岛屿方格走向水域方格,周长加1    return 1;  &#125;  if (grid[row][col] != 1) &#123;    // 过滤掉已经遍历过的    return 0;  &#125;  grid[row][col] = 2;  // 去重,防止多次遍历  int res = dfsGrid(grid, row - 1, col) + dfsGrid(grid, row + 1, col) +            dfsGrid(grid, row, col - 1) + dfsGrid(grid, row, col + 1);  return res;&#125;\n题目限制只有一个岛屿，那我们计算一个即可\nclass Solution &#123; public:  int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;    for (int i = 0; i &lt; grid.size(); i++) &#123;      for (int j = 0; j &lt; grid[0].size(); j++) &#123;        if (grid[i][j] == 1) &#123;          return dfsGrid(grid, i, j);        &#125;      &#125;    &#125;    return 0;  &#125;  int dfsGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int row, int col) &#123;    if (row &gt;= grid.size() || col &gt;= grid[0].size() || row &lt; 0 || col &lt; 0) &#123;      // 从一个岛屿方格走向网格边界,周长加1      return 1;    &#125;    if (grid[row][col] == 0) &#123;      // 从一个岛屿方格走向水域方格,周长加1      return 1;    &#125;    if (grid[row][col] != 1) &#123;      // 过滤掉已经遍历过的      return 0;    &#125;    grid[row][col] = 2;  // 去重,防止多次遍历    int res = dfsGrid(grid, row - 1, col) + dfsGrid(grid, row + 1, col) +              dfsGrid(grid, row, col - 1) + dfsGrid(grid, row, col + 1);    return res;  &#125;&#125;;\n\n13-3、岛屿的最大面积(中)题解从上面两道我们已经知道怎么计算岛屿数量和一个岛屿的周长，这道题是结合了上面两道。因此我们可以对每个岛屿计算它的面积，最后返回最大的那个面积即可。\nclass Solution &#123; public:  int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;    int res = 0;    for (int i = 0; i &lt; grid.size(); i++) &#123;      for (int j = 0; j &lt; grid[0].size(); j++) &#123;        if (grid[i][j] == 1) &#123;          res = max(dfsGrid(grid, i, j), res);        &#125;      &#125;    &#125;    return res;  &#125;  int dfsGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int row, int col) &#123;    if (row &gt;= grid.size() || col &gt;= grid[0].size() || row &lt; 0 || col &lt; 0) &#123;      // row和col越界,都不算岛屿中的陆地,面积为0      return 0;    &#125;    if (grid[row][col] != 1) &#123;      // 遍历到海洋或者已经遍历过的陆地,面积为0      return 0;    &#125;    grid[row][col] = 2;  // 去重,防止多次遍历    int res = dfsGrid(grid, row - 1, col) + dfsGrid(grid, row + 1, col) +              dfsGrid(grid, row, col - 1) + dfsGrid(grid, row, col + 1) +              1;  // 加1是因为第一次肯定是一块陆地才进来的dfsGrid    return res;  &#125;&#125;;\n\n13-4、最大人工岛(困)题解这道题是13-3的升级版，现在我们可以将一个海洋变成陆地，从而连接两个岛屿。那我们就需要先统计各个岛屿面积，找到最大的岛屿；然后把一个海洋变成陆地，再统计一遍连接后各个岛屿面积，找到最大的岛屿。因此需要两次DFS遍历1、划分岛屿，给每个岛屿标号标号要标什么呢？假设我们在所有的格子上标记出岛屿的面积。然后搜索哪个海洋格子相邻的两个岛屿面积最大。例如下图中红色方框内的海洋格子，上边、左边都与岛屿相邻，我们可以计算出它变成陆地之后可以连接成的岛屿面积为7 + 1 + 2 = 10。然而，这种做法可能遇到一个问题。如下图中红色方框内的海洋格子，它的上边、左边都与岛屿相邻，这时候连接成的岛屿面积难道是7 + 1 + 7 = 15？显然不是。这两个7来自同一个岛屿，所以填海造陆之后得到的岛屿面积应该只有7 + 1 = 8。可以看到，要让算法正确，我们得能区分一个海洋格子相邻的两个7是不是来自同一个岛屿。那么，我们不能在方格中标记岛屿的面积，而应该用map记录每个岛屿面积，给每个岛屿标记map的key。如下图所示。这样我们就可以发现红色方框内的海洋格子，它的两个相邻的岛屿实际上是同一个。2、填充海洋，连接四周的岛屿和上面类似，要遍历每个海洋格子上下左右的格子。又因为我们已经有map来记录了各个岛屿的面积，所以只需要在遍历时发现是岛屿，加上对应的面积即可，不需要再全部遍历该岛屿的陆地。要注意的是，我们是将一个海洋变为陆地，所以海洋会占一个面积。\nclass Solution &#123; public:  unordered_map&lt;int, int&gt; area;  // 存放各岛屿面积 public:  int largestIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;    int res = 0;    int index = 2;  // 从2开始是为了和陆地的1做区分,防止多次遍历    // 不同岛屿用不同的数字标记,统计各岛屿面积,同时记录最大值    for (int i = 0; i &lt; grid.size(); i++) &#123;      for (int j = 0; j &lt; grid[0].size(); j++) &#123;        if (grid[i][j] == 1) &#123;          area[index] = dfsGrid(grid, i, j, index);          res = max(res, area[index]);          index++;        &#125;      &#125;    &#125;    // 连接岛屿    for (int i = 0; i &lt; grid.size(); i++) &#123;      for (int j = 0; j &lt; grid.size(); j++) &#123;        if (grid[i][j] == 0) &#123;          res = max(res, linkland(grid, i, j));        &#125;      &#125;    &#125;    return res;  &#125;  int dfsGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int row, int col, int index) &#123;    if (row &gt;= grid.size() || col &gt;= grid[0].size() || row &lt; 0 || col &lt; 0) &#123;      return 0;    &#125;    if (grid[row][col] != 1) &#123;      return 0;    &#125;    grid[row][col] = index;    int res = dfsGrid(grid, row - 1, col, index) +              dfsGrid(grid, row + 1, col, index) +              dfsGrid(grid, row, col - 1, index) +              dfsGrid(grid, row, col + 1, index) + 1;    return res;  &#125;  int linkland(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int row, int col) &#123;    unordered_set&lt;int&gt; around;    int linkarea = 1;  // 海洋占一个面积    if (row - 1 &gt;= 0 &amp;&amp; grid[row - 1][col] &gt; 1) &#123;      // 左      around.insert(grid[row - 1][col]);    &#125;    if (row + 1 &lt; grid.size() &amp;&amp; grid[row + 1][col] &gt; 1) &#123;      // 右      around.insert(grid[row + 1][col]);    &#125;    if (col - 1 &gt;= 0 &amp;&amp; grid[row][col - 1] &gt; 1) &#123;      // 上      around.insert(grid[row][col - 1]);    &#125;    if (col + 1 &lt; grid.size() &amp;&amp; grid[row][col + 1] &gt; 1) &#123;      // 下      around.insert(grid[row][col + 1]);    &#125;    for (auto i : around) &#123;      linkarea += area[i];    &#125;    return linkarea;  &#125;&#125;;\n\n14、有效的括号(简)题解1首先要知道哪些case是有效的，比如&#123;()&#125;是有效的，&#123;(&#125;)是无效的。这种有对称性的，一般都是用栈来解决。遇到一个左括号，先入栈；遇到一个右括号，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，则字符串无效。问题是怎么判断括号的类型呢？可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。在遍历结束后，如果栈中没有左括号，说明我们将字符串中的所有左括号闭合，返回true，否则false。另外有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回false。特别要注意的是，遍历完字符串,最后栈肯定是空的才是左括号和右括号一一配对。\nclass Solution &#123; public:  bool isValid(string s) &#123;    if (s.empty()) &#123;      return true;    &#125;    int n = s.size();    if (n % 2 == 1) &#123;      return false;    &#125;    unordered_map&lt;char, char&gt; pairs = &#123;&#123;&#x27;)&#x27;, &#x27;(&#x27;&#125;, &#123;&#x27;]&#x27;, &#x27;[&#x27;&#125;, &#123;&#x27;&#125;&#x27;, &#x27;&#123;&#x27;&#125;&#125;;    stack&lt;char&gt; stk;    for (char ch : s) &#123;      if (pairs.count(ch)) &#123;        if (stk.empty() || stk.top() != pairs[ch]) &#123;          return false;        &#125;        stk.pop();      &#125; else &#123;        stk.push(ch);      &#125;    &#125;    if (stk.empty()) &#123;      return true;    &#125;    return false;  &#125;&#125;;\n\n题解2那要是不想用map做哈希表呢？其实也很简单，就用if和else解决。\nclass Solution &#123; public:  bool isValid(string s) &#123;    if (s.empty()) &#123;      return true;    &#125;    if (s.size() % 2 == 1) &#123;      return false;    &#125;    stack&lt;char&gt; stk;    for (auto ch : s) &#123;      if (ch == &#x27;(&#x27;) &#123;        stk.push(&#x27;)&#x27;);      &#125; else if (ch == &#x27;[&#x27;) &#123;        stk.push(&#x27;]&#x27;);      &#125; else if (ch == &#x27;&#123;&#x27;) &#123;        stk.push(&#x27;&#125;&#x27;);      &#125; else if (stk.empty()) &#123;        return false;      &#125; else &#123;        if (stk.empty() || stk.top() != ch) &#123;          return false;        &#125;        stk.pop();      &#125;    &#125;    if (stk.empty()) &#123;      return true;    &#125;    return false;  &#125;&#125;;\n\n15、最长回文子串(中)题解1因为回文串是对称的，这道题推荐用中心扩散法。顾名思义，从每一个位置出发，向两边扩散，遇到不是回文的时候结束。所以可以对每个字符进行扩散，以字符为中心点，left为中心点-1，right为中心点+1，有三种情况：1、left没有超出左边界同时与中心点相等，继续向左扩展2、right没有超出右边界同时与中心点相等，继续向右扩展3、left和right都没超出边界，且left的字符等于right的字符，两边同时扩散另外，题目要输出的是子串，所以要记录left的位置和最大长度\nclass Solution &#123; public:  string longestPalindrome(string s) &#123;    int sLen = s.size();    if (sLen == 0) &#123;      return &quot;&quot;;    &#125;    int left = 0, right = 0, maxLen = 0, start = 0;    for (int i = 0; i &lt; sLen; i++) &#123;      int len = 1;      left = i - 1;   // 取中心点左边      right = i + 1;  // 取中心点右边      while (left &gt;= 0 &amp;&amp; s[left] == s[i]) &#123;        // 没有超过左边界同时与中心点相等,继续向左扩展        left--;        len++;      &#125;      while (right &lt; sLen &amp;&amp; s[right] == s[i]) &#123;        // 没有超过右边界同时与中心点相等,继续向右扩展        right++;        len++;      &#125;      while (left &gt;= 0 &amp;&amp; right &lt; sLen &amp;&amp; s[left] == s[right]) &#123;        // 没有超过边界同时左右点都与中心点相等,两边都扩展        // 这里要注意, 在最后一次循环中left还是做了        // -1操作,实际上子串不包含这个位置, 所以下面start=left+1        left--;        right++;        len += 2;      &#125;      if (len &gt; maxLen) &#123;        maxLen = len;        start = left + 1;      &#125;    &#125;    return s.substr(start, maxLen);  &#125;&#125;;\n\n题解2当然这道题也可以用动态规划来做，只不过复杂度会高一点。1、状态定义：dp[left][right]表示区间范围[left,right]的子串是否是回文子串2、状态转移方程：在确定转移方程时，就要分析如下几种情况。整体上是两种，就是s[left]与s[right]相等和不相等两种情况。当s[left]与s[right]不相等，那没啥好说的了，dp[left][right]一定是false。当s[left]与s[right]相等时，这就复杂一些了，有如下三种情况:\n\n下标left与right相同，是同一个字符例如a，当然是回文子串\n下标left与right相差在2以内，例如aa或aba，也是回文子串\n下标left与right相差大于1的时候，例如cabac，此时s[left]与s[right]已经相同了，我们看left到right区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是left+1与right-1区间，这个区间是不是回文就看dp[left + 1][right - 1]是否为true。\n\n那么状态转移方程就是\nif ((s[left] == s[right]) &amp;&amp; (right - left &lt;= 2 || dp[left + 1][right - 1])) &#123;  dp[left][right] = true;&#125;\n另外一个要注意的是遍历顺序，外循环是右边界，内循环是左边界\nclass Solution &#123; public:  string longestPalindrome(string s) &#123;    int sLen = s.size();    if (sLen &lt; 2) &#123;      return s;    &#125;    int maxLen = 1, start = 0;    int dp[sLen][sLen];    memset(dp, 0, sizeof(dp));    for (int right = 1; right &lt; sLen; right++) &#123;      for (int left = 0; left &lt; right; left++) &#123;        if ((s[left] == s[right]) &amp;&amp;            (right - left &lt;= 2 || dp[left + 1][right - 1])) &#123;          dp[left][right] = true;          if (right - left + 1 &gt; maxLen) &#123;            maxLen = right - left + 1;            start = left;          &#125;        &#125;      &#125;    &#125;    return s.substr(start, maxLen);  &#125;&#125;;\n\n16、合并两个有序数组(简)题解1首先我们可以用双指针+额外存储空间来实现O(m + n)的时间复杂度。因为原有数组已经是从小到大排好序了，所以直接从后往前遍历。\nclass Solution &#123; public:  void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;    int p1 = m - 1, p2 = n - 1; // 双指针    int sorted[m + n];  // 额外存储空间    int cur;    while (p1 &gt;= 0 || p2 &gt;= 0) &#123;      if (p1 == -1) &#123;        // p1遍历到头时,记录nums2[p2]的值        cur = nums2[p2];        p2--;      &#125; else if (p2 == -1) &#123;        // p2遍历到头时,记录nums1[p1]的值        cur = nums1[p1];        p1--;      &#125; else if (nums1[p1] &gt; nums2[p2]) &#123;        // nums1[p1]&gt;nums2[p2]时,记录nums1[p1]的值        cur = nums1[p1];        p1--;      &#125; else &#123;        // nums1[p1]&lt;=nums2[p2]时,记录nums2[p2]的值        cur = nums2[p2];        p2--;      &#125;      // 向后更新sorted      sorted[p1 + p2 + 2] = cur;  // 从最后一个开始,m+n=p1+p2+2    &#125;    for (int i = 0; i &lt; m + n; ++i) &#123;      nums1[i] = sorted[i];    &#125;  &#125;&#125;;\n题解2首先题目里告诉了我们nums1.length&gt;=m+n，所以我们可以直接原地修改，把nums2放入nums1中，将空间复杂度降低到O(1)。建立三个指针，两个指针用于指向nums1和nums2的初始化元素数量的末位，也就是分别指向m-1和n-1的位置（设为p1，p2），还有一个指针，我们指向nums1数组m+n-1的位置即可（设为tail）。其余的跟上面一样\nclass Solution &#123; public:  void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;    int p1 = m - 1, p2 = n - 1;    int tail = m + n - 1;    int cur = 0;    while (p1 &gt;= 0 || p2 &gt;= 0) &#123;      if (p1 == -1) &#123;        // p1遍历到头时,记录nums2[p2]的值        cur = nums2[p2];        p2--;      &#125; else if (p2 == -1) &#123;        // p2遍历到头时,记录nums1[p1]的值        cur = nums1[p1];        p1--;      &#125; else if (nums1[p1] &gt; nums2[p2]) &#123;        // nums1[p1]&gt;nums2[p2]时,记录nums1[p1]的值        cur = nums1[p1];        p1--;      &#125; else &#123;        // nums1[p1]&lt;=nums2[p2]时,记录nums2[p2]的值        cur = nums2[p2];        p2--;      &#125;      // 向后更新nums1      nums1[tail] = cur;      tail--;    &#125;  &#125;&#125;;\n\n17、二叉树的最近公共祖先(中)题解这跟后序遍历类似，用递归是最好理解的1、如果当前结点root等于NULL，则直接返回NULL2、如果root等于p或q，直接返回p或q3、递归左右子树找左右结点的最近祖先，因为是递归，所以可以认为，使用函数后左右子树已经算出结果了（理解这句话很重要，递归的精髓），用left_parents和right_parents表示4、若left_parents为空，说明p和q在右子树，只要看right_parents即可；反之亦然5、若left_parents和right_parents都为空，说明p和q一边一个，所以root是最近的公共祖先\nclass Solution &#123; public:  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;    if (root == NULL)      return NULL;    if (root == p || root == q)      return root;    // 求左子树最近祖先    TreeNode* left_parents = lowestCommonAncestor(root-&gt;left, p, q);    // 求右子树最近祖先    TreeNode* right_parents = lowestCommonAncestor(root-&gt;right, p, q);    if (left_parents == NULL)      return right_parents;    if (right_parents == NULL)      return left_parents;    if (left_parents &amp;&amp; right_parents)  // p和q在两侧      return root;    return NULL;  // 必须有返回值  &#125;&#125;;\n\n18、二叉树的锯齿形层序遍历(中)题解有了5-4的二叉树层次遍历，直接对于偶数行进行反转即可\nclass Solution &#123; public:  vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;    vector&lt;vector&lt;int&gt;&gt; res;    queue&lt;TreeNode*&gt; q;    if (root != NULL) &#123;      q.push(root);    &#125;    bool flag = true;    while (!q.empty()) &#123;      int n = q.size();      vector&lt;int&gt; temp;      for (int i = 0; i &lt; n; i++) &#123;        TreeNode* node = q.front();        q.pop();        temp.push_back(node-&gt;val);        if (node-&gt;left != NULL) &#123;          q.push(node-&gt;left);        &#125;        if (node-&gt;right != NULL) &#123;          q.push(node-&gt;right);        &#125;      &#125;      if (!flag) &#123;        reverse(temp.begin(), temp.end());        flag = true;      &#125; else &#123;        flag = false;      &#125;      res.push_back(temp);    &#125;    return res;  &#125;&#125;;\n\n19、全排列(中)题解回溯法实际上是一个类似穷举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”（即回退），尝试别的路径。回溯法有“通用解题法”之称，它适合于解一些组合数较大的最优化问题。那回溯法和DFS有啥区别呢？回溯法以DFS的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。所以可以理解为，回溯算法 &#x3D; 树的深度优先搜索 + 剪枝函数那这道题用回溯法怎么解呢。这里维护两个数组，分别记录当前排列和每个数字的使用情况，之后枚举每个位置可能出现的数字。看下面这张图，应该就好理解了\nclass Solution &#123;  vector&lt;vector&lt;int&gt;&gt; ans;  vector&lt;int&gt; combine;  // 当前组合  vector&lt;bool&gt; used;    // 数字是否使用 public:  vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;    used = vector&lt;bool&gt;(nums.size());    dfs(nums, 0);    return ans;  &#125;  void dfs(vector&lt;int&gt;&amp; nums, int idx) &#123;    // idx为当前枚举的位置    if (idx == nums.size()) &#123;      // 遍历完数组中最后一个数字,把当前组合加入结果      ans.push_back(combine);      return;    &#125;    for (int i = 0; i &lt; nums.size(); i++) &#123;      if (!used[i]) &#123;        // 当前数字没有使用,加入组合        combine.push_back(nums[i]);        // 更新使用状态        used[i] = true;        // 继续搜索下一个位置        dfs(nums, idx + 1);        // 回退使用状态        used[i] = false;        // 把数字从当前组合中删除        combine.pop_back();      &#125;    &#125;  &#125;&#125;;\n\n19-2、全排列 II(中)题解这道题和19-1区别就在于数字是与重复的，那我们就需要在做回溯前先把已经枚举过的数字去重。有两种情况，1、数字已使用过；2、前后数字重复且前面数字已经使用过（这个我们就需要先对数组排序，让相同的数字都在一块）。其余的照搬19-1的回溯就ok了。\nclass Solution &#123;  vector&lt;vector&lt;int&gt;&gt; ans;  vector&lt;int&gt; combine;  // 当前组合  vector&lt;bool&gt; used;    // 数字是否使用 public:  vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;    sort(nums.begin(), nums.end());  // 先排个序,让重复的数字都在一块    used = vector&lt;bool&gt;(nums.size());    dfs(nums, 0);    return ans;  &#125;  void dfs(vector&lt;int&gt;&amp; nums, int idx) &#123;    // idx为当前枚举的位置    if (idx == nums.size()) &#123;      // 遍历完数组中最后一个数字,把当前组合加入结果      ans.push_back(combine);      return;    &#125;    unordered_set&lt;int&gt; s;    for (int i = 0; i &lt; nums.size(); i++) &#123;      if (used[i] || (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1])) &#123;        // 1、数字已使用过; 2、前后数字重复且前面数字已经使用过        continue;      &#125;      // 当前数字没有使用,加入组合      combine.push_back(nums[i]);      // 更新使用状态      used[i] = true;      // 继续搜索下一个位置      dfs(nums, idx + 1);      // 回退使用状态      used[i] = false;      // 把数字从当前组合中删除      combine.pop_back();    &#125;  &#125;&#125;;\n\n20、相交链表(简)题解直接看图更好理解，1、指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历；2、如果 pA 到了末尾，则 pA &#x3D; headB 继续遍历；3、如果 pB 到了末尾，则 pB &#x3D; headA 继续遍历；4、比较长的链表指针指向较短链表head时，长度差就消除了；5、如此，只需要将最短链表遍历两次，当 pA &#x3D; pB 时，即找到位置。\\\n\nclass Solution &#123; public:  ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) &#123;    if (headA == NULL || headB == NULL) &#123;      return NULL;    &#125;    ListNode *pA = headA, pB = headB;    while (pA != pB) &#123;      pA = (pA == NULL) ? headB : pA-&gt;next;      pB = (pB == NULL) ? headA : pB-&gt;next;    &#125;    return pA;  &#125;&#125;;\n\n21、螺旋矩阵(中)题解1、首先设定上下左右边界（上为0，下为行数，左为0，右为列数）；2、其次向右移动到最右，此时第一行因为已经使用过了，可以将其从图中删去，体现在代码中就是重新定义上边界；3、判断若重新定义后，上下边界交错，表明螺旋矩阵遍历结束，跳出循环，返回答案；4、若上下边界不交错，则遍历还未结束，接着向下向左向上移动，操作过程与第一，二步同理；5、不断循环以上步骤，直到某两条边界交错，跳出循环，返回答案。\nclass Solution &#123; public:  vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;    vector&lt;int&gt; ans;    if (matrix.empty())      return ans;   // 若数组为空,直接返回答案    int upper = 0;  // 赋值上下左右边界    int down = matrix.size() - 1;    int left = 0;    int right = matrix[0].size() - 1;    while (true) &#123;      for (int i = left; i &lt;= right; ++i)        ans.push_back(matrix[upper][i]);  // 向右移动直到最右      if (++upper &gt; down)        break;  // 先++,重新设定上边界;若上边界大于下边界,则遍历遍历完成,下同      for (int i = upper; i &lt;= down; ++i)        ans.push_back(matrix[i][right]);  // 向下      if (--right &lt; left)        break;  // 重新设定有边界      for (int i = right; i &gt;= left; --i)        ans.push_back(matrix[down][i]);  // 向左      if (--down &lt; upper)        break;  // 重新设定下边界      for (int i = down; i &gt;= upper; --i)        ans.push_back(matrix[i][left]);  // 向上      if (++left &gt; right)        break;  // 重新设定左边界    &#125;    return ans;  &#125;&#125;;\n\n22、字符串相加(简)题解可以使用双指针来模拟人工计算，步骤如下：1、创建指针i指向num1末位数字，j指向num2末位数字。2、i, j数字相加，进位就用add来记录进位值，无则为0。3、若产生进位，则当前数字为(i+j)%10的值。4、若遍历过程中，num1或num2当前已无数字，则用0补位来计算。\nclass Solution &#123; public:  string addStrings(string num1, string num2) &#123;    int i = num1.length() - 1, j = num2.length() - 1, add = 0;    string nums = &quot;&quot;;    while (i &gt;= 0 || j &gt;= 0 || add != 0) &#123;      int x = i &lt; 0 ? 0 : num1[i] - &#x27;0&#x27;;      int y = j &lt; 0 ? 0 : num2[j] - &#x27;0&#x27;;      int res = x + y + add;      nums.push_back(res % 10);      add = res / 10;      i--;      j--;    &#125;    return nums;  &#125;&#125;;\n\n23、最长递增子序列(中)题解动态规划四步走。1、$dp[i]$的定义$dp[i]$表示$nums$以$nums[i]$结尾的最长子序列长度2、状态转移方程设$j∈[0,i)$，考虑每轮计算新$dp[i]$时，遍历$[0,i)$列表区间，做以下判断：\n\n当$nums[i] &gt; nums[j]$时：$nums[i]$可以接在$nums[j]$之后（此题要求严格递增），此情况下最长上升子序列长度为$dp[j] + 1$；\n这种情况下计算出的$dp[j] + 1$的最大值，为直到$i$的最长上升子序列长度（即$dp[i]$）。实现方式为遍历$j$时，每轮执行$dp[i] &#x3D; max(dp[i], dp[j] + 1)$\n\n\n当$nums[i] &lt;&#x3D; nums[j]$时：$nums[i]$无法接在$nums[j]$之后，此情况上升子序列不成立，跳过。\n\n3、$dp[i]$的初始化$dp[i]$所有元素置1，含义是每个元素都至少可以单独成为子序列，此时长度都为14、$dp[i]$的返回值返回$dp$列表最大值，即可得到全局最长上升子序列长度\nclass Solution &#123; public:  int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();    int dp[n];    dp[0] = 1;    int maxLen = 1;    for (int i = 1; i &lt; n; i++) &#123;      dp[i] = 1;      for (int j = 0; j &lt; i; j++) &#123;        if (nums[j] &lt; nums[i]) &#123;          dp[i] = max(dp[i], dp[j] + 1);        &#125;      &#125;      maxLen = max(dp[i], maxLen);    &#125;    return maxLen;  &#125;&#125;;\n\n\n\n\n\n\n\n\n","categories":["算法交流"],"tags":["刷题笔记"]},{"title":"动态规划问题","url":"/1625968864.html","content":"一、最大子数组和（中）题目给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组 是数组中的一个连续部分。\n示例 1：输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n示例 2：输入：nums &#x3D; [1]输出：1\n示例 3：输入：nums &#x3D; [5,4,-1,7,8]输出：23\n提示：$1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5$$-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4$\n题解1依次遍历数组，记一个临时变量$temp &#x3D; 0$，$temp +&#x3D; nums[i]$，如果$temp &lt; 0$，说明到temp这个位置都是负数（不用管，因为我们要看最大和，负数肯定小于正数），所以直接让temp归0；如果$temp ≥ 0$，记录这时的最大和，同时记录flag（避免遍历玩数组全是负数），继续往下遍历；最后取记录的最大值。另外，如果数组全是负数，就直接取最大那个负数返回。\nclass Solution &#123; public:  int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;    int temp = 0;    int sum = 0;    bool flag = false;    for (int i = 0; i &lt; nums.size(); i++) &#123;      temp += nums[i];      if (temp &lt; 0) &#123;        temp = 0;      &#125; else &#123;        flag = true;        sum = max(temp, sum);      &#125;    &#125;    if (!flag) &#123;      auto maxPosition = max_element(nums.begin(), nums.end());      sum = *maxPosition;    &#125;    return sum;  &#125;&#125;;\n\n题解2动态规划四步走。1、状态定义：$dp[i]$表示$nums$以$nums[i]$结尾的连续子数组的最大和2、状态初始化：$dp[0]$根据定义，只有1个数，一定以$nums[0]$结尾，因此$dp[0] &#x3D; nums[0]$3、状态转移方程：根据状态的定义，由于$nums[i]$一定会被选取，并且以$nums[i]$结尾的连续子数组与以$nums[i - 1]$结尾的连续子数组只相差一个元素$nums[i]$。假设数组$nums$的值全都严格大于0，那么一定有$dp[i] &#x3D; dp[i - 1] + nums[i]$。可是$dp[i - 1]$有可能是负数，于是分类讨论：\n\n如果$dp[i - 1] &gt; 0$，那么可以把$nums[i]$直接接在$dp[i - 1]$表示的那个数组的后面，得到和更大的连续子数组；\n如果$dp[i - 1] &lt;&#x3D; 0$，那么$nums[i]$加上前面的数$dp[i - 1]$以后值不会变大。于是$dp[i]$另起炉灶，此时单独的一个$nums[i]$的值，就是$dp[i]$。\n\n以上两种情况的最大值就是$dp[i]$的值，写出如下状态转移方程：$$dp[i]&#x3D;\\left{\\begin{array}{lll}dp[i-1]+nums[i], &amp; \\text { if } &amp; dp[i-1]&gt;0 \\nums[i], &amp; \\text { if } &amp; dp[i-1] \\leq 0\\end{array}\\right.$$\n4、状态返回值这个问题的输出是把所有的$dp[0]、dp[1]、……、dp[n - 1]$都看一遍，取最大值\nclass Solution &#123; public:  int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();    int dp[n];    dp[0] = nums[0];    for (int i = 1; i &lt; n; i++) &#123;      if (dp[i - 1] &gt;= 0) &#123;        dp[i] = dp[i - 1] + nums[i];      &#125; else &#123;        dp[i] = nums[i];      &#125;    &#125;    auto maxSum = max_element(dp, dp + n);    return *maxSum;  &#125;&#125;;\n\n二、买卖股票的最佳时机（简）题目给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n示例 1：输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n示例 2：输入：prices &#x3D; [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。\n提示：$1 &lt;&#x3D; prices.length &lt;&#x3D; 10^5$$0 &lt;&#x3D; prices[i] &lt;&#x3D; 10^4$\n题解1用一个变量记录一个最低价格$minPrice$，在第i天卖出股票能得到的利润就是$prices[i]-minPrice$我们只需要遍历一遍价格数组，求出每一天卖出股票得到的利润，取最大值$maxProfit$，同时更新最低价格$minPrice$\nclass Solution &#123;public:  int maxProfit(vector&lt;int&gt;&amp; prices) &#123;    int minPrice = INT_MAX;    int maxProfit = 0;    for (auto price : prices) &#123;      maxProfit = max(maxProfit, price - minPrice);      minPrice = min(minPrice, price);    &#125;    return maxProfit;  &#125;&#125;;\n题解2这道题是最基础的动态规划，下面讲下证明用动态规划解决。题目只问最大利润，没有问这几天具体哪一天买、哪一天卖，因此可以考虑使用动态规划的方法来解决。根据题目意思，有以下两个约束条件：1、不能在买入股票前卖出股票；2、最多只允许完成一笔交易。首先先定义好现金数这个概念，买入股票手上的现金数减少，卖出股票手上的现金数增加。对于这道题，当天是否持股会影响现金数，因为持股表示你还没卖掉，不持股表示卖掉了。所以动态规划的状态需要用到二维数组表示，一方面表示第几天，一方面表示是否持股。动态规划四步走如下。1、状态定义：\n\n$dp[i][0]$表示第i天，不持股，手上拥有的现金数\n$dp[i][1]$表示第i天，持股，手上拥有的现金数\n\n2、状态初始化：第1天，$dp[0][0] &#x3D; 0$，$dp[0][1] &#x3D; -prices[0]$3、状态转移方程：第i天，对于$dp[i][0]$，有两种情况\n\n昨天不持股，今天什么都不做\n昨天持股，今天卖出股票（现金数增加）\n\n因此$dp[i][0] &#x3D; max(dp[i-1][0], dp[i-1][1]+prices[i])$同样对于$dp[i][1]$，也有两种情况\n\n昨天持股，今天什么都不做（现金数与昨天一样）\n昨天不持股，今天买入股票（注意：只允许交易一次，因此手上的现金数就是当天的股价的相反数）\n\n因此$dp[i][1] &#x3D; max(dp[i-1][1], -prices[i])$4、状态返回值遍历到最后一天，不持股状态下就是利润最大化的输出，即$dp[n - 1][0]$\nclass Solution &#123; public:  int maxProfit(vector&lt;int&gt;&amp; prices) &#123;    int n = prices.size();    if (n &lt; 2) &#123;      return 0;    &#125;    // vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2));    // 数据量大尽量用数组,vector操作太耗时    int dp[n][2];    // dp[i][0],下标为i这天结束的时候,不持股,手上拥有的现金数    // dp[i][1],下标为i这天结束的时候,持股,手上拥有的现金数    // 初始化:不持股显然为0,持股就需要减去第1天(下标为0)的股价    dp[0][0] = 0;    dp[0][1] = -prices[0];    // 从第2天开始遍历    for (int i = 1; i &lt; n; i++) &#123;      dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);      dp[i][1] = max(dp[i - 1][1], -prices[i]);    &#125;    return dp[n - 1][0];  &#125;&#125;;\n\n三、买卖股票的最佳时机 II（中）题目给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。返回 你能获得的 最大 利润 。\n示例 1：输入：prices &#x3D; [7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6 - 3 &#x3D; 3 。总利润为 4 + 3 &#x3D; 7 。\n示例 2：输入：prices &#x3D; [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。总利润为 4 。\n示例 3：输入：prices &#x3D; [7,6,4,3,1]输出：0解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。\n提示：$1 &lt;&#x3D; prices.length &lt;&#x3D; 3 * 10^4$$0 &lt;&#x3D; prices[i] &lt;&#x3D; 10^4$\n题解和上一题一样，状态定义不变，只不过状态方程有点变化。动态规划四步走如下。1、状态定义：\n\n$dp[i][0]$表示第i天，不持股，手上拥有的现金数\n$dp[i][1]$表示第i天，持股，手上拥有的现金数\n\n2、状态初始化：第1天，$dp[0][0] &#x3D; 0$，$dp[0][1] &#x3D; -prices[0]$\n3、状态转移方程：第i天，对于$dp[i][0]$，有两种情况\n\n昨天不持股，今天什么都不做\n昨天持股，今天卖出股票（现金数增加）\n\n因此$dp[i][0] &#x3D; max(dp[i-1][0], dp[i-1][1]+prices[i])$同样对于$dp[i][1]$，也有两种情况\n\n昨天持股，今天什么都不做（现金数与昨天一样）\n昨天不持股，即$dp[i-1][0]$，今天买入股票（注意：允许交易多次，因此手上的现金数就是$dp[i-1][0]-prices[i]$）\n\n因此$dp[i][1] &#x3D; max(dp[i-1][1], dp[i-1][0]-prices[i])$。4、状态返回值遍历到最后一天，不持股状态下就是利润最大化的输出，即$dp[n - 1][0]$\nclass Solution &#123; public:  int maxProfit(vector&lt;int&gt;&amp; prices) &#123;    int n = prices.size();    if (n &lt; 2) &#123;      return 0;    &#125;    int dp[n][2];    dp[0][0] = 0;    dp[0][1] = -prices[0];    // 从第2天开始遍历    for (int i = 1; i &lt; n; i++) &#123;      dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);      dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);    &#125;    return dp[n - 1][0];  &#125;&#125;;\n\n四、买卖股票的最佳时机 III（困）题目给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n示例 1:输入：prices &#x3D; [3,3,5,0,0,3,1,4]输出：6解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。\n示例 2：输入：prices &#x3D; [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。  注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。  因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n示例 3：输入：prices &#x3D; [7,6,4,3,1]输出：0解释：在这个情况下, 没有交易完成, 所以最大利润为 0。\n示例 4：输入：prices &#x3D; [1]输出：0\n提示：$1 &lt;&#x3D; prices.length &lt;&#x3D; 10^5$$0 &lt;&#x3D; prices[i] &lt;&#x3D; 10^5$\n题解分析步骤参照第二题，但这道题状态比第二题多。一天结束时，可能有持股、可能未持股、可能卖出过1次、可能卖出过2次、也可能未卖出过所以定义状态转移数组dp[天数][当前是否持股][卖出的次数]动态规划四步走如下。1、状态定义：\n\n$dp[i][0][0]$表示第i天，不持股，不卖出过股票，手上拥有的现金数\n$dp[i][0][1]$表示第i天，不持股，卖出1次股票，手上拥有的现金数\n$dp[i][0][2]$表示第i天，不持股，卖出2次股票，手上拥有的现金数\n$dp[i][1][0]$表示第i天，持股，不卖出过股票，手上拥有的现金数\n$dp[i][1][1]$表示第i天，持股，卖出1次股票，手上拥有的现金数\n$dp[i][1][2]$表示第i天，持股，卖出2次股票，手上拥有的现金数\n\n2、状态初始化：第1天有，\n\n第1天休息：$dp[0][0][0] &#x3D; 0$\n第1天买入：$dp[0][1][0] &#x3D; -prices[0]$\n第1天不可能已经有卖出：$dp[0][0][1] &#x3D; float(‘-inf’)$、$dp[0][0][2] &#x3D; float(‘-inf’)$\n第一天不可能已经卖出：$dp[0][1][1] &#x3D; float(‘-inf’)$、$dp[0][1][2] &#x3D; float(‘-inf’)$\n\n3、状态转移方程：第i天有，\n\n对于$dp[i][0][0]$，有一种情况，未持股，未卖出过，说明从未进行过买卖。因此$dp[i][0][0] &#x3D; 0$\n对于$dp[i][0][1]$，有两种情况，未持股，卖出过1次，可能是之前卖的，可能是今天卖的。因此$dp[i][0][1]&#x3D;max(dp[i-1][0][1], dp[i-1][1][0]+prices[i])$\n对于$dp[i][0][2]$，有两种情况，未持股，卖出过2次，可能是之前卖的，可能是今天卖的。因此$dp[i][0][2]&#x3D;max(dp[i-1][0][2], dp[i-1][1][1]+prices[i])$\n对于$dp[i][1][0]$，有两种情况，持股，未卖出过，可能是之前买的，可能是今天买的。因此$dp[i][0][1]&#x3D;max(dp[i-1][1][0], dp[i-1][0][0]-prices[i])$\n对于$dp[i][1][1]$，有两种情况，持股，卖出过1次，可能是之前买的，可能是今天买的。因此$dp[i][0][1]&#x3D;max(dp[i-1][1][1], dp[i-1][0][1]-prices[i])$\n对于$dp[i][1][2]$，有一种情况，持股，卖出过2次，不可能（因为最多只允许买卖两次）。因此$dp[i][1][2]&#x3D;float(‘-inf’)$\n\n4、状态返回值遍历到最后一天，不持股状态下取卖出1次和卖出2次的最大值，即$max(max(dp[n - 1][0][1], dp[n - 1][0][2]), 0)$\nclass Solution &#123; public:  int maxProfit(vector&lt;int&gt;&amp; prices) &#123;    int n = prices.size();    if (n &lt; 2) &#123;      return 0;    &#125;    int MIN_VALUE = INT_MIN / 2;    // 这里除2是因为最小值加上1就变成最大值了,会影响max()函数的结果,除数只要比1大就行    int dp[n][2][3];    dp[0][0][0] = 0;           // 第一天休息    dp[0][1][0] = -prices[0];  // 第一天买入    dp[0][0][1] = MIN_VALUE;   // 第一天不可能已经有卖出    dp[0][0][2] = MIN_VALUE;   // 第一天不可能已经卖出    dp[0][1][1] = MIN_VALUE;    dp[0][1][2] = MIN_VALUE;    // 从第2天开始遍历    for (int i = 1; i &lt; n; i++) &#123;      dp[i][0][0] = 0;  // 未持股，未卖出过      dp[i][0][1] = max(dp[i - 1][1][0] + prices[i],                        dp[i - 1][0][1]);  // 未持股，卖出过1次      dp[i][0][2] = max(dp[i - 1][1][1] + prices[i],                        dp[i - 1][0][2]);  // 未持股，卖出过2次      dp[i][1][0] =          max(dp[i - 1][0][0] - prices[i], dp[i - 1][1][0]);  // 持股，未卖出过      dp[i][1][1] =          max(dp[i - 1][0][1] - prices[i], dp[i - 1][1][1]);  // 持股，卖出过1次      dp[i][1][2] = MIN_VALUE;  // 持股，卖出过2次    &#125;    return max(max(dp[n - 1][0][1], dp[n - 1][0][2]), 0);  &#125;&#125;;\n\n五、最长回文子串（中）题目给你一个字符串 s，找到 s 中最长的回文子串。如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。\n示例 1：输入：s &#x3D; “babad”输出：”bab”解释：”aba” 同样是符合题意的答案。\n示例 2：输入：s &#x3D; “cbbd”输出：”bb”\n提示：1 &lt;&#x3D; s.length &lt;&#x3D; 1000s 仅由数字和英文字母组成\n题解1对于一个子串而言，如果它是回文串，并且长度大于2，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串“ababa”，如果我们已经知道“bab” 是回文串，那么“ababa” 一定是回文串，这是因为它的首尾两个字母都是“a”。因此，如果$dp[left][right]$是回文，我们要判断$dp[left-1][right+1]$是否为回文。只需要判断字符串在$left-1$和$right+1$两个位置是否为相同的字符，就能减少了很多重复计算。动态规划四步走如下。1、状态定义：$dp[left][right]$表示区间范围$[left,right]$的子串是否是回文子串2、状态初始化：根据定义，所有长度为1的子串都是回文串，即\nfor (int i = 0; i &lt; sLen; i++) &#123;  dp[i][i] = true;&#125;\n3、状态转移方程：在确定转移方程时，就要分析如下几种情况。整体上是两种，就是$s[left]$与$s[right]$相等和不相等两种情况。当$s[left]$与$s[right]$不相等，那没啥好说的了，$dp[left][right]$一定是false。当$s[left]$与$s[right]$相等时，这就复杂一些了，有如下三种情况:\n\n下标$left$与$right$相同，是同一个字符，例如a，当然是回文子串\n下标$left$与$right$相差在2以内，例如aa或aba，也是回文子串\n下标$left$与$right$相差大于2的时候，例如cabac，此时$s[left]$与$s[right]$已经相同了，我们看$[left,right]$区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是$[left+1,right-1]$区间，这个区间是不是回文就看$dp[left + 1][right - 1]$是否为true。\n\n那么状态转移方程就是\nif ((s[left] == s[right]) &amp;&amp; (right - left &lt;= 2 || dp[left + 1][right - 1])) &#123;  dp[left][right] = true;&#125;\n4、状态返回值判断$dp[left][right]$是否为回文，是就记录回文长度和起始位置，根据这俩就能输出最长回文子串\nclass Solution &#123; public:  string longestPalindrome(string s) &#123;    int sLen = s.size();    if (sLen &lt; 2) &#123;      return s;    &#125;    int maxLen = 1, start = 0;    int dp[sLen][sLen];    for (int i = 0; i &lt; sLen; i++) &#123;      // 初始化,所有长度为1的子串都是回文串      dp[i][i] = true;    &#125;    for (int subLen = 2; subLen &lt;= sLen; subLen++) &#123;      for (int left = 0; left &lt; sLen; left++) &#123;        int right = subLen + left - 1;  // // 由subLen和left可以确定右边界        if (right &gt;= sLen) &#123;          // 如果右边界越界,就可以退出当前循环          break;        &#125;        if ((s[left] == s[right]) &amp;&amp;            (right - left &lt;= 2 || dp[left + 1][right - 1])) &#123;          dp[left][right] = true;        &#125; else &#123;          dp[left][right] = false;        &#125;        if (dp[left][right] &amp;&amp; right - left + 1 &gt; maxLen) &#123;          maxLen = right - left + 1;          start = left;        &#125;      &#125;    &#125;    return s.substr(start, maxLen);  &#125;&#125;;\n\n题解2因为回文串是对称的，这道题推荐用中心扩散法。顾名思义，从每一个位置出发，向两边扩散，遇到不是回文的时候结束。所以可以对每个字符进行扩散，以字符为中心点，$left$为中心点-1，$right$为中心点+1，有三种情况：1、$left$没有超出左边界同时与中心点相等，继续向左扩展2、$right$没有超出右边界同时与中心点相等，继续向右扩展3、$left$和$right$都没超出边界，且$left$的字符等于$right$的字符，两边同时扩散另外，题目要输出的是子串，所以要记录$left$的位置和最大长度\nclass Solution &#123; public:  string longestPalindrome(string s) &#123;    int sLen = s.size();    if (sLen == 0) &#123;      return &quot;&quot;;    &#125;    int left = 0, right = 0, maxLen = 0, start = 0;    for (int i = 0; i &lt; sLen; i++) &#123;      int len = 1;      left = i - 1;   // 取中心点左边      right = i + 1;  // 取中心点右边      while (left &gt;= 0 &amp;&amp; s[left] == s[i]) &#123;        // 没有超过左边界同时与中心点相等,继续向左扩展        left--;        len++;      &#125;      while (right &lt; sLen &amp;&amp; s[right] == s[i]) &#123;        // 没有超过右边界同时与中心点相等,继续向右扩展        right++;        len++;      &#125;      while (left &gt;= 0 &amp;&amp; right &lt; sLen &amp;&amp; s[left] == s[right]) &#123;        // 没有超过边界同时左右点都与中心点相等,两边都扩展        // 这里要注意, 在最后一次循环中left还是做了        // -1操作,实际上子串不包含这个位置, 所以下面start=left+1        left--;        right++;        len += 2;      &#125;      if (len &gt; maxLen) &#123;        maxLen = len;        start = left + 1;      &#125;    &#125;    return s.substr(start, maxLen);  &#125;&#125;;\n\n六、最长递增子序列（中）题目给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n示例 1：输入：$nums &#x3D; [10,9,2,5,3,7,101,18]$输出：4解释：最长递增子序列是$[2,3,7,101]$，因此长度为 4 。\n示例 2：输入：$nums &#x3D; [0,1,0,3,2,3]$输出：4\n示例 3：输入：$nums &#x3D; [7,7,7,7,7,7,7]$输出：1\n提示：$1 &lt;&#x3D; nums.length &lt;&#x3D; 2500$$-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4$\n题解动态规划四步走如下：1、状态定义：$dp[i]$表示$nums$中以$nums[i]$结尾的最长子序列长度2、状态初始化：$dp[i]$所有元素置1，含义是每个元素都至少可以单独成为子序列，此时长度都为13、状态转移方程：设$j∈[0,i)$，考虑每轮计算新$dp[i]$时，遍历$[0,i)$列表区间，做以下判断：\n\n当$nums[i] &gt; nums[j]$时：$nums[i]$可以接在$nums[j]$之后（此题要求严格递增），此情况下最长上升子序列长度为$dp[j] + 1$；\n这种情况下计算出的$dp[j] + 1$的最大值，为直到$i$的最长上升子序列长度（即$dp[i]$）；\n实现方式为遍历$j$时，每轮执行$dp[i] &#x3D; max(dp[i], dp[j] + 1)$\n\n\n当$nums[i] &lt;&#x3D; nums[j]$时：$nums[i]$无法接在$nums[j]$之后，此情况上升子序列不成立，跳过。\n\n4、状态返回值返回$dp$列表最大值，即可得到全局最长上升子序列长度\nclass Solution &#123; public:  int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();    int dp[n];    dp[0] = 1;    int maxLen = 1;    for (int i = 1; i &lt; n; i++) &#123;      dp[i] = 1;      for (int j = 0; j &lt; i; j++) &#123;        if (nums[j] &lt; nums[i]) &#123;          dp[i] = max(dp[i], dp[j] + 1);        &#125;      &#125;      maxLen = max(dp[i], maxLen);    &#125;    return maxLen;  &#125;&#125;;\n\n七、最长公共子序列（中）题目给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。\n示例 1：输入：text1 &#x3D; “abcde”, text2 &#x3D; “ace”输出：3解释：最长公共子序列是 “ace” ，它的长度为 3 。\n示例 2：输入：text1 &#x3D; “abc”, text2 &#x3D; “abc”输出：3解释：最长公共子序列是 “abc” ，它的长度为 3 。\n示例 3：输入：text1 &#x3D; “abc”, text2 &#x3D; “def”输出：0解释：两个字符串没有公共子序列，返回 0 。\n提示：1 &lt;&#x3D; text1.length, text2.length &lt;&#x3D; 1000text1 和 text2 仅由小写英文字符组成。\n题解动态规划四步走如下：1、状态定义：$dp[i][j]$表示$text1[0:i]$和$text2[0:j]$的最长公共子序列的长度。2、状态初始化：初始化就是要看当$i&#x3D;0$与$j&#x3D;0$时，$dp[i][j]$应该取值为多少。很显然，当$text1$或$text2$为空时，它们的最长公共子序列长度为0。所以，当$i&#x3D;0$或$j&#x3D;0$时，$dp[i][j]$初始化为0。3、状态转移方程：\n\n当$text1[i-1]&#x3D;text2[j-1]$时，说明两个子字符串的最后一位相等，所以最长公共子序列增加1，即$dp[i][j]&#x3D;dp[i-1][j-1]+1$；\n当$text1[i-1]!&#x3D;text2[j-1]$时，说明两个子字符串的最后一位不相等，那么此时的状态$dp[i][j]$应该是$dp[i-1][j]$和$dp[i][j-1]$中的较大值；\n比如对于$ace$和$bc$而言，他们的最长公共子序列的长度等于①$ace$和$b$的最长公共子序列长度0与②$ac$和$bc$的最长公共子序列长度1的最大值，即1。\n\n\n\n4、状态返回值返回$dp[s1][s2]$，即$text1$和$text2$的最长公共子序列长度\nclass Solution &#123; public:  int longestCommonSubsequence(string text1, string text2) &#123;    int s1 = text1.size();    int s2 = text2.size()    int dp[s1 + 1][s2 + 1];    // 初始化    for (int i = 0; i &lt;= s1; i++) &#123;      for (int j = 0; j &lt;= s2; j++) &#123;        dp[i][j] = 0;      &#125;    &#125;    // 状态转移方程    for (int i = 1; i &lt;= s1; i++) &#123;      for (int j = 1; j &lt;= s2; j++) &#123;        if (text1[i - 1] == text2[j - 1]) &#123;          dp[i][j] = dp[i - 1][j - 1] + 1;        &#125; else &#123;          dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);        &#125;      &#125;    &#125;    return dp[s1][s2];  &#125;&#125;;\n","categories":["算法交流"],"tags":["刷题笔记"]},{"title":"动态规划","url":"/2819424305.html","content":"一、概念动态规划（Dynamic programming，简称 DP），是通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。换句话说，就是给定一个问题，我们把它拆成一个个子问题，直到子问题可以直接解决。然后呢，把子问题答案保存起来，以减少重复计算。再根据子问题答案反推，得出原问题解的一种方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题。\n二、核心思想动态规划最核心的思想，就在于拆分子问题，记住过往，减少重复计算。来看一道经典DP问题『青蛙跳台阶』，从这道题就能体会到DP的思想。\n\n一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。\n\n可以这么理解，假设跳到第n级台阶的跳数我们定义为$f(n)$。要跳到第10级台阶，要么是先跳到第9级，然后再跳1级台阶上去；要么是先跳到第8级，然后一次迈2级台阶上去。所以$f(10) &#x3D;  f(9) + f(8)$。同理，要跳到第9级台阶，要么是先跳到第8级，然后再跳1级台阶上去；要么是先跳到第7级，然后一次迈2级台阶上去。所以$f(9) &#x3D;  f(8) + f(7)$。依次类推到最后，$f(3) &#x3D; f(2) + f(1)$。至于$f(2)$，要么直接跳两级，要么一级一级跳，所以$f(2) &#x3D; 2$；而$f(1)$只有一种跳法。看到这里，是不是可以用递归解决，因为$f(n) &#x3D; f(n-1) + f(n-2)$，代码如下\nclass Solution &#123; public:  int numWays(int n) &#123;    if (n &lt;= 2) &#123;      return n;    &#125;    return numWays(n - 1) + numWays(n - 2);  &#125;&#125;;\n\n有没有发现，这其实就是个斐波那契，所以用递归计算时间复杂度是 $O(2^{n})$ （具体时间复杂度计算可以看我另一篇文章）回过头来，你仔细观察这颗递归树，你会发现存在大量重复计算，比如$f(10) &#x3D;  f(9) + f(8)$和$f(9) &#x3D;  f(8) + f(7)$，这里$f(8)$被计算了两次。所以这个递归算法低效的原因，就是存在大量的重复计算！既然存在大量重复计算，那么我们可以先把计算好的答案存下来，等到下次需要的话，先去记录里查一下，有就直接取，没有再计算，就可以省去重新重复计算的耗时。一般使用一个数组或者一个哈希$map$充当这个备忘录。解法如下（很可惜，超时了）：\nclass Solution &#123; public:  int numWays(int n) &#123;    unordered_map&lt;int, int&gt; tempMap;    // n = 0 也算1种    if (n == 0) &#123;      return 1;    &#125;    if (n &lt;= 2) &#123;      return n;    &#125;    // 先判断有没计算过,即看看备忘录有没有    if (tempMap.find(n) != tempMap.end()) &#123;      // 备忘录有,即计算过,直接返回      return tempMap[n];    &#125; else &#123;      // 备忘录没有,即没有计算过,执行递归计算,并且把结果保存到备忘录map中,对1000000007取余(这个是leetcode题目规定的)      tempMap.insert(pair&lt;int, int&gt;(n, (numWays(n - 1) + numWays(n - 2)) % 1000000007));      return tempMap[n];    &#125;  &#125;&#125;;\n\n那这种解法跟动态规划有啥关系呢？动态规划跟带备忘录的递归解法基本思想是一致的，都是减少重复计算，时间复杂度也都是差不多。但是有两点不一样：\n\n带备忘录的递归，是从$f(10)$往$f(1)$方向延伸求解的，所以也称为自顶向下的解法\n动态规划从较小问题的解，由交叠性质，逐步决策出较大问题的解，它是从$f(1)$往$f(10)$方向，往上推求解，所以称为自底向上的解法\n\n动态规划有几个典型特征，最优子结构、状态转移方程、边界、重叠子问题。在青蛙跳阶问题中：\n\n$f(n-1)$和$f(n-2)$称为$f(n)$的最优子结构\n$f(n)&#x3D; f(n-1) + f(n-2)$就称为状态转移方程\n$f(1) &#x3D; 1$，$f(2) &#x3D; 2$就是边界\n比如$f(10) &#x3D; f(9) + f(8)$和$f(9) &#x3D; f(8) + f(7)$中，$f(8)$就是重叠子问题\n\n代码如下：\nclass Solution &#123; public:  int numWays(int n) &#123;    if (n == 0) &#123;      return 1;    &#125;    if (n &lt;= 2) &#123;      return n;    &#125;    int dp[n + 1];    dp[1] = 1;    dp[2] = 2;    for (int i = 3; i &lt; n + 1; i++) &#123;      dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;    &#125;    return dp[n];  &#125;&#125;;\n\n三、解题思路动态规划的核心思想就是拆分子问题，记住过往，减少重复计算。 并且动态规划一般都是自底向上的，基于青蛙跳阶问题，我总结了一下我做动态规划的思路。\n\n穷举分析\n确定边界\n找出规律，确定最优子结构\n写出状态转移方程\n\n穷举分析\n当台阶数是1的时候，有一种跳法，$f(1) &#x3D;1$\n当只有2级台阶时，有两种跳法，第一种是直接跳两级，第二种是先跳一级，然后再跳一级。即$f(2) &#x3D; 2$;\n当台阶是3级时，想跳到第3级台阶，要么是先跳到第2级，然后再跳1级台阶上去，要么是先跳到第 1级，然后一次迈 2 级台阶上去。所以$f(3) &#x3D; f(2) + f(1) &#x3D; 3$\n当台阶是4级时，依次类推\n\n确定边界通过穷举分析，我们发现，当台阶数是1的时候或者2的时候，可以明确知道青蛙跳法。$f(1) &#x3D; 1, f(2) &#x3D; 2$，当台阶$n&gt;&#x3D;3$时，已经呈现出规律$f(3) &#x3D; f(2) + f(1) &#x3D; 3$，因此$f(1) &#x3D; 1, f(2) &#x3D; 2$就是青蛙跳阶的边界。\n找规律，确定最优子结构$n&gt;&#x3D;3$时，已经呈现出规律$f(n)&#x3D; f(n-1) + f(n-2)$ ，因此，$f(n-1)$和$f(n-2)$称为$f(n)$的最优子结构。什么是最优子结构？有这么一个解释\n\n一道动态规划问题，其实就是一个递推问题。假设当前决策结果是$f(n)$，则最优子结构就是要让$f(n-k)$最优，最优子结构性质就是能让转移到n的状态是最优的，并且与后面的决策没有关系，即让后面的决策安心地使用前面的局部最优解的一种性质。\n\n写出状态转移方程通过前面3步，穷举分析，确定边界，最优子结构，我们就可以得出状态转移方程：$$ f(n)&#x3D;\\left{\\begin{aligned}1, \\quad \\quad n&#x3D;1 \\2, \\quad \\quad n&#x3D;2 \\f(n-1)+f(n-2), n&gt;&#x3D; 3\\end{aligned}\\right.$$\n代码实现实现代码的时候，一般注意从底往上遍历，然后关注下边界情况，空间复杂度。动态规划有个大概框架\ndp[0][0][...] = 边界值 for (状态1 ：所有状态1的值) &#123;  for (状态2 ：所有状态2的值) &#123;    for (...) &#123;      //状态转移方程      dp[状态1][状态2][...] = 求最值    &#125;  &#125;&#125;\n","categories":["算法交流"],"tags":["常见算法"]},{"title":"双指针问题","url":"/2727742723.html","content":"前言双指针具体就是用两个变量动态存储两个结点，来方便我们进行一些操作。通常用在线性的数据结构中。特别是链表类的题目，经常需要用到两个或多个指针配合来记忆链表上的节点，完成某些操作。\n一、合并两个有序数组（简）题目给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。\n示例 1：输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3输出：[1,2,2,3,5,6]解释：需要合并 [1,2,3] 和 [2,5,6] 。合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。\n示例 2：输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0输出：[1]解释：需要合并 [1] 和 [] 。合并结果是 [1] 。\n示例 3：输入：nums1 &#x3D; [0], m &#x3D; 0, nums2 &#x3D; [1], n &#x3D; 1输出：[1]解释：需要合并的数组是 [] 和 [1] 。合并结果是 [1] 。注意，因为 m &#x3D; 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。\n提示：nums1.length &#x3D;&#x3D; m + nnums2.length &#x3D;&#x3D; n0 &lt;&#x3D; m, n &lt;&#x3D; 2001 &lt;&#x3D; m + n &lt;&#x3D; 200-10^9 &lt;&#x3D; nums1[i], nums2[j] &lt;&#x3D; 10^9\n题解1首先我们可以用双指针+额外存储空间来实现O(m + n)的时间复杂度。因为原有数组已经是从小到大排好序了，所以直接从后往前遍历。\nclass Solution &#123; public:  void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;    int p1 = m - 1, p2 = n - 1; // 双指针    int sorted[m + n];  // 额外存储空间    int cur;    while (p1 &gt;= 0 || p2 &gt;= 0) &#123;      if (p1 == -1) &#123;        // p1遍历到头时,记录nums2[p2]的值        cur = nums2[p2];        p2--;      &#125; else if (p2 == -1) &#123;        // p2遍历到头时,记录nums1[p1]的值        cur = nums1[p1];        p1--;      &#125; else if (nums1[p1] &gt; nums2[p2]) &#123;        // nums1[p1]&gt;nums2[p2]时,记录nums1[p1]的值        cur = nums1[p1];        p1--;      &#125; else &#123;        // nums1[p1]&lt;=nums2[p2]时,记录nums2[p2]的值        cur = nums2[p2];        p2--;      &#125;      // 向后更新sorted      sorted[p1 + p2 + 2] = cur;  // 从最后一个开始,m+n=p1+p2+2    &#125;    for (int i = 0; i &lt; m + n; ++i) &#123;      nums1[i] = sorted[i];    &#125;  &#125;&#125;;\n题解2首先题目里告诉了我们nums1.length &gt;= m+n，所以我们可以直接原地修改，把nums2放入nums1中，将空间复杂度降低到O(1)。建立三个指针，两个指针用于指向nums1和nums2的初始化元素数量的末位，也就是分别指向m-1和n-1的位置（设为p1，p2），还有一个指针，我们指向nums1数组m+n-1的位置即可（设为tail）。其余的跟上面一样\nclass Solution &#123; public:  void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;    int p1 = m - 1, p2 = n - 1;    int tail = m + n - 1;    int cur = 0;    while (p1 &gt;= 0 || p2 &gt;= 0) &#123;      if (p1 == -1) &#123;        // p1遍历到头时,记录nums2[p2]的值        cur = nums2[p2];        p2--;      &#125; else if (p2 == -1) &#123;        // p2遍历到头时,记录nums1[p1]的值        cur = nums1[p1];        p1--;      &#125; else if (nums1[p1] &gt; nums2[p2]) &#123;        // nums1[p1]&gt;nums2[p2]时,记录nums1[p1]的值        cur = nums1[p1];        p1--;      &#125; else &#123;        // nums1[p1]&lt;=nums2[p2]时,记录nums2[p2]的值        cur = nums2[p2];        p2--;      &#125;      // 向后更新nums1      nums1[tail] = cur;      tail--;    &#125;  &#125;&#125;;\n\n二、字符串相加（简）题目给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。\n示例 1：输入：num1 &#x3D; “11”, num2 &#x3D; “123”输出：”134”\n示例 2：输入：num1 &#x3D; “456”, num2 &#x3D; “77”输出：”533”\n示例 3：输入：num1 &#x3D; “0”, num2 &#x3D; “0”输出：”0”\n提示：1 &lt;&#x3D; num1.length, num2.length &lt;&#x3D; $10^4$num1 和num2 都只包含数字 0-9num1 和num2 都不包含任何前导零\n题解可以使用双指针来模拟人工计算，步骤如下：1、创建指针p1指向num1末位数字，p2指向num2末位数字。2、p1、p2数字相加，进位就用add来记录进位值，无则为0。3、若产生进位，则当前数字为(p1+p2)%10的值。4、若遍历过程中，num1或num2当前已无数字，则用0补位来计算。\nclass Solution &#123; public:  string addStrings(string num1, string num2) &#123;    int p1 = num1.length() - 1, p2 = num2.length() - 1, add = 0;    string nums = &quot;&quot;;    while (p1 &gt;= 0 || j &gt;= 0 || add != 0) &#123;      int x = p1 &lt; 0 ? 0 : num1[p1] - &#x27;0&#x27;;      int y = p2 &lt; 0 ? 0 : num2[p2] - &#x27;0&#x27;;      int res = x + y + add;      nums.push_back(res % 10);      add = res / 10;      p1--;      p2--;    &#125;    return nums;  &#125;&#125;;\n\n三、删除链表的倒数第N个结点（中）题目给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n示例 1：\ngraph LR\n    1 --> 2\n    2 --> 3\n    3 --> 4\n    4 --> 5\n—&gt;\ngraph LR\n    1 --> 2\n    2 --> 3\n    3 --> 5\n输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2输出：[1,2,3,5]\n示例 2：输入：head &#x3D; [1], n &#x3D; 1输出：[]\n示例 3：输入：head &#x3D; [1,2], n &#x3D; 1输出：[1]\n提示：链表中结点的数目为 sz1 &lt;&#x3D; sz &lt;&#x3D; 300 &lt;&#x3D; Node.val &lt;&#x3D; 1001 &lt;&#x3D; n &lt;&#x3D; sz\n题解很简单，可以设想双指针slow和fast，fast先移动，使其和slow间隔n；然后两者同时移动，当fast指向末尾的NULL时，那么slow-&gt;next就是要删除的节点。这里有个问题是，我要删除的节点是头节点怎么办，那此时fast移动间隔n后，肯定是指向NULL，所以直接加个判断就能解决。\nclass Solution &#123; public:  ListNode* removeNthFromEnd(ListNode* head, int n) &#123;    ListNode* slow = head;    ListNode* fast = head;    for (int i = 0; i &lt; n; i++) &#123;      fast = fast-&gt;next;    &#125;    if (fast == NULL) &#123;    // 判断要删除的节点是头节点      return head-&gt;next;    &#125;    while (fast-&gt;next) &#123;      slow = slow-&gt;next;      fast = fast-&gt;next;    &#125;    slow-&gt;next = slow-&gt;next-&gt;next;    return head;  &#125;&#125;;\n","categories":["算法交流"],"tags":["刷题笔记"]},{"title":"回溯算法问题","url":"/2199921100.html","content":"一、全排列（中）题目给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。\n示例 1：输入：$nums &#x3D; [1,2,3]$输出：$[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]$\n示例 2：输入：$nums &#x3D; [0,1]$输出：$[[0,1],[1,0]]$\n示例 3：输入：$nums &#x3D; [1]$输出：$[[1]]$\n提示：$1 &lt;&#x3D; nums.length &lt;&#x3D; 6$$-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10$nums 中的所有整数 互不相同\n题解1这道题可以用『回溯算法』来解决。看下面这张图，应该就好理解了\nclass Solution &#123; private:  vector&lt;vector&lt;int&gt;&gt; result;  // 存储结果  vector&lt;int&gt; track;           // 存储当前路径 public:  vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;    backtrack(nums, 0);  // 回溯函数    return result;  &#125;  // 路径：记录在 track 中  // 选择列表：nums 中不存在于 track 中的元素  // 结束条件：遍历完所有行, 即 index = nums.size()  void backtrack(vector&lt;int&gt;&amp; nums, int index) &#123;    // index为当前枚举的位置    if (index == nums.size()) &#123;      // 遍历完数组中最后一个数字,把当前组合加入结果      result.push_back(track);      return;    &#125;    for (int i = 0; i &lt; nums.size(); i++) &#123;      if (find(track.begin(), track.end(), nums[i]) != track.end()) &#123;        // 排除不合法的选择        continue;      &#125;      track.push_back(nums[i]);  // 做选择,将当前元素添加到路径中      backtrack(nums, index + 1);  // 进⼊下⼀层决策树      track.pop_back();  // 撤销选择,将当前元素从路径中弹出    &#125;  &#125;&#125;;\n\n题解2上面的解法中，排除不合法的选择是通过查找track中元素来排除的，速度有点慢。简单的方法就是维护一个数组，用来记录每个数字的使用情况，遍历nums时直接判断数字使用情况来排除不合法的选择。\nclass Solution &#123;  vector&lt;vector&lt;int&gt;&gt; result; // 存储结果  vector&lt;int&gt; track;  // 存储当前路径  vector&lt;bool&gt; used;    // 数字是否使用 public:  vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;    used = vector&lt;bool&gt;(nums.size());    backtrack(nums, 0);    return result;  &#125;  void backtrack(vector&lt;int&gt;&amp; nums, int index) &#123;    // index为当前枚举的位置    if (index == nums.size()) &#123;      // 遍历完数组中最后一个数字,把当前组合加入结果      result.push_back(track);      return;    &#125;    for (int i = 0; i &lt; nums.size(); i++) &#123;      if (used[i]) &#123;        continue;      &#125;      // 当前数字没有使用,加入组合      track.push_back(nums[i]);      // 更新使用状态      used[i] = true;      // 继续搜索下一个位置      backtrack(nums, index + 1);      // 回退使用状态      used[i] = false;      // 把数字从当前组合中删除      track.pop_back();    &#125;  &#125;&#125;;\n\n二、全排列II（中）题目给定一个可包含重复数字的数组 nums ，按任意顺序 返回所有不重复的全排列。\n示例 1：输入：$nums &#x3D; [1,1,2]$输出：$[[1,1,2], [1,2,1], [2,1,1]]$\n示例 2：输入：$nums &#x3D; [1,2,3]$输出：$[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]$\n提示：$1 &lt;&#x3D; nums.length &lt;&#x3D; 8$$-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10$\n题解这道题和『全排列』区别就在于数字是与重复的，那我们就需要在做回溯前先把已经枚举过的数字去重。\n有两种情况，1、数字已使用过；2、前后数字重复且前面数字已经使用过（这个我们就需要先对数组排序，让相同的数字都在一块）。其余的照搬『全排列』的回溯就ok了。\nclass Solution &#123;  vector&lt;vector&lt;int&gt;&gt; result; // 存储结果  vector&lt;int&gt; track;  // 存储当前路径  vector&lt;bool&gt; used;    // 数字是否使用 public:  vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;    sort(nums.begin(), nums.end());  // 先排个序,让重复的数字都在一块    used = vector&lt;bool&gt;(nums.size());    backtrack(nums, 0);    return result;  &#125;  void backtrack(vector&lt;int&gt;&amp; nums, int index) &#123;    // idx为当前枚举的位置    if (index == nums.size()) &#123;      // 遍历完数组中最后一个数字,把当前组合加入结果      result.push_back(track);      return;    &#125;    unordered_set&lt;int&gt; s;    for (int i = 0; i &lt; nums.size(); i++) &#123;      if (used[i] || (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1])) &#123;        // 1、数字已使用过; 2、前后数字重复且前面数字已经使用过        continue;      &#125;      // 当前数字没有使用,加入组合      track.push_back(nums[i]);      // 更新使用状态      used[i] = true;      // 继续搜索下一个位置      backtrack(nums, index + 1);      // 回退使用状态      used[i] = false;      // 把数字从当前组合中删除      track.pop_back();    &#125;  &#125;&#125;;\n\n三、N皇后（困）题目按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。\n示例 1：输入：$n &#x3D; 4$输出：$[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]$解释：如上图所示，4 皇后问题存在两个不同的解法。\n示例 2：输入：$n &#x3D; 1$输出：$[[“Q”]]$\n提示：$1 &lt;&#x3D; n &lt;&#x3D; 9$\n题解下面我用一个 3 * 3 的棋盘，将搜索过程抽象为一棵树，如图：根据回溯模板，1、定义全局变量二维数组board来记录最终结果。参数n是棋盘的大小，然后用row来记录当前遍历到棋盘的第几层了。\nvector&lt;string&gt; board(n, string(n, &#x27;.&#x27;));\n2、根据上图可以看出，当递归到棋盘最底层（也就是叶子节点）的时候，就可以收集结果并返回了。\nif (row == board.size()) &#123;  res.push_back(board);  return;&#125;\n3、递归深度就是row控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。每次都是要从新的一列的起始位置开始搜，所以都是从0开始。\nfor (int col = 0; col &lt; n; col++) &#123;  // 排除不合法选择  if (!isValid(board, row, col)) &#123;    continue;  &#125;  // 做选择  board[row][col] = &#x27;Q&#x27;;  // 进⼊下⼀行决策  backtrack(board, row + 1);  // 撤销选择  board[row][col] = &#x27;.&#x27;;&#125;\n4、看一下皇后们的约束条件：不能同行、不能同列、不能同斜线。\nbool isValid(vector&lt;string&gt;&amp; board, int row, int col) &#123;  int n = board.size();  // 检查列是否有皇后互相冲突  for (int i = 0; i &lt; n; i++) &#123;    if (board[i][col] == &#x27;Q&#x27;)      return false;  &#125;  // 检查右上方是否有皇后互相冲突  for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) &#123;    if (board[i][j] == &#x27;Q&#x27;)      return false;  &#125;  // 检查左上方是否有皇后互相冲突  for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) &#123;    if (board[i][j] == &#x27;Q&#x27;)      return false;  &#125;  return true;&#125;\n\n完整代码如下：\nclass Solution &#123;  vector&lt;vector&lt;string&gt;&gt; res; public:  /* 输⼊棋盘边⻓ n，返回所有合法的放置 */  vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;    // n x n的棋盘，n行，每行1个元素，大小为n的string    // &#x27;.&#x27; 表⽰空，&#x27;Q&#x27; 表⽰皇后，初始化空棋盘。    vector&lt;string&gt; board(n, string(n, &#x27;.&#x27;));    backtrack(board, 0);    return res;  &#125;  // 路径：board 中小于 row 的那些行都已经成功放置了皇后  // 选择列表：第 row 行的所有列都是放置皇后的选择  // 结束条件：row 超过 board 的最后⼀行  void backtrack(vector&lt;string&gt;&amp; board, int row) &#123;    // 触发结束条件    if (row == board.size()) &#123;      res.push_back(board);      return;    &#125;    int n = board[row].size();    for (int col = 0; col &lt; n; col++) &#123;      // 排除不合法选择      if (!isValid(board, row, col)) &#123;        continue;      &#125;      // 做选择      board[row][col] = &#x27;Q&#x27;;      // 进⼊下⼀行决策      backtrack(board, row + 1);      // 撤销选择      board[row][col] = &#x27;.&#x27;;    &#125;  &#125;  /* 是否可以在 board[row][col] 放置皇后？ */  bool isValid(vector&lt;string&gt;&amp; board, int row, int col) &#123;    int n = board.size();    // 检查列是否有皇后互相冲突    for (int i = 0; i &lt; n; i++) &#123;      if (board[i][col] == &#x27;Q&#x27;)        return false;    &#125;    // 检查右上方是否有皇后互相冲突    for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) &#123;      if (board[i][j] == &#x27;Q&#x27;)        return false;    &#125;    // 检查左上方是否有皇后互相冲突    for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) &#123;      if (board[i][j] == &#x27;Q&#x27;)        return false;    &#125;    return true;  &#125;&#125;;\n\n四、复原IP地址（中）题目有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。\n例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “&#x31;&#57;&#50;&#x2e;&#x31;&#54;&#x38;&#64;&#49;&#x2e;&#49;“ 是 无效 IP 地址。给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。\n示例 1：输入：s &#x3D; “25525511135”输出：[“255.255.11.135”,”255.255.111.35”]\n示例 2：输入：s &#x3D; “0000”输出：[“0.0.0.0”]\n示例 3：输入：s &#x3D; “101023”输出：[“1.0.10.23”,”1.0.102.3”,”10.1.0.23”,”10.10.2.3”,”101.0.2.3”]\n提示：1 &lt;&#x3D; s.length &lt;&#x3D; 20s 仅由数字组成\n题解用回溯的话，把递归树画出来就清晰了。\n\n从字符串的开头开始，每次尝试截取1到3个字符，判断是否是合法的片段；\n一个片段的长度是 1~3\n片段的值范围是 0~255\n不能是 “0x”、”0xx” 形式\n\n\n如果是，就加入到当前的IP地址中，并继续向后搜索，直到找到四个整数或者字符串结束。\n如果找到了四个整数且字符串刚好结束，就说明找到了一个有效的IP地址，可以加入到结果集中。\n如果没有找到四个整数或者字符串还有剩余，就说明这条搜索路径不可行，需要回溯到上一步，尝试其他的截取方式。\n\nclass Solution &#123; private:  vector&lt;string&gt; result;  // 存储结果 public:  vector&lt;string&gt; restoreIpAddresses(string s) &#123;    // 剪枝操作    if (s.size() &lt; 4 || s.size() &gt; 12)      return result;    backtrack(s, 0, 0);    return result;  &#125;  // 回溯函数  void backtrack(string&amp; s, int startIndex, int pointNum) &#123;    // 如果已经找到了 3 个点，且剩余的字符串也是合法的，则将结果加入到 result 中    if (pointNum == 3) &#123;      if (isValid(s, startIndex, s.size() - 1)) &#123;        result.emplace_back(s);      &#125;      return;    &#125;    // 枚举下一个点的位置    for (int i = startIndex; i &lt; s.size(); ++i) &#123;      // 如果当前位置是合法的，则在当前位置加入一个点      if (isValid(s, startIndex, i)) &#123;        s.insert(s.begin() + i + 1, &#x27;.&#x27;);        ++pointNum;        // 继续递归查找下一个点        backtrack(s, i + 2, pointNum);        --pointNum;        // 将加入的点移除        s.erase(s.begin() + i + 1);      &#125; else &#123;        // 如果当前位置不合法，则直接退出循环        break;      &#125;    &#125;  &#125;  // 判断字符串 s 中从 start 到 end 位置的子串是否合法  bool isValid(string s, int start, int end) &#123;    if (start &gt; end)      return false;    if (s[start] == &#x27;0&#x27; &amp;&amp; start != end)      return false;    // 判断字符串中的数字是否合法    int num = 0;    for (int i = start; i &lt;= end; ++i) &#123;      if (s[i] &gt; &#x27;9&#x27; || s[i] &lt; &#x27;0&#x27;) &#123;        return false;      &#125;      // 计算字符串对应的数字      num = num * 10 + (s[i] - &#x27;0&#x27;);      if (num &gt; 255)        return false;    &#125;    return true;  &#125;&#125;;","categories":["算法交流"],"tags":["刷题笔记"]},{"title":"反转链表问题","url":"/2609717024.html","content":"一、反转链表（简）题目给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n示例1：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5—-&gt;5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1输入：head = [1，2，3，4，5]输出：[5，4，3，2，1]\n示例2：1 -&gt; 2—-&gt;2 -&gt; 1输入：head = [1，2]输出：[2，1]\n示例3：输入：head = [ ]输出：[ ]\n提示：链表中节点的数目范围是 [0, 5000]-5000 &lt;= Node.val &lt;= 5000\n题解1迭代法，记录pre节点和cur节点，不断交换pre和cur，同时cur后移\nclass Solution { public:  ListNode* reverseList(ListNode* head) {    ListNode* pre = NULL;    ListNode* cur = head;    while (cur != NULL) {      ListNode* next = cur-&gt;next;  // 这里到最后一个数字时没有next了,返回NULL      cur-&gt;next = pre;      pre = cur;      cur = next;    }    return pre;  }};\n\n题解2递归法，假设链表其余部分已被反转，怎么去反转它前面的部分。假设a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f-&gt;NULL；若e-&gt;f已经被反转成e&lt;-f，此时在d，我们希望将d-&gt;e变为d&lt;-e，所以d-&gt;next-&gt;next=d；这时d和e互相指向，要断开，所以d-&gt;next=NULL。\nclass Solution { public:  ListNode* reverseList(ListNode* head) {    if (!head || !head-&gt;next) {      return head;    }    ListNode* newHead = reverseList(head-&gt;next);    head-&gt;next-&gt;next = head;    head-&gt;next = nullptr;    return newHead;  }};\n\n二、反转链表Ⅱ（中）题目给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。\n示例1：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5—-&gt;1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5输入：head = [1，2，3，4，5], left = 2, right = 4输出：[1，4，3，2，5]\n示例2：输入：head = [5], left = 1, right = 1输出：[5]\n提示：链表中节点数目为 n1 &lt;= n &lt;= 500-500 &lt;= Node.val &lt;= 5001 &lt;= left &lt;= right &lt;= n\n题解首先，凡是链表题都可以创建个伪头节点，如下\nListNode* dummy = new ListNode(0);dummy-&gt;next = head;\n参考反转链表，这题是特定位置反转，可以根据left和right取出需要反转的链表，代入反转链表的解法进行反转，再和前后链表拼接。\nclass Solution { public:  // 照搬反转链表  ListNode* reverseList(ListNode* head) {    ListNode* pre = NULL;    ListNode* cur = head;    while (cur != NULL) {      ListNode* next = cur-&gt;next;      cur-&gt;next = pre;      pre = cur;      cur = next;    }    return pre;  }  ListNode* reverseBetween(ListNode* head, int left, int right) {    ListNode* dummy = new ListNode(0);    dummy-&gt;next = head;    ListNode* pre = dummy;    ListNode* end = dummy;    for (int i = 0; i &lt; left - 1; i++)      pre = pre-&gt;next;  // 要截取链表的头节点的前一个节点    ListNode* start = pre-&gt;next;  // 要截取链表的头节点    for (int i = 0; i &lt; right; i++)      end = end-&gt;next;  // 要截取链表的尾节点    ListNode* next = end-&gt;next; // 要截取链表的尾节点的后一个节点    end-&gt;next = NULL; // 截断链表,才能用于反转    pre-&gt;next = reverseList(start);    start-&gt;next = next; // 链表拼接    return dummy-&gt;next;  }};\n\n三、K个一组翻转链表（困）题目给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。\n示例1：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5—-&gt;2 -&gt; 1 -&gt; 4 -&gt; 3 -&gt; 5输入：head = [1，2，3，4，5], k = 2输出：[2，1，4，3，5]\n示例2：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5—-&gt;3 -&gt; 2 -&gt; 1 -&gt; 4 -&gt; 5输入：head = [1，2，3，4，5], k = 3输出：[3，2，1，4，5]\n示例3：输入：head = [ ]输出：[ ]\n提示：链表中的节点数目为 n1 &lt;= k &lt;= n &lt;= 50000 &lt;= Node.val &lt;= 1000\n题解参考反转链表Ⅱ，反转链表Ⅱ中是给定left和right进行截取来反转，这里可以通过遍历给定的链表，每k个截取一段链表，然后反转并拼接\nclass Solution { public:  // 照搬反转链表  ListNode* reverseList(ListNode* head) {    ListNode* pre = NULL;    ListNode* cur = head;    while (cur != NULL) {      ListNode* next = cur-&gt;next;      cur-&gt;next = pre;      pre = cur;      cur = next;    }    return pre;  }  // 微调反转链表II  ListNode* reverseKGroup(ListNode* head, int k) {    ListNode* dummy = new ListNode(0);    dummy-&gt;next = head;    ListNode* pre = dummy;    ListNode* end = dummy;    while (end-&gt;next != NULL) {      ListNode* start = pre-&gt;next;  // 要截取链表的头节点      for (int i = 0; i &lt; k &amp;&amp; end != NULL; i++)        end = end-&gt;next;  // 要截取链表的尾节点      if (end == NULL)        break;      ListNode* next = end-&gt;next; // 要截取链表的尾节点的后一个节点      end-&gt;next = NULL; // 截断链表,才能用于反转      pre-&gt;next = reverseList(start);      start-&gt;next = next; // 链表拼接      // 开始下一次反转      pre = start;      end = pre;    }    return dummy-&gt;next;  }};","categories":["算法交流"],"tags":["刷题笔记"]},{"title":"回溯算法","url":"/929892390.html","content":"前言回溯算法本质是一个暴力穷举的过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”（即回退），尝试别的路径。\n回溯法有“通用解题法”之称。 它适合于解一些组合数较大的最优化问题。同时涉及回溯算法的题目都有一个共同点：列出所有满足的情况。\n另外，基本所有能用回溯算法解决的题目总能画出一个二叉树来。我们称这样的树为决策树。解决一个回溯问题，其实就是一个决策树的遍历过程。所以在回溯法中，深度优先搜索是一种很重要的工具。\n算法框架遍历整个决策树时，你只需要思考三个问题：\n\n路径：你已经做出的选择\n选择列表：也就是你当前可以做的选择\n结束条件：到达决策树底层，无法再做选择的条件\n\n以『全排列』为例。我们可以直接画出全排列的决策树如下：\n根据这个决策树，比如说你站在红色节点上。你可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你⾝后，这个选择你之前做过了，而全排列是不允许重复使用数字的。\n所以在这里：[2] 就是「路径」，记录你已经做过的选择；[1,3] 就是「选择列表」，表示你当前可以做出的选择；遍历到树的底层，即选择列表为空的时候就是「结束条件」。\n框架如下：\nresult = []def backtrack(原数组, 行数):  if 满足结束条件:    result.add(路径)    return  for 选择 in 选择列表:    # 做选择判断,排除不合法的选择    continue    # 将合法的选择加⼊选择列表    路径.add(选择)    # 回溯下一行    backtrack(原数组, 行数+1)    # 撤销选择,将该选择从选择列表移除    路径.remove(选择)\n\n上面的框架中，为什么要撤销选择呢前面我们就说过，回溯算法本质就是在遍历决策树。大家可以想一想，你的一次选择结束了，你肯定要返回当当时进入递归时的状态，然后进行另外的选择啊，不然你不返回状态，其他选择怎么办。如果不撤销，按照下图的角度，你只会得到一个结果，就是用于遍历的左子树。\n代码示例class Solution &#123; private:  vector&lt;vector&lt;int&gt;&gt; result;  // 存储结果  vector&lt;int&gt; track;           // 存储当前路径 public:  vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;    backtrack(nums, 0);  // 回溯函数    return result;  &#125;  // 路径：记录在 track 中  // 选择列表：nums 中不存在于 track 中的元素  // 结束条件：遍历完所有行, 即 index = nums.size()  void backtrack(vector&lt;int&gt;&amp; nums, int index) &#123;    if (index == nums.size()) &#123;      result.push_back(track);      return;    &#125;    for (int i = 0; i &lt; nums.size(); i++) &#123;      if (find(track.begin(), track.end(), nums[i]) != track.end()) &#123;        // 排除不合法的选择        continue;      &#125;      track.push_back(nums[i]);  // 做选择,将当前元素添加到路径中      backtrack(nums, index + 1);  // 进⼊下⼀层决策树      track.pop_back();  // 撤销选择,将当前元素从路径中弹出    &#125;  &#125;&#125;;\n","categories":["算法交流"],"tags":["常见算法"]},{"title":"堆排序","url":"/3265658309.html","content":"一、堆的概念1、堆是一个完全二叉树，它的所有元素按照完全二叉树的顺序存储方式存储在一个一维数组中。2、堆中某个节点的值总是不大于或不小于其父节点的值；堆总是一棵完全二叉树。3、堆分为两种：大顶堆、小顶堆\n\n大顶堆：每一个父结点的值均大于等于其对应的子结点的值，而父结点的值就是最大的\n小顶堆：每一个父结点的值均小于等于其对应的子结点的值，而父结点的值就是最小的\n\n4、堆排序最后一个非叶子节点（父节点）的序号是n/2-1，n为数组的长度（具体分析见第四点）。\n二、堆的实现有两种方法，一种是自己写堆进行排序，一种是直接对数组建堆。\n1、手动实现堆假设我们排升序，且堆为小顶堆。首先，把数组的每个元素（HeapPush）插入到堆中；其次，小顶堆的堆顶是最小的数字，依次遍历堆顶的元素，将堆顶元素赋值到数组里，从下标0开始，赋值后删除堆顶元素，++数组下标；此时堆就会重新调整，最终堆顶依旧是最小的，再重复上述赋值堆顶到数组的操作，直到堆为空。具体实现可以参考堆的实现和堆排序和Topk问题。\n2、数组建堆堆的调整无非就两种，一种是向下调整，一种是向上调整。向下调整：让调整的结点与其孩子节点进行比较向上调整：让调整的结点与其父亲结点进行比较简单区分就是，向下调整条件是孩子节点值比父节点小；而向上调整条件是父节点值比孩子节点小。以数组[9, 2, 7, 5, 6, 4, 3, 8, 9]为例\n2-1、向下调整思路：选出左右孩子中小的那一个，跟父节点比较，如果父节点大，则父节点和子节点交换。记住一点，child = 2*parent + 1，这里child是左子树首先取左右child更小的那个跟parent节点比较，如果parent节点更大，就把child的值和parent的值互换，同时parent下移到child的位置，用公式child = 2*parent + 1更新child位置；然后换行，比较下一层的parent和child。\n// 向下调整算法void adjust_down(int array[], int i, int n) &#123;  int parent = i;         // 父节点下标  int child = 2 * i + 1;  // 子节点下标  while (child &lt; n) &#123;    if (child + 1 &lt; n &amp;&amp; array[child] &gt; array[child + 1]) &#123;      // 选出左右child小的那个，与parent比较      child++;    &#125;    if (array[child] &lt; array[parent]) &#123;      // 如果child比parent小,交换parent和child,这样就保证parent比左右child都小      swap(array, parent, child);  // 交换parent和child      parent = child;              // child下标赋给parent下标    &#125; else &#123;      break;    &#125;    child = child * 2 + 1;  // 换行,比较下一层的parent和child  &#125;&#125;\n\n2-2、建小顶堆在向下调整中，要保证左子树和右子树均是堆，否则不能；按照这个思路，那采用向下调整建堆时，应该从下往上走，保证左右子树都是堆。从最后一个非叶子节点开始，即n/2-1，调用一次向下调整；再找到前一个节点，调用一次向下调整，循环往复，直到对父节点向下调整（此时父节点的左右子树已是堆），堆就实现了。举例：1、对于数组[9, 2, 7, 5, 6, 4, 3, 8, 9]，n/2-1就是第3个节点，也就是5，取左右子树小的那个，即8，5小于8，不换，跳出循环；2、下一个节点是7，取左右子树小的那个，即3，7大于3，互换，parent到3的位置，没有子树了，跳出调整。\n// 创建小顶堆void BuildMinHeap(int array[], int size) &#123;  for (int i = size / 2 - 1; i &gt;= 0; i--) &#123;    // 倒数第二排开始,对每一个三角形成的堆,创建小顶堆    adjust_down(array, i, size);  &#125;&#125;\n\n2-3、向上调整思路：选出左右孩子中大的那一个，跟父节点比较，如果父节点小，则父节点和子节点交换。记住一点，child = 2*parent + 1，这里child是左子树首先取左右child更大的那个跟parent节点比较，如果parent节点更小，就把child的值和parent的值互换，同时parent下移到child的位置，用公式child = 2*parent + 1更新child位置；然后换行，比较下一层的parent和child。\n// 向上调整算法void adjust_up(int array[], int i, int n) &#123;  int parent = i;         // 父节点下标  int child = 2 * i + 1;  // 子节点下标  while (child &lt; n) &#123;    if (child + 1 &lt; n &amp;&amp; array[child] &lt; array[child + 1]) &#123;      // 选出左右child大的那个，与parent比较      child++;    &#125;    if (array[parent] &lt; array[child]) &#123;      // 如果parent比child小,交换parent和child,这样就保证parent比左右child都大      swap(array, parent, child);  // 交换parent和child      parent = child;              // child下标赋给parent下标    &#125; else &#123;      break;    &#125;    child = child * 2 + 1;  // 换行,比较下一层的parent和child  &#125;&#125;\n\n2-4、建大顶堆跟建小顶堆一样，在向上调整中，要保证左子树和右子树均是堆，否则不能；按照这个思路，那采用向上调整建堆时，应该从下往上走，保证左右子树都是堆。从最后一个非叶子节点开始，即n/2-1，调用一次向下调整；再找到前一个节点，调用一次向上调整，循环往复，直到对父节点向上调整（此时父节点的左右子树已是堆），堆就实现了。\n// 创建大顶堆void BuildMaxHeap(int array[], int size) &#123;  for (int i = size / 2 - 1; i &gt;= 0; i--) &#123;    // 倒数第二排开始,对每一个三角形成的堆,创建大顶堆    adjust_up(array, i, size);  &#125;&#125;\n\n三、堆排序有了上面的建堆，就可以直接进行堆排序了。对于降序，我们可以先创建小顶堆，此时顶点是最小值。从后面开始遍历数组，每次遍历就交换顶点和第i个数据，这样就可以把顶点的最小值存到尾部；然后在剩余的数字中再进行向下调整，重新建立小顶堆；再进行上面的互换操作。对于升序，也是类似的，先创建大顶堆，此时顶点是最大值。从后面开始遍历数组，每次遍历就交换顶点和第i个数据，这样就可以把顶点的最大值存到尾部；然后在剩余的数字中再进行向上调整，重新建立大顶堆；再进行上面的互换操作。\n// 降序void MaxHeapSort(int array[], int size) &#123;  BuildMinHeap(array, size);  // 创建小顶堆  display(array, size);  for (int i = size - 1; i &gt; 0; i--) &#123;    swap(array, 0, i);    // 这里交换顶点和第i个数据,就是把顶点的最小值存到尾部,    // 在剩余的数字中再进行向下调整,重新建立小顶堆    adjust_down(array, 0, i);  &#125;&#125;// 升序void MinHeapSort(int array[], int size) &#123;  BuildMaxHeap(array, size);  // 创建大顶堆  display(array, size);  for (int i = size - 1; i &gt; 0; i--) &#123;    // 这里交换顶点和第i个数据,就是把顶点的最大值存到尾部,    // 在剩余的数字中再进行向上调整,重新建立大顶堆    swap(array, 0, i);    adjust_up(array, 0, i);  &#125;&#125;\n\n四、堆排序最后一个非叶子节点的序号堆排序是基于完全二叉树实现的，在将一个数组调整成一个堆的时候，关键之一的是确定最后一个非叶子节点的序号，这个序号为n/2-1，n为数组的长度。但是为什么呢？\n可以分两种情况考虑：1、堆的最后一个非叶子节点只有左孩子2、堆的最后一个非叶子节点有左右两个孩子完全二叉树的性质之一是：如果节点序号为 i，则它的左孩子序号为2i+1，右孩子序号为 2i+2。\n对于情况1，左孩子(最后一个元素)的序号为 n-1，则 n-1=2i+1，推出 i=n/2-1；对于情况2，左孩子(倒数第二个元素)的序号为 n-2，则 n-2=2i+1，推出i=(n-1)/2-1；右孩子(最后一个元素)的序号为n-1，则n-1=2i+2，推出（这里跟左孩子推出的一样）i=(n-1)/2-1。\n很显然，当完全二叉树最后一个节点是其父节点的左孩子时，树的节点数（数组元素数）为偶数；当完全二叉树最后一个节点是其父节点的右孩子时（满二叉树），树的节点数（数组元素数）为奇数。\n根据一般编程语言的特性，整数除不尽时向下取整，则若n为奇数时(n-1)/2-1=n/2-1。\n因此对于情况2，最后一个非叶子节点的序号也是n/2-1。\n五、完整代码void display(int array[], int size) &#123;  for (int i = 0; i &lt; size; i++) &#123;    printf(&quot;%d &quot;, array[i]);  &#125;  printf(&quot;\\n&quot;);&#125;void swap(int array[], int x, int y) &#123;  int temp = array[x];  array[x] = array[y];  array[y] = temp;&#125;// 向下调整算法void adjust_down(int array[], int i, int n) &#123;  int parent = i;         // 父节点下标  int child = 2 * i + 1;  // 子节点下标  while (child &lt; n) &#123;    if (child + 1 &lt; n &amp;&amp; array[child] &gt; array[child + 1]) &#123;      // 选出左右child小的那个，与parent比较      child++;    &#125;    if (array[parent] &gt; array[child]) &#123;      // 如果parent比child大,交换parent和child,这样就保证parent比左右child都小      swap(array, parent, child);  // 交换parent和child      parent = child;              // child下标赋给parent下标    &#125; else &#123;      break;    &#125;    child = child * 2 + 1;  &#125;&#125;// 向上调整算法void adjust_up(int array[], int i, int n) &#123;  int parent = i;         // 父节点下标  int child = 2 * i + 1;  // 子节点下标  while (child &lt; n) &#123;    if (child + 1 &lt; n &amp;&amp; array[child] &lt; array[child + 1]) &#123;      // 选出左右child大的那个，与parent比较      child++;    &#125;    if (array[parent] &lt; array[child]) &#123;      // 如果parent比child小,交换parent和child,这样就保证parent比左右child都大      swap(array, parent, child);  // 交换parent和child      parent = child;              // child下标赋给parent下标    &#125; else &#123;      break;    &#125;    child = child * 2 + 1;  // 换行,比较下一层的parent和child  &#125;&#125;// 创建小顶堆void BuildMinHeap(int array[], int size) &#123;  for (int i = size / 2 - 1; i &gt;= 0; i--) &#123;    // 倒数第二排开始,对每一个三角形成的堆,创建小顶堆    adjust_down(array, i, size);  &#125;&#125;// 创建大顶堆void BuildMaxHeap(int array[], int size) &#123;  for (int i = size / 2 - 1; i &gt;= 0; i--) &#123;    // 倒数第二排开始,对每一个三角形成的堆,创建大顶堆    adjust_up(array, i, size);  &#125;&#125;// 降序void MaxHeapSort(int array[], int size) &#123;  BuildMinHeap(array, size);  // 创建小顶堆  display(array, size);  for (int i = size - 1; i &gt; 0; i--) &#123;    swap(array, 0, i);    // 这里交换顶点和第i个数据,就是把顶点的最小值存到尾部,    // 在剩余的数字中再进行向下调整,重新建立小顶堆    adjust_down(array, 0, i);  &#125;&#125;// 升序void MinHeapSort(int array[], int size) &#123;  BuildMaxHeap(array, size);  // 创建大顶堆  display(array, size);  for (int i = size - 1; i &gt; 0; i--) &#123;    // 这里交换顶点和第i个数据,就是把顶点的最大值存到尾部,    // 在剩余的数字中再进行向上调整,重新建立大顶堆    swap(array, 0, i);    adjust_up(array, 0, i);  &#125;&#125;int main() &#123;  int array[] = &#123;9, 2, 7, 5, 6, 4, 3, 8, 9&#125;;  int size = sizeof(array) / sizeof(int);  // 打印数据  display(array, size);  MinHeapSort(array, size);  display(array, size);  return 0;&#125;","categories":["算法交流"],"tags":["常见算法"]},{"title":"多数之和问题","url":"/2469441302.html","content":"一、两数之和（简）题目给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。\n示例 1：输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[0,1]解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。\n示例 2：输入：nums &#x3D; [3,2,4], target &#x3D; 6输出：[1,2]\n示例 3：输入：nums &#x3D; [3,3], target &#x3D; 6输出：[0,1]\n提示：2 &lt;&#x3D; nums.length &lt;&#x3D; 10^4-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9-10^9 &lt;&#x3D; target &lt;&#x3D; 10^9只会存在一个有效答案\n题解当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。数组可以做哈希表，set也可以，map也可以，用哪个呢对于这道题，不仅要知道元素有没有遍历过，还有知道这个元素对应的下标。需要使用key-value结构来存放，key来存元素，value来存下标，那么使用map正合适而C++中map有三种类型，如下所示:\n\n\n\n映射\n底层实现\n是否有序\nkey的数量\n能否更改数值\n查询效率\n增删效率\n\n\n\nstd::map\n红黑树\nkey有序\n只能有一个key\nkey不可修改\nO(log n)\nO(log n)\n\n\nstd::multimap\n红黑树\nkey有序\n可以有多个key\nkey不可修改\nO(log n)\nO(log n)\n\n\nstd::map\n哈希表\nkey无序\n只能有一个key\nkey不可修改\nO(1)\nO(1)\n\n\n这道题目中并不需要key有序，所以选择std::unordered_map效率更高接下来就很简单了，首先把数组中的元素作为key，value用来存下标；我们只需要查找map中是否存在target-nums[i]的值，没有就将(nums[i],i)加入map，继续遍历即可\nclass Solution &#123; public:  vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;    unordered_map&lt;int, int&gt; num_map;    vector&lt;int&gt; res;    for (int i = 0; i &lt; nums.size(); i++) &#123;      auto iter = num_map.find(target - nums[i]);      if (iter != num_map.end()) &#123;        res = &#123;iter-&gt;second, i&#125;;        break;      &#125;      num_map.insert(pair&lt;int, int&gt;(nums[i], i));    &#125;    return res;  &#125;&#125;;int main() &#123;  Solution s;  vector&lt;int&gt; nums = &#123;2, 7, 11, 15&#125;;  int target = 22;  vector&lt;int&gt; res = s.twoSum(nums, target);  for (auto i : res) &#123;    cout &lt;&lt; i &lt;&lt; &quot; &quot;;  &#125;&#125;\n\n二、三数之和（中）题目给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。请你返回所有和为 0 且不重复的三元组。注意：答案中不可以包含重复的三元组。\n示例 1：输入：nums &#x3D; [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] &#x3D; (-1) + 0 + 1 &#x3D; 0 。nums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0 。nums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。\n示例 2：输入：nums &#x3D; [0,1,1]输出：[]解释：唯一可能的三元组和不为 0 。\n示例 3：输入：nums &#x3D; [0,0,0]输出：[[0,0,0]]解释：唯一可能的三元组和为 0 。\n提示：3 &lt;&#x3D; nums.length &lt;&#x3D; 3000-10^5 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5\n题解这道题只用求值，不用求下标，就不需要用哈希表了，用双指针就是最方便的。从小到大排序后，就可以用双指针了因为有需要三个数，可以固定一个数a，双指针遍历剩下的数组，求双指针之和target为0-a即可left为数组头，right为数组尾，大于target则right--，小于target则left++主要是去重，因为有可能数组中同一个数字出现多次，排完序后，相同的数字会连在一起，只要将当前的值和前一个值比就可以去重了。\nclass Solution &#123; public:  vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;    vector&lt;vector&lt;int&gt;&gt; res;    sort(nums.begin(), nums.end());    // 目的是找出a + left + right = 0    for (int i = 0; i &lt; nums.size(); i++) &#123;      if (nums[i] &gt; 0) &#123;        return res;      &#125;      if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;        // 去重a        continue;      &#125;      int left = i + 1;      int right = nums.size() - 1;      int target = 0 - nums[i];      while (left &lt; right) &#123;        if (nums[left] + nums[right] &gt; target) &#123;          right--;        &#125; else if (nums[left] + nums[right] &lt; target) &#123;          left++;        &#125; else &#123;          res.push_back(&#123;nums[i], nums[left], nums[right]&#125;);          // 找到答案时，双指针同时收缩          left++;          right--;          while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123;            // 去重left            left++;          &#125;          while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123;            // 去重right            right--;          &#125;        &#125;      &#125;    &#125;  &#125;  return res;&#125;;\n\n三、最接近的三数之和（中）题目给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在恰好一个解。\n示例 1：输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1输出：2解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。\n示例 2：输入：nums &#x3D; [0,0,0], target &#x3D; 1输出：0\n提示：3 &lt;&#x3D; nums.length &lt;&#x3D; 1000-1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000-10^4 &lt;&#x3D; target &lt;&#x3D; 10^4\n题解和三数之和非常类似，求与target最接近的三元组，即差值的绝对值最小。和三数之和一样，从小到大排序后，固定一个数a，求双指针之和尽可能接近target-a即可如果a+b+c&gt;target，right--；如果a+b+c&lt;target，left++，同时和三数之和一样需要去重，只是增加一步，在和taget比较之前，需要先update一下三数之和，记录下最接近target的值。\nclass Solution &#123; public:  int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;    int best = 1e7;    // 根据差值的绝对值来更新答案    auto update = [&amp;](int cur) &#123;      // auto的特殊用法      if (abs(cur - target) &lt; abs(best - target)) &#123;        best = cur;      &#125;    &#125;;    sort(nums.begin(), nums.end());    // 目的是找出a + left + right = 0    for (int i = 0; i &lt; nums.size(); i++) &#123;      if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;        // 去重a        continue;      &#125;      int left = i + 1;      int right = nums.size() - 1;      while (left &lt; right) &#123;        int sum = nums[i] + nums[left] + nums[right];        if (sum == target) &#123;          return target;        &#125;        update(sum);        if (sum &gt; target) &#123;          right--;          while (right &gt; left &amp;&amp; nums[right] == nums[right + 1]) &#123;            // 去重right            right--;          &#125;        &#125; else &#123;          left++;          while (right &gt; left &amp;&amp; nums[left] == nums[left - 1]) &#123;            // 去重left            left++;          &#125;        &#125;      &#125;    &#125;    return best;  &#125;&#125;;\n","categories":["算法交流"],"tags":["刷题笔记"]},{"title":"如何理解 if __name__ == '__main__'","url":"/539495985.html","content":"前言在大多数编排得好一点的脚本或者程序里面都有这段if __name__ == &#39;main&#39;:，虽然一直知道他的作用，但是一直比较模糊，收集资料详细理解之后与大家分享。\n代码功能一个python的文件有两种使用的方法，第一是直接作为脚本执行，第二是import到其他的python脚本中被调用（模块重用）执行。因此if __name__ == &#39;main&#39;:的作用就是控制这两种情况执行代码的过程，if __name__ == &#39;main&#39;:下的代码只有在第一种情况下（即文件作为脚本直接执行）才会被执行，而import到其他脚本中是不会被执行的。\n 举个例子，下面在test.py中写入如下代码： print(&quot;A&quot;)if __name__ == &#x27;__main__&#x27; :    print(&quot;B&quot;)直接执行test.py，输出A和B。即，if __name__==&quot;__main__&quot;:语句之前和之后的代码都被执行。\n 然后在同一文件夹新建名称为import_test.py的脚本，只输入如代码·import test，执行脚本，只输出A。即，if __name__==&quot;__main__&quot;:之前的语句被执行，之后的没有被执行。\n运行原理每个python模块（python文件，也就是此处的test.py和import_test.py）都包含内置的变量__name__，当运行模块被执行的时候，name__等于文件名（包含了后缀.py）；如果import到其他模块中，则__name__等于模块名称（不包含后缀.py）。而“__main__”等于当前执行文件的名称（包含了后缀.py）。进而当模块被直接执行时，__name &#x3D;&#x3D; ‘main’结果为真。\n举例说明，我们在test.py脚本的if __name__==&quot;__main__&quot;:之前加入print (__name__)，即将__name__打印出来。输出__main__。再执行import_test.py，输出test。此时，test.py中的__name__变量值为test，不满足__name__&#x3D;&#x3D;”main“的条件，因此，无法执行其后的代码。\n","categories":["开发运维"],"tags":["python"]},{"title":"岛屿问题","url":"/310434385.html","content":"前言我们知道，DFS通常是在树或者图结构上进行的，而岛屿问题都是网格，能不能用DFS呢？可以，记住，凡是网格的都应该想到用DFS，岛屿问题就是一类典型的网格问题。\n一、岛屿数量（中）题目给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。\n岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。\n此外，你可以假设该网格的四条边均被水包围。\n示例 1：输入：$grid &#x3D; [$  $[“1”,”1”,”1”,”1”,”0”],$  $[“1”,”1”,”0”,”1”,”0”],$  $[“1”,”1”,”0”,”0”,”0”],$  $[“0”,”0”,”0”,”0”,”0”]$$]$输出：1\n示例 2：输入：$grid &#x3D; [$  $[“1”,”1”,”0”,”0”,”0”],$  $[“1”,”1”,”0”,”0”,”0”],$  $[“0”,”0”,”1”,”0”,”0”],$  $[“0”,”0”,”0”,”1”,”1”]$$]$输出：3\n提示：$m &#x3D;&#x3D; grid.length$$n &#x3D;&#x3D; grid[i].length$$1 &lt;&#x3D; m, n &lt;&#x3D; 300$$grid[i][j] 的值为 ‘0’ 或 ‘1’$\n题解首先我们要清楚DFS的基本结构，先看简单的二叉树DFS遍历结构\nvoid traverse(TreeNode* root) &#123;  // 判断base case  if (root == NULL) &#123;    return;  &#125;  // 访问两个相邻结点:左子结点,右子结点  traverse(root-&gt;left);  traverse(root-&gt;right);&#125;\n可以看到，二叉树的DFS有两个要素：访问相邻结点、判断base case。\n\n二叉树的相邻结点非常简单，只有左子结点和右子结点两个。\n二叉树本身就是一个递归定义的结构：一棵二叉树，它的左子树和右子树也是一棵二叉树。那么我们的DFS遍历只需要递归调用左子树和右子树即可。\n\n\n二叉树遍历的base case是root == NULL。\n这样一个条件判断其实有两个含义：一方面，这表示 root 指向的子树为空，不需要再往下遍历了。另一方面，在root == NULL的时候及时返回，可以让后面的root-&gt;left和root-&gt;right操作不会出现空指针异常。\n\n\n\n那么对于网格上的DFS，我们完全可以参考二叉树的DFS，写出网格DFS的两个要素。\n\n首先看相邻结点。很明显，网格结构中的格子的相邻结点是上下左右四个，即(row-1, col),(row+1, col),(row, col-1),(row, col+1)；\n然后是base case。根据二叉树的对应过来，是超出网格范围的格子，即row &gt;= grid.size() || col &gt;= grid[0].size() || row &lt; 0 || col &lt; 0。\n\n根据分析，可以得出网格DFS遍历的框架代码：\nvoid dfsGrid(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int row, int col) &#123;  if (row &gt;= grid.size() || col &gt;= grid[0].size() || row &lt; 0 || col &lt; 0) &#123;    // 防止row和col越界(上下左右)    return;  &#125;  dfsGrid(grid, row - 1, col);  // 上  dfsGrid(grid, row + 1, col);  // 下  dfsGrid(grid, row, col - 1);  // 左  dfsGrid(grid, row, col + 1);  // 右&#125;\n这里有个问题，怎么避免重复值，比如下面这张图，dfsGrid遍历时会一直在这里不断循环。简单的方法就是标记已经遍历过的格子。比如岛屿问题，把走过的陆地格子的值改为2。这样就能得到一个网格DFS遍历的通用框架代码：\nvoid dfsGrid(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int row, int col) &#123;  if (row &gt;= grid.size() || col &gt;= grid[0].size() || row &lt; 0 || col &lt; 0) &#123;    // 防止row和col越界(上下左右)    return;  &#125;  if (grid[row][col] != &#x27;1&#x27;) &#123;    // 遍历到海洋或者已经遍历过的陆地,退出    return;  &#125;  grid[row][col] = &#x27;2&#x27;;         // 去重,防止多次遍历  dfsGrid(grid, row - 1, col);  // 上  dfsGrid(grid, row + 1, col);  // 下  dfsGrid(grid, row, col - 1);  // 左  dfsGrid(grid, row, col + 1);  // 右&#125;\n有了网格DFS遍历的通用框架，我们只需要用两层for循环遍历整张二维表格中所有的陆地，连续的视为一个岛屿。\nclass Solution &#123; public:  int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;    int res = 0;    // 两层for循环,遍历整张二维表格中所有的陆地,i是行,j是列    for (int i = 0; i &lt; grid.size(); i++) &#123;      for (int j = 0; j &lt; grid[0].size(); j++) &#123;        if (grid[i][j] == &#x27;1&#x27;) &#123;          dfsGrid(grid, i, j);  // 深度递归，遍历所有的陆地          res++;        &#125;      &#125;    &#125;    return res;  &#125;  void dfsGrid(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int row, int col) &#123;    if (row &gt;= grid.size() || col &gt;= grid[0].size() || row &lt; 0 || col &lt; 0) &#123;      // 防止row和col越界(上下左右)      return;    &#125;    if (grid[row][col] != &#x27;1&#x27;) &#123;      // 遍历到海洋或者已经遍历过的陆地,退出      return;    &#125;    grid[row][col] = &#x27;2&#x27;;         // 去重,防止多次遍历    dfsGrid(grid, row - 1, col);  // 上    dfsGrid(grid, row + 1, col);  // 下    dfsGrid(grid, row, col - 1);  // 左    dfsGrid(grid, row, col + 1);  // 右  &#125;&#125;;\n\n二、岛屿的周长（简）题目给定一个row x col的二维网格地图grid，其中：grid[i][j] = 1表示陆地，grid[i][j] = 0表示水域。\n网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。\n岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。\n示例 1：输入：$grid &#x3D; [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]$输出：16解释：它的周长是上面图片中的 16 个黄色的边\n示例 2：输入：grid &#x3D; [[1]]输出：4\n示例 3：输入：grid &#x3D; [[1,0]]输出：4\n提示：$row &#x3D;&#x3D; grid.length$$col &#x3D;&#x3D; grid[i].length$$1 &lt;&#x3D; row, col &lt;&#x3D; 100$$grid[i][j] 为 0 或 1$\n题解这道题最牛逼的一点是你要想到，岛屿的周长就是岛屿方格和非岛屿方格相邻的边的数量（如下图所示）。也就是说，在DFS遍历中，从一个岛屿方格走向一个非岛屿方格，就将周长加1。所以，我们可以修改下网格DFS遍历的通用框架：\nint dfsGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int row, int col) &#123;  if (row &gt;= grid.size() || col &gt;= grid[0].size() || row &lt; 0 || col &lt; 0) &#123;    // 从一个岛屿方格走向网格边界,周长加1    return 1;  &#125;  if (grid[row][col] == 0) &#123;    // 从一个岛屿方格走向水域方格,周长加1    return 1;  &#125;  if (grid[row][col] != 1) &#123;    // 过滤掉已经遍历过的    return 0;  &#125;  grid[row][col] = 2;  // 去重,防止多次遍历  int res = dfsGrid(grid, row - 1, col) + dfsGrid(grid, row + 1, col) +            dfsGrid(grid, row, col - 1) + dfsGrid(grid, row, col + 1);  return res;&#125;\n题目限制只有一个岛屿，那我们计算一个即可\nclass Solution &#123; public:  int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;    for (int i = 0; i &lt; grid.size(); i++) &#123;      for (int j = 0; j &lt; grid[0].size(); j++) &#123;        if (grid[i][j] == 1) &#123;          return dfsGrid(grid, i, j);        &#125;      &#125;    &#125;    return 0;  &#125;  int dfsGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int row, int col) &#123;    if (row &gt;= grid.size() || col &gt;= grid[0].size() || row &lt; 0 || col &lt; 0) &#123;      // 从一个岛屿方格走向网格边界,周长加1      return 1;    &#125;    if (grid[row][col] == 0) &#123;      // 从一个岛屿方格走向水域方格,周长加1      return 1;    &#125;    if (grid[row][col] != 1) &#123;      // 过滤掉已经遍历过的      return 0;    &#125;    grid[row][col] = 2;  // 去重,防止多次遍历    int res = dfsGrid(grid, row - 1, col) + dfsGrid(grid, row + 1, col) +              dfsGrid(grid, row, col - 1) + dfsGrid(grid, row, col + 1);    return res;  &#125;&#125;;\n\n三、岛屿的最大面积（中）题目给你一个大小为m x n的二进制矩阵grid。岛屿是由一些相邻的1(代表土地) 构成的组合，这里的「相邻」要求两个1必须在水平或者竖直的四个方向上相邻。你可以假设grid的四个边缘都被0（代表水）包围着。岛屿的面积是岛上值为1的单元格的数目。计算并返回grid中最大的岛屿面积。如果没有岛屿，则返回面积为0。\n示例 1：输入：$grid &#x3D; [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]$输出：6解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。\n示例 2：输入：$grid &#x3D; [[0,0,0,0,0,0,0,0]]$输出：0\n提示：$m &#x3D;&#x3D; grid.length$$n &#x3D;&#x3D; grid[i].length$$1 &lt;&#x3D; m, n &lt;&#x3D; 50$$grid[i][j] 为 0 或 1$\n题解从上面两道我们已经知道怎么计算岛屿数量和一个岛屿的周长，这道题是结合了上面两道。因此我们可以对每个岛屿计算它的面积，最后返回最大的那个面积即可。\nclass Solution &#123; public:  int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;    int res = 0;    for (int i = 0; i &lt; grid.size(); i++) &#123;      for (int j = 0; j &lt; grid[0].size(); j++) &#123;        if (grid[i][j] == 1) &#123;          res = max(dfsGrid(grid, i, j), res);        &#125;      &#125;    &#125;    return res;  &#125;  int dfsGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int row, int col) &#123;    if (row &gt;= grid.size() || col &gt;= grid[0].size() || row &lt; 0 || col &lt; 0) &#123;      // row和col越界,都不算岛屿中的陆地,面积为0      return 0;    &#125;    if (grid[row][col] != 1) &#123;      // 遍历到海洋或者已经遍历过的陆地,面积为0      return 0;    &#125;    grid[row][col] = 2;  // 去重,防止多次遍历    int res = dfsGrid(grid, row - 1, col) + dfsGrid(grid, row + 1, col) +              dfsGrid(grid, row, col - 1) + dfsGrid(grid, row, col + 1) +              1;  // 加1是因为第一次肯定是一块陆地才进来的dfsGrid    return res;  &#125;&#125;;\n\n四、最大人工岛（困）题目给你一个大小为n x n二进制矩阵grid。最多只能将一格0变成1。返回执行此操作后，grid中最大的岛屿面积是多少？岛屿由一组上、下、左、右四个方向相连的1形成。\n示例 1:输入: $grid &#x3D; [[1, 0], [0, 1]]$输出: 3解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。\n示例 2:输入: $grid &#x3D; [[1, 1], [1, 0]]$输出: 4解释: 将一格0变成1，岛屿的面积扩大为 4。\n示例 3:输入: $grid &#x3D; [[1, 1], [1, 1]]$输出: 4解释: 没有0可以让我们变成1，面积依然为 4。\n \n提示：$n &#x3D;&#x3D; grid.length$$n &#x3D;&#x3D; grid[i].length$$1 &lt;&#x3D; n &lt;&#x3D; 500$$grid[i][j] 为 0 或 1$\n题解这道题是第三题的升级版，现在我们可以将一个海洋变成陆地，从而连接两个岛屿。那我们就需要先统计各个岛屿面积，找到最大的岛屿；然后把一个海洋变成陆地，再统计一遍连接后各个岛屿面积，找到最大的岛屿。\n因此需要两次DFS遍历：1、划分岛屿，给每个岛屿标号标号要标什么呢？假设我们在所有的格子上标记出岛屿的面积。然后搜索哪个海洋格子相邻的两个岛屿面积最大。例如下图中红色方框内的海洋格子，上边、左边都与岛屿相邻，我们可以计算出它变成陆地之后可以连接成的岛屿面积为7 + 1 + 2 = 10。然而，这种做法可能遇到一个问题。如下图中红色方框内的海洋格子，它的上边、左边都与岛屿相邻，这时候连接成的岛屿面积难道是7 + 1 + 7 = 15？显然不是。这两个7来自同一个岛屿，所以填海造陆之后得到的岛屿面积应该只有7 + 1 = 8。可以看到，要让算法正确，我们得能区分一个海洋格子相邻的两个7是不是来自同一个岛屿。那么，我们不能在方格中标记岛屿的面积，而应该用map记录每个岛屿面积，给每个岛屿标记map的key。如下图所示。这样我们就可以发现红色方框内的海洋格子，它的两个相邻的岛屿实际上是同一个。\n2、填充海洋，连接四周的岛屿和上面类似，要遍历每个海洋格子上下左右的格子。又因为我们已经有map来记录了各个岛屿的面积，所以只需要在遍历时发现是岛屿，加上对应的面积即可，不需要再全部遍历该岛屿的陆地。要注意的是，我们是将一个海洋变为陆地，所以海洋会占一个面积。\nclass Solution &#123; public:  unordered_map&lt;int, int&gt; area;  // 存放各岛屿面积 public:  int largestIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;    int res = 0;    int index = 2;  // 从2开始是为了和陆地的1做区分,防止多次遍历    // 不同岛屿用不同的数字标记,统计各岛屿面积,同时记录最大值    for (int i = 0; i &lt; grid.size(); i++) &#123;      for (int j = 0; j &lt; grid[0].size(); j++) &#123;        if (grid[i][j] == 1) &#123;          area[index] = dfsGrid(grid, i, j, index);          res = max(res, area[index]);          index++;        &#125;      &#125;    &#125;    // 连接岛屿    for (int i = 0; i &lt; grid.size(); i++) &#123;      for (int j = 0; j &lt; grid.size(); j++) &#123;        if (grid[i][j] == 0) &#123;          res = max(res, linkland(grid, i, j));        &#125;      &#125;    &#125;    return res;  &#125;  int dfsGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int row, int col, int index) &#123;    if (row &gt;= grid.size() || col &gt;= grid[0].size() || row &lt; 0 || col &lt; 0) &#123;      return 0;    &#125;    if (grid[row][col] != 1) &#123;      return 0;    &#125;    grid[row][col] = index;    int res = dfsGrid(grid, row - 1, col, index) +              dfsGrid(grid, row + 1, col, index) +              dfsGrid(grid, row, col - 1, index) +              dfsGrid(grid, row, col + 1, index) + 1;    return res;  &#125;  int linkland(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int row, int col) &#123;    unordered_set&lt;int&gt; around;    int linkarea = 1;  // 海洋占一个面积    if (row - 1 &gt;= 0 &amp;&amp; grid[row - 1][col] &gt; 1) &#123;      // 左      around.insert(grid[row - 1][col]);    &#125;    if (row + 1 &lt; grid.size() &amp;&amp; grid[row + 1][col] &gt; 1) &#123;      // 右      around.insert(grid[row + 1][col]);    &#125;    if (col - 1 &gt;= 0 &amp;&amp; grid[row][col - 1] &gt; 1) &#123;      // 上      around.insert(grid[row][col - 1]);    &#125;    if (col + 1 &lt; grid.size() &amp;&amp; grid[row][col + 1] &gt; 1) &#123;      // 下      around.insert(grid[row][col + 1]);    &#125;    for (auto i : around) &#123;      linkarea += area[i];    &#125;    return linkarea;  &#125;&#125;;\n","categories":["算法交流"],"tags":["刷题笔记"]},{"title":"数据结构之二叉树","url":"/967469330.html","content":"二叉树遍历前序遍历：先访问根节点，再前序遍历左子树，再前序遍历右子树\n中序遍历：先中序遍历左子树，再访问根节点，再中序遍历右子树\n后序遍历：先后序遍历左子树，再后序遍历右子树，再访问根节点\n注意点\n\n以根访问顺序决定是什么遍历\n左子树都是优先右子树\n\n前序递归二叉树的前序遍历\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123; public:     vector&lt;int&gt; ve;     vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;         if(root) &#123;             ve.push_back(root -&gt; val);             preorderTraversal(root -&gt; left);             preorderTraversal(root -&gt; right);         &#125;     return ve;     &#125; &#125;;\n\n前序非递归（迭代法）class Solution &#123;public:    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; ve;        if(root == NULL)            return ve;        vector&lt;TreeNode*&gt; stk;        stk.push_back(root);        while(!stk.empty())&#123;            TreeNode* tmp = stk.back();            stk.pop_back();            ve.push_back(tmp -&gt; val);            if(tmp -&gt; right)&#123;                stk.push_back(tmp -&gt; right);            &#125;            if(tmp -&gt; left)&#123;                stk.push_back(tmp -&gt; left);            &#125;        &#125;    return ve;    &#125;&#125;;\n\n中序非递归（迭代法）二叉树的中序遍历\n/* 思路：每到一个节点 A，因为根的访问在中间，将 A 入vector。 * 然后遍历左子树，接着访问 A，最后遍历右子树。 * 在访问完 A 后，A 就可以出vector了。因为 A 和其左子树都已经访问完成。 * 和前序类似 */class Solution &#123;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;TreeNode*&gt; ve;        vector&lt;int&gt; v;        TreeNode* rt = root;        while(rt || !ve.empty()) &#123;            while(rt) &#123;                ve.push_back(rt);                rt=rt-&gt;left;            &#125;            rt=ve.back();            ve.pop_back();            v.push_back(rt-&gt;val);            rt=rt-&gt;right;        &#125;        return v;    &#125;&#125;;\n\n后序非递归（迭代法）二叉树的后序遍历\nclass Solution &#123;public:    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; res;        if(root == NULL) return res;        vector&lt;TreeNode*&gt; stk;        stk.push_back(root);        while(!stk.empty())&#123;            TreeNode* tmp = stk.back();            stk.pop_back();            if(tmp!=nullptr)&#123;                stk.push_back(tmp);                stk.push_back(nullptr);                if(tmp -&gt; right) stk.push_back(tmp -&gt; right);                if(tmp -&gt; left) stk.push_back(tmp -&gt; left);            &#125;            else&#123;                res.push_back(stk.back()-&gt;val);                stk.pop_back();            &#125;        &#125;        return res;    &#125;&#125;;\n\n注意点\n\n核心就是：根节点必须在右节点弹出之后，再弹出\n\nDFS 深度搜索-从上到下二叉树的前序遍历\nclass Solution &#123;public:    // 深度遍历，结果指针作为参数传入到函数内部    void dfs(TreeNode* root, vector&lt;int&gt;* result)&#123;        if(root)&#123;            result -&gt; push_back(root -&gt; val);            dfs(root -&gt; left, result);            dfs(root -&gt; right, result);        &#125;    &#125;    vector&lt;int&gt; preorderTraversal(TreeNode* root)&#123;        vector&lt;int&gt; res;        dfs(root, &amp;res);        return res;    &#125;&#125;;\n\n这实际上就是递归的实现\nDFS 深度搜索-从下向上（分治法）二叉树的前序遍历\n分治法模板\n\n递归返回条件\n分段处理\n合并结果\n\nType traversal(TreeNode* root) &#123;    // NULL or leaf    if(root == NULL) &#123;        // do something and return    &#125;    // Divide    Type left = traversal(root -&gt; Left)    Type right = traversal(root -&gt; Right)    // Conquer    Type result = Merge from left and right    return result&#125;\n\n答案代码\nclass Solution &#123;public:    vector&lt;int&gt; divideAndConquer(TreeNode* root)&#123;        vector&lt;int&gt; result;        if(root != NULL)&#123;            vector&lt;int&gt; r_left = divideAndConquer(root -&gt; left);            vector&lt;int&gt; r_right = divideAndConquer(root -&gt; right);            result.push_back(root -&gt; val);            for(auto it : r_left)&#123;                 result.push_back(it);            &#125;            for(auto it : r_right)&#123;                 result.push_back(it);            &#125;        &#125;        return result;    &#125;    vector&lt;int&gt; preorderTraversal(TreeNode* root)&#123;        vector&lt;int&gt; res;        res = divideAndConquer(root);        return res;    &#125;&#125;;\n\n注意点：\n\nDFS 深度搜索（从上到下） 和分治法区别：前者一般将最终结果通过指针参数传入，后者一般递归返回结果最后合并\n\nBFS 层次遍历二叉树的层次遍历 II\n\n给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n\n思路：在层级遍历的基础上，翻转一下结果即可\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123;        queue&lt;TreeNode*&gt; q;        vector&lt;vector&lt;int&gt;&gt; result;        if(!root)&#123;            return result;        &#125;        q.push(root);        while(!q.empty())&#123;            vector&lt;int&gt; ve;            int nums = q.size();            for(int i = 0; i &lt; nums; i++)&#123;                TreeNode* tmp = q.front();                q.pop();                ve.push_back(tmp-&gt;val);                if(tmp-&gt;left)&#123;                    q.push(tmp-&gt;left);                &#125;                if(tmp-&gt;right)&#123;                    q.push(tmp-&gt;right);                &#125;            &#125;            result.insert(result.begin(), ve);        &#125;        return result;    &#125;&#125;;\n\n分治法应用先分别处理局部，再合并结果\n适用场景\n\n归并排序\n\n快速排序\n\n二叉树相关问题\n\n\n归并排序\n​\t\t归并排序是典型分治思想的代表——首先把原问题分解为两个或多个子问题，然后求解子问题的解，最后使用子问题的解来构造出原问题的解。​\t\t对于归并排序，给定一个待排序的数组，首先把该数组划分为两个子数组，然后对子数组进行排序（递归调用归并排序），最后对两个有序的子数组进行合并，使合并之后的数组为有序状态。​\t\t让我们想想，把一个数组不断地划分为子数组，不断地划分……,不断地划分……., 最后停止了划分不下去了。 此时子数组的元素有一个，它们本身就是有序的。接下来，我们就需要执行合并过程，不断地一层层向上合并，…….., 直到原数组。通过这个过程就会发现， 归并排序的核心在于合并有序的子数组，而不是对子数组进行排序，因为最底层的子数组本身就是有序的，上一层子数组如果想要变成有序的，通过合并底层有序的子数组就可以得到， 最终我们使原数组变成了有序的，从而完成了排序操作。\n归并排序是用分治思想，时间复杂度为O(NlogN)。分治模式在每一层递归上有三个步骤：\n\n分解（Divide）：将n个元素分成个含n&#x2F;2个元素的子序列。\n解决（Conquer）：用合并排序法对两个子序列递归的排序。\n合并（Combine）：合并两个已排序的子序列已得到排序结果。\n\n#include &lt;cstring&gt;#include &lt;iostream&gt;typedef bool (*CompareFunc)(int, int);// 下面函数实现合并功能，输入三个下标参数表示了两个子数组, :[nStart_, nMiddle)和[nMiddle, nEnd)void Merge(int array[], int nStart_, int nMiddle_, int nEnd_,           CompareFunc comp) &#123;  if (array == nullptr || nStart_ &gt;= nMiddle_ || nMiddle_ &gt;= nEnd_) return;  // 建立一个临时数组存放中间数据  int _nIndex = 0;  int* _pTempArray = new int[nEnd_ - nStart_];  // 对两个子数组进行合并  int _nStartChange = nStart_;  int _nMiddleChange = nMiddle_;  while (_nStartChange &lt; nMiddle_ &amp;&amp; _nMiddleChange &lt; nEnd_) &#123;    // 此处的if中比较语句的安排可以保持稳定排序的特性。    if (comp(array[_nMiddleChange], array[_nStartChange])) &#123;      _pTempArray[_nIndex] = array[_nMiddleChange];      ++_nMiddleChange;    &#125; else &#123;      _pTempArray[_nIndex] = array[_nStartChange];      ++_nStartChange;    &#125;    ++_nIndex;  &#125;  // 把不为空的子数组的元素追加到临时数  if (_nStartChange &lt; nMiddle_) &#123;    memcpy(_pTempArray + _nIndex, array + _nStartChange,           sizeof(int) * (nMiddle_ - _nStartChange));  &#125; else if (_nMiddleChange &lt; nEnd_) &#123;    memcpy(_pTempArray + _nIndex, array + _nMiddleChange,           sizeof(int) * (nEnd_ - _nMiddleChange));  &#125; else &#123;    /* do noting */  &#125;  // 数据交换  memcpy(array + nStart_, _pTempArray, sizeof(int) * (nEnd_ - nStart_));  delete[] _pTempArray;  _pTempArray = nullptr;&#125;// 归并排序功能实现函数void MergeSort(int array[], int nStart_, int nEnd_, CompareFunc comp) &#123;  // 数组指针为空，或者数组内的个数少于等于1个时，直接返回。  if (nullptr == array || (nEnd_ - nStart_) &lt;= 1) return;  // 划分为两个子数组并递归调用自身进行排序  int _nMiddle = (nStart_ + nEnd_) / 2;  MergeSort(array, nStart_, _nMiddle, comp);  MergeSort(array, _nMiddle, nEnd_, comp);  // 合并排序完成的子数组  Merge(array, nStart_, _nMiddle, nEnd_, comp);&#125;// 比较函数bool less(int lhs, int rhs) &#123; return lhs &lt; rhs; &#125;bool large(int lhs, int rhs) &#123; return lhs &gt; rhs; &#125;// 打印数组函数void PrintArray(int array[], int nLength_) &#123;  if (nullptr == array || nLength_ &lt;= 0) return;  for (int i = 0; i &lt; nLength_; ++i) &#123;    std::cout &lt;&lt; array[i] &lt;&lt; &quot; &quot;;  &#125;  std::cout &lt;&lt; std::endl;&#125;/***************    main.c     *********************/int main(int argc, char* argv[]) &#123;  // 测试  int array[10] = &#123;1, -1, 1, 5, -5, -1, -1, 3, -4, -2&#125;;  MergeSort(array, 0, 9, large);  PrintArray(array, 10);  return 0;&#125;\n\n快速排序​\t\t快速排序作为20世纪十大算法之一，我们这些玩编程的好像没有理由不去学习它。快速排序是冒泡排序的升级版。\n​\t\t基本思想：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可以分别对这两部分记录继续进行排序，以达到整个序列有序的目的。可参考这位大佬\n\n#include &lt;iostream&gt;typedef bool (*CompareFunc)(int, int);// 比较函数bool less(int lhs, int rhs) &#123; return lhs &lt;= rhs; &#125;   // 从小到大bool large(int lhs, int rhs) &#123; return lhs &gt;= rhs; &#125;  // 从大到小void quickSort(int left, int right, int arr[], CompareFunc comp) &#123;  // 递归边界条件  if (left &gt;= right) return;  int i, j, base, temp;  i = left, j = right;  base = arr[left];  //取最左边的数为基准数  while (i &lt; j) &#123;    while (comp(base, arr[j]) &amp;&amp; i &lt; j) j--;    while (comp(arr[i], base) &amp;&amp; i &lt; j) i++;    if (i &lt; j) &#123;      temp = arr[i];      arr[i] = arr[j];      arr[j] = temp;    &#125;  &#125;  //基准数归位  arr[left] = arr[i];  arr[i] = base;  quickSort(left, i - 1, arr, comp);   //递归左边  quickSort(i + 1, right, arr, comp);  //递归右边&#125;// 打印数组函数void PrintArray(int array[], int nLength_) &#123;  if (nullptr == array || nLength_ &lt;= 0) return;  for (int i = 0; i &lt; nLength_; ++i) &#123;    std::cout &lt;&lt; array[i] &lt;&lt; &quot; &quot;;  &#125;  std::cout &lt;&lt; std::endl;&#125;int main(int argc, char* argv[]) &#123;  // 测试  int array[10] = &#123;1, -1, 1, 5, -5, -1, -1, 3, -4, -2&#125;;  quickSort(0, 9, array, less);  PrintArray(array, 10);  quickSort(0, 9, array, large);  PrintArray(array, 10);  return 0;&#125;\n\n注意点：\n\n快排由于是原地交换所以没有合并过程 传入的索引是存在的索引（如：0、length-1 等），越界可能导致崩溃\n\n常见题目示例二叉树的最大深度\n\n给定一个二叉树，找出其最大深度。\n\n思路：分治法\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    int maxDepth(TreeNode* root) &#123;        if(!root) return 0;        if(!root -&gt; left &amp;&amp; !root -&gt; right) return 1;        // divide：分左右子树分别计算        int left = maxDepth(root -&gt; left);        int right = maxDepth(root -&gt; right);        // conquer：合并左右子树结果        return left &gt; right ? left + 1 : right + 1;    &#125;&#125;;\n\n平衡二叉树\n\n给定一个二叉树，判断它是否是高度平衡的二叉树。\n\n思路：分治法，左边平衡 &amp;&amp; 右边平衡 &amp;&amp; 左右两边高度 &lt;&#x3D; 1， 因为需要返回是否平衡及高度，要么返回两个数据，要么合并两个数据， 所以用-1 表示不平衡，&gt;0 表示树高度（二义性：一个变量有两种含义）。\nclass Solution &#123;public:    bool isBalanced(TreeNode* root) &#123;        if(maxDepth(root) == -1) &#123;            return false;        &#125;        return true;    &#125;    int maxDepth(TreeNode* root) &#123;        if(!root) return 0;        if(!root -&gt; left &amp;&amp; !root -&gt; right) return 1;        int left = maxDepth(root -&gt; left);        int right = maxDepth(root -&gt; right);        // 为什么返回-1呢？因为高度不可能为负数        if(abs(left - right) &gt; 1 || left == -1 || right == -1) &#123;            return -1;        &#125;        return left &gt; right ? left + 1 : right + 1;    &#125;&#125;;\n\n注意\n\n一般工程中，结果通过两个变量来返回，不建议用一个变量表示两种含义\n\n二叉树中的最大路径和\n\n给定一个非空二叉树，返回其最大路径和。\n\n思路：分治法，分为三种情况：左子树最大路径和最大，右子树最大路径和最大，左右子树最大加根节点最大，需要保存两个变量：一个保存子树最大路径和，一个保存左右加根节点和，然后比较这个两个变量选择最大值即可\nclass Solution &#123;public:    struct ResultType &#123;        int SinglePath; // 保存单边最大值        int MaxPath;    // 保存最大值（单边或者两个单边+根的值）    &#125;;    ResultType helper(TreeNode* root) &#123;        if(root == NULL) &#123;            return &#123;0,-(1 &lt;&lt; 10)&#125;;        &#125;        // Divide        ResultType left = helper(root -&gt; left);        ResultType right = helper(root -&gt; right);        // Conquer        ResultType result;        // 求单边最大值        if(left.SinglePath &gt; right.SinglePath) &#123;            result.SinglePath = std::max(left.SinglePath + root -&gt; val, 0);        &#125; else &#123;            result.SinglePath = std::max(right.SinglePath + root -&gt; val, 0);        &#125;        // 求两边加根最大值        int tempMax = std::max(right.MaxPath, left.MaxPath);        result.MaxPath = std::max(tempMax, left.SinglePath + right.SinglePath + root -&gt; val);        return result;    &#125;    int maxPathSum(TreeNode* root) &#123;        ResultType result = helper(root);        return result.MaxPath;    &#125;&#125;;\n\n二叉树的最近公共祖先\n\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n\n思路：分治法，有左子树的公共祖先或者有右子树的公共祖先，就返回子树的祖先，否则返回根节点\nclass Solution &#123;public:    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        // 相等 直接返回root节点即可        if(root == NULL || root == p || root == q) &#123;            return root;        &#125;        // Divide        TreeNode* left = lowestCommonAncestor(root -&gt; left, p, q);        TreeNode* right = lowestCommonAncestor(root -&gt; right, p, q);        // Conquer        // 左右两边都不为空，则根节点为祖先        if(left != NULL &amp;&amp; right != NULL) &#123;            return root;        &#125;        if(left != NULL) &#123;            return left;        &#125;        if(right != NULL) &#123;            return right;        &#125;        return NULL;    &#125;&#125;;\n\nBFS 层次应用二叉树的层序遍历\n\n给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）\n\n思路：用一个队列记录一层的元素，然后扫描这一层元素添加下一层元素到队列（一个数进去出来一次，所以复杂度 O(logN)）。(和之前的二叉树的层次遍历 II类似)\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;        queue&lt;TreeNode*&gt; q;        vector&lt;vector&lt;int&gt;&gt; result;        if(!root)&#123;            return result;        &#125;        q.push(root);        while(!q.empty())&#123;            vector&lt;int&gt; ve;            int nums = q.size();            for(int i = 0; i &lt; nums; i++)&#123;                TreeNode* tmp = q.front();                q.pop();                ve.push_back(tmp-&gt;val);                if(tmp-&gt;left)&#123;                    q.push(tmp-&gt;left);                &#125;                if(tmp-&gt;right)&#123;                    q.push(tmp-&gt;right);                &#125;            &#125;            result.push_back(ve);        &#125;        return result;    &#125;&#125;;\n\n二叉树的锯齿形层次遍历\n\n给定一个二叉树，返回其节点值的锯齿形层次遍历。Z 字形遍历\n\n思路：在层次遍历的基础上加个下一层反向\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;        queue&lt;TreeNode*&gt; q;        vector&lt;vector&lt;int&gt;&gt; result;        if(!root)&#123;            return result;        &#125;        q.push(root);        bool reverse_flag = false;        while(!q.empty())&#123;            vector&lt;int&gt; ve;            int nums = q.size();            for(int i = 0; i &lt; nums; i++)&#123;                TreeNode* tmp = q.front();                q.pop();                ve.push_back(tmp-&gt;val);                if(tmp-&gt;left)&#123;                    q.push(tmp-&gt;left);                &#125;                if(tmp-&gt;right)&#123;                    q.push(tmp-&gt;right);                &#125;            &#125;            if(reverse_flag) &#123;                std::reverse(ve.begin(), ve.end());                reverse_flag = false;            &#125;            else &#123;                reverse_flag = true;            &#125;            result.push_back(ve);        &#125;        return result;    &#125;&#125;;\n\n二叉搜索树应用验证二叉搜索树\n\n给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n\n思路 1：递归\n思路 2：中序遍历，检查结果列表是否已经有序\n思路 3：分治法，判断左 MAX &lt; 根 &lt; 右 MIN\n// v1class Solution &#123;public:    bool isBSTUtil(TreeNode* root, long min, long max) &#123;        if(root == NULL)            return true;        if(root-&gt;val &lt;= min || root-&gt;val &gt;= max)            return false;        return isBSTUtil(root-&gt;left, min, root-&gt;val) &amp;&amp; isBSTUtil(root-&gt;right, root-&gt;val, max);    &#125;    bool isValidBST(TreeNode* root) &#123;        long v_min = LONG_MIN, v_max = LONG_MAX;        return isBSTUtil(root, v_min, v_max);    &#125;&#125;;// v2class Solution &#123;public:    bool isValidBST(TreeNode* root) &#123;        if(root == NULL) &#123;            return true;        &#125;        vector&lt;int&gt; result;        inOrder(root, &amp;result);        // 按左、根、右排列进行比较，左大于根或者根大于右则肯定不是平衡二叉树        for(int i = 0; i &lt; result.size() - 1; i++) &#123;            if(result[i] &gt;= result[i + 1]) &#123;                return false;            &#125;        &#125;        return true;    &#125;    // 分别将左节点和右节点放入result    void inOrder(TreeNode* root, vector&lt;int&gt;* result) &#123;        if(root == NULL) &#123;            return;        &#125;        inOrder(root -&gt; left, result);        result -&gt; push_back(root -&gt; val);        inOrder(root -&gt; right, result);    &#125;&#125;;// v3class Solution &#123;public:    struct ResultType &#123;        bool IsValid;        // 记录左右两边最大最小值，和根节点进行比较        TreeNode* Max;        TreeNode* Min;    &#125;;    bool isValidBST(TreeNode* root) &#123;        ResultType result = helper(root);        return result.IsValid;    &#125;    ResultType helper(TreeNode* root) &#123;        ResultType result = &#123;&#125;;        if(root == NULL) &#123;            result.IsValid = true;            return result;        &#125;        ResultType left = helper(root -&gt; left);        ResultType right = helper(root -&gt; right);        if(!left.IsValid || !right.IsValid) &#123;            result.IsValid = false;            return result;        &#125;        if(left.Max != NULL &amp;&amp; (left.Max -&gt; val) &gt;= (root -&gt; val)) &#123;            result.IsValid = false;            return result;        &#125;        if(right.Min != NULL &amp;&amp; right.Min -&gt; val &lt;= root -&gt; val) &#123;            result.IsValid = false;            return result;        &#125;        result.IsValid = true;        // 如果左边还有更小的3，就用更小的节点，不用4        //  5        // / \\        // 1   4        //    / \\        //   3   6        result.Min = root;        if(left.Min != NULL) &#123;            result.Min = left.Min;        &#125;        result.Max = root;        if(right.Max != NULL) &#123;            result.Max = right.Max;        &#125;        return result;    &#125;&#125;;\n\n二叉搜索树中的插入操作\n\n给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。\n\n思路：找到最后一个叶子节点满足插入条件即可\nclass Solution &#123;public:    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;        if(root == NULL) &#123;            return new TreeNode(val);        &#125;        if(root -&gt; val &gt; val) &#123;            root -&gt; left = insertIntoBST(root -&gt; left, val);        &#125;        else &#123;            root -&gt;right = insertIntoBST(root -&gt; right, val);        &#125;        return root;    &#125;&#125;;\n总结\n掌握二叉树递归与非递归遍历\n理解 DFS 前序遍历与分治法\n理解 BFS 层次遍历\n\n","categories":["算法交流"],"tags":["二叉树","数据结构"]},{"title":"排序算法","url":"/1935562632.html","content":"前言排序算法面试中经常被考到，这里对排序算法做一次总结，方便巩固复习。\n\ntable th:first-of-type {\n    width: 15%;\n}\ntable th:nth-of-type(2) {\n    width: 25%;\n}\ntable th:nth-of-type(3) {\n    width: 10%;\n}\ntable th:nth-of-type(4) {\n    width: 50%;\n}\n\n\n\n\n\n名称\n时间\n空间\n说明\n\n\n\n冒泡排序\n$O(n^2)$\n1\n按顺序依次两个比较，通过交换位置保证大的排后面，依次循环\n\n\n选择排序\n$O(n^2)$\n1\n选出最小的数，放在首位；再次选，放在第二位\n\n\n快速排序\n$O(nlog_{2}n)$\n1\n先选择中间值，然后把比它小的放在左边，大的放在右边（具体实现就是从两边找，找到一对后交换）；然后分别对两边重复进行上述操作\n\n\n堆排序\n$O(nlog_{2}n)$\n1\n利用堆的性质进行的选择排序\n\n\n插入排序\n$O(n^2)$\n1\n逐一取出元素，在已经排序的元素序列中从后向前扫描，放到适当的位置\n\n\n希尔排序\n$O(n^{1+ε})$  $0&lt;ε&lt;1$\n1\n选择一个步长，然后按间隔为步长的单元进行排序，递归，步长逐渐变小，直至为1\n\n\n归并排序\n$O(nlog_{2}n)$\nn\n逐层对半拆分，然后逐层从最小分组开始排序，合并成大的分组\n\n\n冒泡排序算法原理1、遍历数组，从左到右，若右边的数比左边的大，则交换；2、第一遍：最大的数沉下去；3、第二遍：第二大的数沉在倒数第二个位置。\n复杂度时间复杂度最差是$O(n^2)$，最优是$O(n)$两层循环，最差循环次数是$n(n-1)&#x2F;2$，也就是$(n-1)+(n-2)+…+1$属于稳定排序注：稳定排序：排序前后两个相等的数相对位置不变，则算法稳定；非稳定排序：排序前后两个相等的数相对位置发生了变化，则算法不稳定比如[5,5,1,4,3]，排序后第一个5还是在前，第二个5还是在后，即稳定\nCode// 这个排序次数是固定的，不论元素排列怎么样，时间复杂度都是O(n^2)void BubbleSort(vector&lt;int&gt;&amp; nums) &#123;  int n = nums.size();  for (int i = n - 1; i &gt; 0; i--) &#123;    for (int j = 0; j &lt; i; j++) &#123;      if (nums[j] &gt; nums[j + 1]) &#123;        // 交换        int temp = nums[j];        nums[j] = nums[j + 1];        nums[j + 1] = temp;      &#125;    &#125;  &#125;&#125;// 优化，比如[1,2,3,5,4]，只需要遍历一趟即可void BubbleSort_2(vector&lt;int&gt;&amp; nums) &#123;  int n = nums.size();  bool flag = false;  // 无序  for (int i = n - 1; i &gt; 0 &amp;&amp; !flag; i--) &#123;    flag = true;  // 有序    for (int j = 0; j &lt; i; j++) &#123;      if (nums[j] &gt; nums[j + 1]) &#123;        // 交换        int temp = nums[j];        nums[j] = nums[j + 1];        nums[j + 1] = temp;        flag = false;  // 无序      &#125;    &#125;  &#125;&#125;\n\n选择排序算法原理1、线性遍历数组，选出最小的数，放在第一个位置；2、然后，选出第二小的数，放在第二个位置。依此类推。\n复杂度时间复杂度最差是$O(n^2)$，最优也是$O(n^2)$两层循环，最差循环次数是$n(n-1)&#x2F;2$，也就是$(n-1)+(n-2)+…+1$属于不稳定排序\nCodevoid SelectSort(vector&lt;int&gt; &amp; nums) &#123;  int n = nums.size();  for (int i = 0; i &lt; n; i++) &#123;    // 找到从i开始到最后一个元素中最小的元素,k存储最小元素的下标.    int k = i;    for (int j = i + 1; j &lt; n; j++) &#123;      if (nums[j] &lt; nums[k]) &#123;        k = j;      &#125;    &#125;    // 将最小的元素a[k]和开始的元素a[i]交换数据    if (k != i) &#123;      int temp;      temp = nums[k];      nums[k] = nums[i];      nums[i] = temp;    &#125;  &#125;&#125;\n\n快速排序算法原理1、确定一个分界点；2、调整区间：使得左边所有值 &lt;&#x3D; 分界点， 右边所有值 &gt;&#x3D; 分界点；3、递归处理左右两段。\n复杂度时间复杂度最差是$O(n^2)$，最优是$O(nlog_2⁡n)$属于不稳定排序和归并相比，都是分治思想，但归并是稳定的，他是不稳定的\nCode/* 看上面的图示, i 从左边移动, j 从右边移动,以最左边作为基准数 pivot ,所以先是 j 移动 * 这里排小到大, ve[j] 比 pivot 大的, j 左移,否则停下; ve[i] 比 pivot 小的, i 右移,否则停下 * j 和 i 都停下后, ve[j] 和 ve[i] 互换,继续上面的移动 * 直到 j 和 i 相碰后,都停下, pivot 和 ve[i] 互换 * 至此,第一轮探测结束, pivot 左边数字均 ≤ pivot,右边数字均 ≥ pivot * 然后我们可以分开左右两边,又按照上述方法排序 */void QuickSort(vector&lt;int&gt;&amp; nums, int left, int right) &#123;  if (left &gt;= right) &#123;    // 如果左边界大于等于右边界，直接返回    return;  &#125;  int pivot = nums[left]; // 选取第一个元素作为基准值  int i = left, j = right;  // 定义左右指针  while (i &lt; j) &#123; // 双指针遍历数组    while (i &lt; j &amp;&amp; nums[j] &gt;= pivot) &#123;      // 从右往左找到第一个小于基准值的元素      j--;    &#125;    while (i &lt; j &amp;&amp; nums[i] &lt;= pivot) &#123;      // 从左往右找到第一个大于基准值的元素      i++;    &#125;    // 将左边大于基准值的元素和右边小于基准值的元素交换    std::swap(nums[i], nums[j]);  &#125;  // 这时nums[i]是小于基准值的元素,跟基准值交换,就可以将基准值放到中间  std::swap(nums[left], nums[i]);  QuickSort(nums, left, i - 1);  QuickSort(nums, j + 1, right);&#125;int main() &#123;  vector&lt;int&gt; ve = &#123;6, 1, 2, 7, 9, 3, 4, 5, 10, 8&#125;;  QuickSort(ve, 0, ve.size() - 1);  for (auto i : ve) &#123;    cout &lt;&lt; i &lt;&lt; &quot; &quot;;  &#125;  return 0;&#125;\n\n堆排序算法原理1、将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点；2、将其与末尾元素进行交换，此时末尾就为最大值；3、然后将剩余 n-1 个元素重新构造成一个堆，这样会得到n个元素的次小值；4、如此反复执行，便能得到一个有序序列了注：升序采用大顶堆，降序采用小顶堆\n复杂度时间复杂度最差是$O(nlog_2⁡n)$，最优是$O(nlog_2⁡n)$属于不稳定排序详见堆排序\nCodevoid display(int array[], int size) &#123;  for (int i = 0; i &lt; size; i++) &#123;    printf(&quot;%d &quot;, array[i]);  &#125;  printf(&quot;\\n&quot;);&#125;void swap(int array[], int x, int y) &#123;  int temp = array[x];  array[x] = array[y];  array[y] = temp;&#125;// 向下调整算法void adjust_down(int array[], int i, int n) &#123;  int parent = i;         // 父节点下标  int child = 2 * i + 1;  // 子节点下标  while (child &lt; n) &#123;    if (child + 1 &lt; n &amp;&amp; array[child] &gt; array[child + 1]) &#123;      // 选出左右child小的那个，与parent比较      child++;    &#125;    if (array[child] &lt; array[parent]) &#123;      // 如果child比parent小,交换parent和child,这样就保证parent比左右child都小      swap(array, parent, child);  // 交换parent和child      parent = child;              // child下标赋给parent下标    &#125; else &#123;      break;    &#125;    child = child * 2 + 1;  // 换行,比较下一层的parent和child  &#125;&#125;// 向上调整算法void adjust_up(int array[], int i, int n) &#123;  int parent = i;         // 父节点下标  int child = 2 * i + 1;  // 子节点下标  while (child &lt; n) &#123;    if (child + 1 &lt; n &amp;&amp; array[child] &lt; array[child + 1]) &#123;      // 选出左右child大的那个，与parent比较      child++;    &#125;    if (array[parent] &lt; array[child]) &#123;      // 如果parent比child小,交换parent和child,这样就保证parent比左右child都大      swap(array, parent, child);  // 交换parent和child      parent = child;              // child下标赋给parent下标    &#125; else &#123;      break;    &#125;    child = child * 2 + 1;  // 换行,比较下一层的parent和child  &#125;&#125;// 创建小顶堆void BuildMinHeap(int array[], int size) &#123;  for (int i = size / 2 - 1; i &gt;= 0; i--) &#123;    // 倒数第二排开始,对每一个三角形成的堆,创建小顶堆    adjust_down(array, i, size);  &#125;&#125;// 创建大顶堆void BuildMaxHeap(int array[], int size) &#123;  for (int i = size / 2 - 1; i &gt;= 0; i--) &#123;    // 倒数第二排开始,对每一个三角形成的堆,创建大顶堆    adjust_up(array, i, size);  &#125;&#125;// 降序void MaxHeapSort(int array[], int size) &#123;  BuildMinHeap(array, size);  // 创建小顶堆  display(array, size);  for (int i = size - 1; i &gt; 0; i--) &#123;    swap(array, 0, i);    // 这里交换顶点和第i个数据,就是把顶点的最小值存到尾部,    // 在剩余的数字中再进行向下调整,重新建立小顶堆    adjust_down(array, 0, i);  &#125;&#125;// 升序void MinHeapSort(int array[], int size) &#123;  BuildMaxHeap(array, size);  // 创建大顶堆  display(array, size);  for (int i = size - 1; i &gt; 0; i--) &#123;    // 这里交换顶点和第i个数据,就是把顶点的最大值存到尾部,    // 在剩余的数字中再进行向上调整,重新建立大顶堆    swap(array, 0, i);    adjust_up(array, 0, i);  &#125;&#125;int main() &#123;  int array[] = &#123;49, 38, 65, 97, 76, 13, 27, 49, 10&#125;;  int size = sizeof(array) / sizeof(int);  // 打印数据  display(array, size);  MaxHeapSort(array, size);  display(array, size);  return 0;&#125;\n\n插入排序算法原理对于数组a[10]，1、把a[0]认为已经排好序的；2、从a[1]开始向前和已经排好序的对比，小于排好的就调换，否则停止，并认为a[0,1]已经排好；3、然后a[2]又开始按步骤2进行，一直到a[10]。\n复杂度时间复杂度最差是$O(n^2)$，最优是$O(n)$两层循环，最差循环次数是$n(n-1)&#x2F;2$，也就是$(n-1)+(n-2)+…+1$属于稳定排序\nCodevoid InsertSort(vector&lt;int&gt;&amp; nums) &#123;  int n = nums.size();  // 间隔为1，对数组从第2位开始，记为key；  // 按间隔依次比较前面的元素，比key大就放到key后面；  // 一个key比较完后，key=key+1，继续比较  int gap = 1;  for (int i = 0; i &lt; gap; i++) &#123;    for (int j = i + gap; j &lt; n; j = j + gap) &#123;      int key = nums[j];      int k = j - gap;      while (k &gt;= 0 &amp;&amp; nums[k] &gt; key) &#123;        nums[k + gap] = nums[k];        k = k - gap;      &#125;      nums[k + gap] = key;    &#125;  &#125;&#125;\n\n希尔排序算法原理希尔排序又称 “缩小增量排序”，它也是一种插入类排序的方法。希尔排序属于插入类排序，是将整个有序序列分割成若干小的子序列分别进行插入排序。其实和插入排序一样，只不过比较间隔不局限于1，而是 n&#x2F;2，其余都一样。\n复杂度时间复杂度是$O(n^{1+ε})$，$0&lt;ε&lt;1$属于不稳定排序\nCodevoid ShellSort(vector&lt;int&gt;&amp; nums) &#123;  int n = nums.size();  // 这里d=n/2,插入排序d=1  for (int gap = n / 2; gap &gt;= 1; gap = gap / 2) &#123;  // 将数组分割为多个子表    for (int i = 0; i &lt; gap; i++) &#123;                 // 依次处理子表      for (int j = i + gap; j &lt; n; j = j + gap) &#123;  // 按间隔处理子表        int key = nums[j];        int k = j - gap;        while (k &gt;= 0 &amp;&amp; nums[k] &gt; key) &#123;          nums[k + gap] = nums[k];          k = k - gap;        &#125;        nums[k + gap] = key;      &#125;    &#125;  &#125;&#125;\n\n归并排序算法原理1、确定分界点mid &#x3D; (left + right)&gt;&gt;1，逐层折半分组；2、然后从最小分组开始比较排序，合并成一个大的分组，逐层进行；3、最终所有的元素都是有序的。注：&gt;&gt;1：除以2取整（进1法），&lt;&lt;1：乘以2取整\n复杂度时间复杂度最差是$O(nlog_2⁡n)$，最优是$O(nlog_2⁡n)$假设待排序的数组元素个数为n，设高度为x，x意味着n个元素需要连续二分x次才剩下1个元素，即$n&#x2F;(2^x)&#x3D;1，x&#x3D;log_2⁡n）$，每一层的总比较次数为n，所以时间复杂度为$nlog_2⁡n$属于稳定排序\nCodevoid MergeSort(vector&lt;int&gt;&amp; nums, int left, int right) &#123;  if (left &gt;= right) &#123;    return;  &#125;  vector&lt;int&gt; tmp;  int mid = left + right &gt;&gt; 1;  // 分别对左边和右边排序，对应归并里的分  MergeSort(nums, left, mid);  MergeSort(nums, mid + 1, right);  /*对应归并里的合  * 可以这么理解，当left &gt;= right后，就是数组拆分完了，下面是进行合并操作；  * tmp数组是用来存储每次排序后的结果，然后赋值会给原数组，  * 这样每次合并前的左右两边都是排好序的，我们只需要比较左右两边即可；  * 比如[7, 8, 11, 12]和[3, 9]排序；  * 7和3比，3存入tmp；7和9比，7存入tmp；8和9比，8存入tmp；11和9比，9存入tmp；  * 最后剩下[11, 12]，直接存入tmp  */  int i = left, j = mid + 1;  while (i &lt;= mid &amp;&amp; j &lt;= right) &#123;    if (nums[i] &lt;= nums[j]) &#123;      tmp.push_back(nums[i]);      i++;    &#125; else &#123;      tmp.push_back(nums[j]);      j++;    &#125;  &#125;  while (i &lt;= mid) &#123;    tmp.push_back(nums[i]);    i++;  // 只要左边没循环完，就执行此操作  &#125;  while (j &lt;= right) &#123;    tmp.push_back(nums[j]);    j++;  // 只要右边没循环完，就执行此操作  &#125;  for (i = left, j = 0; i &lt;= right; i++, j++) &#123;    nums[i] = tmp[j];  // 再将临时数组放回原数组  &#125;&#125;int main() &#123;  vector&lt;int&gt; ve = &#123;8, 9, 1, 7, 2, 3, 5, 4, 6, 0&#125;;  MergeSort(ve, 0, ve.size() - 1);  for (auto i : ve) &#123;    cout &lt;&lt; i &lt;&lt; &quot; &quot;;  &#125;  return 0;&#125;","categories":["算法交流"],"tags":["常见算法"]},{"title":"数据结构之栈和队列","url":"/3423645076.html","content":"栈和队列简介\n栈的特点是后入先出。根据这个特点可以临时保存一些数据，之后用到依次再弹出来，常用于 DFS 深度搜索\n\n\n\n队列一般常用于 BFS 广度搜索，类似一层一层的搜索\n\nStack 栈 最小栈\n设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。\n\n\n思路：用两个栈实现，一个最小栈始终保证最小值在顶部\n\nclass MinStack &#123; public:  MinStack() &#123;&#125;  void push(int val) &#123;    stack_data.push_back(val);    if (min_data.empty() || val &lt;= min_data.back()) &#123;      min_data.push_back(val);    &#125;  &#125;  void pop() &#123;    if (stack_data.back() == min_data.back()) &#123;      min_data.pop_back();    &#125;    stack_data.pop_back();  &#125;  int top() &#123; return stack_data.back(); &#125;  int getMin() &#123;    return min_data.back();    // return *min_element(stack_data.begin(), stack_data.end());  &#125; private:  vector&lt;int&gt; min_data;  vector&lt;int&gt; stack_data;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(val); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;getMin(); */\n逆波兰表达式求值\n波兰表达式计算 -&gt; 输入: [“2”, “1”, “+”, “3”, “*“] -&gt; 输出: 9解释: ((2 + 1) * 3) &#x3D; 9\n\n\n思路：通过栈保存原来的元素，遇到表达式弹出运算，再推入结果，重复这个过程\n\nclass Solution &#123; public:  int evalRPN(const vector&lt;string&gt;&amp; tokens) &#123;    stack&lt;int&gt; s;    for (string i : tokens) &#123;      if (i != &quot;+&quot; &amp;&amp; i != &quot;-&quot; &amp;&amp; i != &quot;*&quot; &amp;&amp; i != &quot;/&quot;) &#123;        s.push(stoi(i));        continue;      &#125;      int tmp2 = s.top();      s.pop();      int tmp1 = s.top();      s.pop();      if (i == &quot;+&quot;)        s.push(tmp1 + tmp2);      else if (i == &quot;-&quot;)        s.push(tmp1 - tmp2);      else if (i == &quot;*&quot;)        s.push(tmp1 * tmp2);      else if (i == &quot;/&quot;)        s.push(tmp1 / tmp2);    &#125;    return s.top();  &#125;&#125;;\n字符串解码\n给定一个经过编码的字符串，返回它解码后的字符串。 s &#x3D; “3[a]2[bc]”, 返回 “aaabcbc”. s &#x3D; “3[a2[c]]”, 返回 “accaccacc”. s &#x3D; “2[abc]3[cd]ef”, 返回 “abcabccdcdcdef”.\n\n\n思路：通过栈辅助进行操作，这里建了两个栈\n\nclass Solution &#123; public:  string decodeString(string s) &#123;    string res = &quot;&quot;;    stack&lt;int&gt; nums;    stack&lt;string&gt; strs;    int num = 0;    for (int i = 0; i &lt; s.size(); ++i) &#123;      if (s[i] &gt;= &#x27;0&#x27; &amp;&amp; s[i] &lt;= &#x27;9&#x27;) &#123;        num = num * 10 + s[i] - &#x27;0&#x27;;      &#125; else if (s[i] == &#x27;[&#x27;) &#123;        // 将‘[’前的数字压入nums栈内,字母字符串压入strs栈内        nums.push(num);        num = 0;        strs.push(res);        res = &quot;&quot;;      &#125; else if (s[i] == &#x27;]&#x27;) &#123;        // 遇到‘]’时,操作与之相配的‘[’之间的字符,使用分配律        int times = nums.top();        nums.pop();        for (int j = 0; j &lt; times; ++j)          strs.top() += res;        res = strs.top();        strs.pop();      &#125; else &#123;        res = res + s[i];      &#125;    &#125;    return res;  &#125;&#125;;\n二叉树的中序遍历\n给定一个二叉树，返回它的中序遍历。\n\n\n思路：通过stack 保存已经访问的元素，用于原路返回。由于中序遍历是左-&gt;根-&gt;右，所以要保证有左子树的情况下左子树在栈顶\n\nclass Solution &#123; public:  std::vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;    std::stack&lt;TreeNode*&gt; s;    std::vector&lt;int&gt; res;    while (root || !s.empty()) &#123;      while (root) &#123;        s.push(root);        root = root-&gt;left;\t// 一直向左      &#125;      // 弹出      root = s.top();      s.pop();      res.push_back(root-&gt;val);      root = root-&gt;right;    &#125;    return res;  &#125;&#125;;\n\n克隆图\n给你无向连通图中一个节点的引用，请你返回该图的深拷贝（克隆）\n\n\n思路：由于节点数不会超过100个，所以可以提前创建一个大小为101的 Node * 类型的vector容器nodes，用于存放所有节点。然后通过辅助栈，从给定节点开始遍历原图。遍历的方法是：从当前节点开始，把它所有的邻居节点入栈。遍历的过程中，会遇到以下几种情况：\n\n当前节点是第一次被访问。此时nodes中对应的节点的 val 必定还是0（默认构造函数），对nodes中的节点的 val 进行赋值，并把所有的邻居节点push到其neighbors字段中，同时把原图对应的节点入栈。\n当前节点已经被访问。判断的依据是nodes数组中的节点 val 已经不是0，直接跳过即可。等遍历完毕后，nodes存储的就是一张原图的深拷贝，只需要返回初始节点对应的nodes中的节点即可\n\n\n/*// Definition for a Node.class Node &#123;public:    int val;    vector&lt;Node*&gt; neighbors;    Node() &#123;        val = 0;        neighbors = vector&lt;Node*&gt;();    &#125;    Node(int _val) &#123;        val = _val;        neighbors = vector&lt;Node*&gt;();    &#125;    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;        val = _val;        neighbors = _neighbors;    &#125;&#125;;*/class Solution &#123; public:  Node* cloneGraph(Node* node) &#123;    if (!node)      return nullptr;    stack&lt;Node*&gt; stack;    vector&lt;Node*&gt; nodes(101);    for (int i = 0; i &lt; 101; ++i) &#123;      nodes[i] = new Node();    &#125;    stack.push(node);    while (!stack.empty()) &#123;      Node* cur = stack.top();      stack.pop();      int val = cur-&gt;val;      if (nodes[val]-&gt;val == 0) &#123;        nodes[val]-&gt;val = val;        for (auto n : cur-&gt;neighbors) &#123;          (nodes[val]-&gt;neighbors).push_back(nodes[n-&gt;val]);          stack.push(n);        &#125;      &#125;    &#125;    return nodes[node-&gt;val];  &#125;&#125;;\n\n\n\n（未完待续）\n","categories":["算法交流"],"tags":["数据结构"]},{"title":"数据结构之链表","url":"/1091615714.html","content":"链表链表相关的核心点\nNULL 异常处理\ndummy node(哑巴节点)\n快慢指针\n插入一个节点到排序链表\n从一个链表中移除一个节点\n翻转链表\n合并两个链表\n找到链表的中间节点\n\n哑巴节点哑节点（dummy node）是初始值为NULL的节点，创建在使用到链表的函数中，可以起到避免处理头节点为空的边界问题的作用，减少代码执行异常的可能性。也就是说，哑节点的使用可以对代码起到简化作用（省略当函数的入口参数为空时的判断）。\n// 普通结构体struct ListNode &#123;    int val;    struct ListNode *next;&#125;;// 定义函数ListNode *addNode( ListNode *node, int num)&#123;\t// 函数返回的是尾节点    struct ListNode *new = (struct ListNode*) malloc(sizeof(struct ListNode) * num);    node-&gt;next = new;    return new;&#125;// 问题是当node节点为空时，便会产生异常，node-&gt;next = new会报错，应该修改如下ListNode *addNode( ListNode *node, int num)&#123;\t// 函数返回的是尾节点    struct ListNode *new = (struct ListNode*) malloc( sizeof(struct ListNode) * num );    if( null == node )&#123;\t\t\t\t\t\t\t// 头节点为空的情况        return new;\t\t\t\t\t\t\t\t// 直接返回新建的节点（头节点的地址），相当于新建了一组链表    &#125;    node-&gt;next = new;    return new;&#125;// 定义哑节点如下struct ListNode *dummyNode= (struct ListNode*) malloc(sizeof(struct ListNode));dummyNode-&gt;val = NULL;dummyNode-&gt;next = NULL;// 函数addNode()重新定义如下ListNode *addNode( ListNode *dummyNode, int num) \t// 函数返回的是尾节点    struct ListNode *new = (struct ListNode*) malloc( sizeof(struct ListNode) * num );    /* 此处不再需要处理头节点为空的情况，因为dummyNode一定非空 */    dummyNode-&gt;next = new;    return new;&#125;\n\n快慢指针快慢指针就是定义两根指针，移动的速度一快一慢，以此来制造出自己想要的差值。这个差值可以让我们找到链表上相应的节点。比如，我们把一个链表看成一个跑道，假设a的速度是b的两倍，那么当a跑完全程后，b刚好跑一半，以此来达到找到中间节点的目的。\n常见题型 删除排序链表中的重复元素\n\n给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。\n\n/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */// 递归class Solution &#123;public:    ListNode* deleteDuplicates(ListNode* head) &#123;        if(head == NULL) &#123;            return head;        &#125;        if(head-&gt;next)&#123;            head-&gt;next = deleteDuplicates(head-&gt;next);            if(head-&gt;val == head-&gt;next-&gt;val) &#123;                head = head-&gt;next;\t\t// 删除head            &#125;        &#125;        return head;    &#125;&#125;;// 迭代class Solution &#123;public:    ListNode* deleteDuplicates(ListNode* head) &#123;        ListNode* current = head;        while(current) &#123;            while(current-&gt;next &amp;&amp; current-&gt;val == current-&gt;next-&gt;val) &#123;                current-&gt;next = current-&gt;next-&gt;next;            &#125;            current = current-&gt;next;        &#125;        return head;    &#125;&#125;;\n\n删除排序链表中的重复元素 II\n\n给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现的数字。\n\n思路：链表头结点可能被删除，所以用dummy node辅助删除\n// 递归class Solution &#123;public:    ListNode* deleteDuplicates(ListNode* head) &#123;        if(head == NULL)            return head;        if(head-&gt;next &amp;&amp; head-&gt;val == head-&gt;next-&gt;val) &#123;            while(head-&gt;next &amp;&amp; head-&gt;val == head-&gt;next-&gt;val) &#123;                head = head-&gt;next;            &#125;            return deleteDuplicates(head-&gt;next);        &#125; else &#123;            head-&gt;next = deleteDuplicates(head-&gt;next);        &#125;        return head;    &#125;&#125;;// 迭代class Solution &#123;public:    ListNode* deleteDuplicates(ListNode* head) &#123;        if(head == NULL) &#123;            return head;        &#125;        // 链表头结点可能被删除，所以用dummy node辅助删除        struct ListNode *dummyNode= (struct ListNode*) malloc(sizeof(struct ListNode));        dummyNode-&gt;next = head;        head = dummyNode;\t// 之后不管head怎么移动，dummyNode-&gt;next就是head移动完的链表的头结点        int temp;        while(head-&gt;next &amp;&amp; head-&gt;next-&gt;next) &#123;            if(head-&gt;next-&gt;val == head-&gt;next-&gt;next-&gt;val) &#123;                temp = head-&gt;next-&gt;val;                while(head-&gt;next &amp;&amp; head-&gt;next-&gt;val == temp) &#123;                    head-&gt;next = head-&gt;next-&gt;next;                &#125;            &#125; else &#123;                head = head-&gt;next;            &#125;        &#125;        return dummyNode-&gt;next;    &#125;&#125;;\n\n注意点◉ A-&gt;B-&gt;C 删除 B，A-&gt;next &#x3D; C◉ 删除用一个dummy node节点辅助（允许头节点可变）◉ 访问 X-&gt;next 、X-&gt;value 一定要保证 X !&#x3D; NULL\n反转链表\n\n反转一个单链表。\n\n思路：用一个prev节点保存向前指针，next保存向后的临时指针\n// 递归，参考https://leetcode-cn.com/problems/reverse-linked-list/solution/zhu-bu-tu-jie-di-gui-die-dai-by-sucongcjs/class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        if (head == NULL || head-&gt;next == NULL) &#123;            return head;        &#125;        ListNode* ret = reverseList(head-&gt;next);        head-&gt;next-&gt;next = head;        head-&gt;next = NULL;        return ret;    &#125;&#125;;// 迭代class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        ListNode *next = NULL;        ListNode *prev = NULL;        while(head) &#123;            /**             * 保存当前head-&gt;next节点，防止重新赋值后被覆盖             * 一轮之后状态：NULL &lt;- 1      2 -&gt; 3 -&gt; 4             *                   prev   head             */            next = head-&gt;next;            head-&gt;next = prev;            prev = head;\t\t// prev 移动            head = next;\t\t// head 移动        &#125;        return prev;    &#125;&#125;;\n\n反转链表 II\n\n反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。\n\n思路：先遍历到 m 处，翻转，再拼接后续，注意指针处理\n// 递归，参考https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/bu-bu-chai-jie-ru-he-di-gui-di-fan-zhuan-lian-biao/class Solution &#123;public:    ListNode* successor = NULL; // 后驱节点    // 反转以 head 为起点的 n 个节点，返回新的头结点    ListNode* reverseN(ListNode* head, int n) &#123;        if (n == 1) &#123;            // 记录第 n + 1 个节点            successor = head-&gt;next;            return head;        &#125;        // 以 head.next 为起点，需要反转前 n - 1 个节点        ListNode* last = reverseN(head-&gt;next, n - 1);        head-&gt;next-&gt;next = head;        // 让反转之后的 head 节点和后面的节点连起来        head-&gt;next = successor;        return last;    &#125;    ListNode* reverseBetween(ListNode* head, int m, int n) &#123;        // base case        if (m == 1) &#123;            return reverseN(head, n);        &#125;        // 前进到反转的起点触发 base case        head-&gt;next = reverseBetween(head-&gt;next, m - 1, n - 1);        return head;    &#125;&#125;;// 迭代class Solution &#123; public:  ListNode* reverseBetween(ListNode* head, int m, int n) &#123;    // 思路：先遍历到m处，翻转，再拼接后续，注意指针处理    // 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4    if (head == NULL) &#123;      return head;    &#125;    // 头部变化所以使用dummy node    ListNode* dummyNode = (struct ListNode*)malloc(sizeof(struct ListNode));    dummyNode-&gt;next = head;    head = dummyNode;    // 最开始：0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL    ListNode* pre = NULL;    int i = 0;    while (i &lt; m) &#123;      pre = head;      head = head-&gt;next;      i++;    &#125;    // 遍历之后： 1(pre)-&gt;2(head)-&gt;3-&gt;4-&gt;5-&gt;NULL    // i = 1    int j = i;    ListNode* next = NULL;    ListNode* mid = head;  // 用于中间节点连接    while (head != NULL &amp;&amp; j &lt;= n) &#123;      // 第一次循环： 1(pre) NULL&lt;-2 3(head)-&gt;4-&gt;5-&gt;NULL      ListNode* temp = head-&gt;next;      head-&gt;next = next;      next = head;      head = temp;      j++;    &#125;    // 循环需要执行四次    // 循环结束：1(pre) NULL&lt;-2&lt;-3&lt;-4 5(head)-&gt;NULL    pre-&gt;next = next;    mid-&gt;next = head;    return dummyNode-&gt;next;  &#125;&#125;;\n\n合并两个有序链表\n\n将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\n\n思路：通过 dummy node 链表，连接各个元素\n// 递归class Solution &#123;public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;        if (l1 == nullptr) &#123;            return l2;        &#125; else if (l2 == nullptr) &#123;            return l1;        &#125; else if (l1-&gt;val &lt; l2-&gt;val) &#123;            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);            return l1;        &#125; else &#123;            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);            return l2;        &#125;    &#125;&#125;;// 迭代class Solution &#123; public:  ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;    if (l1 == NULL) &#123;      return l2;    &#125; else if (l2 == NULL) &#123;      return l1;    &#125;    // 头部变化所以使用dummy node    ListNode* dummyNode = (struct ListNode*)malloc(sizeof(struct ListNode));    ListNode* head = dummyNode;    while (l1 != NULL &amp;&amp; l2 != NULL) &#123;      if (l1-&gt;val &lt; l2-&gt;val) &#123;        head-&gt;next = l1;        l1 = l1-&gt;next;      &#125; else &#123;        head-&gt;next = l2;        l2 = l2-&gt;next;      &#125;      head = head-&gt;next;    &#125;    while (l1 != NULL) &#123;      head-&gt;next = l1;      head = head-&gt;next;      l1 = l1-&gt;next;    &#125;    while (l2 != NULL) &#123;      head-&gt;next = l2;      head = head-&gt;next;      l2 = l2-&gt;next;    &#125;    return dummyNode-&gt;next;  &#125;&#125;;\n\n分隔链表\n\n给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。\n\n思路：将大于 x 的节点，放到另外一个链表，最后连接这两个链表\n// 迭代class Solution &#123; public:  ListNode* partition(ListNode* head, int x) &#123;    if (head == NULL) &#123;      return head;    &#125;    ListNode* headDummy = (struct ListNode*)malloc(sizeof(struct ListNode));    headDummy-&gt;next = head;    head = headDummy;    ListNode* tailDummy = (struct ListNode*)malloc(sizeof(struct ListNode));    ListNode* tail = tailDummy;    while (head-&gt;next) &#123;      if (head-&gt;next-&gt;val &lt; x) &#123;        head = head-&gt;next;      &#125; else &#123;        // 移除&lt;x节点        ListNode* temp = head-&gt;next;        head-&gt;next = head-&gt;next-&gt;next;        // 放到另外一个链表        tail-&gt;next = temp;        tail = tail-&gt;next;      &#125;    &#125;    // 拼接两个链表    tail-&gt;next = NULL;    head-&gt;next = tailDummy-&gt;next;    return headDummy-&gt;next;  &#125;&#125;;\n\n哑巴节点使用场景\n\n当头节点不确定的时候，使用哑巴节点\n\n排序链表\n\n在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。\n\n思路：归并排序，找中点和合并操作\n// 链表排序， 归并递归排序class Solution &#123; public:  ListNode *sortList(ListNode *head) &#123;    return (head == NULL) ? NULL : mergeSort(head);  &#125; private:  ListNode *findMid(ListNode *head) &#123;    ListNode *slow = head;    ListNode *fast = head;    ListNode *previous = NULL;    while (fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123;      previous = slow;      slow = slow-&gt;next;      fast = fast-&gt;next-&gt;next;    &#125;    // split the list into two parts    previous-&gt;next = NULL;    return slow;  &#125;  ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123;    if (l1 == NULL) return l2;    if (l2 == NULL) return l1;    if (l1-&gt;val &lt; l2-&gt;val) &#123;      l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);      return l1;    &#125; else &#123;      l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);      return l2;    &#125;  &#125;  ListNode *mergeSort(ListNode *head) &#123;    if (head-&gt;next == NULL) return head;    ListNode *mid = findMid(head);    ListNode *l1 = mergeSort(head);    ListNode *l2 = mergeSort(mid);    return mergeTwoLists(l1, l2);  &#125;&#125;;\n\n注意点\n\n快慢指针 判断 fast 及 fast-&gt;next 是否为 NULL 值\n递归 mergeSort 需要断开中间节点\n递归返回条件为 head 为 NULL或者 head-&gt;next 为 NULL\n\n重排链表\n\n给定一个单链表 L：L→L→…→L__n→L 将其重新排列后变为： L→L__n→L→L__n→L→L__n→…\n\n思路：1.快慢指针找到中点 2.拆成两个链表 3.遍历两个链表，后面的塞到前面的“缝隙里”\nclass Solution &#123; public:  void reorderList(ListNode *head) &#123;    if (head == NULL || head-&gt;next == NULL) return;    // 快慢指针分出两段    ListNode *slow = head;    ListNode *fast = head;    while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;      slow = slow-&gt;next;      fast = fast-&gt;next-&gt;next;    &#125;    // 拆成两个链表    ListNode *needReverser = slow-&gt;next;    slow-&gt;next = NULL;    // 后端反转,反转用上面的反转链表I    needReverser = reverseList(needReverser);    // 插入前端缝隙    ListNode *cur = head;    while (cur &amp;&amp; needReverser) &#123;      ListNode *curSecond = needReverser;      needReverser = needReverser-&gt;next;      ListNode *nextCur = cur-&gt;next;      curSecond-&gt;next = cur-&gt;next;      cur-&gt;next = curSecond;      cur = nextCur;    &#125;  &#125;  ListNode *reverseList(ListNode *head) &#123;    if (head == NULL || head-&gt;next == NULL) &#123;      return head;    &#125;    ListNode *ret = reverseList(head-&gt;next);    head-&gt;next-&gt;next = head;    head-&gt;next = NULL;    return ret;  &#125;  // 第二种反转  ListNode *reverse(ListNode *head) &#123;    ListNode *next = NULL;    ListNode *prev = NULL;    while (head) &#123;      next = head-&gt;next;      head-&gt;next = prev;      prev = head;  // prev 移动      head = next;  // head 移动    &#125;    return prev;  &#125;&#125;;\n\n环形链表\n\n给定一个链表，判断链表中是否有环。\n\n思路：快慢指针，快慢指针相同则有环(因为fast快，slow慢，所以如果有环fast最后一定会追上slow)，\n证明：如果有环每走一步快慢指针距离会减 1\n\nclass Solution &#123; public:  bool hasCycle(ListNode *head) &#123;    if (!head || !head-&gt;next) &#123;      return false;    &#125;    // 直接套用上面快慢指针写法    ListNode *slow = head;    ListNode *fast = head;    while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;      if(!slow-&gt;next) &#123;        return false;\t\t// 稍微加个判断，减少下用时      &#125;      slow = slow-&gt;next;      fast = fast-&gt;next-&gt;next;      if (fast == slow) &#123;        return true;      &#125;    &#125;    return false;  &#125;&#125;;// 另一种表示方法是fast = head-&gt;next;slow = head;// 两种方式不同点在于，一般用 fast=head-&gt;next 较多,因为这样可以知道中点的上一个节点，可以用来删除等操作// fast 如果初始化为 head-&gt;next 则中点在 slow-&gt;next// fast 初始化为 head ,则中点在 slow\n\n环形链表 II\n\n给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n\n思路：快慢指针，快慢相遇之后，慢指针回到头，快慢指针步调一致一起移动，相遇点即为入环点看下图：F为第一个节点-F到入环点0的距离；a为入环点0到相遇点h距离；b为相遇点h到入环点0距离；当fast和slow相遇时，fast走过的是slow的两倍，设slow走过为S，则S&#x3D;F+a，2S&#x3D;F+a+b+a，故F&#x3D;b；现在让slow返回第一个节点，fast处于第一次相遇的节点，此时slow从第一个节点出发，因为F&#x3D;b，所以fast和slow会在入环口第二次相遇，即为所求节点。\n\nclass Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        if (!head || !head-&gt;next) &#123;            return NULL;        &#125;        bool hasCycle = false;        // 先判断是否有环        ListNode *slow = head;        ListNode *fast = head;        while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;            slow = slow-&gt;next;            fast = fast-&gt;next-&gt;next;            if (fast == slow) &#123;                hasCycle = true;                break;            &#125;        &#125;        // 有环则找入环开始的节点        if (hasCycle) &#123;            slow = head;            while (slow != fast) &#123;                slow = slow-&gt;next;                fast = fast-&gt;next;            &#125;            return slow;        &#125;        return NULL;    &#125;&#125;;\n\n\n\n坑点\n\n指针比较时直接比较对象，不要用值比较，链表中有可能存在重复值情况\n第一次相交后，快指针需要从下一个节点开始和头指针一起匀速移动\n\n回文链表\n\n请判断一个链表是否为回文链表。\n\n取中间分开链表，反转后面的链表，如果和前面的重合则为回文链表\n/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode *reverse(ListNode *head) &#123;        ListNode *next = NULL;        ListNode *prev = NULL;        while (head) &#123;            next = head-&gt;next;            head-&gt;next = prev;            prev = head;  // prev 移动            head = next;  // head 移动        &#125;        return prev;    &#125;    bool isPalindrome(ListNode* head) &#123;        if (head == NULL) &#123;            return true;        &#125;        ListNode *left = head;        ListNode *right = head;        while (right-&gt;next &amp;&amp; right-&gt;next-&gt;next) &#123;            left = left-&gt;next;            right = right-&gt;next-&gt;next;        &#125;        ListNode *middle = reverse(left);        left-&gt;next = NULL;        while (middle &amp;&amp; head) &#123;            if(head-&gt;val != middle-&gt;val) &#123;                return false;            &#125;            head = head-&gt;next;            middle = middle-&gt;next;        &#125;        return true;    &#125;&#125;;\n\n\n\n复制带随机指针的链表\n\n给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。 要求返回这个链表的深拷贝。\n\n思路：1、hash 表存储指针，2、复制节点跟在原节点后面，如A-&gt;B-&gt;C 变为 A-&gt;A’-&gt;B-&gt;B’-&gt;C-&gt;C’，3、设置节点random值4、将复制链表从原链表分离，如A-&gt;B-&gt;C和A’-&gt;B’-&gt;C’\n/*// Definition for a Node.class Node &#123;public:    int val;    Node* next;    Node* random;    Node(int _val) &#123;        val = _val;        next = NULL;        random = NULL;    &#125;&#125;;*/class Solution &#123;public:    Node* copyRandomList(Node* head) &#123;        if (!head) &#123;            return head;        &#125;        // 复制节点 (遍历链表,在当前节点后插入副本节点)        Node* cur = head;        while (cur) &#123;            Node* clone = new Node(cur-&gt;val, NULL, NULL);            clone-&gt;next = cur-&gt;next;            Node* temp = cur-&gt;next;            cur-&gt;next = clone;            cur = temp;        &#125;        // 对副本节点设置random指针        cur = head;        // 因为复制了节点，cur-&gt;next不会为空 最终是cur为空        while (cur) &#123;            if (cur-&gt;random != NULL) &#123;                // 注意：原链表中cur-&gt;random可能为空                cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;            &#125;            cur = cur-&gt;next-&gt;next;        &#125;        // 分离出原链表与副本链表        cur = head;        Node* new_head = head-&gt;next; // 副本链表的头节点        Node* new_tail = new_head;   // 副本链表的尾节点        while (cur) &#123;            cur-&gt;next = cur-&gt;next-&gt;next;            if (new_tail -&gt; next != NULL) &#123;                new_tail-&gt;next = new_tail-&gt;next-&gt;next;            &#125;            cur = cur-&gt;next;            // 注意：最后cur为空的情况            new_tail = new_tail-&gt;next;        &#125;        return new_head;    &#125;&#125;;\n\n是不是看不懂复制节点那一步，图解在这。\n\n总结链表必须要掌握的一些点，通过下面练习题，基本大部分的链表类的题目都是手到擒来~\n\nnull&#x2F;nil 异常处理\ndummy node 哑巴节点\n快慢指针\n插入一个节点到排序链表\n从一个链表中移除一个节点\n翻转链表\n合并两个链表\n找到链表的中间节点\n\n","categories":["算法交流"],"tags":["数据结构"]},{"title":"数组排列问题","url":"/3805883677.html","content":"一、下一个排列（中）题目整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。\n\n例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。\n\n整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。\n\n例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。\n类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。\n而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。\n\n给你一个整数数组 nums ，找出 nums 的下一个排列。必须 原地 修改，只允许使用额外常数空间。\n示例 1：输入：$nums &#x3D; [1,2,3]$输出：$[1,3,2]$\n示例 2：输入：$nums &#x3D; [3,2,1]$输出：$[1,2,3]$\n示例 3：输入：$nums &#x3D; [1,1,5]$输出：$[1,5,1]$\n提示：$1 &lt;&#x3D; nums.length &lt;&#x3D; 100$$0 &lt;&#x3D; nums[i] &lt;&#x3D; 100$\n题解怎么说呢，首先你得读懂题目。就是按照升序排序，然后依次选取次大的元素进行排序组合。\n举个例子，$[1,2,3]-[1,3,2]-[2,1,3]-[2,3,1]-[3,1,2]-[3,2,1]$所以$[1,2,3]$下一个排列就是$[1,3,2]$\n这道题记住思路，就很容易解决。1、从右开始遍历，先找出第一个索引$i$，满足$nums[i] &lt; nums[i+1]$，如果不存在，就翻转整个数组；2、再从右开始遍历，找出第二个索引$j$，满足$nums[j] &gt; nums[i]$；3、交换$nums[j]$和$nums[i]$；4、最后翻转$nums[i+1:]$。\n比如$nums &#x3D; [1,2,7,4,3,1]$，下一个排列是什么？我们找到第一个索引是$nums[1] &#x3D; 2$；再找到第二个索引是$nums[4] &#x3D; 3$；交换，$nums &#x3D; [1,3,7,4,2,1]$；翻转，$nums &#x3D; [1,3,1,2,4,7]$。\nclass Solution &#123; public:  void nextPermutation(vector&lt;int&gt;&amp; nums) &#123;    if (nums.size() == 0) &#123;      return;    &#125;    int firstIndex = -1;    for (int i = nums.size() - 2; i &gt;= 0; i--) &#123;      if (nums[i] &lt; nums[i + 1]) &#123;        firstIndex = i;        break;      &#125;    &#125;    if (firstIndex == -1) &#123;      reverse(nums.begin(), nums.end());      return;    &#125;    int secondIndex = -1;    for (int i = nums.size() - 1; i &gt; 0; i--) &#123;      if (nums[i] &gt; nums[firstIndex]) &#123;        secondIndex = i;        break;      &#125;    &#125;    int temp = nums[firstIndex];    nums[firstIndex] = nums[secondIndex];    nums[secondIndex] = temp;    reverse(nums.begin() + firstIndex + 1, nums.end());  &#125;&#125;;\n\n二、上一个排列（中）题目给定一个整数数组来表示排列，按升序找出其上一个排列。\n示例 1：输入：$nums &#x3D; [1]$输出：$[1]$\n示例 2：输入：$nums &#x3D; [1,3,2,3]$输出：$[1,2,3,3]$\n示例 3：输入：$nums &#x3D; [1,2,3,4]$输出：$[4,3,2,1]$\n提示：$1 &lt;&#x3D; nums.length &lt;&#x3D; 100$$0 &lt;&#x3D; nums[i] &lt;&#x3D; 100$\n题解跟下一个排列一样，只不过求的是上一个，而不是下一个。\n举个例子，$[1,2,3]-[1,3,2]-[2,1,3]-[2,3,1]-[3,1,2]-[3,2,1]$所以$[1,3,2]$上一个排列就是$[1,2,3]$\n所以只需要根据第一题的代码，只用把遍历里的&gt;换成&lt;即可。1、从右开始遍历，先找出第一个索引$i$，满足$nums[i] &gt; nums[i+1]$，如果不存在，就翻转整个数组；2、再从右开始遍历，找出第二个索引$j$，满足$nums[j] &lt; nums[i]$；3、交换$nums[j]$和$nums[i]$；4、最后翻转$nums[i+1:]$。\nclass Solution &#123; public:  void prevPermutation(vector&lt;int&gt;&amp; nums) &#123;    if (nums.size() == 0) &#123;      return;    &#125;    int firstIndex = -1;    for (int i = nums.size() - 2; i &gt;= 0; i--) &#123;      if (nums[i] &gt; nums[i + 1]) &#123;        firstIndex = i;        break;      &#125;    &#125;    if (firstIndex == -1) &#123;      reverse(nums.begin(), nums.end());      return;    &#125;    int secondIndex = -1;    for (int i = nums.size() - 1; i &gt; 0; i--) &#123;      if (nums[i] &lt; nums[firstIndex]) &#123;        secondIndex = i;        break;      &#125;    &#125;    int temp = nums[firstIndex];    nums[firstIndex] = nums[secondIndex];    nums[secondIndex] = temp;    reverse(nums.begin() + firstIndex + 1, nums.end());  &#125;&#125;;\n\n三、交换一次的先前排列（中）题目给你一个正整数数组 arr（可能存在重复的元素），请你返回可在 一次交换（交换两数字 arr[i] 和 arr[j] 的位置）后得到的、按字典序排列小于 arr 的最大排列。如果无法这么操作，就请返回原数组。\n示例 1：输入：$arr &#x3D; [3,2,1]$输出：$[3,1,2]$解释：交换 2 和 1\n示例 2：输入：$arr &#x3D; [1,1,5]$输出：$[1,1,5]$解释：已经是最小排列\n示例 3：输入：$arr &#x3D; [1,9,4,6,7]$输出：$[1,7,4,6,9]$解释：交换 9 和 7\n提示：$1 &lt;&#x3D; arr.length &lt;&#x3D; 10^4$$1 &lt;&#x3D; arr[i] &lt;&#x3D; 10^4$\n题解这题跟我『上一个排列』差不多，主要是它找的排列是两个元素调换位置的，不像『上一个排列』那样，元素可以全部重排。\n那首先照搬『上一个排列』解法，最后交换 firstIndex 和 secondIndex ，不用 reverse 逆序排列。\nclass Solution &#123; public:  vector&lt;int&gt; prevPermOpt1(vector&lt;int&gt;&amp; nums) &#123;    if (nums.size() == 0) &#123;      return nums;    &#125;    int firstIndex = -1;    for (int i = nums.size() - 2; i &gt;= 0; i--) &#123;      if (nums[i] &gt; nums[i + 1]) &#123;        firstIndex = i;        break;      &#125;    &#125;    if (firstIndex == -1) &#123;      return nums;    &#125;    int secondIndex = -1;    for (int i = nums.size() - 1; i &gt; 0; i--) &#123;      if (nums[i] &lt; nums[firstIndex]) &#123;        if (nums[i] == nums[i - 1]) &#123;          // 防止有相邻重复元素出现,比如[3,1,1,4]          continue;        &#125;        secondIndex = i;        break;      &#125;    &#125;    int temp = nums[firstIndex];    nums[firstIndex] = nums[secondIndex];    nums[secondIndex] = temp;    return nums;  &#125;&#125;;\n","categories":["算法交流"],"tags":["刷题笔记"]},{"title":"数据结构之入门篇","url":"/1699436293.html","content":"前言算法模板，最科学的刷题方式，最快速的刷题路径，一个月从入门到 offer，你值得拥有 🐶~\n算法模板顾名思义就是刷题的套路模板，掌握了刷题模板之后，刷题也变得好玩起来了~\n此项目是根据github大佬项目改写的C++版本（大佬的是Go版本），从0开始学习，通过各种刷题文章、专栏、视频等总结了一套自己的刷题模板。\n这个模板主要是介绍了一些通用的刷题模板，以及一些常见问题，如到底要刷多少题，按什么顺序来刷题，如何提高刷题效率等。\n数据结构与算法数据结构是一种数据的表现形式，如链表、二叉树、栈、队列等都是内存中一段数据表现的形式。 算法是一种通用的解决问题的模板或者思路，大部分数据结构都有一套通用的算法模板，所以掌握这些通用的算法模板即可解决各种算法问题。\n后面会分专题讲解各种数据结构、基本的算法模板、和一些高级算法模板，每一个专题都有一些经典练习题，完成所有练习的题后，你对数据结构和算法会有新的收获和体会。\n先介绍两个算法题，试试感觉~\n1、实现 strStr()\n\n给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从 0 开始)。如果不存在，则返回 -1。\n\n思路：核心点遍历给定字符串字符，判断以当前字符开头字符串是否等于目标字符串\nclass Solution &#123; public:  int strStr(string haystack, string needle) &#123;    if (needle.size() == 0) &#123;      return 0;    &#125;    if (needle.size() &gt; haystack.size()) &#123;      return -1;    &#125;    int i, j;    for (i = 0; i &lt; haystack.size() - needle.size() + 1; i++) &#123;      for (j = 0; j &lt; needle.size(); j++) &#123;        if (haystack[i + j] != needle[j]) &#123;          break;        &#125;      &#125;      if (needle.size() == j) &#123;        return i;      &#125;    &#125;    return -1;  &#125;&#125;;\n\n\n需要注意点\n\n循环时，i 不需要到 len-1\n如果找到目标字符串，len(needle)&#x3D;&#x3D;j\n\n（下一步，试试KMP算法）\n2、子集\n\n给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。\n\n思路：这是一个典型的应用回溯法的题目，简单来说就是穷尽所有可能性，算法模板如下\nresult = []def backtrack(路径, 选择列表):    if 满足结束条件:        result.add(路径)        return    for 选择 in 选择列表:        做选择        backtrack(路径, 选择列表)        撤销选择\n\n\n通过不停的选择，撤销选择，来穷尽所有可能性，最后将满足条件的结果返回\n答案代码\nvector&lt;vector&lt;int&gt;&gt; res;vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;    // 记录走过的路径    vector&lt;int&gt; track;    backtrack(nums, 0, track);    return res;&#125;// 路径：记录在 track 中// 选择列表：nums 中不存在于 track 的那些元素// 结束条件：nums 中的元素全都在 track 中出现void backtrack(vector&lt;int&gt;&amp; nums, int start, vector&lt;int&gt;&amp; track) &#123;    res.push_back(track);    // 注意 i 从 start 开始递增    for (int i = start; i &lt; nums.size(); i++) &#123;        // 做选择        track.push_back(nums[i]);        // 回溯，进入下一层决策树        backtrack(nums, i + 1, track);        // 撤销选择        track.pop_back();    &#125;&#125;\n\n可以看见，对 res 的更新是一个前序遍历，也就是说，res 就是树上的所有节点：\n\n说明：后面会深入讲解几个典型的回溯算法问题，如果当前不太了解可以暂时先跳过（可参考这个）\n简单法：\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;        int size = nums.size();        vector&lt;vector&lt;int&gt;&gt; obj;        vector&lt;int&gt; outArray;        for (int i:nums) &#123;            int len = obj.size();            obj.push_back(&#123;i&#125;);            for (int j = 0; j &lt; len ; j++) &#123;                outArray = obj[j];                outArray.push_back(i);                obj.push_back(outArray);            &#125;        &#125;        obj.push_back(&#123;&#125;);        return obj;    &#125;&#125;;\n\n\n面试注意点我们大多数时候，刷算法题可能都是为了准备面试，所以面试的时候需要注意一些点\n\n快速定位到题目的知识点，找到知识点的通用模板，可能需要根据题目特殊情况做特殊处理。\n先去朝一个解决问题的方向！先抛出可行解，而不是最优解！先解决，再优化！\n代码的风格要统一，熟悉各类语言的代码规范。\n命名尽量简洁明了，尽量不用数字命名如：i1、node1、a1、b2\n\n\n常见错误总结\n访问下标时，不能访问越界\n空值 null 问题 run time error\n\n\n\n","categories":["算法交流"],"tags":["数据结构"]},{"title":"斐波那契数列递归算法的时间复杂度","url":"/1050747593.html","content":"前言一直以为斐波那契数列暴力递归的时间复杂度是$O(2^{n})$，百度了才发现，实际紧界时间复杂度应该是$O((\\frac{1+\\sqrt{5}}{2})^{n})$。但其实$O(2^{n})$应该也没错，毕竟求时间复杂度是只要求量级不管系数。\n证明紧界时间复杂度证明斐波那契数列的计算过程很简单。就是简单的$F(n) &#x3D; F(n-1) + F(n-2)$我们把计算$F(i)$所需的时间记为$T(i)$。然后记计算加法所需的时间为1，那么显然有$T(n) &#x3D; 1+ T(n-1) + T(n-2)$这一式子可以进行变形。两边同时加 1，得到$T(n)+1 &#x3D; (T(n-1)+1) + (T(n-2)+1)$记$A(n) &#x3D; T(n) + 1$，显然有$A(n) &#x3D; A(n-1) + A(n-2)$明显这是一个斐波那契数列，只不过初项有所不同\n但是注意，斐波那契数列的增长率与初项是无关的。证明如下：设某斐波那契数列的前两项为$a, b$，令$c &#x3D; max(a, b)$，显然这个数列的增长速度不会超过以$c, c$为前两项的斐波那契数列。而这个斐波那契数列就是$c, c, 2c, 3c, 5c, 8c, …, F(n)c$，即$c(1, 1, 2, 3, 5, 8, …, F(n))$而$c$是个常数，因此斐波那契数列无论初项是多少，渐进增长率都是相同的。所以$A(n)$的渐进增长率与$F(n)$相同，而$T(n) &#x3D; A(n) - 1$，增长率也是一样的\n所以$T(n) ∈ O(F(n))$百度可以知道斐波那契数列$F(n) &#x3D; \\frac{1}{\\sqrt{5}}[(\\frac{1+\\sqrt{5}}{2})^{n}-(\\frac{1-\\sqrt{5}}{2})^{n}]$所以$T(n) ∈ O((\\frac{1+\\sqrt{5}}{2})^{n})$\n量级时间复杂度证明我们可以根据函数递归执行顺序画出下图的二叉树结构（假设求第五个斐波那契数）\ngraph TD\nA((\"F(5)\")) --> B((\"F(4)\"))\nA((\"F(5)\")) --> C((\"F(3)\"))\nB((\"F(4)\")) --> D((\"F(3)\"))\nB((\"F(4)\")) --> E((\"F(2)\"))\nC((\"F(3)\")) --> F((\"F(2)\"))\nC((\"F(3)\")) --> G((\"F(1)\"))\nD((\"F(3)\")) --> H((\"F(2)\"))\nD((\"F(3)\")) --> I((\"F(1)\"))\nE((\"F(2)\")) --> J(\"X\")\nE((\"F(2)\")) --> K(\"X\")\nF((\"F(2)\")) --> L(\"X\")\nF((\"F(2)\")) --> M(\"X\")\nG((\"F(1)\")) --> N(\"X\")\nG((\"F(1)\")) --> O(\"X\")\n带X为将斐波那契数列二叉树补齐成满二叉树，根据这个二叉树，可以得出几个特征：\n\n满二叉树层数为$n-1$，这里$n&#x3D;5$，所以有4层\n满二叉树第h层（第1层为首层）个数为$2^{h-1}$\n满二叉树总结点数为$2^{n-1}-1$，这里$n&#x3D;5$，所以满二叉树结点为15\n斐波那契数列二叉树总结点数为$2^{n-2}+1$，这里$n&#x3D;5$，斐波那契数列二叉树总结点数为9\n\n所以这个时间复杂度就是$O(2^{n-2}+1) &#x3D; O(2^{n})$\n","categories":["算法交流"],"tags":["常见算法"]},{"title":"正则表示 re.findall 用法","url":"/440403458.html","content":"前言re.findall作用是搜索字符串，以列表形式返回能匹配的字符。\n形式re.findall(pattern, string, flags=0)\n该方法有3个参数，第一个就是你写的正则表达式，第二个匹配的目标字符串，第三个是一个匹配模式。\n练习#search是找一个结果的，findall是查询所有结果的。import rehtml=&#x27;&#x27;&#x27;&lt;div id=&quot;songs-list&quot;&gt;    &lt;h2 class=&quot;title&quot;&gt;经典老歌&lt;/h2&gt;    &lt;p class=&quot;introduction&quot;&gt;        经典老歌列表    &lt;/p&gt;    &lt;ul id =&quot;list&quot; class=&quot;list-group&quot;&gt;        &lt;li data-view=&quot;2&quot;&gt;一路上有你&lt;/li&gt;        &lt;li data-view=&quot;7&quot;&gt;            &lt;a href=&quot;/2.mp3&quot; singer=&quot;任贤齐&quot;&gt;沧海一声笑&lt;/a&gt;        &lt;/li&gt;        &lt;li data-view=&quot;4&quot; class=&quot;active&quot;&gt;            &lt;a href=&quot;/3.mp3&quot; singer=&quot;齐秦&quot;&gt;往事随风&lt;/a&gt;        &lt;/li&gt;        &lt;li data-view=&quot;6&quot;&gt;&lt;a href=&quot;/4.mp3&quot; singer=&quot;beyond&quot;&gt;光辉岁月&lt;/a&gt;&lt;/li&gt;        &lt;li data-view=&quot;5&quot;&gt;&lt;a href=&quot;/5.mp3&quot; singer=&quot;陈惠琳&quot;&gt;记事本&lt;/a&gt;&lt;/li&gt;        &lt;li data-view=&quot;5&quot;&gt;            &lt;a href=&quot;/6.mp3&quot; singer=&quot;邓丽君&quot;&gt;但愿人长久&lt;/a&gt;        &lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;\n\n练习1：要求：匹配出li标签中既有歌手又有歌名的信息，包括超链接也匹配出来。分析：我们可以看出排除了歌曲”一路有你”，其余的歌曲，歌手，以及超链接都要匹配出来。\nresults = re.findall(&#x27;&lt;li.*?href=&quot;(.*?)&quot;.*?singer=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&#x27;,html,re.S)print(results)  #返回list，元素由tuple组成for result in results:    print(result) #返回每个tuple元素# 输出[(’/2.mp3’, ‘任贤齐’, ‘沧海一声笑’), (’/3.mp3’, ‘齐秦’, ‘往事随风’), (’/4.mp3’, ‘beyond’, ‘光辉岁月’), (’/5.mp3’, ‘陈惠琳’, ‘记事本’), (’/6.mp3’, ‘邓丽君’, ‘但愿人长久’)]\n\n练习2：要求：对上述html代码匹配出所有歌名。\n# * 表多个 ？表示前面匹配有或者没有,就到前面results = re.findall(&#x27;&lt;li.*?&gt;\\s*?(&lt;a.*?&gt;)?(\\w+)(&lt;/a&gt;)?\\s*?&lt;/li&gt;&#x27;,html,re.S)print(results)# 输出[(’’, ‘一路上有你’, ‘’), (’’, ‘沧海一声笑’, ‘’), (’’, ‘往事随风’, ‘’), (’’, ‘光辉岁月’, ‘’), (’’, ‘记事本’, ‘’), (’’, ‘但愿人长久’, ‘’)]\n练习3：要求：对于string类型数据，筛选出两个子串之间的内容\ns_data = &#x27;&#123;&quot;STGraph&quot;: &#123;&quot;Index&quot;: 10,&quot;planning&quot; : [&quot;Now: 1390.04, Gap: 0.10&quot;],&quot;mp_intention&quot; : &#123; &quot;maneuver_name&quot;: &quot;FOLLOW&quot;, &quot;scenario&quot;: 0, &quot;flag_to_stop&quot;: 0&#125;&#125;&#125;&#x27;# re.findall格式为re.findall(&#x27;sub_str_a, sub_str_b&#x27;, str_data, re.S),返回listresult_1 = re.findall(&#x27;.*?&quot;planning&quot; :(.*?),&quot;mp_intention&quot;&#x27;, s_data, re.S)# [&#x27; [&quot;Now: 1390.04, Gap: 0.10&quot;]&#x27;]result_2 = re.findall(&#x27;.*?&quot;planning&quot; :.*?,&quot;mp_intention&quot;&#x27;, s_data, re.S)# [&#x27;&#123;&quot;STGraph&quot;: &#123;&quot;Index&quot;: 10,&quot;planning&quot; : [&quot;Now: 1390.04, Gap: 0.10&quot;],&quot;mp_intention&quot;&#x27;]result_3 = re.findall(&#x27;(.*?)&quot;planning&quot; :.*?,&quot;mp_intention&quot;&#x27;, s_data, re.S)# [&#x27;&#123;&quot;STGraph&quot;: &#123;&quot;Index&quot;: 10,&#x27;]result_4 = re.findall(&#x27;(.*?)&quot;planning&quot; :(.*?),&quot;mp_intention&quot;&#x27;, s_data, re.S)# [(&#x27;&#123;&quot;STGraph&quot;: &#123;&quot;Index&quot;: 10,&#x27;, &#x27; [&quot;Now: 1390.04, Gap: 0.10&quot;]&#x27;)]\n\n\n\n\n\n","categories":["开发运维"],"tags":["python","正则表达式"]},{"title":"有效的时间管理","url":"/1344029253.html","content":"本文是《比时间管理更重要的，是注意力管理》的读书笔记。\n\n你如何过一天，便如何过一生。\n\n前言每天都很忙，却好像什么都没做到；很努力地付出，最后就是没有拿得出手的工作成果；都快年底了，年初的读书计划一半都没完成。\n你可能需要的是真正的时间管理，准确来说，是注意力管理。\n重要紧急四象限是最没用的理论几乎每个知道重要紧急四象限的人，都做不好时间管理，因为从实际的落地上，几乎没有可操作性。\n\n通过时间账户看清时间分布时间可以分为九个账户，分别是精力恢复、收拾自己、通勤、工作、学习成长、锻炼、情感、社交、消遣娱乐。\n明确时间账户后，可以细化我们对生活中时间的理解与复盘，进而调整不同账户的时间投入，调整自己的身心状态。\n\n\n  \n    时间账户\n          属性\n    投入\n  \n\n\n  \n          精力恢复\n          必要时间\n    9.5小时\n  \n  \n          收拾自己\n  \n  \n          通勤\n  \n  \n          工作\n          工作时间\n    9.5小时\n  \n  \n          学习成长\n          自我时间\n    5小时\n  \n  \n          锻炼\n  \n  \n          情感\n  \n  \n          社交\n  \n  \n          消遣娱乐\n  \n\n\n\n时间管理需要养成习惯\n\n\n习惯\n说明\n\n\n\n养成记工作日志的习惯\n坚持记工作日志是不可缺少的职业习惯，把当天的工作收获、经验教训用文字的形式记录下来\n\n\n不在工作时间内干私事\n提高工作效率。今天你缺乏上进心、得过且过、安于现状，明天就有可能被淘汰。\n\n\n挤出一切可以利用的时间\n挤出可以利用的时间，效率最大化。\n\n\n今日事，今日毕\n杜绝工作生活中拖延的习惯。\n\n\n避开一切排队\n比如上班路程上的时间损耗，中午吃饭的时间损耗，错峰行动是在不增加经济负担情况下的更佳策略。\n\n\n巧妙投资健康\n包括饮食、运动投入、情绪稳定、工作压力管理、家人健康身心守护等内容。健康越稳定，做事情的质量就更高。\n\n\n降低无效社交\n尝试避开充满炫耀和攀比，只为了吃喝的聚会，更要慎重对待突然冒出来的邀约。\n\n\n控制娱乐消遣\n✅尽量减少在娱乐应用上花费时间和精力。✅设计合理的使用时间断点。坐车吃饭的时候可以刷B站，但是周末或睡觉前刷短视频，肯定会越刷越兴奋，这个时候是没有打断点的。✅设计堕落约束规则。如果想刷剧了，就去跑步机上跑步；如果想干点堕落的事，就给自己肉体增加点运动量或者惩罚。\n\n\n\n\n\n\n别再做无法执行的日程表这类日程无法对抗意外，需要各个时间点都踩准节奏。如果有中断或者延误或者突发状况，则剩余的日程安排基本就会失效，最后的结果就是无法执行日程。\n\n我们应该通过任务流去管理自己的日程。\n\n1、流水日记区\n\n流水事件关键词： 记录各时间段发生的事，尽量精练，不超过15个字。\n过程-感受-反思： 记录各时间段的想法和感受，也可作为流水事件的补充。\n\n主要负责收集与整理。通过流水日记区观察到自己在那段时间里的可支配时间被分配在哪些事情上。 哪些事情是主动做的，哪些事情是问题发生后，被动拿出可支配时间容错的。\n 在日记区并不仅仅是记录这个时候在做什么，更重要的是旁边一栏的“过程、感受、反思”。\n2、思考复盘区\n\n二次复盘反思： 往往是今天受了某事情的触动，是今天值得反复思考的部分。\n三次复盘反思： 往往是二次复盘反思的延伸思考，亦或者是对这段时间的反思。\n\n三次复盘是过一段时间的复盘，比如一周再复盘，加入了时间的变量，我们能更理智地看待一些当时被情绪裹挟的事。\n3、待办任务区\n\nDDL (Deadline)： 几时交付。\n相关人： 可以是自己，也可以是其他人。\n核心诉求： 相关人想要什么结果。\n待办任务： 服务于核心诉求的行动关键词。\n\n这里写上去的每一个任务都是自己给自己加的，并且是根据当天实际发生的事情推演出来的。\n核心述求需要记录的是，相关人想要什么，尝试着推演与洞察， 一定要养成推演（或者问，或者猜）出对方核心述求的习惯 。\n","categories":["读书笔记"],"tags":["时间管理"]},{"title":"环形链表问题","url":"/2408095554.html","content":"一、链表的中间结点（简）题目给定一个头结点为 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。\n示例 1：输入：[1,2,3,4,5]输出：此列表中的结点 3 (序列化形式：[3,4,5])返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。注意，我们返回了一个 ListNode 类型的对象 ans，这样：ans.val &#x3D; 3, ans.next.val &#x3D; 4, ans.next.next.val &#x3D; 5, 以及 ans.next.next.next &#x3D; NULL.\n示例 2：输入：[1,2,3,4,5,6]输出：此列表中的结点 4 (序列化形式：[4,5,6])由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。\n提示：给定链表的结点数介于 1 和 100 之间。\n题解利用快慢指针，快指针一次走两步，慢指针一次走一步。当快指针走到尽头时，此时慢指针对应的九三中间结点。\nclass Solution &#123; public:  ListNode* middleNode(ListNode* head) &#123;    if (!head) &#123;      return NULL;    &#125;    ListNode* slow = head;    ListNode* fast = head;    while (fast &amp;&amp; fast-&gt;next) &#123;      slow = slow-&gt;next;      fast = fast-&gt;next-&gt;next;    &#125;    return slow;  &#125;&#125;;\n\n二、环形链表（简）题目给你一个链表的头节点 head ，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。如果链表中存在环 ，则返回 true 。 否则，返回 false 。\n示例 1：\ngraph LR\n  3 --> 2 --> 0 --> -4\n  -4 --> 2\n输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。\n示例 2：\nflowchart LR\n  1 --> 2\n  2 --> 1\n输入：head &#x3D; [1,2], pos &#x3D; 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。\n示例 3：\nflowchart LR\n  1\n输入：head &#x3D; [1], pos &#x3D; -1输出：false解释：链表中没有环。\n提示：链表中节点的数目范围在范围 [0, 10^4] 内-10^5 &lt;&#x3D; Node.val &lt;&#x3D; 10^5pos 为 -1 或者链表中的一个 有效索引 。\n题解利用快慢指针，快指针一次走两步，慢指针一次走一步。因为快指针快，慢指针慢，所以如果有环快指针最后一定会追上慢指针\nclass Solution &#123; public:  bool hasCycle(ListNode *head) &#123;    if (!head || !head-&gt;next) &#123;      return false;    &#125;    ListNode *slow = head;    ListNode *fast = head;    while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;      if(!slow-&gt;next) &#123;        return false;\t\t// 稍微加个判断，减少下用时      &#125;      slow = slow-&gt;next;      fast = fast-&gt;next-&gt;next;      if (fast == slow) &#123;        return true;      &#125;    &#125;    return false;  &#125;&#125;;// 另一种表示方法是ListNode *slow = head;ListNode *fast = head-&gt;next;// 两种方式不同点在于,一般用fast=head-&gt;next较多,因为这样可以知道相交点的上一个节点,可以用来删除等操作// fast如果初始化为head-&gt;next,则相交点在slow-&gt;next// fast初始化为head,则相交点在slow\n\n三、环形链表 II（中）题目给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。不允许修改 链表。\n示例 1：\nflowchart LR\n  3 --> 2 --> 0 --> -4\n  -4 --> 2\n输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。\n示例 2：\nflowchart LR\n  1 --> 2\n  2 --> 1\n输入：head &#x3D; [1,2], pos &#x3D; 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。\n示例 3：\nflowchart LR\n  1\n输入：head &#x3D; [1], pos &#x3D; -1输出：返回 null解释：链表中没有环。\n提示：链表中节点的数目范围在范围 [0, 10^4] 内-10^5 &lt;&#x3D; Node.val &lt;&#x3D; 10^5pos 的值为 -1 或者链表中的一个有效索引\n题解这道题是要求入环点，首先要判断有环，这个就直接照搬上一题。主要是怎么找入环点。可以看下面这张图F为第一个节点-F到入环点0的距离；a为入环点0到相遇点h距离；b为相遇点h到入环点0距离；当fast和slow相遇时，因为fast每次走两步，slow每次一步，所以fast走过的是slow的两倍，设slow走过为S，则S&#x3D;F+a，2S&#x3D;F+a+b+a，故F&#x3D;b；现在让slow返回第一个节点，fast处于第一次相遇的节点，此时slow从第一个节点出发，因为F&#x3D;b，所以fast和slow会在入环口第二次相遇，即为所求节点。\nclass Solution &#123; public:  ListNode* detectCycle(ListNode* head) &#123;    if (!head || !head-&gt;next) &#123;      return NULL;    &#125;    bool hasCycle = false;    // 先判断是否有环    ListNode* slow = head;    ListNode* fast = head;    while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;      if (!slow-&gt;next) &#123;        break;      &#125;      slow = slow-&gt;next;      fast = fast-&gt;next-&gt;next;      if (fast == slow) &#123;        hasCycle = true;        break;      &#125;    &#125;    // 有环则找入环开始的节点    if (hasCycle) &#123;      slow = head;      while (slow != fast) &#123;        slow = slow-&gt;next;        fast = fast-&gt;next;      &#125;      return slow;    &#125;    return NULL;  &#125;&#125;;\n","categories":["算法交流"],"tags":["刷题笔记"]},{"title":"粘贴到 Vim 中的代码缩进混乱解决方法","url":"/3108661719.html","content":"前言我经常用Vim写代码，有时从其他地方复制粘贴到Vim下时，代码会出现缩进混乱，看起来很难受。\n原因终端处理粘贴的文本时，会存入键盘缓存 (Keyboard Buffer)。Vim 处理时，会把这些内容作为用户键盘输入来处理。所以如果 Vim 开启了自动缩进，那么在遇到换行符时，就会默认把上一行的缩进插入到下一行的开头。\n解决Vim 编辑模式中有一个 Paste 模式，在该模式下，可将文本保持原样粘贴到 Vim 中。在 Vim 中键入命令：\n# 设置 粘贴模式:set paste# 取消 粘贴模式:set nopaste\n在粘贴模式下进行粘贴，就不会遇到缩进混乱的问题了。\n","categories":["开发运维"],"tags":["linux","vim"]},{"title":"滑动窗口问题","url":"/2662471910.html","content":"前言滑动窗口是一类特殊的双指针类型题，只不过他的双指针是同向移动。滑动窗口和双指针最大的区别是，滑动窗口更关心窗口内的值，而不只两个指针上的元素。使用滑动窗口解决的问题通常是暴力解法的优化。很多时候滑动窗口会和哈希表一起使用。\n一、无重复字符的最长子串（中）题目给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n示例1：输入: s &#x3D; “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。\n示例2：输入: s &#x3D; “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。\n示例3：输入: s &#x3D; “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。\n提示：0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 10^4s 由英文字母、数字、符号和空格组成\n题解对于数组或字符串寻找找最xx这一类的，都可以用滑动窗口法1、那什么是滑动窗口呢其实就是一个队列。比如abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当窗口右移进入a，队列变成了abca，这时候不满足要求。所以，我们要移动这个队列！2、如何移动我们只要把队列的左边的元素移出就行了，直到满足题目要求！一直维持这样的队列，找出队列出现最长的长度时候，求出解！3、具体操作使用unordered_set作为容器，unordered_set是无序且只有唯一值的容器；unordered_set.insert是在头部插入，当插入元素已存在容器中时，默认删除容器中的元素，按插入的元素排列\nclass Solution &#123; public:  int lengthOfLongestSubstring(string s) &#123;    if (s.size() == 0) &#123;      return 0;    &#125;    unordered_set&lt;char&gt; lookup;    int maxStr = 0;    int left = 0;    for (int i = 0; i &lt; s.size(); i++) &#123;      while (lookup.find(s[i]) != lookup.end()) &#123;        // 找到有相同的字母,窗口右移        // 用while是因为可能有连续多个相同的字母        lookup.erase(s[left]);        left++;      &#125;      maxStr = max(maxStr, i - left + 1);      lookup.insert(s[i]);    &#125;    return maxStr;  &#125;&#125;;\n","categories":["算法交流"],"tags":["刷题笔记"]},{"title":"终身免费 ORG 顶级域名申请","url":"/2502663362.html","content":"前言有时我们在云上搭建一个网站，需要有对应的域名，那怎么办呢，有人说去买一个啊！确实可以去买一个域名，但咱主打的是一个省钱，有永久免费的域名为什么不薅呢。\n说到免费的顶级域名，可能很多人会想到 Freenom 家的 .tk 域名吧，他家太难注册就不推荐了，今天给大家推荐另外一个 .EU.ORG 的免费域名（虽然他们的【官方网站】界面很Low，但是不要怀疑，就是真的官方网站）。\nEU.ORG 是欧盟组织下面的域名（EU 代表欧盟），是 1996 年 9 月 10 日由 Paul Mockapetris 创建的域名，目前个人和组织都是可以免费注册的。虽然 .EU.ORG 看起来本身像个二级域名，但是已被大部分 DNS 服务商（包括谷歌、Cloudflare等）认定为顶级域名，所以我们就放心大胆的使用就好了。\n注册账号1、在浏览器打开 EU.ORG 官网；\n\n2、由于这个网站服务器是在欧盟（法国），注册账号的个人信息就填写英国那边的，这样容易审核通过。那英国个人信息怎么获取呢，用这个随机地址生成器来获取，点一下“随机地址”，需要记录一下全名、街道、城市、电话这四项内容；\n\n3、注册账号填写好，前面填写的邮箱会收到一条激活邮件，把邮件里的链接复制在当前浏览器打开激活即可，同时记住下面这个临时名称，后面要用。\n\n4、点“Validate”验证通过；\n\n注册域名1、激活后，登录账号进行注册域名；\n\n2、输入上面获取到的临时名称和之前设置的密码，然后点“Login”；\n\n3、点“New Domain”，开始注册正式的域名；\n\n4、注册域名过程中，需要注意的是：填写的域名要完整、填写域名服务器选择第第一个即可。域名解析提供商可以是阿里云和腾讯云；我这边填写的是 Cloudflare 的 NS，可以直接填写上：sid.ns.cloudflare.com，grannbo.ns.cloudflare.com；\n\n\n5、完成到这里就基本完成了，接下来需要等等网站工作人员的人工审核，快的话1小时左右，慢的话可能要等到第3天（比如遇到非工作日），所以需要耐心等就是了；\n\n6、注册成功后，你的邮箱会再次收到注册成功的邮件，里面写有.EU.ORG就是你的域名了。\n\n域名解析待 EU.ORG 登入页面出現你注册的域名后\n\n就可以使用 Cloudflare 进行域名解析了。\n","categories":["折腾系列"],"tags":["建站","域名"]},{"title":"禁用 Windows Defender Antivirus Service","url":"/969299867.html","content":"前言禁用 Windows Defender Antivirus Service可能会降低计算机的安全性，因为它是 Windows操作系统的内置防病毒和恶意软件保护工具。但没办法，我的老电脑内存顶不住了，只能忍痛禁掉。\n关闭注册表\n使用注册表编辑器。win+R，打开”运行”对话框，输入regedit.exe打开注册表；\n浏览路径HKEY_LOCAL_MACHINE/SOFTWARE/Policies/Microsoft/Windows Defender；\n右键单击Windows Defender文件夹键，选择新建→DWORD（32位）值。将新建的键命名为DisableAntiSpyware，并双击该键将值设置为 1 。\n\n关闭组策略\nwin+R，输入gpedit.msc，打开组策略编辑器。然后浏览路径计算机配置/管理模板/Windows组件/Windows Defender防病毒程序；\n双击关闭Windows Defender防病毒程序选项，选择已启用选项以禁用Windows Defender Antivirus。最后单击应用按钮和确定按钮，并重启电脑。\n\n电脑重启后 Windows Defender Antivirus Service 就不会有启动且占用内存的情况了。\n","categories":["开发运维"],"tags":["windows"]},{"title":"网易云在线缓存歌曲解码","url":"/106058906.html","content":"前言用手机网易云听歌时，网易云会帮你缓存歌曲文件，是.uc!文件，要想在电脑端回放，需要解码成.flac格式。这里提供一种方法。\n解决首先将缓存目录下的.uc!文件提取到电脑，将每个文件按字节与0xA3进行异或，并对文件格式修改成.flac即可。\nimport osdef getCurPath():    return os.getcwd()def getAllFiles(data_path):    # 返回data_path目录下的所有文件名    return [f for f in os.listdir(data_path)]def isUcExtension(file):    # 判断是否是.uc文件    if len(file) &gt;= 4 and file[-4:] == &#x27;.uc!&#x27;:        return True    else:        return Falsedef ucToFlac(file):    # 将当前文件按字节与0xA3进行异或，并对文件格式进行修改    fSource = open(file, &#x27;rb&#x27;)    fOut = open(file[:-4] + &#x27;.flac&#x27;, &#x27;wb&#x27;)    content = bytearray(fSource.read())    for index in range(len(content)):        content[index] ^= 0xA3    fOut.write(content)    fSource.close()    fOut.close()if __name__ == &#x27;__main__&#x27;:    origin_path = &quot;Music&quot;    cur_path = getCurPath()    total_origin_path = os.path.join(cur_path, origin_path)    # 函数调用：将当前目录下所有的.uc文件自动解码成.flac文件    files = getAllFiles(total_origin_path)    for file in files:        if isUcExtension(os.path.join(total_origin_path, file)):            ucToFlac(os.path.join(total_origin_path, file))            print(file[:-4] + &#x27;.flac&#x27; + &#x27;转换成功&#x27;)","categories":["工具脚本"],"tags":["python"]},{"title":"美股投资原则","url":"/268856862.html","content":"原则\n永远谨记『高收益，高风险』。\n市值低于100 亿美元的股票，不要碰。\n刚上市的股票谨慎购买。\n中概股和港股谨慎购买。\n抵住诱惑更加专注，不要妄想抓住所有机会。控制好持股个数，美股不应该超过 10 个，港股不应该超过 2 个。\n购买股票应该像买大件家电一样，操作不要太频繁，购买也不要太过随意，购买之前一定是做足了功课。\n谨慎抄底大跌的股票，先搞清楚为什么大跌？好的股票很多，没必要冒这个风险。\n\n卖股票原则\n[短期投资] 对于投机类股票，可以不设置止盈点，但是必须设置止损点（铁律）。止损点设置在 8%～15%。\n[长期投资] 股票卖出与价格无关，卖出原因：\n因为买入逻辑没有了。\n需要资金买入更好的股票。\n股票涨得太快，卖出为了降低风险，分散化投资。\n\n\n\n抄底原则\n考虑是否卖股票，参考卖股票原则。\n当股票下跌时犹豫是否加仓，优先考虑的是「风险是否能承受」而不是分摊成本或者赌反弹。\n\n","categories":["投资"],"tags":["股票"]},{"title":"获取网页 logo 图标","url":"/430851967.html","content":"前言最近在做自己的网址导航，需要提取和显示网址的 favicon 图标，使导航链接除了文字名称，前面还有更明显的 logo 标志，使选择和查看都更加便捷。\n网页 logo 图标一般是指 favicon 图标，作为缩略的网站标志，一般显示于浏览器的地址栏或者在标签上。\n如下图红圈的位置， 即是 favicon 图标。\n\nfavicon 的格式不一定是 ico 格式，它可以是 png，jpg 甚至是 gif，不过 ico 格式是所有浏览器都支持的。\n实操那么怎么获取网页 logo 图标的 URL 链接呢？有三种方法。\n法一最常用的方法（适用于 90% 的站点）是，直接在访问网址首页链接后加上 /favicon.ico，例如：https://www.baidu.com/favicon.ico\n法二第二种获取方法，需要在浏览器界面按 F12 键，进入开发者模式（建议使用 google 内核浏览器）。在默认的 Elements 中点开&lt;head&gt;...&lt;/head&gt;。\n找到 &lt;link 中含有 favicon 或 ico 的链接，右键点选 Edit attribute（即编辑属性）以复制该链接，粘贴到空白页面后回车后即显示该网站的 logo 图标。\n说明：有的链接前缀格式是//开头的，建议使用作为 URL 链接时前面加上https:，\n法三第三种方法，使用第三方的网页图标在线抓取网站，比如这个。\n以上，你学会了吗？\n","categories":["工具脚本"],"tags":["logo"]},{"title":"设置 VirtualBox 共享文件夹","url":"/2993632212.html","content":"前言自己的开发环境在Ubuntu下，但是工作环境在Windows，又不想装双系统，所以用了VirtualBox虚拟机。在使用虚拟机时，有时希望将Windows的目录挂载到虚拟机Ubuntu里，实现两个系统之间的文件交换（当然，要是你觉得双向拖放就满足了，当我没说）。\n方法1、在Windows主机里创建一个要共享的文件夹，比如我的是E:\\VM\\share2、点击VirtualBox的设置-&gt;共享文件夹设置被共享的文件夹是E:\\VM\\share。命名为Share。3、进入虚拟机的Ubuntu，创建一个共享文件夹share_dir\nmkdir share_dir\n4、进入共享文件夹share_dir所在目录，将Windows的Share挂载到share_dir\nsudo mount -t vboxsf Share share_dir\n大功告成\n","categories":["开发运维"],"tags":["linux"]},{"title":"进程间通信之共享内存","url":"/3534901462.html","content":"定义内核管理一片物理内存，允许不同的进程同时映射，多个进程可以映射同一块内存，被多个进程同时映射的物理内存，即共享内存。映射物理内存叫挂接，用完以后解除映射叫脱接。共享内存的特点：\n\n优点：最快的IPC\n缺点：要编程者自己实现对共享内存互斥访问\n\n实现编程模型：具体函数的用法可以用man手册（强力推荐）\n写入内存进程\n获得key, ftok()\n使用key来创建一个共享内存 shmget()\n映射共享内存（得到虚拟地址）， shmat()\n使用共享内存， 往共享内存中写入数据\n解除映射 shmdt()\n如果共享内存不再使用，可以使用shmctl()销毁共享内存\n\n从内存读取进程\n获得key, ftok()\n使用key来获得一个共享内存 shmget()\n映射共享内存（得到虚拟地址）， shmat()\n使用共享内存， 读取共享内存中的数据\n解除映射 shmdt()\n\n代码如下：\n// write_memory.cc#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/time.h&gt;#include &lt;unistd.h&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &quot;./shmdata.h&quot;int main() &#123;  int running = 1;  void *shm = NULL;  struct shared_use_st *shared = NULL;  int shmid;  // 创建共享内存  shmid = shmget((key_t)1234, sizeof(struct shared_use_st), 0666 | IPC_CREAT);  if (shmid == -1) &#123;    fprintf(stderr, &quot;shmget failed\\n&quot;);    exit(EXIT_FAILURE);  &#125;  // 将共享内存连接到当前进程的地址空间  shm = shmat(shmid, (void *)0, 0);  if (shm == (void *)-1) &#123;    fprintf(stderr, &quot;shmat err\\n&quot;);    exit(EXIT_FAILURE);  &#125;  shared = (struct shared_use_st *)shm;  while (running) &#123;    struct timeval tv;    gettimeofday(&amp;tv, NULL);    std::string time_ = std::to_string(1000 * tv.tv_sec + tv.tv_usec / 1000);    // std::string time_ = std::to_string(1000 * tv.tv_sec);    strcpy(shared-&gt;timestamp, time_.c_str());    std::cout &lt;&lt; &quot;You wrote: &quot; &lt;&lt; shared-&gt;timestamp &lt;&lt; std::endl;    usleep(1000);    shared-&gt;written = 1;  &#125;  if (shmdt(shm) == -1) &#123;    exit(EXIT_FAILURE);  &#125;  exit(EXIT_SUCCESS);&#125;// read_memory.cc#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/shm.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &quot;./shmdata.h&quot;int main() &#123;  int running = 1;  void *shm = NULL;  struct shared_use_st *shared;  int shmid;  // 创建共享内存  shmid = shmget((key_t)1234, sizeof(struct shared_use_st), 0666 | IPC_CREAT);  if (shmid == -1) &#123;    fprintf(stderr, &quot;shmget err\\n&quot;);    exit(EXIT_FAILURE);  &#125;  // 将共享内存连接到当前进程的地址空间  shm = shmat(shmid, 0, 0);  if (shm == (void *)-1) &#123;    fprintf(stderr, &quot;shmat err\\n&quot;);    exit(EXIT_FAILURE);  &#125;  shared = (struct shared_use_st *)shm;  shared-&gt;written = 0;  while (running) &#123;    if (shared-&gt;written != 0) &#123;      std::cout &lt;&lt; &quot;You receivr: &quot; &lt;&lt; shared-&gt;timestamp &lt;&lt; std::endl;      shared-&gt;written = 0;    &#125;    usleep(5000);  &#125;  if (shmdt(shm) == -1) &#123;    fprintf(stderr, &quot;shmdt err\\n&quot;);    exit(EXIT_FAILURE);  &#125;  if (shmctl(shmid, IPC_RMID, 0) == -1) &#123;    fprintf(stderr, &quot;shmctl(IPC_RM)\\n&quot;);    exit(EXIT_FAILURE);  &#125;  exit(EXIT_SUCCESS);&#125;// shmdata.h#include &lt;string&gt;#ifndef __SHMDATA_H_HEADER#define __SHMDATA_H_HEADER#define TEXT_SZ 2048struct shared_use_st &#123;  int written;  //标志位，非0：read；0：write  char timestamp[1];&#125;;#endif\n\n\n\n\n\n\n\n\n","categories":["开发运维"],"tags":["linux"]},{"title":"链表处理问题","url":"/600145628.html","content":"一、合并两个有序链表（简）题目将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\n示例 1：\ngraph LR\n  a((1)) --> b((2)) --> c((4))\ngraph LR\n  d[1] --> e[3] --> f[4]\ngraph LR\n  a((1)) --> d[1] --> b((2)) --> e[3] --> c((4)) --> f[4]\n输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]输出：[1,1,2,3,4,4]\n示例 2：输入：l1 &#x3D; [], l2 &#x3D; []输出：[]\n示例 3：输入：l1 &#x3D; [], l2 &#x3D; [0]输出：[0]\n提示：两个链表的节点数目范围是 [0, 50]-100 &lt;&#x3D; Node.val &lt;&#x3D; 100l1 和 l2 均按 非递减顺序 排列\n题解很简单，定义第三个链表，然后依次比较两个有序链表的每一位，小的先接到第三个链表后面。最后遍历完后，如果两个链表中还有剩下元素的，直接整个接到第三个链表后面。\nclass Solution &#123; public:  ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;    ListNode* dummyNode = new ListNode(0);    ListNode* pre = dummyNode;    while (l1 != NULL &amp;&amp; l2 != NULL) &#123;      if (l1-&gt;val &lt;= l2-&gt;val) &#123;        pre-&gt;next = l1;        l1 = l1-&gt;next;      &#125; else &#123;        pre-&gt;next = l2;        l2 = l2-&gt;next;      &#125;      pre = pre-&gt;next;    &#125;    if (l1 == NULL) &#123;      pre-&gt;next = l2;    &#125; else if (l2 == NULL) &#123;      pre-&gt;next = l1;    &#125;    return dummyNode-&gt;next;  &#125;&#125;;\n\n二、合并K个升序链表（困）题目给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。\n示例 1：输入：lists &#x3D; [ [1,4,5],[1,3,4],[2,6] ]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n示例 2：输入：lists &#x3D; [ ]输出：[ ]\n示例 3：输入：lists &#x3D; [ [ ] ]输出：[ ]\n提示：k &#x3D;&#x3D; lists.length0 &lt;&#x3D; k &lt;&#x3D; 10^40 &lt;&#x3D; lists[i].length &lt;&#x3D; 500-10^4 &lt;&#x3D; lists[i][j] &lt;&#x3D; 10^4lists[i] 按 升序 排列lists[i].length 的总和不超过 10^4\n题解1根据之前的合并两个有序链表，遍历链表组中的元素，两两合并即可。\nclass Solution &#123; public:  ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;    ListNode* dummyNode = new ListNode(0);    ListNode* pre = dummyNode;    while (l1 != NULL &amp;&amp; l2 != NULL) &#123;      if (l1-&gt;val &lt;= l2-&gt;val) &#123;        pre-&gt;next = l1;        l1 = l1-&gt;next;      &#125; else &#123;        pre-&gt;next = l2;        l2 = l2-&gt;next;      &#125;      pre = pre-&gt;next;    &#125;    if (l1 == NULL) &#123;      pre-&gt;next = l2;    &#125; else if (l2 == NULL) &#123;      pre-&gt;next = l1;    &#125;    return dummyNode-&gt;next;  &#125;  ListNode* mergeKLists(const vector&lt;ListNode*&gt;&amp; lists) &#123;    if (lists.size() == 0) &#123;      return NULL;    &#125;    ListNode* result = NULL;    for (int i = 0; i &lt; lists.size(); i++) &#123;      result = mergeTwoLists(result, lists[i]);    &#125;    return result;  &#125;&#125;;\n题解2题解1是按顺序合并，每次合并完的链表就会加长，下一次合并又得遍历一遍，所以时间复杂度会高。这里可以联想到排序算法的归并排序。当然这里我们不用排序，只用归并，然后一一合并链表。具体怎么做呢。比如lists=[[1, 2], [3, 4], [5, 6], [7, 8]]，首先拆分成[[1, 2], [3, 4]]和[[5, 6], [7, 8]]，然后两组分别组内合并，得到两个链表，再互相合并。\nclass Solution &#123; public:  ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;    ListNode* dummyNode = new ListNode(0);    ListNode* pre = dummyNode;    while (l1 != NULL &amp;&amp; l2 != NULL) &#123;      if (l1-&gt;val &lt;= l2-&gt;val) &#123;        pre-&gt;next = l1;        l1 = l1-&gt;next;      &#125; else &#123;        pre-&gt;next = l2;        l2 = l2-&gt;next;      &#125;      pre = pre-&gt;next;    &#125;    if (l1 == NULL) &#123;      pre-&gt;next = l2;    &#125; else if (l2 == NULL) &#123;      pre-&gt;next = l1;    &#125;    return dummyNode-&gt;next;  &#125;  ListNode* merge(const vector&lt;ListNode*&gt;&amp; lists, int left, int right) &#123;    if (left == right) &#123;      return lists[left];    &#125;    if (left &gt; right) &#123;      return NULL;    &#125;    int mid = (left + right) &gt;&gt; 1;    ListNode* l1 = merge(lists, left, mid);    ListNode* l2 = merge(lists, mid + 1, right);    return mergeTwoLists(l1, l2);  &#125;  ListNode* mergeKLists(const vector&lt;ListNode*&gt;&amp; lists) &#123;    if (lists.size() == 0) &#123;      return NULL;    &#125;    return merge(lists, 0, lists.size() - 1);  &#125;&#125;;\n题解3因为最后返回的链表中数组是按由小到大排序的，而C++自带的优先队列priority_queue，可以自动帮我们排序。所以可以拿小根堆先遍历参数中的lists, 因为小根堆top()返回的是最小值，因此可以通过不断吐出小根堆的值，重新组装链表。\nclass Solution &#123; public:  ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;    ListNode* res = new ListNode();    // 小根堆    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; queue;    for (auto list : lists) &#123;      while (list != NULL) &#123;        queue.push(list-&gt;val);        list = list-&gt;next;      &#125;    &#125;    ListNode* temp = res;    while (!queue.empty()) &#123;      ListNode* node = new ListNode();      node-&gt;val = queue.top();      queue.pop();      temp-&gt;next = node;      temp = temp-&gt;next;    &#125;    return res-&gt;next;  &#125;&#125;;\n题解4题解3用的是C++自带的priority_queue，我们也可以自己定义类似的queue，从小到大排序。\nstruct Status &#123;  int val;  ListNode* ptr;  bool operator&lt;(const Status&amp; rhs) const &#123; return val &gt; rhs.val; &#125;&#125;;\n其余的和题解3类似。\nclass Solution &#123; public:  ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;    struct Status &#123;      int val;      ListNode* ptr;      bool operator&lt;(const Status&amp; rhs) const &#123; return val &gt; rhs.val; &#125;    &#125;;    ListNode* res = new ListNode();    // 最小堆    priority_queue&lt;Status&gt; queue;    for (auto list : lists) &#123;      while (list != NULL) &#123;        queue.push(&#123;list-&gt;val, list&#125;);        list = list-&gt;next;      &#125;    &#125;    ListNode* temp = res;    while (!queue.empty()) &#123;      ListNode* node = new ListNode();      node-&gt;val = queue.top().val;      queue.pop();      temp-&gt;next = node;      temp = temp-&gt;next;    &#125;    return res-&gt;next;  &#125;&#125;;\n\n三、相交链表（简）题目给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。图示两个链表在节点 c1 开始相交：\ngraph LR\n  a1 --> a2 --> c1\n  b1 --> b2 --> b3 --> c1 --> c2 --> c3\n题目数据 保证 整个链式结构中不存在环。注意，函数返回结果后，链表必须 保持其原始结构 。自定义评测：评测系统 的输入如下（你设计的程序 不适用 此输入）：\n\nintersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0\nlistA - 第一个链表\nlistB - 第二个链表\nskipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数\nskipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数\n\n评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。\n示例 1：\ngraph LR\n  a[4] --> b[1] --> 8\n  d[5] --> 6 --> e[1] --> 8 --> f[4] --> g[5]\n输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3输出：Intersected at ‘8’解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。\n示例 2：\ngraph LR\n  a[1] --> 9 --> b[1] --> 2\n  3 --> 2 --> 4\n输入：intersectVal &#x3D; 2, listA &#x3D; [1,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1输出：Intersected at ‘2’解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n示例 3：\ngraph LR\n  2 --> 6 --> 4\n  1 --> 5\n输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2输出：null解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。\n提示：listA 中节点数目为 mlistB 中节点数目为 n1 &lt;&#x3D; m, n &lt;&#x3D; 3 * 10^41 &lt;&#x3D; Node.val &lt;&#x3D; 10^50 &lt;&#x3D; skipA &lt;&#x3D; m0 &lt;&#x3D; skipB &lt;&#x3D; n如果 listA 和 listB 没有交点，intersectVal 为 0如果 listA 和 listB 有交点，intersectVal &#x3D;&#x3D; listA[skipA] &#x3D;&#x3D; listB[skipB]\n题解直接看图更好理解，1、指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历；2、如果 pA 到了末尾，则 pA &#x3D; headB 继续遍历；3、如果 pB 到了末尾，则 pB &#x3D; headA 继续遍历；4、比较长的链表指针指向较短链表head时，长度差就消除了；5、如此，只需要将最短链表遍历两次，当 pA &#x3D; pB 时，即找到位置。\nclass Solution &#123; public:  ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) &#123;    if (headA == NULL || headB == NULL) &#123;      return NULL;    &#125;    ListNode *pA = headA, pB = headB;    while (pA != pB) &#123;      pA = (pA == NULL) ? headB : pA-&gt;next;      pB = (pB == NULL) ? headA : pB-&gt;next;    &#125;    return pA;  &#125;&#125;;\n\n四、重排链表（中）题目给定一个单链表 L 的头节点 head ，单链表 L 表示为：L0 → L1 → … → Ln - 1 → Ln请将其重新排列后变为：L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n示例 1：输入：head &#x3D; [1,2,3,4]输出：[1,4,2,3]\n示例 2：输入：head &#x3D; [1,2,3,4,5]输出：[1,5,2,4,3]\n提示：链表的长度范围为 [1, 5 * 10^4]1 &lt;&#x3D; node.val &lt;&#x3D; 1000\n题解这题其实是个大杂烩，寻找链表中点(快慢指针) + 链表逆序（反转链表） + 合并链表，这三个的合集。\n举个例子，链表 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6第一步，将链表平均分成两半1 -&gt; 2 -&gt; 34 -&gt; 5 -&gt; 6第二步，将第二个链表逆序1 -&gt; 2 -&gt; 36 -&gt; 5 -&gt; 4第三步，依次连接两个链表，得到答案1 -&gt; 6 -&gt; 2 -&gt; 5 -&gt; 3 -&gt; 4\n第一步找中点的话，很明显用快慢指针。快指针一次走两步，慢指针一次走一步，当快指针走到终点的话，慢指针会刚好到中点。如果节点个数是偶数的话，slow 走到的是左端点，利用这一点，我们可以把奇数和偶数的情况合并，不需要分开考虑。（快慢指针参考环形链表问题）\n第二步链表逆序的话，有迭代和递归的两种方式，迭代的话主要利用两个指针，依次逆转。（反转链表参考反转链表问题）\n第三步的话就很简单了，两个指针分别向后移动就可以。\nclass Solution &#123; public:  void reorderList(ListNode* head) &#123;    if (head == NULL || head-&gt;next == NULL)      return;    // 快慢指针分出两段    ListNode* slow = head;    ListNode* fast = head;    while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;      slow = slow-&gt;next;      fast = fast-&gt;next-&gt;next;    &#125;    // 后端反转    ListNode* reverseNode = slow-&gt;next;    slow-&gt;next = NULL;    reverseNode = reverseList(reverseNode);    // 合并链表    while (reverseNode) &#123;      ListNode* tempHead = head-&gt;next;      ListNode* tempReverse = reverseNode-&gt;next;      head-&gt;next = reverseNode;      reverseNode-&gt;next = tempHead;      head = tempHead;      reverseNode = tempReverse;    &#125;  &#125;  ListNode* reverseList(ListNode* head) &#123;    ListNode* next = NULL;    ListNode* prev = NULL;    while (head) &#123;      next = head-&gt;next;      head-&gt;next = prev;      prev = head;  // prev 移动      head = next;  // head 移动    &#125;    return prev;  &#125;&#125;;\n\n五、排序链表（中）题目给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。\n示例 1：\ngraph LR\n  4 --> 2 --> 1 --> 3\n—&gt;\ngraph LR\n  1 --> 2 --> 3 --> 4\n输入：head &#x3D; [4,2,1,3]输出：[1,2,3,4]\n示例 2：\ngraph LR\n  -1 --> 5 --> 3 --> 4 --> 0\n—&gt;\ngraph LR\n  -1 --> 0 --> 3 --> 4 --> 5\n输入：head &#x3D; [-1,5,3,4,0]输出：[-1,0,3,4,5]\n示例 3：输入：head &#x3D; []输出：[]\n提示：链表中节点的数目在范围 $[0, 5 * 10^4]$ 内$-10^5 &lt;&#x3D; Node.val &lt;&#x3D; 10^5$需要在$O(n log n)$时间复杂度和常数级空间复杂度下，对链表进行排序\n题解1要实现$O(n log n)$时间复杂度和常数级空间复杂度，看之前的排序算法可以知道，符合要求的只有快速排序和归并排序。\n首先是快速排序，回顾数组的快排步骤：1、确定一个分界点；2、调整区间：使得左边所有值 &lt;&#x3D; 分界点， 右边所有值 &gt;&#x3D; 分界点；3、递归处理左右两段。\n那么链表也可以同样的操作：1、首先找到链表的中间节点；2、然后将链表分为左、中、右三部分，分别存储在三个链表中；3、然后递归地对左、右链表进行排序；4、最后将左、中、右三个链表拼接起来。\nclass Solution &#123; public:  ListNode* sortList(ListNode* head) &#123;    // 如果链表为空或只有一个节点，直接返回    if (!head || !head-&gt;next) &#123;      return head;    &#125;    // 定义左右指针和中间节点    ListNode *left = new ListNode(0), *right = new ListNode(0),             *mid = new ListNode(0);    ListNode *i = left, *j = right, *m = mid;    // 这里用中间节点的原因是，如果每次用最左边的节点，对于纯递增和纯递减的case就退化为O(n)    int pivot = getMid(head)-&gt;val;    // 如果不考虑超时限制，也可以取最左边的节点作为中间节点    // int pivot = head-&gt;val;    // 遍历链表，将节点分别放入左、右、中间链表中    ListNode* cur = head;    while (cur) &#123;      if (cur-&gt;val &lt; pivot) &#123;        i-&gt;next = cur;        i = i-&gt;next;      &#125; else if (cur-&gt;val &gt; pivot) &#123;        j-&gt;next = cur;        j = j-&gt;next;      &#125; else &#123;        m-&gt;next = cur;        m = m-&gt;next;      &#125;      cur = cur-&gt;next;    &#125;    // 将左、右链表的末尾指向空    i-&gt;next = j-&gt;next = m-&gt;next = NULL;    // 递归排序左、右链表    left-&gt;next = sortList(left-&gt;next);    right-&gt;next = sortList(right-&gt;next);    // 将左、中、右链表拼接起来    cur = left;    while (cur-&gt;next) &#123;      cur = cur-&gt;next;    &#125;    cur-&gt;next = mid-&gt;next;    while (cur-&gt;next) &#123;      cur = cur-&gt;next;    &#125;    cur-&gt;next = right-&gt;next;    // 返回排序后的链表    return left-&gt;next;  &#125;  ListNode* getMid(ListNode* head) &#123;    ListNode* fast = head;    ListNode* slow = head;    while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123;      fast = fast-&gt;next-&gt;next;      slow = slow-&gt;next;    &#125;    return slow;  &#125;&#125;;\n\n题解2上面说了，归并也可以解决这道题。回顾数组的归并步骤：1、确定分界点mid &#x3D; (left + right)&gt;&gt;1，逐层折半分组；2、然后从最小分组开始比较排序，合并成一个大的分组，逐层进行\n那么链表也可以同样的操作：1、用快慢指针的方法找到链表的中间节点；2、然后递归地对前半部分和后半部分分别进行排序；3、最后将两个有序链表合并起来\nclass Solution &#123; public:  ListNode* sortList(ListNode* head) &#123;    if (!head || !head-&gt;next)      return head;  // 如果链表为空或只有一个节点，直接返回    ListNode *slow = head, *fast = head;  // 定义快慢指针    while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;      // 快指针每次走两步，慢指针每次走一步，最终慢指针指向链表中间节点      slow = slow-&gt;next;      fast = fast-&gt;next-&gt;next;    &#125;    fast = slow-&gt;next;  // 定义fast指针指向链表后半部分    slow-&gt;next = NULL;  // 将链表断开    return merge(sortList(head), sortList(fast));    // 递归调用sortList函数，对前半部分和后半部分分别进行排序，然后合并两个有序链表  &#125;  ListNode* merge(ListNode* l1, ListNode* l2) &#123;  // 合并两个有序链表    // 定义虚拟头节点和当前节点    ListNode *dummy = new ListNode(0), *cur = dummy;    while (l1 &amp;&amp; l2) &#123;          // 当l1和l2都不为空时      if (l1-&gt;val &lt; l2-&gt;val) &#123;  // 如果l1的值小于l2的值        cur-&gt;next = l1;         // 将l1接到当前节点的后面        l1 = l1-&gt;next;          // l1指针后移      &#125; else &#123;                  // 如果l1的值大于等于l2的值        cur-&gt;next = l2;         // 将l2接到当前        l2 = l2-&gt;next;          // l2指针后移      &#125;      cur = cur-&gt;next;  // 当前节点后移    &#125;    cur-&gt;next = l1 ? l1 : l2;  // 将剩余的链表接到当前节点的后面    return dummy-&gt;next;        // 返回虚拟头节点的下一个节点  &#125;&#125;;\n\n六、删除排序链表中的重复元素（简）题目给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。\n示例 1：\ngraph LR\n  a(1) --> b(1) --> c(2)\n—&gt;\ngraph LR\n  a(1) --> b(2)\n输入：head &#x3D; [1,1,2]输出：[1,2]\n示例 2：\ngraph LR\n  a(1) --> b(1) --> c(2) --> d(3) --> e(3)\n—&gt;\ngraph LR\n  a(1) --> b(2) --> c(3)\n输入：head &#x3D; [1,1,2,3,3]输出：[1,2,3]\n提示：\n\n链表中节点数目在范围 [0, 300] 内\n-100 &lt;&#x3D; Node.val &lt;&#x3D; 100\n题目数据保证链表已经按升序 排列\n\n题解1、首先，使用虚拟头结点dummyNode，让它的next指针指向head，这样可以避免对head进行特判；2、然后遍历链表，有重复元素head就跳一位，就可以达到去重目的了。\nclass Solution &#123; public:  ListNode* deleteDuplicates(ListNode* head) &#123;    ListNode* dummyNode = new ListNode(0);    dummyNode-&gt;next = head;    while (head) &#123;      while (head-&gt;next &amp;&amp; head-&gt;val == head-&gt;next-&gt;val) &#123;        head-&gt;next = head-&gt;next-&gt;next;      &#125;      head = head-&gt;next;    &#125;    return dummyNode-&gt;next;  &#125;&#125;;\n\n七、删除排序链表中的重复元素II（中）题目给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。\n示例 1：\ngraph LR\n  a(1) --> b(2) --> c(3) --> d(3) --> e(4) --> f(4) --> g(5)\n—&gt;\ngraph LR\n  a(1) --> b(2) --> c(5)\n输入：head &#x3D; [1,2,3,3,4,4,5]输出：[1,2,5]\n示例 2：\ngraph LR\n  a(1) --> b(1) --> c(1) --> d(2) --> e(3)\n—&gt;\ngraph LR\n  a(2) --> b(3)\n输入：head &#x3D; [1,1,1,2,3]输出：[2,3]\n提示：链表中节点数目在范围 [0, 300] 内-100 &lt;&#x3D; Node.val &lt;&#x3D; 100题目数据保证链表已经按升序 排列\n题解跟上面第六题类似，只不过这里所有重复的都删除，不保留。1、可以用个标志位，判断当前节点是否需要删除；2、遍历链表，有重复节点就将head右移，这样head就指向了重复节点中的最后一个，同时标记该节点为要删除的；3、根据flag进行删除即可\nclass Solution &#123; public:  ListNode* deleteDuplicates(ListNode* head) &#123;    ListNode* dummyNode = new ListNode(0);    dummyNode-&gt;next = head;    ListNode* pre = dummyNode;    while (head) &#123;      bool flag = false;  // 标记当前节点是否需要删除      while (head-&gt;next &amp;&amp; head-&gt;val == head-&gt;next-&gt;val) &#123;        head = head-&gt;next;        flag = true;  // 标记当前节点需要删除      &#125;      if (flag) &#123;        // 对于要删除的节点，将前一个节点的next指针指向当前节点的下一个节点，这样就可以将当前节点删除        pre-&gt;next = head-&gt;next;      &#125; else &#123;        // 如果当前节点不用删除，则pre不需要改变指向，仍然指向当前节点的前一个节点        pre = head;      &#125;      head = head-&gt;next;    &#125;    return dummyNode-&gt;next;  &#125;&#125;;","categories":["算法交流"],"tags":["刷题笔记"]}]